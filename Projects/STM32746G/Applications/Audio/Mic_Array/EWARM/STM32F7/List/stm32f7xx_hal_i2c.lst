###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       16/Apr/2016  18:31:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_i2c.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_i2c.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   I2C HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral State and Errors functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19              The I2C HAL driver can be used as follows:
     20              
     21              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     22                  I2C_HandleTypeDef  hi2c; 
     23          
     24              (#)Initialize the I2C low level resources by implement the HAL_I2C_MspInit ()API:
     25                  (##) Enable the I2Cx interface clock
     26                  (##) I2C pins configuration
     27                      (+++) Enable the clock for the I2C GPIOs
     28                      (+++) Configure I2C pins as alternate function open-drain
     29                  (##) NVIC configuration if you need to use interrupt process
     30                      (+++) Configure the I2Cx interrupt priority
     31                      (+++) Enable the NVIC I2C IRQ Channel
     32                  (##) DMA Configuration if you need to use DMA process
     33                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     34                      (+++) Enable the DMAx interface clock using
     35                      (+++) Configure the DMA handle parameters
     36                      (+++) Configure the DMA Tx or Rx Stream
     37                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     38                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream
     39          
     40              (#) Configure the Communication Clock Timing, Own Address1, Master Addressing mode, Dual Addressing mode,
     41                  Own Address2, Own Address2 Mask, General call and Nostretch mode in the hi2c Init structure.
     42          
     43              (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware 
     44                  (GPIO, CLOCK, NVIC...etc) by calling the customed HAL_I2C_MspInit(&hi2c) API.
     45          
     46              (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()
     47          
     48              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     49          
     50              *** Polling mode IO operation ***
     51              =================================
     52              [..]
     53                (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()
     54                (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()
     55                (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()
     56                (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()
     57          
     58              *** Polling mode IO MEM operation ***
     59              =====================================
     60              [..]
     61                (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()
     62                (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()
     63          
     64          
     65              *** Interrupt mode IO operation ***
     66              ===================================
     67              [..]
     68                (+) Transmit in master mode an amount of data in non blocking mode using HAL_I2C_Master_Transmit_IT()
     69                (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback is executed and user can
     70                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback
     71                (+) Receive in master mode an amount of data in non blocking mode using HAL_I2C_Master_Receive_IT()
     72                (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback is executed and user can
     73                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback
     74                (+) Transmit in slave mode an amount of data in non blocking mode using HAL_I2C_Slave_Transmit_IT()
     75                (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback is executed and user can
     76                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback
     77                (+) Receive in slave mode an amount of data in non blocking mode using HAL_I2C_Slave_Receive_IT()
     78                (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback is executed and user can
     79                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback
     80                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     81                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
     82          
     83              *** Interrupt mode IO MEM operation ***
     84              =======================================
     85              [..]
     86                (+) Write an amount of data in no-blocking mode with Interrupt to a specific memory address using
     87                    HAL_I2C_Mem_Write_IT()
     88                (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback is executed and user can
     89                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback
     90                (+) Read an amount of data in no-blocking mode with Interrupt from a specific memory address using
     91                    HAL_I2C_Mem_Read_IT()
     92                (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback is executed and user can
     93                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback
     94                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     95                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
     96          
     97              *** DMA mode IO operation ***
     98              ==============================
     99              [..]
    100                (+) Transmit in master mode an amount of data in non blocking mode (DMA) using
    101                    HAL_I2C_Master_Transmit_DMA()
    102                (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback is executed and user can
    103                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback
    104                (+) Receive in master mode an amount of data in non blocking mode (DMA) using
    105                    HAL_I2C_Master_Receive_DMA()
    106                (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback is executed and user can
    107                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback
    108                (+) Transmit in slave mode an amount of data in non blocking mode (DMA) using
    109                    HAL_I2C_Slave_Transmit_DMA()
    110                (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback is executed and user can
    111                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback
    112                (+) Receive in slave mode an amount of data in non blocking mode (DMA) using
    113                    HAL_I2C_Slave_Receive_DMA()
    114                (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback is executed and user can
    115                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback
    116                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    117                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    118          
    119              *** DMA mode IO MEM operation ***
    120              =================================
    121              [..]
    122                (+) Write an amount of data in no-blocking mode with DMA to a specific memory address using
    123                    HAL_I2C_Mem_Write_DMA()
    124                (+) At Memory end of write transfer HAL_I2C_MemTxCpltCallback is executed and user can
    125                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback
    126                (+) Read an amount of data in no-blocking mode with DMA from a specific memory address using
    127                    HAL_I2C_Mem_Read_DMA()
    128                (+) At Memory end of read transfer HAL_I2C_MemRxCpltCallback is executed and user can
    129                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback
    130                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    131                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    132          
    133          
    134               *** I2C HAL driver macros list ***
    135               ==================================
    136               [..]
    137                 Below the list of most used macros in I2C HAL driver.
    138          
    139                (+) __HAL_I2C_ENABLE: Enable the I2C peripheral
    140                (+) __HAL_I2C_DISABLE: Disable the I2C peripheral
    141                (+) __HAL_I2C_GET_FLAG : Check whether the specified I2C flag is set or not
    142                (+) __HAL_I2C_CLEAR_FLAG : Clear the specified I2C pending flag
    143                (+) __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt
    144                (+) __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    145          
    146               [..]
    147                 (@) You can refer to the I2C HAL driver header file for more useful macros
    148          
    149            @endverbatim
    150            ******************************************************************************
    151            * @attention
    152            *
    153            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    154            *
    155            * Redistribution and use in source and binary forms, with or without modification,
    156            * are permitted provided that the following conditions are met:
    157            *   1. Redistributions of source code must retain the above copyright notice,
    158            *      this list of conditions and the following disclaimer.
    159            *   2. Redistributions in binary form must reproduce the above copyright notice,
    160            *      this list of conditions and the following disclaimer in the documentation
    161            *      and/or other materials provided with the distribution.
    162            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    163            *      may be used to endorse or promote products derived from this software
    164            *      without specific prior written permission.
    165            *
    166            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    167            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    168            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    169            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    170            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    171            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    172            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    173            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    174            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    175            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    176            *
    177            ******************************************************************************  
    178            */ 
    179          
    180          /* Includes ------------------------------------------------------------------*/
    181          #include "stm32f7xx_hal.h"
    182          
    183          /** @addtogroup STM32F7xx_HAL_Driver
    184            * @{
    185            */
    186          
    187          /** @defgroup I2C I2C HAL module driver
    188            * @brief I2C HAL module driver
    189            * @{
    190            */
    191          
    192          #ifdef HAL_I2C_MODULE_ENABLED
    193          
    194          /* Private typedef -----------------------------------------------------------*/
    195          /* Private constants ---------------------------------------------------------*/
    196          /** @addtogroup I2C_Private_Constants I2C Private Constants
    197            * @{
    198            */
    199          #define TIMING_CLEAR_MASK   ((uint32_t)0xF0FFFFFF)  /*<! I2C TIMING clear register Mask */
    200          #define I2C_TIMEOUT_ADDR    ((uint32_t)10000)       /* 10 s  */
    201          #define I2C_TIMEOUT_BUSY    ((uint32_t)25)          /* 25 ms */
    202          #define I2C_TIMEOUT_DIR     ((uint32_t)25)          /* 25 ms */
    203          #define I2C_TIMEOUT_RXNE    ((uint32_t)25)          /* 25 ms */
    204          #define I2C_TIMEOUT_STOPF   ((uint32_t)25)          /* 25 ms */
    205          #define I2C_TIMEOUT_TC      ((uint32_t)25)          /* 25 ms */
    206          #define I2C_TIMEOUT_TCR     ((uint32_t)25)          /* 25 ms */
    207          #define I2C_TIMEOUT_TXIS    ((uint32_t)25)          /* 25 ms */
    208          #define I2C_TIMEOUT_FLAG    ((uint32_t)25)          /* 25 ms */
    209          /**
    210            * @}
    211            */ 
    212          
    213          /* Private macro -------------------------------------------------------------*/
    214          /* Private variables ---------------------------------------------------------*/
    215          /* Private function prototypes -----------------------------------------------*/
    216          /** @addtogroup I2C_Private_Functions I2C Private Functions
    217            * @{
    218            */
    219          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);
    220          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);
    221          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);
    222          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);
    223          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma);
    224          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma);
    225          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    226          
    227          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    228          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    229          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    230          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    231          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    232          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    233          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    234          
    235          static HAL_StatusTypeDef I2C_MasterTransmit_ISR(I2C_HandleTypeDef *hi2c);
    236          static HAL_StatusTypeDef I2C_MasterReceive_ISR(I2C_HandleTypeDef *hi2c);
    237          
    238          static HAL_StatusTypeDef I2C_SlaveTransmit_ISR(I2C_HandleTypeDef *hi2c);
    239          static HAL_StatusTypeDef I2C_SlaveReceive_ISR(I2C_HandleTypeDef *hi2c);
    240          
    241          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request);
    242          /**
    243            * @}
    244            */ 
    245          
    246          /* Exported functions --------------------------------------------------------*/
    247          
    248          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    249            * @{
    250            */
    251          
    252          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    253           *  @brief    Initialization and Configuration functions 
    254           *
    255          @verbatim    
    256           ===============================================================================
    257                        ##### Initialization and de-initialization functions #####
    258           ===============================================================================
    259              [..]  This subsection provides a set of functions allowing to initialize and 
    260                    de-initialize the I2Cx peripheral:
    261          
    262                (+) User must Implement HAL_I2C_MspInit() function in which he configures 
    263                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    264          
    265                (+) Call the function HAL_I2C_Init() to configure the selected device with 
    266                    the selected configuration:
    267                  (++) Clock Timing
    268                  (++) Own Address 1
    269                  (++) Addressing mode (Master, Slave)
    270                  (++) Dual Addressing mode
    271                  (++) Own Address 2
    272                  (++) Own Address 2 Mask
    273                  (++) General call mode
    274                  (++) Nostretch mode
    275          
    276                (+) Call the function HAL_I2C_DeInit() to restore the default configuration 
    277                    of the selected I2Cx peripheral.       
    278          
    279          @endverbatim
    280            * @{
    281            */
    282          
    283          /**
    284            * @brief  Initializes the I2C according to the specified parameters 
    285            *         in the I2C_InitTypeDef and create the associated handle.
    286            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    287            *                the configuration information for the specified I2C.
    288            * @retval HAL status
    289            */

   \                                 In section .text, align 2, keep-with-next
    290          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    291          { 
   \                     HAL_I2C_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    292            /* Check the I2C handle allocation */
    293            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_Init_0
    294            {
    295              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    296            }
    297            
    298            /* Check the parameters */
    299            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    300            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    301            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    302            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    303            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    304            assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    305            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    306            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    307          
    308            if(hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \   0000000A   0xF105 0x0434      ADD      R4,R5,#+52
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_I2C_Init_1
    309            {
    310              /* Allocate lock resource and initialize it */
    311              hi2c->Lock = HAL_UNLOCKED;
   \   00000012   0x7020             STRB     R0,[R4, #+0]
    312              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    313              HAL_I2C_MspInit(hi2c);
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x.... 0x....      BL       HAL_I2C_MspInit
    314            }
    315          
    316            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x7060             STRB     R0,[R4, #+1]
    317            
    318            /* Disable the selected I2C peripheral */
    319            __HAL_I2C_DISABLE(hi2c);
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    320            
    321            /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
    322            /* Configure I2Cx: Frequency range */
    323            hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
   \   00000028   0x6868             LDR      R0,[R5, #+4]
   \   0000002A   0x6829             LDR      R1,[R5, #+0]
   \   0000002C   0xF020 0x6070      BIC      R0,R0,#0xF000000
   \   00000030   0x6108             STR      R0,[R1, #+16]
    324            
    325            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    326            /* Configure I2Cx: Own Address1 and ack own address1 mode */
    327            hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
   \   00000032   0x6828             LDR      R0,[R5, #+0]
   \   00000034   0x6881             LDR      R1,[R0, #+8]
   \   00000036   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000003A   0x6081             STR      R1,[R0, #+8]
    328            if(hi2c->Init.OwnAddress1 != 0)
   \   0000003C   0x68A8             LDR      R0,[R5, #+8]
   \   0000003E   0xB140             CBZ.N    R0,??HAL_I2C_Init_2
    329            {
    330              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \   00000040   0x68E9             LDR      R1,[R5, #+12]
   \   00000042   0x2901             CMP      R1,#+1
   \   00000044   0xBF0C             ITE      EQ 
   \   00000046   0xF440 0x4000      ORREQ    R0,R0,#0x8000
   \   0000004A   0xF440 0x4004      ORRNE    R0,R0,#0x8400
    331              {
    332                hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    333              }
    334              else /* I2C_ADDRESSINGMODE_10BIT */
    335              {
    336                hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
   \   0000004E   0x6829             LDR      R1,[R5, #+0]
   \   00000050   0x6088             STR      R0,[R1, #+8]
    337              }
    338            }
    339            
    340            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    341            /* Configure I2Cx: Addressing Master mode */
    342            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \                     ??HAL_I2C_Init_2: (+1)
   \   00000052   0x68E8             LDR      R0,[R5, #+12]
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD103             BNE.N    ??HAL_I2C_Init_3
    343            {
    344              hi2c->Instance->CR2 = (I2C_CR2_ADD10);
   \   00000058   0x6829             LDR      R1,[R5, #+0]
   \   0000005A   0xF44F 0x6000      MOV      R0,#+2048
   \   0000005E   0x6048             STR      R0,[R1, #+4]
    345            }
    346            /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
    347            hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
   \                     ??HAL_I2C_Init_3: (+1)
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0x6841             LDR      R1,[R0, #+4]
   \   00000064   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000068   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000006C   0x6041             STR      R1,[R0, #+4]
    348            
    349            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    350            /* Configure I2Cx: Dual mode and Own Address2 */
    351            hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
   \   0000006E   0x6928             LDR      R0,[R5, #+16]
   \   00000070   0x6969             LDR      R1,[R5, #+20]
   \   00000072   0x4308             ORRS     R0,R1,R0
   \   00000074   0x69A9             LDR      R1,[R5, #+24]
   \   00000076   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000007A   0x6829             LDR      R1,[R5, #+0]
   \   0000007C   0x60C8             STR      R0,[R1, #+12]
    352          
    353            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    354            /* Configure I2Cx: Generalcall and NoStretch mode */
    355            hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
   \   0000007E   0x69E8             LDR      R0,[R5, #+28]
   \   00000080   0x6A29             LDR      R1,[R5, #+32]
   \   00000082   0x4308             ORRS     R0,R1,R0
   \   00000084   0x6829             LDR      R1,[R5, #+0]
   \   00000086   0x6008             STR      R0,[R1, #+0]
    356            
    357            /* Enable the selected I2C peripheral */
    358            __HAL_I2C_ENABLE(hi2c);
   \   00000088   0x6828             LDR      R0,[R5, #+0]
   \   0000008A   0x6801             LDR      R1,[R0, #+0]
   \   0000008C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000090   0x6001             STR      R1,[R0, #+0]
    359            
    360            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x6060             STR      R0,[R4, #+4]
    361            hi2c->State = HAL_I2C_STATE_READY;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x7060             STRB     R0,[R4, #+1]
    362            
    363            return HAL_OK;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    364          }
    365          
    366          /**
    367            * @brief  DeInitializes the I2C peripheral. 
    368            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    369            *                the configuration information for the specified I2C.
    370            * @retval HAL status
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    373          {
   \                     HAL_I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    374            /* Check the I2C handle allocation */
    375            if(hi2c == NULL)
   \   00000002   0xB908             CBNZ.N   R0,??HAL_I2C_DeInit_0
    376            {
    377              return HAL_ERROR;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xBD10             POP      {R4,PC}
    378            }
    379            
    380            /* Check the parameters */
    381            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    382            
    383            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \   00000008   0xF100 0x0434      ADD      R4,R0,#+52
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x7061             STRB     R1,[R4, #+1]
    384            
    385            /* Disable the I2C Peripheral Clock */
    386            __HAL_I2C_DISABLE(hi2c);
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0x0852             LSRS     R2,R2,#+1
   \   00000016   0x0052             LSLS     R2,R2,#+1
   \   00000018   0x600A             STR      R2,[R1, #+0]
    387            
    388            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    389            HAL_I2C_MspDeInit(hi2c);
   \   0000001A   0x.... 0x....      BL       HAL_I2C_MspDeInit
    390            
    391            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6060             STR      R0,[R4, #+4]
    392          
    393            hi2c->State = HAL_I2C_STATE_RESET;
   \   00000022   0x7060             STRB     R0,[R4, #+1]
    394            
    395            /* Release Lock */
    396            __HAL_UNLOCK(hi2c);
   \   00000024   0x7020             STRB     R0,[R4, #+0]
    397          
    398            return HAL_OK;
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    399          }
    400          
    401          /**
    402            * @brief I2C MSP Init.
    403            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    404            *                the configuration information for the specified I2C.
    405            * @retval None
    406            */

   \                                 In section .text, align 2, keep-with-next
    407           __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    408          {
    409            /* Prevent unused argument(s) compilation warning */
    410            UNUSED(hi2c);
    411            
    412            /* NOTE : This function Should not be modified, when the callback is needed,
    413                      the HAL_I2C_MspInit could be implemented in the user file
    414             */ 
    415          }
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    416          
    417          /**
    418            * @brief I2C MSP DeInit
    419            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    420            *                the configuration information for the specified I2C.
    421            * @retval None
    422            */

   \                                 In section .text, align 2, keep-with-next
    423           __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    424          {
    425            /* Prevent unused argument(s) compilation warning */
    426            UNUSED(hi2c);
    427            
    428            /* NOTE : This function Should not be modified, when the callback is needed,
    429                      the HAL_I2C_MspDeInit could be implemented in the user file
    430             */ 
    431          }
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    432          
    433          /**
    434            * @}
    435            */
    436          
    437          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
    438           *  @brief   Data transfers functions 
    439           *
    440          @verbatim   
    441           ===============================================================================
    442                                ##### IO operation functions #####
    443           ===============================================================================  
    444              [..]
    445              This subsection provides a set of functions allowing to manage the I2C data 
    446              transfers.
    447          
    448              (#) There are two modes of transfer:
    449                 (++) Blocking mode : The communication is performed in the polling mode. 
    450                      The status of all data processing is returned by the same function 
    451                      after finishing transfer.  
    452                 (++) No-Blocking mode : The communication is performed using Interrupts 
    453                      or DMA. These functions return the status of the transfer startup.
    454                      The end of the data processing will be indicated through the 
    455                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when 
    456                      using DMA mode.
    457          
    458              (#) Blocking mode functions are :
    459                  (++) HAL_I2C_Master_Transmit()
    460                  (++) HAL_I2C_Master_Receive()
    461                  (++) HAL_I2C_Slave_Transmit()
    462                  (++) HAL_I2C_Slave_Receive()
    463                  (++) HAL_I2C_Mem_Write()
    464                  (++) HAL_I2C_Mem_Read()
    465                  (++) HAL_I2C_IsDeviceReady()
    466                  
    467              (#) No-Blocking mode functions with Interrupt are :
    468                  (++) HAL_I2C_Master_Transmit_IT()
    469                  (++) HAL_I2C_Master_Receive_IT()
    470                  (++) HAL_I2C_Slave_Transmit_IT()
    471                  (++) HAL_I2C_Slave_Receive_IT()
    472                  (++) HAL_I2C_Mem_Write_IT()
    473                  (++) HAL_I2C_Mem_Read_IT()
    474          
    475              (#) No-Blocking mode functions with DMA are :
    476                  (++) HAL_I2C_Master_Transmit_DMA()
    477                  (++) HAL_I2C_Master_Receive_DMA()
    478                  (++) HAL_I2C_Slave_Transmit_DMA()
    479                  (++) HAL_I2C_Slave_Receive_DMA()
    480                  (++) HAL_I2C_Mem_Write_DMA()
    481                  (++) HAL_I2C_Mem_Read_DMA()
    482          
    483              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    484                  (++) HAL_I2C_MemTxCpltCallback()
    485                  (++) HAL_I2C_MemRxCpltCallback()
    486                  (++) HAL_I2C_MasterTxCpltCallback()
    487                  (++) HAL_I2C_MasterRxCpltCallback()
    488                  (++) HAL_I2C_SlaveTxCpltCallback()
    489                  (++) HAL_I2C_SlaveRxCpltCallback()
    490                  (++) HAL_I2C_ErrorCallback()
    491          
    492          @endverbatim
    493            * @{
    494            */
    495          
    496          /**
    497            * @brief  Transmits in master mode an amount of data in blocking mode.
    498            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    499            *                the configuration information for the specified I2C.
    500            * @param  DevAddress: Target device address
    501            * @param  pData: Pointer to data buffer
    502            * @param  Size: Amount of data to be sent
    503            * @param  Timeout: Timeout duration
    504            * @retval HAL status
    505            */

   \                                 In section .text, align 2, keep-with-next
    506          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    507          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
    508            uint32_t sizetmp = 0;
    509            
    510            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF104 0x0534      ADD      R5,R4,#+52
   \   0000000A   0x4688             MOV      R8,R1
   \   0000000C   0x4691             MOV      R9,R2
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0x461E             MOV      R6,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x80A5      BNE.W    ??HAL_I2C_Master_Transmit_0
    511            {    
    512              if((pData == NULL ) || (Size == 0)) 
   \   00000018   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2E00             CMPNE    R6,#+0
   \   00000020   0xF000 0x80A0      BEQ.W    ??HAL_I2C_Master_Transmit_1
    513              {
    514                return  HAL_ERROR;                                    
    515              }
    516              
    517              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6980             LDR      R0,[R0, #+24]
   \   00000028   0x0400             LSLS     R0,R0,#+16
   \   0000002A   0xF100 0x809A      BMI.W    ??HAL_I2C_Master_Transmit_0
    518              {
    519                return HAL_BUSY;
    520              }
    521              
    522              /* Process Locked */
    523              __HAL_LOCK(hi2c);
   \   0000002E   0x7828             LDRB     R0,[R5, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xF000 0x8096      BEQ.W    ??HAL_I2C_Master_Transmit_0
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x7028             STRB     R0,[R5, #+0]
    524              
    525              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
   \   0000003A   0x2012             MOVS     R0,#+18
   \   0000003C   0x7068             STRB     R0,[R5, #+1]
    526              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6068             STR      R0,[R5, #+4]
    527              
    528              /* Send Slave Address */
    529              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    530              /* Size > 255, need to set RELOAD bit */
    531              if(Size > 255)
   \   00000042   0x2EFF             CMP      R6,#+255
   \   00000044   0xF44F 0x5000      MOV      R0,#+8192
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xDD09             BLE.N    ??HAL_I2C_Master_Transmit_2
    532              {
    533                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   0000004C   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000050   0x22FF             MOVS     R2,#+255
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x27FF             MOVS     R7,#+255
   \   00000056   0x.... 0x....      BL       I2C_TransferConfig
    534                sizetmp = 255;
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \   0000005A   0xF8DD 0xA028      LDR      R10,[SP, #+40]
   \   0000005E   0xE011             B.N      ??HAL_I2C_Master_Transmit_4
    535              }
    536              else
    537              {
    538                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \   00000060   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000064   0xB2F2             UXTB     R2,R6
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x4637             MOV      R7,R6
   \   0000006A   0x.... 0x....      BL       I2C_TransferConfig
    539                sizetmp = Size;
   \   0000006E   0xE7F4             B.N      ??HAL_I2C_Master_Transmit_3
    540              }
    541              
    542              do
    543              {
    544                /* Wait until TXIS flag is set */
    545                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    546                {
    547                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    548                  {
    549                    return HAL_ERROR;
    550                  }
    551                  else
    552                  {
    553                    return HAL_TIMEOUT;
    554                  }
    555                }
    556                /* Write data to TXDR */
    557                hi2c->Instance->TXDR = (*pData++);
    558                sizetmp--;
    559                Size--;
    560                
    561                if((sizetmp == 0)&&(Size!=0))
    562                {
    563                  /* Wait until TCR flag is set */
    564                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
    565                  {
    566                    return HAL_TIMEOUT;
    567                  }
    568                  
    569                  if(Size > 255)
    570                  {
    571                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    572                    sizetmp = 255;
    573                  }
    574                  else
    575                  {
    576                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0xB2F2             UXTB     R2,R6
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       I2C_TransferConfig
    577                    sizetmp = Size;
   \   00000082   0x4637             MOV      R7,R6
    578                  }
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \   00000084   0x.... 0x....      BL       HAL_GetTick
   \   00000088   0x4683             MOV      R11,R0
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6981             LDR      R1,[R0, #+24]
   \   0000008E   0x0789             LSLS     R1,R1,#+30
   \   00000090   0xD41C             BMI.N    ??HAL_I2C_Master_Transmit_7
   \   00000092   0x4651             MOV      R1,R10
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000009A   0xB998             CBNZ.N   R0,??HAL_I2C_Master_Transmit_8
   \   0000009C   0xF11A 0x0F01      CMN      R10,#+1
   \   000000A0   0xD0F3             BEQ.N    ??HAL_I2C_Master_Transmit_6
   \   000000A2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000A6   0xD005             BEQ.N    ??HAL_I2C_Master_Transmit_9
   \   000000A8   0x.... 0x....      BL       HAL_GetTick
   \   000000AC   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000B0   0x4582             CMP      R10,R0
   \   000000B2   0xD2EA             BCS.N    ??HAL_I2C_Master_Transmit_6
   \                     ??HAL_I2C_Master_Transmit_9: (+1)
   \   000000B4   0x6868             LDR      R0,[R5, #+4]
   \   000000B6   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000BA   0x6068             STR      R0,[R5, #+4]
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0x7068             STRB     R0,[R5, #+1]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x7028             STRB     R0,[R5, #+0]
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \   000000C4   0x6868             LDR      R0,[R5, #+4]
   \   000000C6   0x2804             CMP      R0,#+4
   \   000000C8   0xD13B             BNE.N    ??HAL_I2C_Master_Transmit_10
   \   000000CA   0xE039             B.N      ??HAL_I2C_Master_Transmit_11
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \   000000CC   0xF819 0x1B01      LDRB     R1,[R9], #+1
   \   000000D0   0x1E7F             SUBS     R7,R7,#+1
   \   000000D2   0xF1A6 0x0601      SUB      R6,R6,#+1
   \   000000D6   0xB2B6             UXTH     R6,R6
   \   000000D8   0x6281             STR      R1,[R0, #+40]
   \   000000DA   0xD127             BNE.N    ??HAL_I2C_Master_Transmit_12
   \   000000DC   0xB346             CBZ.N    R6,??HAL_I2C_Master_Transmit_13
   \   000000DE   0x.... 0x....      BL       HAL_GetTick
   \   000000E2   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_Master_Transmit_14: (+1)
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6981             LDR      R1,[R0, #+24]
   \   000000E8   0x0609             LSLS     R1,R1,#+24
   \   000000EA   0xD40F             BMI.N    ??HAL_I2C_Master_Transmit_15
   \   000000EC   0xF11A 0x0F01      CMN      R10,#+1
   \   000000F0   0xD0F8             BEQ.N    ??HAL_I2C_Master_Transmit_14
   \   000000F2   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000F6   0xD004             BEQ.N    ??HAL_I2C_Master_Transmit_16
   \   000000F8   0x.... 0x....      BL       HAL_GetTick
   \   000000FC   0x1BC0             SUBS     R0,R0,R7
   \   000000FE   0x4582             CMP      R10,R0
   \   00000100   0xD2F0             BCS.N    ??HAL_I2C_Master_Transmit_14
   \                     ??HAL_I2C_Master_Transmit_16: (+1)
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x7068             STRB     R0,[R5, #+1]
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x7028             STRB     R0,[R5, #+0]
   \   0000010A   0xE01A             B.N      ??HAL_I2C_Master_Transmit_10
   \                     ??HAL_I2C_Master_Transmit_15: (+1)
   \   0000010C   0x2EFF             CMP      R6,#+255
   \   0000010E   0xDDAF             BLE.N    ??HAL_I2C_Master_Transmit_5
   \   00000110   0x6841             LDR      R1,[R0, #+4]
   \   00000112   0x.... 0x....      LDR.W    R3,??DataTable9  ;; 0xfc009800
   \   00000116   0xEA4F 0x5288      LSL      R2,R8,#+22
   \   0000011A   0x27FF             MOVS     R7,#+255
   \   0000011C   0x4019             ANDS     R1,R3,R1
   \   0000011E   0xEA51 0x5192      ORRS     R1,R1,R2, LSR #+22
   \   00000122   0x.... 0x....      LDR.W    R2,??DataTable9_1  ;; 0x1ff0000
   \   00000126   0x4311             ORRS     R1,R2,R1
   \   00000128   0x6041             STR      R1,[R0, #+4]
   \   0000012A   0xE7AB             B.N      ??HAL_I2C_Master_Transmit_4
    579                }
    580                
    581              }while(Size > 0);
   \                     ??HAL_I2C_Master_Transmit_12: (+1)
   \   0000012C   0x2E00             CMP      R6,#+0
   \   0000012E   0xD1A9             BNE.N    ??HAL_I2C_Master_Transmit_4
    582              
    583              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    584              /* Wait until STOPF flag is set */
    585              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_13: (+1)
   \   00000130   0x4651             MOV      R1,R10
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000138   0xB120             CBZ.N    R0,??HAL_I2C_Master_Transmit_17
    586              {
    587                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000013A   0x6868             LDR      R0,[R5, #+4]
   \   0000013C   0x2804             CMP      R0,#+4
   \   0000013E   0xD100             BNE.N    ??HAL_I2C_Master_Transmit_10
    588                {
    589                  return HAL_ERROR;
   \                     ??HAL_I2C_Master_Transmit_11: (+1)
   \   00000140   0x....             B.N      ?Subroutine4
    590                }
    591                else
    592                {
    593                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Master_Transmit_10: (+1)
   \   00000142   0x....             B.N      ?Subroutine3
    594                }
    595              }
    596              
    597              /* Clear STOP Flag */
    598              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Transmit_17: (+1)
   \   00000144   0x6821             LDR      R1,[R4, #+0]
   \   00000146   0x2020             MOVS     R0,#+32
    599            	
    600              /* Clear Configuration Register 2 */
    601              I2C_RESET_CR2(hi2c);
   \   00000148   0x.... 0x....      LDR.W    R2,??DataTable9_2  ;; 0xfe00e800
   \   0000014C   0x61C8             STR      R0,[R1, #+28]
   \   0000014E   0x6820             LDR      R0,[R4, #+0]
   \   00000150   0x6841             LDR      R1,[R0, #+4]
   \   00000152   0x4011             ANDS     R1,R2,R1
   \   00000154   0x6041             STR      R1,[R0, #+4]
    602              
    603              hi2c->State = HAL_I2C_STATE_READY; 	  
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0x7068             STRB     R0,[R5, #+1]
    604              
    605              /* Process Unlocked */
    606              __HAL_UNLOCK(hi2c);
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0x7028             STRB     R0,[R5, #+0]
    607              
    608              return HAL_OK;
   \   0000015E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    609            }
    610            else
    611            {
    612              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \   00000162   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \   00000164   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    613            }
    614          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    615          
    616          /**
    617            * @brief  Receives in master mode an amount of data in blocking mode. 
    618            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    619            *                the configuration information for the specified I2C.
    620            * @param  DevAddress: Target device address
    621            * @param  pData: Pointer to data buffer
    622            * @param  Size: Amount of data to be sent
    623            * @param  Timeout: Timeout duration
    624            * @retval HAL status
    625            */

   \                                 In section .text, align 2, keep-with-next
    626          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    627          {
   \                     HAL_I2C_Master_Receive: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
    628            uint32_t sizetmp = 0;
    629            
    630            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF105 0x0434      ADD      R4,R5,#+52
   \   0000000A   0x4689             MOV      R9,R1
   \   0000000C   0x4692             MOV      R10,R2
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x461E             MOV      R6,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x80AD      BNE.W    ??HAL_I2C_Master_Receive_0
    631            {    
    632              if((pData == NULL ) || (Size == 0)) 
   \   00000018   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2E00             CMPNE    R6,#+0
   \   00000020   0xF000 0x80A8      BEQ.W    ??HAL_I2C_Master_Receive_1
    633              {
    634                return  HAL_ERROR;                                    
    635              }
    636              
    637              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x6980             LDR      R0,[R0, #+24]
   \   00000028   0x0400             LSLS     R0,R0,#+16
   \   0000002A   0xF100 0x80A2      BMI.W    ??HAL_I2C_Master_Receive_0
    638              {
    639                return HAL_BUSY;
    640              }
    641              
    642              /* Process Locked */
    643              __HAL_LOCK(hi2c);
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xF000 0x809E      BEQ.W    ??HAL_I2C_Master_Receive_0
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x7020             STRB     R0,[R4, #+0]
    644              
    645              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
   \   0000003A   0x2022             MOVS     R0,#+34
   \   0000003C   0x7060             STRB     R0,[R4, #+1]
    646              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6060             STR      R0,[R4, #+4]
    647              
    648              /* Send Slave Address */
    649              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    650              /* Size > 255, need to set RELOAD bit */
    651              if(Size > 255)
   \   00000042   0x2EFF             CMP      R6,#+255
   \   00000044   0xF44F 0x5010      MOV      R0,#+9216
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0xDD09             BLE.N    ??HAL_I2C_Master_Receive_2
    652              {
    653                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   0000004C   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000050   0x22FF             MOVS     R2,#+255
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x27FF             MOVS     R7,#+255
   \   00000056   0x.... 0x....      BL       I2C_TransferConfig
    654                sizetmp = 255;
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \   0000005A   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \   0000005E   0xE011             B.N      ??HAL_I2C_Master_Receive_4
    655              }
    656              else
    657              {
    658                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \   00000060   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000064   0xB2F2             UXTB     R2,R6
   \   00000066   0x4628             MOV      R0,R5
   \   00000068   0x4637             MOV      R7,R6
   \   0000006A   0x.... 0x....      BL       I2C_TransferConfig
    659                sizetmp = Size;
   \   0000006E   0xE7F4             B.N      ??HAL_I2C_Master_Receive_3
    660              }
    661              
    662              do
    663              {
    664                /* Wait until RXNE flag is set */
    665                if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, I2C_FLAG_RXNE) != HAL_OK)      
    666                {
    667                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    668                  {
    669                    return HAL_ERROR;
    670                  }
    671                  else
    672                  {
    673                    return HAL_TIMEOUT;
    674                  }
    675          	  }
    676                
    677                /* Write data to RXDR */
    678                (*pData++) =hi2c->Instance->RXDR;
    679                sizetmp--;
    680                Size--;
    681                
    682                if((sizetmp == 0)&&(Size!=0))
    683                {
    684                  /* Wait until TCR flag is set */
    685                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
    686                  {
    687                    return HAL_TIMEOUT;
    688                  }
    689                  
    690                  if(Size > 255)
    691                  {
    692                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    693                    sizetmp = 255;
    694                  }
    695                  else
    696                  {
    697                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0xB2F2             UXTB     R2,R6
   \   0000007A   0x4649             MOV      R1,R9
   \   0000007C   0x4628             MOV      R0,R5
   \   0000007E   0x.... 0x....      BL       I2C_TransferConfig
    698                    sizetmp = Size;
   \   00000082   0x4637             MOV      R7,R6
    699                  }
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \   00000084   0x.... 0x....      BL       HAL_GetTick
   \   00000088   0x4683             MOV      R11,R0
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \   0000008A   0x6828             LDR      R0,[R5, #+0]
   \   0000008C   0x6981             LDR      R1,[R0, #+24]
   \   0000008E   0x0749             LSLS     R1,R1,#+29
   \   00000090   0xD424             BMI.N    ??HAL_I2C_Master_Receive_7
   \   00000092   0x2104             MOVS     R1,#+4
   \   00000094   0x4628             MOV      R0,R5
   \   00000096   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000009A   0xB988             CBNZ.N   R0,??HAL_I2C_Master_Receive_8
   \   0000009C   0x6828             LDR      R0,[R5, #+0]
   \   0000009E   0x6981             LDR      R1,[R0, #+24]
   \   000000A0   0x0689             LSLS     R1,R1,#+26
   \   000000A2   0xD511             BPL.N    ??HAL_I2C_Master_Receive_9
   \   000000A4   0x2120             MOVS     R1,#+32
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable9_2  ;; 0xfe00e800
   \   000000AA   0x61C1             STR      R1,[R0, #+28]
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0x6841             LDR      R1,[R0, #+4]
   \   000000B0   0x4011             ANDS     R1,R2,R1
   \   000000B2   0x6041             STR      R1,[R0, #+4]
   \   000000B4   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Receive_10: (+1)
   \   000000B6   0x6060             STR      R0,[R4, #+4]
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x7060             STRB     R0,[R4, #+1]
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x7020             STRB     R0,[R4, #+0]
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \   000000C0   0x6860             LDR      R0,[R4, #+4]
   \   000000C2   0x2804             CMP      R0,#+4
   \   000000C4   0xD145             BNE.N    ??HAL_I2C_Master_Receive_11
   \   000000C6   0xE043             B.N      ??HAL_I2C_Master_Receive_12
   \                     ??HAL_I2C_Master_Receive_9: (+1)
   \   000000C8   0x.... 0x....      BL       HAL_GetTick
   \   000000CC   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000D0   0x2805             CMP      R0,#+5
   \   000000D2   0xD3DA             BCC.N    ??HAL_I2C_Master_Receive_6
   \   000000D4   0x6860             LDR      R0,[R4, #+4]
   \   000000D6   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000DA   0xE7EC             B.N      ??HAL_I2C_Master_Receive_10
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \   000000DC   0x6A40             LDR      R0,[R0, #+36]
   \   000000DE   0x1E7F             SUBS     R7,R7,#+1
   \   000000E0   0xF1A6 0x0601      SUB      R6,R6,#+1
   \   000000E4   0xB2B6             UXTH     R6,R6
   \   000000E6   0xF80A 0x0B01      STRB     R0,[R10], #+1
   \   000000EA   0xD127             BNE.N    ??HAL_I2C_Master_Receive_13
   \   000000EC   0xB346             CBZ.N    R6,??HAL_I2C_Master_Receive_14
   \   000000EE   0x.... 0x....      BL       HAL_GetTick
   \   000000F2   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_Master_Receive_15: (+1)
   \   000000F4   0x6828             LDR      R0,[R5, #+0]
   \   000000F6   0x6981             LDR      R1,[R0, #+24]
   \   000000F8   0x0609             LSLS     R1,R1,#+24
   \   000000FA   0xD40F             BMI.N    ??HAL_I2C_Master_Receive_16
   \   000000FC   0xF118 0x0F01      CMN      R8,#+1
   \   00000100   0xD0F8             BEQ.N    ??HAL_I2C_Master_Receive_15
   \   00000102   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000106   0xD004             BEQ.N    ??HAL_I2C_Master_Receive_17
   \   00000108   0x.... 0x....      BL       HAL_GetTick
   \   0000010C   0x1BC0             SUBS     R0,R0,R7
   \   0000010E   0x4580             CMP      R8,R0
   \   00000110   0xD2F0             BCS.N    ??HAL_I2C_Master_Receive_15
   \                     ??HAL_I2C_Master_Receive_17: (+1)
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x7060             STRB     R0,[R4, #+1]
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x7020             STRB     R0,[R4, #+0]
   \   0000011A   0xE01A             B.N      ??HAL_I2C_Master_Receive_11
   \                     ??HAL_I2C_Master_Receive_16: (+1)
   \   0000011C   0x2EFF             CMP      R6,#+255
   \   0000011E   0xDDA7             BLE.N    ??HAL_I2C_Master_Receive_5
   \   00000120   0x6841             LDR      R1,[R0, #+4]
   \   00000122   0x.... 0x....      LDR.W    R3,??DataTable9  ;; 0xfc009800
   \   00000126   0xEA4F 0x5289      LSL      R2,R9,#+22
   \   0000012A   0x27FF             MOVS     R7,#+255
   \   0000012C   0x4019             ANDS     R1,R3,R1
   \   0000012E   0xEA51 0x5192      ORRS     R1,R1,R2, LSR #+22
   \   00000132   0x.... 0x....      LDR.W    R2,??DataTable9_1  ;; 0x1ff0000
   \   00000136   0x4311             ORRS     R1,R2,R1
   \   00000138   0x6041             STR      R1,[R0, #+4]
   \   0000013A   0xE7A3             B.N      ??HAL_I2C_Master_Receive_4
    700                }
    701                
    702              }while(Size > 0);
   \                     ??HAL_I2C_Master_Receive_13: (+1)
   \   0000013C   0x2E00             CMP      R6,#+0
   \   0000013E   0xD1A1             BNE.N    ??HAL_I2C_Master_Receive_4
    703              
    704              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    705              /* Wait until STOPF flag is set */
    706              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_14: (+1)
   \   00000140   0x2119             MOVS     R1,#+25
   \   00000142   0x4628             MOV      R0,R5
   \   00000144   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000148   0xB120             CBZ.N    R0,??HAL_I2C_Master_Receive_18
    707              {
    708                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000014A   0x6860             LDR      R0,[R4, #+4]
   \   0000014C   0x2804             CMP      R0,#+4
   \   0000014E   0xD100             BNE.N    ??HAL_I2C_Master_Receive_11
    709                {
    710                  return HAL_ERROR;
   \                     ??HAL_I2C_Master_Receive_12: (+1)
   \   00000150   0x....             B.N      ?Subroutine4
    711                }
    712                else
    713                {
    714                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Master_Receive_11: (+1)
   \   00000152   0x....             B.N      ?Subroutine3
    715                }
    716              }
    717              
    718              /* Clear STOP Flag */
    719              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Receive_18: (+1)
   \   00000154   0x6829             LDR      R1,[R5, #+0]
   \   00000156   0x2020             MOVS     R0,#+32
    720            	
    721              /* Clear Configuration Register 2 */
    722              I2C_RESET_CR2(hi2c);
   \   00000158   0x.... 0x....      LDR.W    R2,??DataTable9_2  ;; 0xfe00e800
   \   0000015C   0x61C8             STR      R0,[R1, #+28]
   \   0000015E   0x6828             LDR      R0,[R5, #+0]
   \   00000160   0x6841             LDR      R1,[R0, #+4]
   \   00000162   0x4011             ANDS     R1,R2,R1
   \   00000164   0x6041             STR      R1,[R0, #+4]
    723              
    724              hi2c->State = HAL_I2C_STATE_READY; 	  
   \   00000166   0x2001             MOVS     R0,#+1
   \   00000168   0x7060             STRB     R0,[R4, #+1]
    725              
    726              /* Process Unlocked */
    727              __HAL_UNLOCK(hi2c);
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0x7020             STRB     R0,[R4, #+0]
    728              
    729              return HAL_OK;
   \   0000016E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    730            }
    731            else
    732            {
    733              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \   00000172   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \   00000174   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    734            }
    735          }
    736          
    737          /**
    738            * @brief  Transmits in slave mode an amount of data in blocking mode. 
    739            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    740            *                the configuration information for the specified I2C.
    741            * @param  pData: Pointer to data buffer
    742            * @param  Size: Amount of data to be sent
    743            * @param  Timeout: Timeout duration
    744            * @retval HAL status
    745            */

   \                                 In section .text, align 2, keep-with-next
    746          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    747          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
    748            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF105 0x0434      ADD      R4,R5,#+52
   \   0000000A   0x4688             MOV      R8,R1
   \   0000000C   0x4617             MOV      R7,R2
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x461E             MOV      R6,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x809A      BNE.W    ??HAL_I2C_Slave_Transmit_0
    749            {    
    750              if((pData == NULL ) || (Size == 0)) 
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2F00             CMPNE    R7,#+0
   \   00000020   0xF000 0x8095      BEQ.W    ??HAL_I2C_Slave_Transmit_1
    751              {
    752                return  HAL_ERROR;                                    
    753              }
    754              
    755              /* Process Locked */
    756              __HAL_LOCK(hi2c);
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xF000 0x8090      BEQ.W    ??HAL_I2C_Slave_Transmit_0
   \   0000002C   0x2001             MOVS     R0,#+1
    757              
    758              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    759              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    760              
    761              /* Enable Address Acknowledge */
    762              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
    763              
    764              /* Wait until ADDR flag is set */
    765              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x7020             STRB     R0,[R4, #+0]
   \   00000032   0x2042             MOVS     R0,#+66
   \   00000034   0x7060             STRB     R0,[R4, #+1]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6060             STR      R0,[R4, #+4]
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x6841             LDR      R1,[R0, #+4]
   \   0000003E   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000042   0x6041             STR      R1,[R0, #+4]
   \   00000044   0x2108             MOVS     R1,#+8
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000004C   0xB128             CBZ.N    R0,??HAL_I2C_Slave_Transmit_2
    766              {
    767                /* Disable Address Acknowledge */
    768                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   0000004E   0x6828             LDR      R0,[R5, #+0]
   \   00000050   0x6841             LDR      R1,[R0, #+4]
   \   00000052   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000056   0x6041             STR      R1,[R0, #+4]
    769                return HAL_TIMEOUT;
   \   00000058   0xE071             B.N      ??HAL_I2C_Slave_Transmit_3
    770              }
    771              
    772              /* Clear ADDR flag */
    773              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \   0000005A   0x6829             LDR      R1,[R5, #+0]
   \   0000005C   0x2008             MOVS     R0,#+8
   \   0000005E   0x61C8             STR      R0,[R1, #+28]
    774              
    775              /* If 10bit addressing mode is selected */
    776              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \   00000060   0x68E8             LDR      R0,[R5, #+12]
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD10F             BNE.N    ??HAL_I2C_Slave_Transmit_4
    777              {
    778                /* Wait until ADDR flag is set */
    779                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
   \   00000066   0x4633             MOV      R3,R6
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x2108             MOVS     R1,#+8
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000072   0xB128             CBZ.N    R0,??HAL_I2C_Slave_Transmit_5
    780                {
    781                  /* Disable Address Acknowledge */
    782                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0x6841             LDR      R1,[R0, #+4]
   \   00000078   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000007C   0x6041             STR      R1,[R0, #+4]
    783                  return HAL_TIMEOUT;
   \   0000007E   0xE05E             B.N      ??HAL_I2C_Slave_Transmit_3
    784                }
    785                
    786                /* Clear ADDR flag */
    787                __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \   00000080   0x6829             LDR      R1,[R5, #+0]
   \   00000082   0x2008             MOVS     R0,#+8
   \   00000084   0x61C8             STR      R0,[R1, #+28]
    788              }
    789              
    790              /* Wait until DIR flag is set Transmitter mode */
    791              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout) != HAL_OK)      
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \   00000086   0x4633             MOV      R3,R6
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0xF44F 0x3180      MOV      R1,#+65536
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000094   0xB128             CBZ.N    R0,??HAL_I2C_Slave_Transmit_6
    792              {
    793                /* Disable Address Acknowledge */
    794                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000096   0x6828             LDR      R0,[R5, #+0]
   \   00000098   0x6841             LDR      R1,[R0, #+4]
   \   0000009A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000009E   0x6041             STR      R1,[R0, #+4]
    795                return HAL_TIMEOUT;
   \   000000A0   0xE04D             B.N      ??HAL_I2C_Slave_Transmit_3
    796              }
    797              
    798              do
    799              {
    800                /* Wait until TXIS flag is set */
    801                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \   000000A2   0x.... 0x....      BL       HAL_GetTick
   \   000000A6   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \   000000A8   0x6828             LDR      R0,[R5, #+0]
   \   000000AA   0x6981             LDR      R1,[R0, #+24]
   \   000000AC   0x0789             LSLS     R1,R1,#+30
   \   000000AE   0xD41F             BMI.N    ??HAL_I2C_Slave_Transmit_8
   \   000000B0   0x4631             MOV      R1,R6
   \   000000B2   0x4628             MOV      R0,R5
   \   000000B4   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000B8   0xB988             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_9
   \   000000BA   0xF116 0x0F01      CMN      R6,#+1
   \   000000BE   0xD0F3             BEQ.N    ??HAL_I2C_Slave_Transmit_7
   \   000000C0   0xB12E             CBZ.N    R6,??HAL_I2C_Slave_Transmit_10
   \   000000C2   0x.... 0x....      BL       HAL_GetTick
   \   000000C6   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000CA   0x4286             CMP      R6,R0
   \   000000CC   0xD2EC             BCS.N    ??HAL_I2C_Slave_Transmit_7
   \                     ??HAL_I2C_Slave_Transmit_10: (+1)
   \   000000CE   0x6860             LDR      R0,[R4, #+4]
   \   000000D0   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000D4   0x6060             STR      R0,[R4, #+4]
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x7060             STRB     R0,[R4, #+1]
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0x7020             STRB     R0,[R4, #+0]
    802                {
    803                  /* Disable Address Acknowledge */
    804                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \   000000DE   0x6828             LDR      R0,[R5, #+0]
   \   000000E0   0x6841             LDR      R1,[R0, #+4]
   \   000000E2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000E6   0x6041             STR      R1,[R0, #+4]
    805                  
    806                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000E8   0x6860             LDR      R0,[R4, #+4]
   \   000000EA   0x2804             CMP      R0,#+4
   \   000000EC   0xD127             BNE.N    ??HAL_I2C_Slave_Transmit_3
    807                  {
    808                    return HAL_ERROR;
   \   000000EE   0x....             B.N      ?Subroutine6
    809                  }
    810                  else
    811                  {
    812                    return HAL_TIMEOUT;
    813                  }
    814                }
    815                
    816                /* Read data from TXDR */
    817                hi2c->Instance->TXDR = (*pData++);
    818                Size--;
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \   000000F0   0x1E7F             SUBS     R7,R7,#+1
   \   000000F2   0xF818 0x1B01      LDRB     R1,[R8], #+1
    819              }while(Size > 0);
   \   000000F6   0xB2BF             UXTH     R7,R7
   \   000000F8   0x2F00             CMP      R7,#+0
   \   000000FA   0x6281             STR      R1,[R0, #+40]
   \   000000FC   0xD1D1             BNE.N    ??HAL_I2C_Slave_Transmit_6
    820              
    821              /* Wait until STOP flag is set */
    822              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   000000FE   0x2119             MOVS     R1,#+25
   \   00000100   0x4628             MOV      R0,R5
   \   00000102   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000106   0xB148             CBZ.N    R0,??HAL_I2C_Slave_Transmit_11
    823              {
    824                /* Disable Address Acknowledge */
    825                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000108   0x6828             LDR      R0,[R5, #+0]
   \   0000010A   0x6841             LDR      R1,[R0, #+4]
   \   0000010C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000110   0x6041             STR      R1,[R0, #+4]
    826                
    827                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000112   0x6860             LDR      R0,[R4, #+4]
   \   00000114   0x2804             CMP      R0,#+4
   \   00000116   0xD112             BNE.N    ??HAL_I2C_Slave_Transmit_3
    828                {
    829                  /* Normal use case for Transmitter mode */
    830                  /* A NACK is generated to confirm the end of transfer */
    831                  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x6060             STR      R0,[R4, #+4]
    832                }
    833                else
    834                {
    835                  return HAL_TIMEOUT;
    836                }
    837              }
    838              
    839              /* Clear STOP flag */
    840              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Slave_Transmit_11: (+1)
   \   0000011C   0x6829             LDR      R1,[R5, #+0]
   \   0000011E   0x2020             MOVS     R0,#+32
    841              
    842              /* Wait until BUSY flag is reset */ 
    843              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
   \   00000120   0x4633             MOV      R3,R6
   \   00000122   0x2201             MOVS     R2,#+1
   \   00000124   0x61C8             STR      R0,[R1, #+28]
   \   00000126   0xF44F 0x4100      MOV      R1,#+32768
   \   0000012A   0x4628             MOV      R0,R5
   \   0000012C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0x6828             LDR      R0,[R5, #+0]
   \   00000134   0x6841             LDR      R1,[R0, #+4]
   \   00000136   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000013A   0x6041             STR      R1,[R0, #+4]
   \   0000013C   0xD000             BEQ.N    ??HAL_I2C_Slave_Transmit_12
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \   0000013E   0x....             B.N      ?Subroutine5
    844              {
    845                /* Disable Address Acknowledge */
    846                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    847                return HAL_TIMEOUT;
    848              }
    849              
    850              /* Disable Address Acknowledge */
    851              hi2c->Instance->CR2 |= I2C_CR2_NACK;
    852              
    853              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Transmit_12: (+1)
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0x7060             STRB     R0,[R4, #+1]
    854              
    855              /* Process Unlocked */
    856              __HAL_UNLOCK(hi2c);
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x7020             STRB     R0,[R4, #+0]
    857              
    858              return HAL_OK;
   \   00000148   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    859            }
    860            else
    861            {
    862              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \   0000014C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \   0000014E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    863            }
    864          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    865          
    866          /**
    867            * @brief  Receive in slave mode an amount of data in blocking mode 
    868            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    869            *                the configuration information for the specified I2C.
    870            * @param  pData: Pointer to data buffer
    871            * @param  Size: Amount of data to be sent
    872            * @param  Timeout: Timeout duration
    873            * @retval HAL status
    874            */

   \                                 In section .text, align 2, keep-with-next
    875          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    876          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    877            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF104 0x0734      ADD      R7,R4,#+52
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0x7878             LDRB     R0,[R7, #+1]
   \   00000010   0x4698             MOV      R8,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x8096      BNE.W    ??HAL_I2C_Slave_Receive_0
    878            {  
    879              if((pData == NULL ) || (Size == 0)) 
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2E00             CMPNE    R6,#+0
   \   0000001E   0xF000 0x8092      BEQ.W    ??HAL_I2C_Slave_Receive_1
    880              {
    881                return  HAL_ERROR;                                    
    882              }
    883              
    884              /* Process Locked */
    885              __HAL_LOCK(hi2c);
   \   00000022   0x7838             LDRB     R0,[R7, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xF000 0x808D      BEQ.W    ??HAL_I2C_Slave_Receive_0
   \   0000002A   0x2001             MOVS     R0,#+1
    886              
    887              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
    888              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    889              
    890              /* Enable Address Acknowledge */
    891              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
    892              
    893              /* Wait until ADDR flag is set */
    894              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x7038             STRB     R0,[R7, #+0]
   \   00000030   0x2042             MOVS     R0,#+66
   \   00000032   0x7078             STRB     R0,[R7, #+1]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6078             STR      R0,[R7, #+4]
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6841             LDR      R1,[R0, #+4]
   \   0000003C   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000040   0x6041             STR      R1,[R0, #+4]
   \   00000042   0x2108             MOVS     R1,#+8
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000004A   0xB128             CBZ.N    R0,??HAL_I2C_Slave_Receive_2
    895              {
    896                /* Disable Address Acknowledge */
    897                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000054   0x6041             STR      R1,[R0, #+4]
    898                return HAL_TIMEOUT;
   \   00000056   0xE06E             B.N      ??HAL_I2C_Slave_Receive_3
    899              }
    900              
    901              /* Clear ADDR flag */
    902              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x2008             MOVS     R0,#+8
    903              
    904              /* Wait until DIR flag is reset Receiver mode */
    905              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout) != HAL_OK)      
   \   0000005C   0x4643             MOV      R3,R8
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x61C8             STR      R0,[R1, #+28]
   \   00000062   0xF44F 0x3180      MOV      R1,#+65536
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000006C   0xBB60             CBNZ.N   R0,??HAL_I2C_Slave_Receive_4
    906              {
    907                /* Disable Address Acknowledge */
    908                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    909                return HAL_TIMEOUT;
    910              }
    911              
    912              while(Size > 0)
    913              {
    914                /* Wait until RXNE flag is set */
    915                if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \   0000006E   0x.... 0x....      BL       HAL_GetTick
   \   00000072   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6981             LDR      R1,[R0, #+24]
   \   00000078   0x0749             LSLS     R1,R1,#+29
   \   0000007A   0xD438             BMI.N    ??HAL_I2C_Slave_Receive_7
   \   0000007C   0x4641             MOV      R1,R8
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000084   0xB988             CBNZ.N   R0,??HAL_I2C_Slave_Receive_8
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6981             LDR      R1,[R0, #+24]
   \   0000008A   0x0689             LSLS     R1,R1,#+26
   \   0000008C   0xD522             BPL.N    ??HAL_I2C_Slave_Receive_9
   \   0000008E   0x2120             MOVS     R1,#+32
   \   00000090   0x.... 0x....      LDR.W    R2,??DataTable9_2  ;; 0xfe00e800
   \   00000094   0x61C1             STR      R1,[R0, #+28]
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x6841             LDR      R1,[R0, #+4]
   \   0000009A   0x4011             ANDS     R1,R2,R1
   \   0000009C   0x6041             STR      R1,[R0, #+4]
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Slave_Receive_10: (+1)
   \   000000A0   0x6078             STR      R0,[R7, #+4]
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x7078             STRB     R0,[R7, #+1]
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x7038             STRB     R0,[R7, #+0]
    916                {
    917                  /* Disable Address Acknowledge */
    918                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x6841             LDR      R1,[R0, #+4]
   \   000000AE   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000B2   0x6041             STR      R1,[R0, #+4]
    919                  
    920                  /* Store Last receive data if any */
    921                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6981             LDR      R1,[R0, #+24]
   \   000000B8   0x0749             LSLS     R1,R1,#+29
   \   000000BA   0xBF44             ITT      MI 
   \   000000BC   0x6A40             LDRMI    R0,[R0, #+36]
   \   000000BE   0x7028             STRBMI   R0,[R5, #+0]
    922                  {
    923                    /* Read data from RXDR */
    924                    (*pData++) = hi2c->Instance->RXDR;
    925                  }
    926                  
    927                  if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   000000C0   0x6878             LDR      R0,[R7, #+4]
   \   000000C2   0x2820             CMP      R0,#+32
   \   000000C4   0xD125             BNE.N    ??HAL_I2C_Slave_Receive_11
    928                  {
    929                    return HAL_TIMEOUT;
   \   000000C6   0xE036             B.N      ??HAL_I2C_Slave_Receive_3
    930                  }
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6841             LDR      R1,[R0, #+4]
   \   000000CC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000D0   0x6041             STR      R1,[R0, #+4]
   \   000000D2   0xE030             B.N      ??HAL_I2C_Slave_Receive_3
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \   000000D4   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000D8   0xD005             BEQ.N    ??HAL_I2C_Slave_Receive_12
   \   000000DA   0x.... 0x....      BL       HAL_GetTick
   \   000000DE   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000E2   0x4580             CMP      R8,R0
   \   000000E4   0xD2C6             BCS.N    ??HAL_I2C_Slave_Receive_6
   \                     ??HAL_I2C_Slave_Receive_12: (+1)
   \   000000E6   0x6878             LDR      R0,[R7, #+4]
   \   000000E8   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000EC   0xE7D8             B.N      ??HAL_I2C_Slave_Receive_10
    931                  else
    932                  {
    933                    return HAL_ERROR;
    934                  }
    935                }
    936                
    937                /* Read data from RXDR */
    938                (*pData++) = hi2c->Instance->RXDR;
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \   000000EE   0x6A40             LDR      R0,[R0, #+36]
    939                Size--;
   \   000000F0   0x1E76             SUBS     R6,R6,#+1
   \   000000F2   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   000000F6   0xD1BA             BNE.N    ??HAL_I2C_Slave_Receive_5
    940              }
    941              
    942              /* Wait until STOP flag is set */
    943              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   000000F8   0x2119             MOVS     R1,#+25
   \   000000FA   0x4620             MOV      R0,R4
   \   000000FC   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000100   0xB140             CBZ.N    R0,??HAL_I2C_Slave_Receive_13
    944              {
    945                /* Disable Address Acknowledge */
    946                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6841             LDR      R1,[R0, #+4]
   \   00000106   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000010A   0x6041             STR      R1,[R0, #+4]
    947                
    948                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000010C   0x6878             LDR      R0,[R7, #+4]
   \   0000010E   0x2804             CMP      R0,#+4
   \   00000110   0xD111             BNE.N    ??HAL_I2C_Slave_Receive_3
    949                {
    950                  return HAL_ERROR;
    951                }
    952                else
    953                {
    954                  return HAL_TIMEOUT;
    955                }
    956              }
   \                     ??HAL_I2C_Slave_Receive_11: (+1)
   \   00000112   0x....             B.N      ?Subroutine6
    957              
    958              /* Clear STOP flag */
    959              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Slave_Receive_13: (+1)
   \   00000114   0x6821             LDR      R1,[R4, #+0]
   \   00000116   0x2020             MOVS     R0,#+32
    960              
    961              /* Wait until BUSY flag is reset */ 
    962              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
   \   00000118   0x4643             MOV      R3,R8
   \   0000011A   0x2201             MOVS     R2,#+1
   \   0000011C   0x61C8             STR      R0,[R1, #+28]
   \   0000011E   0xF44F 0x4100      MOV      R1,#+32768
   \   00000122   0x4620             MOV      R0,R4
   \   00000124   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x6841             LDR      R1,[R0, #+4]
   \   0000012E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000132   0x6041             STR      R1,[R0, #+4]
   \   00000134   0xD000             BEQ.N    ??HAL_I2C_Slave_Receive_14
    963              {
    964                /* Disable Address Acknowledge */
    965                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    966                return HAL_TIMEOUT;
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \   00000136   0x....             B.N      ?Subroutine5
    967              }
    968              
    969              
    970              /* Disable Address Acknowledge */
    971              hi2c->Instance->CR2 |= I2C_CR2_NACK;
    972              
    973              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Receive_14: (+1)
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0x7078             STRB     R0,[R7, #+1]
    974              
    975              /* Process Unlocked */
    976              __HAL_UNLOCK(hi2c);
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x7038             STRB     R0,[R7, #+0]
    977              
    978              return HAL_OK;
   \   00000140   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    979            }
    980            else
    981            {
    982              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \   00000144   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \   00000146   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    983            } 
    984          }
    985          
    986          /**
    987            * @brief  Transmit in master mode an amount of data in no-blocking mode with Interrupt
    988            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    989            *                the configuration information for the specified I2C.
    990            * @param  DevAddress: Target device address
    991            * @param  pData: Pointer to data buffer
    992            * @param  Size: Amount of data to be sent
    993            * @retval HAL status
    994            */

   \                                 In section .text, align 2, keep-with-next
    995          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    996          {   
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    997            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000008   0x7868             LDRB     R0,[R5, #+1]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD133             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
    998            {
    999              if((pData == NULL) || (Size == 0)) 
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2B00             CMPNE    R3,#+0
   \   00000014   0xD030             BEQ.N    ??HAL_I2C_Master_Transmit_IT_1
   1000              {
   1001                return  HAL_ERROR;                                    
   1002              }
   1003              
   1004              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6980             LDR      R0,[R0, #+24]
   \   0000001A   0x0400             LSLS     R0,R0,#+16
   \   0000001C   0xD42B             BMI.N    ??HAL_I2C_Master_Transmit_IT_0
   1005              {
   1006                return HAL_BUSY;
   1007              }
   1008              
   1009              /* Process Locked */
   1010              __HAL_LOCK(hi2c);
   \   0000001E   0x7828             LDRB     R0,[R5, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD028             BEQ.N    ??HAL_I2C_Master_Transmit_IT_0
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7028             STRB     R0,[R5, #+0]
   1011              
   1012              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
   \   00000028   0x2012             MOVS     R0,#+18
   \   0000002A   0x7068             STRB     R0,[R5, #+1]
   1013              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6068             STR      R0,[R5, #+4]
   1014              
   1015              hi2c->pBuffPtr = pData;
   1016              hi2c->XferCount = Size;
   1017              if(Size > 255)
   \   00000030   0x2BFF             CMP      R3,#+255
   \   00000032   0x6262             STR      R2,[R4, #+36]
   \   00000034   0x8563             STRH     R3,[R4, #+42]
   \   00000036   0xBFC6             ITTE     GT 
   \   00000038   0x20FF             MOVGT    R0,#+255
   \   0000003A   0x8520             STRHGT   R0,[R4, #+40]
   \   0000003C   0x8523             STRHLE   R3,[R4, #+40]
   1018              {
   1019                hi2c->XferSize = 255;
   1020              }
   1021              else
   1022              {
   1023                hi2c->XferSize = Size;
   1024              }
   1025              
   1026              /* Send Slave Address */
   1027              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1028              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   0000003E   0x8D22             LDRH     R2,[R4, #+40]
   \   00000040   0x2AFF             CMP      R2,#+255
   \   00000042   0xD108             BNE.N    ??HAL_I2C_Master_Transmit_IT_2
   \   00000044   0x8D60             LDRH     R0,[R4, #+42]
   \   00000046   0x4282             CMP      R2,R0
   \   00000048   0xD205             BCS.N    ??HAL_I2C_Master_Transmit_IT_2
   1029              {
   1030                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   0000004A   0xF44F 0x5000      MOV      R0,#+8192
   \   0000004E   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0xE005             B.N      ??HAL_I2C_Master_Transmit_IT_3
   1031              }
   1032              else
   1033              {
   1034                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_IT_2: (+1)
   \   00000056   0xF44F 0x5000      MOV      R0,#+8192
   \   0000005A   0xF04F 0x7300      MOV      R3,#+33554432
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Master_Transmit_IT_3: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       I2C_TransferConfig
   1035              }
   1036              
   1037              /* Process Unlocked */
   1038              __HAL_UNLOCK(hi2c); 
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x7028             STRB     R0,[R5, #+0]
   1039              
   1040              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1041              to avoid the risk of I2C interrupt handle execution before current
   1042              process unlock */
   1043              
   1044              
   1045              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1046              /* possible to enable all of these */
   1047              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1048              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0xF041 0x01F2      ORR      R1,R1,#0xF2
   \   00000074   0x....             B.N      ?Subroutine0
   1049              
   1050              return HAL_OK;
   1051            }
   1052            else
   1053            {
   1054              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \   00000076   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_IT_1: (+1)
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1055            } 
   1056          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xBD32             POP      {R1,R4,R5,PC}
   1057          
   1058          /**
   1059            * @brief  Receive in master mode an amount of data in no-blocking mode with Interrupt
   1060            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1061            *                the configuration information for the specified I2C.
   1062            * @param  DevAddress: Target device address
   1063            * @param  pData: Pointer to data buffer
   1064            * @param  Size: Amount of data to be sent
   1065            * @retval HAL status
   1066            */

   \                                 In section .text, align 2, keep-with-next
   1067          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1068          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1069            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000008   0x7868             LDRB     R0,[R5, #+1]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD133             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1070            {
   1071              if((pData == NULL) || (Size == 0)) 
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2B00             CMPNE    R3,#+0
   \   00000014   0xD030             BEQ.N    ??HAL_I2C_Master_Receive_IT_1
   1072              {
   1073                return  HAL_ERROR;                                    
   1074              }
   1075              
   1076              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6980             LDR      R0,[R0, #+24]
   \   0000001A   0x0400             LSLS     R0,R0,#+16
   \   0000001C   0xD42B             BMI.N    ??HAL_I2C_Master_Receive_IT_0
   1077              {
   1078                return HAL_BUSY;
   1079              }
   1080              
   1081              /* Process Locked */
   1082              __HAL_LOCK(hi2c);
   \   0000001E   0x7828             LDRB     R0,[R5, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD028             BEQ.N    ??HAL_I2C_Master_Receive_IT_0
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7028             STRB     R0,[R5, #+0]
   1083              
   1084              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
   \   00000028   0x2022             MOVS     R0,#+34
   \   0000002A   0x7068             STRB     R0,[R5, #+1]
   1085              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6068             STR      R0,[R5, #+4]
   1086              
   1087              hi2c->pBuffPtr = pData;
   1088              hi2c->XferCount = Size;
   1089              if(Size > 255)
   \   00000030   0x2BFF             CMP      R3,#+255
   \   00000032   0x6262             STR      R2,[R4, #+36]
   \   00000034   0x8563             STRH     R3,[R4, #+42]
   \   00000036   0xBFC6             ITTE     GT 
   \   00000038   0x20FF             MOVGT    R0,#+255
   \   0000003A   0x8520             STRHGT   R0,[R4, #+40]
   \   0000003C   0x8523             STRHLE   R3,[R4, #+40]
   1090              {
   1091                hi2c->XferSize = 255;
   1092              }
   1093              else
   1094              {
   1095                hi2c->XferSize = Size;
   1096              }
   1097              
   1098              /* Send Slave Address */
   1099              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1100              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   0000003E   0x8D22             LDRH     R2,[R4, #+40]
   \   00000040   0x2AFF             CMP      R2,#+255
   \   00000042   0xD108             BNE.N    ??HAL_I2C_Master_Receive_IT_2
   \   00000044   0x8D60             LDRH     R0,[R4, #+42]
   \   00000046   0x4282             CMP      R2,R0
   \   00000048   0xD205             BCS.N    ??HAL_I2C_Master_Receive_IT_2
   1101              {
   1102                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   0000004A   0xF44F 0x5010      MOV      R0,#+9216
   \   0000004E   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0xE005             B.N      ??HAL_I2C_Master_Receive_IT_3
   1103              }
   1104              else
   1105              {
   1106                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_IT_2: (+1)
   \   00000056   0xF44F 0x5010      MOV      R0,#+9216
   \   0000005A   0xF04F 0x7300      MOV      R3,#+33554432
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Master_Receive_IT_3: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       I2C_TransferConfig
   1107              }
   1108              
   1109              /* Process Unlocked */
   1110              __HAL_UNLOCK(hi2c); 
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x7028             STRB     R0,[R5, #+0]
   1111              
   1112              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1113              to avoid the risk of I2C interrupt handle execution before current
   1114              process unlock */
   1115              
   1116              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1117              /* possible to enable all of these */
   1118              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1119              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI );
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0xF041 0x01F4      ORR      R1,R1,#0xF4
   \   00000074   0x....             B.N      ?Subroutine0
   1120              
   1121              return HAL_OK;
   1122            }
   1123            else
   1124            {
   1125              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \   00000076   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_IT_1: (+1)
   \   00000078   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1126            } 
   1127          }
   1128          
   1129          /**
   1130            * @brief  Transmit in slave mode an amount of data in no-blocking mode with Interrupt 
   1131            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1132            *                the configuration information for the specified I2C.
   1133            * @param  pData: Pointer to data buffer
   1134            * @param  Size: Amount of data to be sent
   1135            * @retval HAL status
   1136            */

   \                                 In section .text, align 2, keep-with-next
   1137          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1138          {
   1139            if(hi2c->State == HAL_I2C_STATE_READY)
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \   00000000   0xF100 0x0334      ADD      R3,R0,#+52
   \   00000004   0xB430             PUSH     {R4,R5}
   \   00000006   0x785C             LDRB     R4,[R3, #+1]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD11C             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1140            {
   1141              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0x2001             MOVEQ    R0,#+1
   1142              {
   1143                return  HAL_ERROR;                                    
   \   00000014   0xD018             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_1
   1144              }
   1145              
   1146              /* Process Locked */
   1147              __HAL_LOCK(hi2c);
   \   00000016   0x781C             LDRB     R4,[R3, #+0]
   \   00000018   0x2C01             CMP      R4,#+1
   \   0000001A   0xD014             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_0
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0x701C             STRB     R4,[R3, #+0]
   1148              
   1149              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
   \   00000020   0x2432             MOVS     R4,#+50
   \   00000022   0x705C             STRB     R4,[R3, #+1]
   1150              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000024   0x2400             MOVS     R4,#+0
   \   00000026   0x605C             STR      R4,[R3, #+4]
   1151              
   1152              /* Enable Address Acknowledge */
   1153              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   00000028   0x6804             LDR      R4,[R0, #+0]
   \   0000002A   0x6865             LDR      R5,[R4, #+4]
   \   0000002C   0xF425 0x4500      BIC      R5,R5,#0x8000
   \   00000030   0x6065             STR      R5,[R4, #+4]
   1154              
   1155              hi2c->pBuffPtr = pData;
   \   00000032   0x6241             STR      R1,[R0, #+36]
   1156              hi2c->XferSize = Size;
   1157              hi2c->XferCount = Size;
   1158              
   1159              /* Process Unlocked */
   1160              __HAL_UNLOCK(hi2c); 
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x8502             STRH     R2,[R0, #+40]
   \   00000038   0x8542             STRH     R2,[R0, #+42]
   \   0000003A   0x7019             STRB     R1,[R3, #+0]
   1161              
   1162              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1163              to avoid the risk of I2C interrupt handle execution before current
   1164              process unlock */
   1165              
   1166              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1167              /* possible to enable all of these */
   1168              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1169              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_TXI );
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xF041 0x01FA      ORR      R1,R1,#0xFA
   \   00000044   0x....             B.N      ?Subroutine7
   1170              
   1171              return HAL_OK;
   1172            }
   1173            else
   1174            {
   1175              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \   00000046   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_IT_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
   1176            } 
   1177          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xBC30             POP      {R4,R5}
   \   00000006   0x4770             BX       LR
   1178          
   1179          /**
   1180            * @brief  Receive in slave mode an amount of data in no-blocking mode with Interrupt 
   1181            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1182            *                the configuration information for the specified I2C.
   1183            * @param  pData: Pointer to data buffer
   1184            * @param  Size: Amount of data to be sent
   1185            * @retval HAL status
   1186            */

   \                                 In section .text, align 2, keep-with-next
   1187          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1188          {
   1189            if(hi2c->State == HAL_I2C_STATE_READY)
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \   00000000   0xF100 0x0334      ADD      R3,R0,#+52
   \   00000004   0xB430             PUSH     {R4,R5}
   \   00000006   0x785C             LDRB     R4,[R3, #+1]
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD11C             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1190            {
   1191              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0x2001             MOVEQ    R0,#+1
   1192              {
   1193                return  HAL_ERROR;                                    
   \   00000014   0xD018             BEQ.N    ??HAL_I2C_Slave_Receive_IT_1
   1194              }
   1195              
   1196              /* Process Locked */
   1197              __HAL_LOCK(hi2c);
   \   00000016   0x781C             LDRB     R4,[R3, #+0]
   \   00000018   0x2C01             CMP      R4,#+1
   \   0000001A   0xD014             BEQ.N    ??HAL_I2C_Slave_Receive_IT_0
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0x701C             STRB     R4,[R3, #+0]
   1198              
   1199              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   \   00000020   0x2442             MOVS     R4,#+66
   \   00000022   0x705C             STRB     R4,[R3, #+1]
   1200              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000024   0x2400             MOVS     R4,#+0
   \   00000026   0x605C             STR      R4,[R3, #+4]
   1201              
   1202              /* Enable Address Acknowledge */
   1203              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   00000028   0x6804             LDR      R4,[R0, #+0]
   \   0000002A   0x6865             LDR      R5,[R4, #+4]
   \   0000002C   0xF425 0x4500      BIC      R5,R5,#0x8000
   \   00000030   0x6065             STR      R5,[R4, #+4]
   1204              
   1205              hi2c->pBuffPtr = pData;
   \   00000032   0x6241             STR      R1,[R0, #+36]
   1206              hi2c->XferSize = Size;
   1207              hi2c->XferCount = Size;
   1208              
   1209              /* Process Unlocked */
   1210              __HAL_UNLOCK(hi2c); 
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x8502             STRH     R2,[R0, #+40]
   \   00000038   0x8542             STRH     R2,[R0, #+42]
   \   0000003A   0x7019             STRB     R1,[R3, #+0]
   1211              
   1212              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1213              to avoid the risk of I2C interrupt handle execution before current
   1214              process unlock */
   1215              
   1216              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1217              /* possible to enable all of these */
   1218              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1219              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI);
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xF041 0x01FC      ORR      R1,R1,#0xFC
   \   00000044   0x....             B.N      ?Subroutine7
   1220              
   1221              return HAL_OK;
   1222            }
   1223            else
   1224            {
   1225              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \   00000046   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_IT_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
   1226            }
   1227          }
   1228          
   1229          /**
   1230            * @brief  Transmit in master mode an amount of data in no-blocking mode with DMA
   1231            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1232            *                the configuration information for the specified I2C.
   1233            * @param  DevAddress: Target device address
   1234            * @param  pData: Pointer to data buffer
   1235            * @param  Size: Amount of data to be sent
   1236            * @retval HAL status
   1237            */

   \                                 In section .text, align 2, keep-with-next
   1238          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1239          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1240            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x460E             MOV      R6,R1
   \   0000000C   0x7868             LDRB     R0,[R5, #+1]
   \   0000000E   0x4611             MOV      R1,R2
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD157             BNE.N    ??HAL_I2C_Master_Transmit_DMA_0
   1241            {
   1242              if((pData == NULL) || (Size == 0)) 
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xBF18             IT       NE 
   \   00000018   0x2B00             CMPNE    R3,#+0
   \   0000001A   0xD054             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_1
   1243              {
   1244                return  HAL_ERROR;                                    
   1245              }     
   1246              
   1247              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0400             LSLS     R0,R0,#+16
   \   00000022   0xD44F             BMI.N    ??HAL_I2C_Master_Transmit_DMA_0
   1248              {
   1249                return HAL_BUSY;
   1250              }
   1251              
   1252              /* Process Locked */
   1253              __HAL_LOCK(hi2c);
   \   00000024   0x7828             LDRB     R0,[R5, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD04C             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_0
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x7028             STRB     R0,[R5, #+0]
   1254              
   1255              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
   \   0000002E   0x2012             MOVS     R0,#+18
   \   00000030   0x7068             STRB     R0,[R5, #+1]
   1256              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6068             STR      R0,[R5, #+4]
   1257              
   1258              hi2c->pBuffPtr = pData;
   1259              hi2c->XferCount = Size;
   1260              if(Size > 255)
   \   00000036   0x2BFF             CMP      R3,#+255
   \   00000038   0x6261             STR      R1,[R4, #+36]
   \   0000003A   0x8563             STRH     R3,[R4, #+42]
   \   0000003C   0xBFC6             ITTE     GT 
   \   0000003E   0x20FF             MOVGT    R0,#+255
   \   00000040   0x8520             STRHGT   R0,[R4, #+40]
   \   00000042   0x8523             STRHLE   R3,[R4, #+40]
   1261              {
   1262                hi2c->XferSize = 255;
   1263              }
   1264              else
   1265              {
   1266                hi2c->XferSize = Size;
   1267              }
   1268              
   1269              /* Set the I2C DMA transfer complete callback */
   1270              hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \   00000044   0x6AE2             LDR      R2,[R4, #+44]
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000004A   0x63D0             STR      R0,[R2, #+60]
   1271              
   1272              /* Set the DMA error callback */
   1273              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   0000004C   0x6AE2             LDR      R2,[R4, #+44]
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000052   0x6490             STR      R0,[R2, #+72]
   1274              
   1275              /* Enable the DMA channel */
   1276              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x8D23             LDRH     R3,[R4, #+40]
   \   00000058   0xF100 0x0228      ADD      R2,R0,#+40
   \   0000005C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Start_IT
   1277              
   1278              /* Send Slave Address */
   1279              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1280              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000062   0x8D22             LDRH     R2,[R4, #+40]
   \   00000064   0x2AFF             CMP      R2,#+255
   \   00000066   0xD108             BNE.N    ??HAL_I2C_Master_Transmit_DMA_2
   \   00000068   0x8D60             LDRH     R0,[R4, #+42]
   \   0000006A   0x4282             CMP      R2,R0
   \   0000006C   0xD205             BCS.N    ??HAL_I2C_Master_Transmit_DMA_2
   1281              {
   1282                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   0000006E   0xF44F 0x5000      MOV      R0,#+8192
   \   00000072   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0xE005             B.N      ??HAL_I2C_Master_Transmit_DMA_3
   1283              }
   1284              else
   1285              {
   1286                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \   0000007A   0xF44F 0x5000      MOV      R0,#+8192
   \   0000007E   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000082   0x9000             STR      R0,[SP, #+0]
   \   00000084   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \   00000086   0x4631             MOV      R1,R6
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       I2C_TransferConfig
   1287              }  
   1288              
   1289              /* Wait until TXIS flag is set */
   1290              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   0000008E   0x2119             MOVS     R1,#+25
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_4
   1291              {
   1292                /* Disable Address Acknowledge */
   1293                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   0000009C   0x6841             LDR      R1,[R0, #+4]
   \   0000009E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000A2   0x6041             STR      R1,[R0, #+4]
   1294                
   1295                /* Abort DMA */
   1296                HAL_DMA_Abort(hi2c->hdmatx);
   \   000000A4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000A6   0x.... 0x....      BL       HAL_DMA_Abort
   1297                
   1298                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000AA   0x6868             LDR      R0,[R5, #+4]
   \   000000AC   0x2804             CMP      R0,#+4
   \   000000AE   0xBF0C             ITE      EQ 
   \   000000B0   0x2001             MOVEQ    R0,#+1
   \   000000B2   0x2003             MOVNE    R0,#+3
   1299                {
   1300                  return HAL_ERROR;
   1301                }
   1302                else
   1303                {
   1304                  return HAL_TIMEOUT;
   \   000000B4   0xBD76             POP      {R1,R2,R4-R6,PC}
   1305                }
   1306              }
   1307              
   1308              /* Enable DMA Request */
   1309              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;   
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \   000000B6   0x6801             LDR      R1,[R0, #+0]
   \   000000B8   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000BC   0x6001             STR      R1,[R0, #+0]
   1310              
   1311              /* Process Unlocked */
   1312              __HAL_UNLOCK(hi2c);
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x7028             STRB     R0,[R5, #+0]
   1313              
   1314              return HAL_OK;
   \   000000C2   0xBD76             POP      {R1,R2,R4-R6,PC}
   1315            }
   1316            else
   1317            {
   1318              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \   000000C4   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \   000000C6   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1319            }
   1320          }
   1321          
   1322          /**
   1323            * @brief  Receive in master mode an amount of data in no-blocking mode with DMA 
   1324            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1325            *                the configuration information for the specified I2C.
   1326            * @param  DevAddress: Target device address
   1327            * @param  pData: Pointer to data buffer
   1328            * @param  Size: Amount of data to be sent
   1329            * @retval HAL status
   1330            */

   \                                 In section .text, align 2, keep-with-next
   1331          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1332          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   1333            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF105 0x0434      ADD      R4,R5,#+52
   \   00000008   0xB082             SUB      SP,SP,#+8
   \   0000000A   0x460E             MOV      R6,R1
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD152             BNE.N    ??HAL_I2C_Master_Receive_DMA_0
   1334            {
   1335              if((pData == NULL) || (Size == 0)) 
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2B00             CMPNE    R3,#+0
   \   00000018   0xD04F             BEQ.N    ??HAL_I2C_Master_Receive_DMA_1
   1336              {
   1337                return  HAL_ERROR;                                    
   1338              }  
   1339              
   1340              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0x0400             LSLS     R0,R0,#+16
   \   00000020   0xD44A             BMI.N    ??HAL_I2C_Master_Receive_DMA_0
   1341              {
   1342                return HAL_BUSY;
   1343              }
   1344              
   1345              /* Process Locked */
   1346              __HAL_LOCK(hi2c);
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD047             BEQ.N    ??HAL_I2C_Master_Receive_DMA_0
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x7020             STRB     R0,[R4, #+0]
   1347              
   1348              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
   \   0000002C   0x2022             MOVS     R0,#+34
   \   0000002E   0x7060             STRB     R0,[R4, #+1]
   1349              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6060             STR      R0,[R4, #+4]
   1350              
   1351              hi2c->pBuffPtr = pData;
   1352              hi2c->XferCount = Size;
   1353              if(Size > 255)
   \   00000034   0x2BFF             CMP      R3,#+255
   \   00000036   0x626A             STR      R2,[R5, #+36]
   \   00000038   0x856B             STRH     R3,[R5, #+42]
   \   0000003A   0xBFC6             ITTE     GT 
   \   0000003C   0x20FF             MOVGT    R0,#+255
   \   0000003E   0x8528             STRHGT   R0,[R5, #+40]
   \   00000040   0x852B             STRHLE   R3,[R5, #+40]
   1354              {
   1355                hi2c->XferSize = 255;
   1356              }
   1357              else
   1358              {
   1359                hi2c->XferSize = Size;
   1360              }
   1361              
   1362              /* Set the I2C DMA transfer complete callback */
   1363              hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \   00000042   0x6B29             LDR      R1,[R5, #+48]
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000048   0x63C8             STR      R0,[R1, #+60]
   1364              
   1365              /* Set the DMA error callback */
   1366              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   0000004A   0x6B29             LDR      R1,[R5, #+48]
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000050   0x6488             STR      R0,[R1, #+72]
   1367              
   1368              /* Enable the DMA channel */
   1369              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   \   00000052   0x6828             LDR      R0,[R5, #+0]
   \   00000054   0x8D2B             LDRH     R3,[R5, #+40]
   \   00000056   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000005A   0x6B28             LDR      R0,[R5, #+48]
   \   0000005C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1370              
   1371              /* Send Slave Address */
   1372              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1373              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000060   0x8D2A             LDRH     R2,[R5, #+40]
   \   00000062   0x2AFF             CMP      R2,#+255
   \   00000064   0xD108             BNE.N    ??HAL_I2C_Master_Receive_DMA_2
   \   00000066   0x8D68             LDRH     R0,[R5, #+42]
   \   00000068   0x4282             CMP      R2,R0
   \   0000006A   0xD205             BCS.N    ??HAL_I2C_Master_Receive_DMA_2
   1374              {
   1375                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   0000006C   0xF44F 0x5010      MOV      R0,#+9216
   \   00000070   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0xE005             B.N      ??HAL_I2C_Master_Receive_DMA_3
   1376              }
   1377              else
   1378              {
   1379                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \   00000078   0xF44F 0x5010      MOV      R0,#+9216
   \   0000007C   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \   00000084   0x4631             MOV      R1,R6
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       I2C_TransferConfig
   1380              }
   1381              
   1382              /* Wait until RXNE flag is set */
   1383              if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, I2C_FLAG_RXNE) != HAL_OK)      
   \   0000008C   0x2104             MOVS     R1,#+4
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \   00000094   0xB140             CBZ.N    R0,??HAL_I2C_Master_Receive_DMA_4
   1384              {
   1385                /* Abort DMA */
   1386                HAL_DMA_Abort(hi2c->hdmarx);
   \   00000096   0x6B28             LDR      R0,[R5, #+48]
   \   00000098   0x.... 0x....      BL       HAL_DMA_Abort
   1387                
   1388                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000009C   0x6860             LDR      R0,[R4, #+4]
   \   0000009E   0x2804             CMP      R0,#+4
   \   000000A0   0xBF0C             ITE      EQ 
   \   000000A2   0x2001             MOVEQ    R0,#+1
   \   000000A4   0x2003             MOVNE    R0,#+3
   1389                {
   1390                  return HAL_ERROR;
   1391                }
   1392                else
   1393                {
   1394                  return HAL_TIMEOUT;
   \   000000A6   0xBD76             POP      {R1,R2,R4-R6,PC}
   1395                }
   1396          	}
   1397              
   1398              /* Enable DMA Request */
   1399              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;   
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \   000000A8   0x6828             LDR      R0,[R5, #+0]
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000B0   0x6001             STR      R1,[R0, #+0]
   1400              
   1401              /* Process Unlocked */
   1402              __HAL_UNLOCK(hi2c);
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x7020             STRB     R0,[R4, #+0]
   1403              
   1404              return HAL_OK;
   \   000000B6   0xBD76             POP      {R1,R2,R4-R6,PC}
   1405            }
   1406            else
   1407            {
   1408              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \   000000B8   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \   000000BA   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1409            }
   1410          }
   1411          
   1412          /**
   1413            * @brief  Transmit in slave mode an amount of data in no-blocking mode with DMA 
   1414            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1415            *                the configuration information for the specified I2C.
   1416            * @param  pData: Pointer to data buffer
   1417            * @param  Size: Amount of data to be sent
   1418            * @retval HAL status
   1419            */

   \                                 In section .text, align 2, keep-with-next
   1420          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1421          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1422            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000008   0x7868             LDRB     R0,[R5, #+1]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD157             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   1423            {
   1424              if((pData == NULL) || (Size == 0)) 
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2A00             CMPNE    R2,#+0
   \   00000014   0xD054             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_1
   1425              {
   1426                return  HAL_ERROR;                                    
   1427              }   
   1428              /* Process Locked */
   1429              __HAL_LOCK(hi2c); 
   \   00000016   0x7828             LDRB     R0,[R5, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD050             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_0
   \   0000001C   0x2001             MOVS     R0,#+1
   1430              
   1431              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
   1432              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1433              
   1434              hi2c->pBuffPtr = pData;
   1435              hi2c->XferCount = Size;
   1436              hi2c->XferSize = Size;
   1437              
   1438              /* Set the I2C DMA transfer complete callback */
   1439              hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   1440              
   1441              /* Set the DMA error callback */
   1442              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   1443              
   1444              /* Enable the DMA channel */
   1445              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   0000001E   0xF242 0x7611      MOVW     R6,#+10001
   \   00000022   0x7028             STRB     R0,[R5, #+0]
   \   00000024   0x2032             MOVS     R0,#+50
   \   00000026   0x7068             STRB     R0,[R5, #+1]
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6068             STR      R0,[R5, #+4]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000030   0x6261             STR      R1,[R4, #+36]
   \   00000032   0x8562             STRH     R2,[R4, #+42]
   \   00000034   0x8522             STRH     R2,[R4, #+40]
   \   00000036   0x6AE2             LDR      R2,[R4, #+44]
   \   00000038   0x63D0             STR      R0,[R2, #+60]
   \   0000003A   0x6AE2             LDR      R2,[R4, #+44]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000040   0x6490             STR      R0,[R2, #+72]
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x8D23             LDRH     R3,[R4, #+40]
   \   00000046   0xF100 0x0228      ADD      R2,R0,#+40
   \   0000004A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000004C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1446              
   1447              /* Enable Address Acknowledge */
   1448              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6841             LDR      R1,[R0, #+4]
   \   00000054   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000058   0x6041             STR      R1,[R0, #+4]
   1449              
   1450              /* Wait until ADDR flag is set */
   1451              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   0000005A   0x.... 0x....      BL       HAL_GetTick
   \   0000005E   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6981             LDR      R1,[R0, #+24]
   \   00000064   0x0709             LSLS     R1,R1,#+28
   \   00000066   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_3
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1BC0             SUBS     R0,R0,R7
   \   0000006E   0x42B0             CMP      R0,R6
   \   00000070   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_2
   \   00000072   0xE01F             B.N      ??HAL_I2C_Slave_Transmit_DMA_4
   1452              {
   1453                /* Disable Address Acknowledge */
   1454                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1455                return HAL_TIMEOUT;
   1456              }
   1457              
   1458              /* Clear ADDR flag */
   1459              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \   00000074   0x2108             MOVS     R1,#+8
   \   00000076   0x61C1             STR      R1,[R0, #+28]
   1460              
   1461              /* If 10bits addressing mode is selected */
   1462              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \   00000078   0x68E0             LDR      R0,[R4, #+12]
   \   0000007A   0x2802             CMP      R0,#+2
   \   0000007C   0xD10E             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_5
   1463              {
   1464                /* Wait until ADDR flag is set */
   1465                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   0000007E   0x.... 0x....      BL       HAL_GetTick
   \   00000082   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_6: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6981             LDR      R1,[R0, #+24]
   \   00000088   0x0709             LSLS     R1,R1,#+28
   \   0000008A   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_7
   \   0000008C   0x.... 0x....      BL       HAL_GetTick
   \   00000090   0x1BC0             SUBS     R0,R0,R7
   \   00000092   0x42B0             CMP      R0,R6
   \   00000094   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_6
   \   00000096   0xE00D             B.N      ??HAL_I2C_Slave_Transmit_DMA_4
   1466                {
   1467                  /* Disable Address Acknowledge */
   1468                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1469                  return HAL_TIMEOUT;
   1470                }
   1471                
   1472                /* Clear ADDR flag */
   1473                __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Transmit_DMA_7: (+1)
   \   00000098   0x2108             MOVS     R1,#+8
   \   0000009A   0x61C1             STR      R1,[R0, #+28]
   1474              }
   1475              
   1476              /* Wait until DIR flag is set Transmitter mode */
   1477              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \                     ??HAL_I2C_Slave_Transmit_DMA_5: (+1)
   \   0000009C   0x.... 0x....      BL       HAL_GetTick
   \   000000A0   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_8: (+1)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6981             LDR      R1,[R0, #+24]
   \   000000A6   0x03C9             LSLS     R1,R1,#+15
   \   000000A8   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_9
   \   000000AA   0x.... 0x....      BL       HAL_GetTick
   \   000000AE   0x1B80             SUBS     R0,R0,R6
   \   000000B0   0x281A             CMP      R0,#+26
   \   000000B2   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_8
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \   000000B4   0x....             B.N      ?Subroutine8
   1478              {
   1479                /* Disable Address Acknowledge */
   1480                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1481                return HAL_TIMEOUT;
   1482              }
   1483              
   1484              /* Enable DMA Request */
   1485              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN; 
   \                     ??HAL_I2C_Slave_Transmit_DMA_9: (+1)
   \   000000B6   0x6801             LDR      R1,[R0, #+0]
   \   000000B8   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000BC   0x....             B.N      ?Subroutine9
   1486              
   1487              /* Process Unlocked */
   1488              __HAL_UNLOCK(hi2c);
   1489              
   1490              return HAL_OK;
   1491            }
   1492            else
   1493            {
   1494              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \   000000BE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \   000000C0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1495            }
   1496          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x7028             STRB     R0,[R5, #+0]
   \   00000006   0xBDF2             POP      {R1,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x7068             STRB     R0,[R5, #+1]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7028             STRB     R0,[R5, #+0]
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6841             LDR      R1,[R0, #+4]
   \   0000000C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000010   0x6041             STR      R1,[R0, #+4]
   \   00000012   0x2003             MOVS     R0,#+3
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
   1497          
   1498          /**
   1499            * @brief  Receive in slave mode an amount of data in no-blocking mode with DMA 
   1500            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1501            *                the configuration information for the specified I2C.
   1502            * @param  pData: Pointer to data buffer
   1503            * @param  Size: Amount of data to be sent
   1504            * @retval HAL status
   1505            */

   \                                 In section .text, align 2, keep-with-next
   1506          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1507          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1508            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000008   0x7868             LDRB     R0,[R5, #+1]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD146             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   1509            {
   1510              if((pData == NULL) || (Size == 0)) 
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2A00             CMPNE    R2,#+0
   \   00000014   0xD043             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_1
   1511              {
   1512                return  HAL_ERROR;                                    
   1513              }   
   1514              /* Process Locked */
   1515              __HAL_LOCK(hi2c);
   \   00000016   0x7828             LDRB     R0,[R5, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD03F             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_0
   \   0000001C   0x2001             MOVS     R0,#+1
   1516              
   1517              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   1518              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1519              
   1520              hi2c->pBuffPtr = pData;
   1521              hi2c->XferSize = Size;
   1522              hi2c->XferCount = Size;
   1523              
   1524              /* Set the I2C DMA transfer complete callback */
   1525              hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   1526              
   1527              /* Set the DMA error callback */
   1528              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   1529              
   1530              /* Enable the DMA channel */
   1531              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, Size);
   \   0000001E   0xF242 0x7711      MOVW     R7,#+10001
   \   00000022   0x7028             STRB     R0,[R5, #+0]
   \   00000024   0x2042             MOVS     R0,#+66
   \   00000026   0x7068             STRB     R0,[R5, #+1]
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6068             STR      R0,[R5, #+4]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable13_4
   \   00000030   0x6261             STR      R1,[R4, #+36]
   \   00000032   0x8522             STRH     R2,[R4, #+40]
   \   00000034   0x8562             STRH     R2,[R4, #+42]
   \   00000036   0x6B23             LDR      R3,[R4, #+48]
   \   00000038   0x63D8             STR      R0,[R3, #+60]
   \   0000003A   0x6B23             LDR      R3,[R4, #+48]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000040   0x6498             STR      R0,[R3, #+72]
   \   00000042   0x4613             MOV      R3,R2
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x460A             MOV      R2,R1
   \   00000048   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000004C   0x6B20             LDR      R0,[R4, #+48]
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Start_IT
   1532              
   1533              /* Enable Address Acknowledge */
   1534              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6841             LDR      R1,[R0, #+4]
   \   00000056   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000005A   0x6041             STR      R1,[R0, #+4]
   1535              
   1536              /* Wait until ADDR flag is set */
   1537              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6981             LDR      R1,[R0, #+24]
   \   00000066   0x0709             LSLS     R1,R1,#+28
   \   00000068   0xD405             BMI.N    ??HAL_I2C_Slave_Receive_DMA_3
   \   0000006A   0x.... 0x....      BL       HAL_GetTick
   \   0000006E   0x1B80             SUBS     R0,R0,R6
   \   00000070   0x42B8             CMP      R0,R7
   \   00000072   0xD3F6             BCC.N    ??HAL_I2C_Slave_Receive_DMA_2
   \   00000074   0xE00D             B.N      ??HAL_I2C_Slave_Receive_DMA_4
   1538              {
   1539                /* Disable Address Acknowledge */
   1540                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1541                return HAL_TIMEOUT;
   1542              }
   1543              
   1544              /* Clear ADDR flag */
   1545              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \   00000076   0x2108             MOVS     R1,#+8
   \   00000078   0x61C1             STR      R1,[R0, #+28]
   1546              
   1547              /* Wait until DIR flag is set Receiver mode */
   1548              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, I2C_TIMEOUT_DIR) != HAL_OK)      
   \   0000007A   0x.... 0x....      BL       HAL_GetTick
   \   0000007E   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Receive_DMA_5: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6981             LDR      R1,[R0, #+24]
   \   00000084   0x03C9             LSLS     R1,R1,#+15
   \   00000086   0xD505             BPL.N    ??HAL_I2C_Slave_Receive_DMA_6
   \   00000088   0x.... 0x....      BL       HAL_GetTick
   \   0000008C   0x1B80             SUBS     R0,R0,R6
   \   0000008E   0x281A             CMP      R0,#+26
   \   00000090   0xD3F6             BCC.N    ??HAL_I2C_Slave_Receive_DMA_5
   \                     ??HAL_I2C_Slave_Receive_DMA_4: (+1)
   \   00000092   0x....             B.N      ?Subroutine8
   1549              {
   1550                /* Disable Address Acknowledge */
   1551                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1552                return HAL_TIMEOUT;
   1553              }
   1554              
   1555              /* Enable DMA Request */
   1556              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;  
   \                     ??HAL_I2C_Slave_Receive_DMA_6: (+1)
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000009A   0x....             B.N      ?Subroutine9
   1557              
   1558              /* Process Unlocked */
   1559              __HAL_UNLOCK(hi2c);
   1560              
   1561              return HAL_OK;
   1562            }
   1563            else
   1564            {
   1565              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \   0000009C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \   0000009E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1566            }
   1567          }
   1568          /**
   1569            * @brief  Write an amount of data in blocking mode to a specific memory address
   1570            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1571            *                the configuration information for the specified I2C.
   1572            * @param  DevAddress: Target device address
   1573            * @param  MemAddress: Internal memory address
   1574            * @param  MemAddSize: Size of internal memory address
   1575            * @param  pData: Pointer to data buffer
   1576            * @param  Size: Amount of data to be sent
   1577            * @param  Timeout: Timeout duration
   1578            * @retval HAL status
   1579            */

   \                                 In section .text, align 2, keep-with-next
   1580          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1581          {
   \                     HAL_I2C_Mem_Write: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   1582            uint32_t Sizetmp = 0;
   1583            
   1584            /* Check the parameters */
   1585            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1586            
   1587            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF105 0x0634      ADD      R6,R5,#+52
   \   0000000A   0x4689             MOV      R9,R1
   \   0000000C   0x7870             LDRB     R0,[R6, #+1]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xF040 0x80A7      BNE.W    ??HAL_I2C_Mem_Write_0
   \   00000014   0xF8DD 0xA028      LDR      R10,[SP, #+40]
   1588            { 
   1589              if((pData == NULL) || (Size == 0)) 
   \   00000018   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x9C0B             LDRNE    R4,[SP, #+44]
   \   00000020   0x2C00             CMPNE    R4,#+0
   \   00000022   0xF000 0x809F      BEQ.W    ??HAL_I2C_Mem_Write_1
   1590              {
   1591                return  HAL_ERROR;                                    
   1592              }
   1593              
   1594              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x6980             LDR      R0,[R0, #+24]
   \   0000002A   0x0400             LSLS     R0,R0,#+16
   \   0000002C   0xF100 0x8099      BMI.W    ??HAL_I2C_Mem_Write_0
   1595              {
   1596                return HAL_BUSY;
   1597              }
   1598              
   1599              /* Process Locked */
   1600              __HAL_LOCK(hi2c);
   \   00000030   0x7830             LDRB     R0,[R6, #+0]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xF000 0x8095      BEQ.W    ??HAL_I2C_Mem_Write_0
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x7030             STRB     R0,[R6, #+0]
   1601              
   1602              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   \   0000003C   0x2052             MOVS     R0,#+82
   \   0000003E   0x7070             STRB     R0,[R6, #+1]
   1603              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6070             STR      R0,[R6, #+4]
   \   00000044   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   1604              
   1605              /* Send Slave Address and Memory Address */
   1606              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000004E   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   00000052   0xB140             CBZ.N    R0,??HAL_I2C_Mem_Write_2
   1607              {
   1608                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000054   0x6870             LDR      R0,[R6, #+4]
   \   00000056   0x2804             CMP      R0,#+4
   \   00000058   0xD102             BNE.N    ??HAL_I2C_Mem_Write_3
   1609                {
   1610                  /* Process Unlocked */
   1611                  __HAL_UNLOCK(hi2c);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7030             STRB     R0,[R6, #+0]
   1612                  return HAL_ERROR;
   \   0000005E   0xE07B             B.N      ??HAL_I2C_Mem_Write_4
   1613                }
   1614                else
   1615                {
   1616                  /* Process Unlocked */
   1617                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x7030             STRB     R0,[R6, #+0]
   1618                  return HAL_TIMEOUT;
   \   00000064   0xE07A             B.N      ??HAL_I2C_Mem_Write_5
   1619                }
   1620              }
   1621              
   1622              /* Set NBYTES to write and reload if size > 255 */
   1623              /* Size > 255, need to set RELOAD bit */
   1624              if(Size > 255)
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \   00000066   0x2CFF             CMP      R4,#+255
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0xDD08             BLE.N    ??HAL_I2C_Mem_Write_6
   1625              {
   1626                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   0000006C   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000070   0x22FF             MOVS     R2,#+255
   \   00000072   0x4649             MOV      R1,R9
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       I2C_TransferConfig
   1627                Sizetmp = 255;
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \   0000007A   0x27FF             MOVS     R7,#+255
   \   0000007C   0xE011             B.N      ??HAL_I2C_Mem_Write_8
   1628              }
   1629              else
   1630              {
   1631                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \   0000007E   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000082   0xB2E2             UXTB     R2,R4
   \   00000084   0x4649             MOV      R1,R9
   \   00000086   0x4628             MOV      R0,R5
   \   00000088   0x.... 0x....      BL       I2C_TransferConfig
   1632                Sizetmp = Size;
   \   0000008C   0xE008             B.N      ??HAL_I2C_Mem_Write_9
   1633              }
   1634              
   1635              do
   1636              {
   1637                /* Wait until TXIS flag is set */
   1638                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   1639                {
   1640                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1641                  {
   1642                    return HAL_ERROR;
   1643                  }
   1644                  else
   1645                  {
   1646                    return HAL_TIMEOUT;
   1647                  }
   1648                }
   1649                
   1650                /* Write data to DR */
   1651                hi2c->Instance->TXDR = (*pData++);
   1652                Sizetmp--;
   1653                Size--;
   1654                
   1655                if((Sizetmp == 0)&&(Size!=0))
   1656                {
   1657                  /* Wait until TCR flag is set */
   1658                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   1659                  {
   1660                    return HAL_TIMEOUT;
   1661                  }
   1662                  
   1663                  
   1664                  if(Size > 255)
   1665                  {
   1666                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   1667                    Sizetmp = 255;
   1668                  }
   1669                  else
   1670                  {
   1671                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Write_10: (+1)
   \   0000008E   0x4011             ANDS     R1,R2,R1
   \   00000090   0xB2E2             UXTB     R2,R4
   \   00000092   0xEA51 0x5193      ORRS     R1,R1,R3, LSR #+22
   \   00000096   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000009A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000009E   0x6041             STR      R1,[R0, #+4]
   1672                    Sizetmp = Size;
   \                     ??HAL_I2C_Mem_Write_9: (+1)
   \   000000A0   0x4627             MOV      R7,R4
   1673                  }
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \   000000A2   0x.... 0x....      BL       HAL_GetTick
   \   000000A6   0x4683             MOV      R11,R0
   \                     ??HAL_I2C_Mem_Write_11: (+1)
   \   000000A8   0x6828             LDR      R0,[R5, #+0]
   \   000000AA   0x6981             LDR      R1,[R0, #+24]
   \   000000AC   0x0789             LSLS     R1,R1,#+30
   \   000000AE   0xD41C             BMI.N    ??HAL_I2C_Mem_Write_12
   \   000000B0   0x4641             MOV      R1,R8
   \   000000B2   0x4628             MOV      R0,R5
   \   000000B4   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000B8   0xB998             CBNZ.N   R0,??HAL_I2C_Mem_Write_13
   \   000000BA   0xF118 0x0F01      CMN      R8,#+1
   \   000000BE   0xD0F3             BEQ.N    ??HAL_I2C_Mem_Write_11
   \   000000C0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C4   0xD005             BEQ.N    ??HAL_I2C_Mem_Write_14
   \   000000C6   0x.... 0x....      BL       HAL_GetTick
   \   000000CA   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000CE   0x4580             CMP      R8,R0
   \   000000D0   0xD2EA             BCS.N    ??HAL_I2C_Mem_Write_11
   \                     ??HAL_I2C_Mem_Write_14: (+1)
   \   000000D2   0x6870             LDR      R0,[R6, #+4]
   \   000000D4   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000D8   0x6070             STR      R0,[R6, #+4]
   \   000000DA   0x2001             MOVS     R0,#+1
   \   000000DC   0x7070             STRB     R0,[R6, #+1]
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x7030             STRB     R0,[R6, #+0]
   \                     ??HAL_I2C_Mem_Write_13: (+1)
   \   000000E2   0x6870             LDR      R0,[R6, #+4]
   \   000000E4   0x2804             CMP      R0,#+4
   \   000000E6   0xD139             BNE.N    ??HAL_I2C_Mem_Write_5
   \   000000E8   0xE036             B.N      ??HAL_I2C_Mem_Write_4
   \                     ??HAL_I2C_Mem_Write_12: (+1)
   \   000000EA   0xF81A 0x1B01      LDRB     R1,[R10], #+1
   \   000000EE   0x1E7F             SUBS     R7,R7,#+1
   \   000000F0   0xF1A4 0x0401      SUB      R4,R4,#+1
   \   000000F4   0xB2A4             UXTH     R4,R4
   \   000000F6   0x6281             STR      R1,[R0, #+40]
   \   000000F8   0xD124             BNE.N    ??HAL_I2C_Mem_Write_15
   \   000000FA   0xB32C             CBZ.N    R4,??HAL_I2C_Mem_Write_16
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_Mem_Write_17: (+1)
   \   00000102   0x6828             LDR      R0,[R5, #+0]
   \   00000104   0x6981             LDR      R1,[R0, #+24]
   \   00000106   0x0609             LSLS     R1,R1,#+24
   \   00000108   0xD40F             BMI.N    ??HAL_I2C_Mem_Write_18
   \   0000010A   0xF118 0x0F01      CMN      R8,#+1
   \   0000010E   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Write_17
   \   00000110   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000114   0xD004             BEQ.N    ??HAL_I2C_Mem_Write_19
   \   00000116   0x.... 0x....      BL       HAL_GetTick
   \   0000011A   0x1BC0             SUBS     R0,R0,R7
   \   0000011C   0x4580             CMP      R8,R0
   \   0000011E   0xD2F0             BCS.N    ??HAL_I2C_Mem_Write_17
   \                     ??HAL_I2C_Mem_Write_19: (+1)
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0x7070             STRB     R0,[R6, #+1]
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x7030             STRB     R0,[R6, #+0]
   \   00000128   0xE018             B.N      ??HAL_I2C_Mem_Write_5
   \                     ??HAL_I2C_Mem_Write_18: (+1)
   \   0000012A   0x2CFF             CMP      R4,#+255
   \   0000012C   0xEA4F 0x5389      LSL      R3,R9,#+22
   \   00000130   0x....             LDR.N    R2,??DataTable9  ;; 0xfc009800
   \   00000132   0x6841             LDR      R1,[R0, #+4]
   \   00000134   0xDDAB             BLE.N    ??HAL_I2C_Mem_Write_10
   \   00000136   0x4011             ANDS     R1,R2,R1
   \   00000138   0x....             LDR.N    R2,??DataTable9_1  ;; 0x1ff0000
   \   0000013A   0xEA51 0x5193      ORRS     R1,R1,R3, LSR #+22
   \   0000013E   0x4311             ORRS     R1,R2,R1
   \   00000140   0x6041             STR      R1,[R0, #+4]
   \   00000142   0xE79A             B.N      ??HAL_I2C_Mem_Write_7
   1674                }
   1675                
   1676              }while(Size > 0);
   \                     ??HAL_I2C_Mem_Write_15: (+1)
   \   00000144   0x2C00             CMP      R4,#+0
   \   00000146   0xD1AC             BNE.N    ??HAL_I2C_Mem_Write_8
   1677              
   1678              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1679              /* Wait until STOPF flag is reset */ 
   1680              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_16: (+1)
   \   00000148   0x2119             MOVS     R1,#+25
   \   0000014A   0x4628             MOV      R0,R5
   \   0000014C   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000150   0xB130             CBZ.N    R0,??HAL_I2C_Mem_Write_20
   1681              {
   1682                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000152   0x6870             LDR      R0,[R6, #+4]
   \   00000154   0x2804             CMP      R0,#+4
   \   00000156   0xD101             BNE.N    ??HAL_I2C_Mem_Write_5
   1683                {
   1684                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \   00000158   0x.... 0x....      B.W      ?Subroutine4
   1685                }
   1686                else
   1687                {
   1688                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \   0000015C   0x.... 0x....      B.W      ?Subroutine3
   1689                }
   1690              }
   1691              
   1692              /* Clear STOP Flag */
   1693              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Write_20: (+1)
   \   00000160   0x....             B.N      ?Subroutine2
   1694            	
   1695              /* Clear Configuration Register 2 */
   1696              I2C_RESET_CR2(hi2c);
   1697              
   1698              hi2c->State = HAL_I2C_STATE_READY; 	  
   1699              
   1700              /* Process Unlocked */
   1701              __HAL_UNLOCK(hi2c);
   1702              
   1703              return HAL_OK;
   1704            }
   1705            else
   1706            {
   1707              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \   00000162   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \   00000164   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1708            }
   1709          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x6829             LDR      R1,[R5, #+0]
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0x....             LDR.N    R2,??DataTable9_2  ;; 0xfe00e800
   \   00000006   0x61C8             STR      R0,[R1, #+28]
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x6841             LDR      R1,[R0, #+4]
   \   0000000C   0x4011             ANDS     R1,R2,R1
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7070             STRB     R0,[R6, #+1]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x7030             STRB     R0,[R6, #+0]
   \   00000018   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   1710          
   1711          /**
   1712            * @brief  Read an amount of data in blocking mode from a specific memory address
   1713            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1714            *                the configuration information for the specified I2C.
   1715            * @param  DevAddress: Target device address
   1716            * @param  MemAddress: Internal memory address
   1717            * @param  MemAddSize: Size of internal memory address
   1718            * @param  pData: Pointer to data buffer
   1719            * @param  Size: Amount of data to be sent
   1720            * @param  Timeout: Timeout duration
   1721            * @retval HAL status
   1722            */

   \                                 In section .text, align 2, keep-with-next
   1723          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1724          {
   \                     HAL_I2C_Mem_Read: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   1725            uint32_t Sizetmp = 0;
   1726            
   1727            /* Check the parameters */
   1728            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1729            
   1730            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF105 0x0634      ADD      R6,R5,#+52
   \   0000000A   0x4689             MOV      R9,R1
   \   0000000C   0x7870             LDRB     R0,[R6, #+1]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xF040 0x809D      BNE.W    ??HAL_I2C_Mem_Read_0
   \   00000014   0xF8DD 0xA028      LDR      R10,[SP, #+40]
   1731            {    
   1732              if((pData == NULL) || (Size == 0)) 
   \   00000018   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x9C0B             LDRNE    R4,[SP, #+44]
   \   00000020   0x2C00             CMPNE    R4,#+0
   \   00000022   0xF000 0x8095      BEQ.W    ??HAL_I2C_Mem_Read_1
   1733              {
   1734                return  HAL_ERROR;                                    
   1735              }
   1736              
   1737              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x6980             LDR      R0,[R0, #+24]
   \   0000002A   0x0400             LSLS     R0,R0,#+16
   \   0000002C   0xF100 0x808F      BMI.W    ??HAL_I2C_Mem_Read_0
   1738              {
   1739                return HAL_BUSY;
   1740              }
   1741              
   1742              /* Process Locked */
   1743              __HAL_LOCK(hi2c);
   \   00000030   0x7830             LDRB     R0,[R6, #+0]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xF000 0x808B      BEQ.W    ??HAL_I2C_Mem_Read_0
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x7030             STRB     R0,[R6, #+0]
   1744              
   1745              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   \   0000003C   0x2062             MOVS     R0,#+98
   \   0000003E   0x7070             STRB     R0,[R6, #+1]
   1746              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6070             STR      R0,[R6, #+4]
   \   00000044   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   1747              
   1748              /* Send Slave Address and Memory Address */
   1749              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000004E   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   00000052   0xB140             CBZ.N    R0,??HAL_I2C_Mem_Read_2
   1750              {
   1751                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000054   0x6870             LDR      R0,[R6, #+4]
   \   00000056   0x2804             CMP      R0,#+4
   \   00000058   0xD102             BNE.N    ??HAL_I2C_Mem_Read_3
   1752                {
   1753                  /* Process Unlocked */
   1754                  __HAL_UNLOCK(hi2c);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7030             STRB     R0,[R6, #+0]
   1755                  return HAL_ERROR;
   \   0000005E   0xE071             B.N      ??HAL_I2C_Mem_Read_4
   1756                }
   1757                else
   1758                {
   1759                  /* Process Unlocked */
   1760                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x7030             STRB     R0,[R6, #+0]
   1761                  return HAL_TIMEOUT;
   \   00000064   0xE070             B.N      ??HAL_I2C_Mem_Read_5
   1762                }
   1763              }
   1764              
   1765              /* Send Slave Address */
   1766              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1767              /* Size > 255, need to set RELOAD bit */
   1768              if(Size > 255)
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \   00000066   0x2CFF             CMP      R4,#+255
   \   00000068   0xF44F 0x5010      MOV      R0,#+9216
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0xDD08             BLE.N    ??HAL_I2C_Mem_Read_6
   1769              {
   1770                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000070   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000074   0x22FF             MOVS     R2,#+255
   \   00000076   0x4649             MOV      R1,R9
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x.... 0x....      BL       I2C_TransferConfig
   1771                Sizetmp = 255;
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \   0000007E   0x27FF             MOVS     R7,#+255
   \   00000080   0xE011             B.N      ??HAL_I2C_Mem_Read_8
   1772              }
   1773              else
   1774              {
   1775                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \   00000082   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000086   0xB2E2             UXTB     R2,R4
   \   00000088   0x4649             MOV      R1,R9
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x.... 0x....      BL       I2C_TransferConfig
   1776                Sizetmp = Size;
   \   00000090   0xE008             B.N      ??HAL_I2C_Mem_Read_9
   1777              }
   1778              
   1779              do
   1780              {  
   1781                /* Wait until RXNE flag is set */
   1782                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)      
   1783                {
   1784                  return HAL_TIMEOUT;
   1785                }
   1786                
   1787                /* Read data from RXDR */
   1788                (*pData++) = hi2c->Instance->RXDR;
   1789                
   1790                /* Decrement the Size counter */
   1791                Sizetmp--;
   1792                Size--;   
   1793                
   1794                if((Sizetmp == 0)&&(Size!=0))
   1795                {
   1796                  /* Wait until TCR flag is set */
   1797                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   1798                  {
   1799                    return HAL_TIMEOUT;
   1800                  }
   1801                  
   1802                  if(Size > 255)
   1803                  {
   1804                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   1805                    Sizetmp = 255;
   1806                  }
   1807                  else
   1808                  {
   1809                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \   00000092   0x4011             ANDS     R1,R2,R1
   \   00000094   0xB2E2             UXTB     R2,R4
   \   00000096   0xEA51 0x5193      ORRS     R1,R1,R3, LSR #+22
   \   0000009A   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000009E   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   000000A2   0x6041             STR      R1,[R0, #+4]
   1810                    Sizetmp = Size;
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \   000000A4   0x4627             MOV      R7,R4
   1811                  }
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \   000000A6   0x.... 0x....      BL       HAL_GetTick
   \   000000AA   0x4683             MOV      R11,R0
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \   000000AC   0x6828             LDR      R0,[R5, #+0]
   \   000000AE   0x6981             LDR      R1,[R0, #+24]
   \   000000B0   0x0749             LSLS     R1,R1,#+29
   \   000000B2   0xD410             BMI.N    ??HAL_I2C_Mem_Read_12
   \   000000B4   0xF118 0x0F01      CMN      R8,#+1
   \   000000B8   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Read_11
   \   000000BA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000BE   0xD005             BEQ.N    ??HAL_I2C_Mem_Read_13
   \   000000C0   0x.... 0x....      BL       HAL_GetTick
   \   000000C4   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000C8   0x4580             CMP      R8,R0
   \   000000CA   0xD2EF             BCS.N    ??HAL_I2C_Mem_Read_11
   \                     ??HAL_I2C_Mem_Read_13: (+1)
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x7070             STRB     R0,[R6, #+1]
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x7030             STRB     R0,[R6, #+0]
   \   000000D4   0xE038             B.N      ??HAL_I2C_Mem_Read_5
   \                     ??HAL_I2C_Mem_Read_12: (+1)
   \   000000D6   0x6A40             LDR      R0,[R0, #+36]
   \   000000D8   0x1E7F             SUBS     R7,R7,#+1
   \   000000DA   0xF1A4 0x0401      SUB      R4,R4,#+1
   \   000000DE   0xB2A4             UXTH     R4,R4
   \   000000E0   0xF80A 0x0B01      STRB     R0,[R10], #+1
   \   000000E4   0xD124             BNE.N    ??HAL_I2C_Mem_Read_14
   \   000000E6   0xB32C             CBZ.N    R4,??HAL_I2C_Mem_Read_15
   \   000000E8   0x.... 0x....      BL       HAL_GetTick
   \   000000EC   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_Mem_Read_16: (+1)
   \   000000EE   0x6828             LDR      R0,[R5, #+0]
   \   000000F0   0x6981             LDR      R1,[R0, #+24]
   \   000000F2   0x0609             LSLS     R1,R1,#+24
   \   000000F4   0xD40F             BMI.N    ??HAL_I2C_Mem_Read_17
   \   000000F6   0xF118 0x0F01      CMN      R8,#+1
   \   000000FA   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Read_16
   \   000000FC   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000100   0xD004             BEQ.N    ??HAL_I2C_Mem_Read_18
   \   00000102   0x.... 0x....      BL       HAL_GetTick
   \   00000106   0x1BC0             SUBS     R0,R0,R7
   \   00000108   0x4580             CMP      R8,R0
   \   0000010A   0xD2F0             BCS.N    ??HAL_I2C_Mem_Read_16
   \                     ??HAL_I2C_Mem_Read_18: (+1)
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x7070             STRB     R0,[R6, #+1]
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x7030             STRB     R0,[R6, #+0]
   \   00000114   0xE018             B.N      ??HAL_I2C_Mem_Read_5
   \                     ??HAL_I2C_Mem_Read_17: (+1)
   \   00000116   0x2CFF             CMP      R4,#+255
   \   00000118   0xEA4F 0x5389      LSL      R3,R9,#+22
   \   0000011C   0x....             LDR.N    R2,??DataTable9  ;; 0xfc009800
   \   0000011E   0x6841             LDR      R1,[R0, #+4]
   \   00000120   0xDDB7             BLE.N    ??HAL_I2C_Mem_Read_10
   \   00000122   0x4011             ANDS     R1,R2,R1
   \   00000124   0x....             LDR.N    R2,??DataTable9_1  ;; 0x1ff0000
   \   00000126   0xEA51 0x5193      ORRS     R1,R1,R3, LSR #+22
   \   0000012A   0x4311             ORRS     R1,R2,R1
   \   0000012C   0x6041             STR      R1,[R0, #+4]
   \   0000012E   0xE7A6             B.N      ??HAL_I2C_Mem_Read_7
   1812                }
   1813                
   1814              }while(Size > 0);
   \                     ??HAL_I2C_Mem_Read_14: (+1)
   \   00000130   0x2C00             CMP      R4,#+0
   \   00000132   0xD1B8             BNE.N    ??HAL_I2C_Mem_Read_8
   1815              
   1816              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1817              /* Wait until STOPF flag is reset */ 
   1818              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_15: (+1)
   \   00000134   0x2119             MOVS     R1,#+25
   \   00000136   0x4628             MOV      R0,R5
   \   00000138   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000013C   0xB130             CBZ.N    R0,??HAL_I2C_Mem_Read_19
   1819              {
   1820                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000013E   0x6870             LDR      R0,[R6, #+4]
   \   00000140   0x2804             CMP      R0,#+4
   \   00000142   0xD101             BNE.N    ??HAL_I2C_Mem_Read_5
   1821                {
   1822                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \   00000144   0x.... 0x....      B.W      ?Subroutine4
   1823                }
   1824                else
   1825                {
   1826                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \   00000148   0x.... 0x....      B.W      ?Subroutine3
   1827                }
   1828              }
   1829              
   1830              /* Clear STOP Flag */
   1831              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Read_19: (+1)
   \   0000014C   0x....             B.N      ?Subroutine2
   1832            	
   1833              /* Clear Configuration Register 2 */
   1834              I2C_RESET_CR2(hi2c);
   1835              
   1836              hi2c->State = HAL_I2C_STATE_READY;
   1837              
   1838              /* Process Unlocked */
   1839              __HAL_UNLOCK(hi2c);
   1840              
   1841              return HAL_OK;
   1842            }
   1843            else
   1844            {
   1845              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \   0000014E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \   00000150   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1846            }
   1847          }
   1848          /**
   1849            * @brief  Write an amount of data in no-blocking mode with Interrupt to a specific memory address
   1850            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1851            *                the configuration information for the specified I2C.
   1852            * @param  DevAddress: Target device address
   1853            * @param  MemAddress: Internal memory address
   1854            * @param  MemAddSize: Size of internal memory address
   1855            * @param  pData: Pointer to data buffer
   1856            * @param  Size: Amount of data to be sent
   1857            * @retval HAL status
   1858            */

   \                                 In section .text, align 2, keep-with-next
   1859          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   1860          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1861            /* Check the parameters */
   1862            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1863            
   1864            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF104 0x0634      ADD      R6,R4,#+52
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x7870             LDRB     R0,[R6, #+1]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD13F             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   \   00000010   0x9906             LDR      R1,[SP, #+24]
   1865            {
   1866              if((pData == NULL) || (Size == 0)) 
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x9807             LDRNE    R0,[SP, #+28]
   \   00000018   0x2800             CMPNE    R0,#+0
   \   0000001A   0xD01D             BEQ.N    ??HAL_I2C_Mem_Write_IT_1
   1867              {
   1868                return  HAL_ERROR;                                    
   1869              }
   1870              
   1871              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001C   0x6827             LDR      R7,[R4, #+0]
   \   0000001E   0x69BF             LDR      R7,[R7, #+24]
   \   00000020   0x043F             LSLS     R7,R7,#+16
   \   00000022   0xD435             BMI.N    ??HAL_I2C_Mem_Write_IT_0
   1872              {
   1873                return HAL_BUSY;
   1874              }
   1875              
   1876              /* Process Locked */
   1877              __HAL_LOCK(hi2c);
   \   00000024   0x7837             LDRB     R7,[R6, #+0]
   \   00000026   0x2F01             CMP      R7,#+1
   \   00000028   0xD032             BEQ.N    ??HAL_I2C_Mem_Write_IT_0
   \   0000002A   0x2701             MOVS     R7,#+1
   \   0000002C   0x7037             STRB     R7,[R6, #+0]
   1878              
   1879              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   \   0000002E   0x2752             MOVS     R7,#+82
   \   00000030   0x7077             STRB     R7,[R6, #+1]
   1880              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000032   0x2700             MOVS     R7,#+0
   \   00000034   0x6077             STR      R7,[R6, #+4]
   1881              
   1882              hi2c->pBuffPtr = pData;
   1883              hi2c->XferCount = Size;
   1884              if(Size > 255)
   \   00000036   0x28FF             CMP      R0,#+255
   \   00000038   0x6261             STR      R1,[R4, #+36]
   1885              {
   1886                hi2c->XferSize = 255;
   1887              }
   1888              else
   1889              {
   1890                hi2c->XferSize = Size;
   1891              }
   1892              
   1893              /* Send Slave Address and Memory Address */
   1894              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000003A   0x4629             MOV      R1,R5
   \   0000003C   0x8560             STRH     R0,[R4, #+42]
   \   0000003E   0xBFC8             IT       GT 
   \   00000040   0x20FF             MOVGT    R0,#+255
   \   00000042   0x8520             STRH     R0,[R4, #+40]
   \   00000044   0x2019             MOVS     R0,#+25
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   0000004E   0xB138             CBZ.N    R0,??HAL_I2C_Mem_Write_IT_2
   1895              {
   1896                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000050   0x6870             LDR      R0,[R6, #+4]
   \   00000052   0x7037             STRB     R7,[R6, #+0]
   \   00000054   0x2804             CMP      R0,#+4
   \   00000056   0xD101             BNE.N    ??HAL_I2C_Mem_Write_IT_3
   1897                {
   1898                  /* Process Unlocked */
   1899                  __HAL_UNLOCK(hi2c);
   1900                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}
   1901                }
   1902                else
   1903                {
   1904                  /* Process Unlocked */
   1905                  __HAL_UNLOCK(hi2c);
   1906                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}
   1907                }
   1908              }
   1909              
   1910              /* Set NBYTES to write and reload if size > 255 */
   1911              /* Size > 255, need to set RELOAD bit */
   1912              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \   00000060   0x8D22             LDRH     R2,[R4, #+40]
   \   00000062   0x2AFF             CMP      R2,#+255
   \   00000064   0xD106             BNE.N    ??HAL_I2C_Mem_Write_IT_4
   \   00000066   0x8D60             LDRH     R0,[R4, #+42]
   \   00000068   0x4282             CMP      R2,R0
   \   0000006A   0xD203             BCS.N    ??HAL_I2C_Mem_Write_IT_4
   1913              {
   1914                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   0000006C   0x9700             STR      R7,[SP, #+0]
   \   0000006E   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000072   0xE003             B.N      ??HAL_I2C_Mem_Write_IT_5
   1915              }
   1916              else
   1917              {
   1918                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \   00000074   0x9700             STR      R7,[SP, #+0]
   \   00000076   0xF04F 0x7300      MOV      R3,#+33554432
   \   0000007A   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Mem_Write_IT_5: (+1)
   \   0000007C   0x4629             MOV      R1,R5
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       I2C_TransferConfig
   1919              }  
   1920              
   1921              /* Process Unlocked */
   1922              __HAL_UNLOCK(hi2c); 
   \   00000084   0x7037             STRB     R7,[R6, #+0]
   1923              
   1924              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1925              to avoid the risk of I2C interrupt handle execution before current
   1926              process unlock */
   1927              
   1928              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1929              /* possible to enable all of these */
   1930              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1931              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0xF041 0x01F2      ORR      R1,R1,#0xF2
   \   0000008E   0x....             B.N      ?Subroutine10
   1932              
   1933              return HAL_OK;
   1934            }
   1935            else
   1936            {
   1937              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1938            }
   1939          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xBDF2             POP      {R1,R4-R7,PC}
   1940          
   1941          /**
   1942            * @brief  Read an amount of data in no-blocking mode with Interrupt from a specific memory address
   1943            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1944            *                the configuration information for the specified I2C.
   1945            * @param  DevAddress: Target device address
   1946            * @param  MemAddress: Internal memory address
   1947            * @param  MemAddSize: Size of internal memory address
   1948            * @param  pData: Pointer to data buffer
   1949            * @param  Size: Amount of data to be sent
   1950            * @retval HAL status
   1951            */

   \                                 In section .text, align 2, keep-with-next
   1952          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   1953          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1954            /* Check the parameters */
   1955            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1956            
   1957            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF104 0x0634      ADD      R6,R4,#+52
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x7870             LDRB     R0,[R6, #+1]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD145             BNE.N    ??HAL_I2C_Mem_Read_IT_0
   \   00000010   0x9906             LDR      R1,[SP, #+24]
   1958            {
   1959              if((pData == NULL) || (Size == 0)) 
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x9807             LDRNE    R0,[SP, #+28]
   \   00000018   0x2800             CMPNE    R0,#+0
   \   0000001A   0xD01C             BEQ.N    ??HAL_I2C_Mem_Read_IT_1
   1960              {
   1961                return  HAL_ERROR;                                    
   1962              }
   1963              
   1964              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001C   0x6827             LDR      R7,[R4, #+0]
   \   0000001E   0x69BF             LDR      R7,[R7, #+24]
   \   00000020   0x043F             LSLS     R7,R7,#+16
   \   00000022   0xD43B             BMI.N    ??HAL_I2C_Mem_Read_IT_0
   1965              {
   1966                return HAL_BUSY;
   1967              }
   1968              
   1969              /* Process Locked */
   1970              __HAL_LOCK(hi2c);
   \   00000024   0x7837             LDRB     R7,[R6, #+0]
   \   00000026   0x2F01             CMP      R7,#+1
   \   00000028   0xD038             BEQ.N    ??HAL_I2C_Mem_Read_IT_0
   \   0000002A   0x2701             MOVS     R7,#+1
   \   0000002C   0x7037             STRB     R7,[R6, #+0]
   1971              
   1972              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   \   0000002E   0x2762             MOVS     R7,#+98
   \   00000030   0x7077             STRB     R7,[R6, #+1]
   1973              
   1974              hi2c->pBuffPtr = pData;
   1975              hi2c->XferCount = Size;
   1976              if(Size > 255)
   \   00000032   0x28FF             CMP      R0,#+255
   \   00000034   0x6261             STR      R1,[R4, #+36]
   1977              {
   1978                hi2c->XferSize = 255;
   1979              }
   1980              else
   1981              {
   1982                hi2c->XferSize = Size;
   1983              }
   1984              
   1985              /* Send Slave Address and Memory Address */
   1986              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x8560             STRH     R0,[R4, #+42]
   \   0000003A   0xBFC8             IT       GT 
   \   0000003C   0x20FF             MOVGT    R0,#+255
   \   0000003E   0x8520             STRH     R0,[R4, #+40]
   \   00000040   0x2019             MOVS     R0,#+25
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   0000004A   0xB150             CBZ.N    R0,??HAL_I2C_Mem_Read_IT_2
   1987              {
   1988                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000004C   0x6870             LDR      R0,[R6, #+4]
   \   0000004E   0x2804             CMP      R0,#+4
   \   00000050   0xD103             BNE.N    ??HAL_I2C_Mem_Read_IT_3
   1989                {
   1990                  /* Process Unlocked */
   1991                  __HAL_UNLOCK(hi2c);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x7030             STRB     R0,[R6, #+0]
   1992                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}
   1993                }
   1994                else
   1995                {
   1996                  /* Process Unlocked */
   1997                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x7030             STRB     R0,[R6, #+0]
   1998                  return HAL_TIMEOUT;
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}
   1999                }
   2000              }
   2001              
   2002              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   2003              /* Size > 255, need to set RELOAD bit */
   2004              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \   00000062   0x8D22             LDRH     R2,[R4, #+40]
   \   00000064   0x2AFF             CMP      R2,#+255
   \   00000066   0xD108             BNE.N    ??HAL_I2C_Mem_Read_IT_4
   \   00000068   0x8D60             LDRH     R0,[R4, #+42]
   \   0000006A   0x4282             CMP      R2,R0
   \   0000006C   0xD205             BCS.N    ??HAL_I2C_Mem_Read_IT_4
   2005              {
   2006                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   0000006E   0xF44F 0x5010      MOV      R0,#+9216
   \   00000072   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000076   0x9000             STR      R0,[SP, #+0]
   \   00000078   0xE005             B.N      ??HAL_I2C_Mem_Read_IT_5
   2007              }
   2008              else
   2009              {
   2010                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \   0000007A   0xF44F 0x5010      MOV      R0,#+9216
   \   0000007E   0xF04F 0x7300      MOV      R3,#+33554432
   \   00000082   0x9000             STR      R0,[SP, #+0]
   \   00000084   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Mem_Read_IT_5: (+1)
   \   00000086   0x4629             MOV      R1,R5
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0x.... 0x....      BL       I2C_TransferConfig
   2011              }
   2012              
   2013              /* Process Unlocked */
   2014              __HAL_UNLOCK(hi2c); 
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x7030             STRB     R0,[R6, #+0]
   2015              
   2016              /* Note : The I2C interrupts must be enabled after unlocking current process 
   2017              to avoid the risk of I2C interrupt handle execution before current
   2018              process unlock */
   2019              
   2020              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   2021              /* possible to enable all of these */
   2022              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   2023              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0xF041 0x01F4      ORR      R1,R1,#0xF4
   \   0000009A   0x....             B.N      ?Subroutine10
   2024              
   2025              return HAL_OK;
   2026            }
   2027            else
   2028            {
   2029              return HAL_BUSY; 
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \   0000009C   0x2002             MOVS     R0,#+2
   \   0000009E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2030            }   
   2031          }
   2032          /**
   2033            * @brief  Write an amount of data in no-blocking mode with DMA to a specific memory address
   2034            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2035            *                the configuration information for the specified I2C.
   2036            * @param  DevAddress: Target device address
   2037            * @param  MemAddress: Internal memory address
   2038            * @param  MemAddSize: Size of internal memory address
   2039            * @param  pData: Pointer to data buffer
   2040            * @param  Size: Amount of data to be sent
   2041            * @retval HAL status
   2042            */

   \                                 In section .text, align 2, keep-with-next
   2043          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2044          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   2045            /* Check the parameters */
   2046            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2047            
   2048            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF105 0x0434      ADD      R4,R5,#+52
   \   0000000A   0xB082             SUB      SP,SP,#+8
   \   0000000C   0x460E             MOV      R6,R1
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x4617             MOV      R7,R2
   \   00000012   0x4698             MOV      R8,R3
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD160             BNE.N    ??HAL_I2C_Mem_Write_DMA_0
   \   00000018   0x9908             LDR      R1,[SP, #+32]
   2049            {
   2050              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x9809             LDRNE    R0,[SP, #+36]
   \   00000020   0x2800             CMPNE    R0,#+0
   \   00000022   0xD04F             BEQ.N    ??HAL_I2C_Mem_Write_DMA_1
   2051              {
   2052                return  HAL_ERROR;                                    
   2053              }
   2054              
   2055              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000024   0x682A             LDR      R2,[R5, #+0]
   \   00000026   0x6992             LDR      R2,[R2, #+24]
   \   00000028   0x0412             LSLS     R2,R2,#+16
   \   0000002A   0xD456             BMI.N    ??HAL_I2C_Mem_Write_DMA_0
   2056              {
   2057                return HAL_BUSY;
   2058              }
   2059              
   2060              /* Process Locked */
   2061              __HAL_LOCK(hi2c);
   \   0000002C   0x7822             LDRB     R2,[R4, #+0]
   \   0000002E   0x2A01             CMP      R2,#+1
   \   00000030   0xD053             BEQ.N    ??HAL_I2C_Mem_Write_DMA_0
   \   00000032   0x2201             MOVS     R2,#+1
   \   00000034   0x7022             STRB     R2,[R4, #+0]
   2062              
   2063              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   \   00000036   0x2252             MOVS     R2,#+82
   \   00000038   0x7062             STRB     R2,[R4, #+1]
   2064              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x6062             STR      R2,[R4, #+4]
   2065              
   2066              hi2c->pBuffPtr = pData;
   2067              hi2c->XferCount = Size;
   2068              if(Size > 255)
   \   0000003E   0x28FF             CMP      R0,#+255
   \   00000040   0x6269             STR      R1,[R5, #+36]
   \   00000042   0x8568             STRH     R0,[R5, #+42]
   \   00000044   0xBFC8             IT       GT 
   \   00000046   0x20FF             MOVGT    R0,#+255
   2069              {
   2070                hi2c->XferSize = 255;
   2071              }
   2072              else
   2073              {
   2074                hi2c->XferSize = Size;
   \   00000048   0x8528             STRH     R0,[R5, #+40]
   2075              }
   2076              
   2077              /* Set the I2C DMA transfer complete callback */
   2078              hi2c->hdmatx->XferCpltCallback = I2C_DMAMemTransmitCplt;
   \   0000004A   0x6AEA             LDR      R2,[R5, #+44]
   \   0000004C   0x.... 0x....      ADR.W    R0,I2C_DMAMemTransmitCplt
   \   00000050   0x63D0             STR      R0,[R2, #+60]
   2079              
   2080              /* Set the DMA error callback */
   2081              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   00000052   0x6AEA             LDR      R2,[R5, #+44]
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000058   0x6490             STR      R0,[R2, #+72]
   2082              
   2083              /* Enable the DMA channel */
   2084              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x8D2B             LDRH     R3,[R5, #+40]
   \   0000005E   0xF100 0x0228      ADD      R2,R0,#+40
   \   00000062   0x6AE8             LDR      R0,[R5, #+44]
   \   00000064   0x.... 0x....      BL       HAL_DMA_Start_IT
   2085              
   2086              /* Send Slave Address and Memory Address */
   2087              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000068   0x2019             MOVS     R0,#+25
   \   0000006A   0x4643             MOV      R3,R8
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0x463A             MOV      R2,R7
   \   00000070   0x4631             MOV      R1,R6
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \   00000078   0xB140             CBZ.N    R0,??HAL_I2C_Mem_Write_DMA_2
   2088              {
   2089                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000007A   0x6860             LDR      R0,[R4, #+4]
   \   0000007C   0x2804             CMP      R0,#+4
   \   0000007E   0xD102             BNE.N    ??HAL_I2C_Mem_Write_DMA_3
   2090                {
   2091                  /* Process Unlocked */
   2092                  __HAL_UNLOCK(hi2c);
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x7020             STRB     R0,[R4, #+0]
   2093                  return HAL_ERROR;
   \   00000084   0xE01E             B.N      ??HAL_I2C_Mem_Write_DMA_1
   2094                }
   2095                else
   2096                {
   2097                  /* Process Unlocked */
   2098                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x7020             STRB     R0,[R4, #+0]
   2099                  return HAL_TIMEOUT;
   \   0000008A   0xE01C             B.N      ??HAL_I2C_Mem_Write_DMA_4
   2100                }
   2101              }
   2102              
   2103              /* Send Slave Address */
   2104              /* Set NBYTES to write and reload if size > 255 */
   2105              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \   0000008C   0x8D2A             LDRH     R2,[R5, #+40]
   \   0000008E   0x2AFF             CMP      R2,#+255
   \   00000090   0xD107             BNE.N    ??HAL_I2C_Mem_Write_DMA_5
   \   00000092   0x8D68             LDRH     R0,[R5, #+42]
   \   00000094   0x4282             CMP      R2,R0
   \   00000096   0xD204             BCS.N    ??HAL_I2C_Mem_Write_DMA_5
   2106              {
   2107                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF04F 0x7380      MOV      R3,#+16777216
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0xE004             B.N      ??HAL_I2C_Mem_Write_DMA_6
   2108              }
   2109              else
   2110              {
   2111                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF04F 0x7300      MOV      R3,#+33554432
   \   000000A8   0x9000             STR      R0,[SP, #+0]
   \   000000AA   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Mem_Write_DMA_6: (+1)
   \   000000AC   0x4631             MOV      R1,R6
   \   000000AE   0x4628             MOV      R0,R5
   \   000000B0   0x.... 0x....      BL       I2C_TransferConfig
   2112              }
   2113              
   2114              /* Wait until TXIS flag is set */
   2115              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   000000B4   0x2119             MOVS     R1,#+25
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \   000000BC   0xB120             CBZ.N    R0,??HAL_I2C_Mem_Write_DMA_7
   2116              {
   2117                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000BE   0x6860             LDR      R0,[R4, #+4]
   \   000000C0   0x2804             CMP      R0,#+4
   \   000000C2   0xD100             BNE.N    ??HAL_I2C_Mem_Write_DMA_4
   2118                {
   2119                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \   000000C4   0x....             B.N      ?Subroutine13
   2120                }
   2121                else
   2122                {
   2123                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \   000000C6   0x....             B.N      ?Subroutine12
   2124                }
   2125              }
   2126              
   2127              /* Enable DMA Request */
   2128              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;  
   \                     ??HAL_I2C_Mem_Write_DMA_7: (+1)
   \   000000C8   0x6828             LDR      R0,[R5, #+0]
   \   000000CA   0x6801             LDR      R1,[R0, #+0]
   \   000000CC   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000D0   0x6001             STR      R1,[R0, #+0]
   2129              
   2130              /* Process Unlocked */
   2131              __HAL_UNLOCK(hi2c);
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x7020             STRB     R0,[R4, #+0]
   2132              
   2133              return HAL_OK;
   \   000000D6   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   2134            }
   2135            else
   2136            {
   2137              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \   000000DA   0x....             B.N      ?Subroutine11
   2138            }
   2139          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2140          
   2141          /**
   2142            * @brief  Reads an amount of data in no-blocking mode with DMA from a specific memory address.
   2143            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2144            *                the configuration information for the specified I2C.
   2145            * @param  DevAddress: Target device address
   2146            * @param  MemAddress: Internal memory address
   2147            * @param  MemAddSize: Size of internal memory address
   2148            * @param  pData: Pointer to data buffer
   2149            * @param  Size: Amount of data to be read
   2150            * @retval HAL status
   2151            */

   \                                 In section .text, align 2, keep-with-next
   2152          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2153          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   2154            /* Check the parameters */
   2155            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2156            
   2157            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000006   0xF104 0x0534      ADD      R5,R4,#+52
   \   0000000A   0xB082             SUB      SP,SP,#+8
   \   0000000C   0x460E             MOV      R6,R1
   \   0000000E   0x7868             LDRB     R0,[R5, #+1]
   \   00000010   0x4617             MOV      R7,R2
   \   00000012   0x4698             MOV      R8,R3
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD163             BNE.N    ??HAL_I2C_Mem_Read_DMA_0
   \   00000018   0x9A08             LDR      R2,[SP, #+32]
   2158            {
   2159              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x9809             LDRNE    R0,[SP, #+36]
   \   00000020   0x2800             CMPNE    R0,#+0
   \   00000022   0xD02D             BEQ.N    ??HAL_I2C_Mem_Read_DMA_1
   2160              {
   2161                return  HAL_ERROR;                                    
   2162              }
   2163              
   2164              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6989             LDR      R1,[R1, #+24]
   \   00000028   0x0409             LSLS     R1,R1,#+16
   \   0000002A   0xD459             BMI.N    ??HAL_I2C_Mem_Read_DMA_0
   2165              {
   2166                return HAL_BUSY;
   2167              }
   2168              
   2169              /* Process Locked */
   2170              __HAL_LOCK(hi2c);
   \   0000002C   0x7829             LDRB     R1,[R5, #+0]
   \   0000002E   0x2901             CMP      R1,#+1
   \   00000030   0xD056             BEQ.N    ??HAL_I2C_Mem_Read_DMA_0
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x7029             STRB     R1,[R5, #+0]
   2171              
   2172              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   \   00000036   0x2162             MOVS     R1,#+98
   \   00000038   0x7069             STRB     R1,[R5, #+1]
   2173              
   2174              hi2c->pBuffPtr = pData;
   2175              hi2c->XferCount = Size;
   2176              if(Size > 255)
   \   0000003A   0x28FF             CMP      R0,#+255
   \   0000003C   0x6262             STR      R2,[R4, #+36]
   \   0000003E   0x8560             STRH     R0,[R4, #+42]
   \   00000040   0xBFC8             IT       GT 
   \   00000042   0x20FF             MOVGT    R0,#+255
   2177              {
   2178                hi2c->XferSize = 255;
   2179              }
   2180              else
   2181              {
   2182                hi2c->XferSize = Size;
   \   00000044   0x8520             STRH     R0,[R4, #+40]
   2183              }
   2184              
   2185              /* Set the I2C DMA transfer complete callback */
   2186              hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
   \   00000046   0x6B21             LDR      R1,[R4, #+48]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000004C   0x63C8             STR      R0,[R1, #+60]
   2187              
   2188              /* Set the DMA error callback */
   2189              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   0000004E   0x6B21             LDR      R1,[R4, #+48]
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000054   0x6488             STR      R0,[R1, #+72]
   2190              
   2191              /* Enable the DMA channel */
   2192              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x8D23             LDRH     R3,[R4, #+40]
   \   0000005A   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000005E   0x6B20             LDR      R0,[R4, #+48]
   \   00000060   0x.... 0x....      BL       HAL_DMA_Start_IT
   2193              
   2194              /* Send Slave Address and Memory Address */
   2195              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000064   0x2019             MOVS     R0,#+25
   \   00000066   0x4643             MOV      R3,R8
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0x463A             MOV      R2,R7
   \   0000006C   0x4631             MOV      R1,R6
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       I2C_RequestMemoryRead
   \   00000074   0xB128             CBZ.N    R0,??HAL_I2C_Mem_Read_DMA_2
   2196              {
   2197                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000076   0x6868             LDR      R0,[R5, #+4]
   \   00000078   0x2804             CMP      R0,#+4
   \   0000007A   0xD126             BNE.N    ??HAL_I2C_Mem_Read_DMA_3
   2198                {
   2199                  /* Process Unlocked */
   2200                  __HAL_UNLOCK(hi2c);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x7028             STRB     R0,[R5, #+0]
   2201                  return HAL_ERROR;
   2202                }
   2203                else
   2204                {
   2205                  /* Process Unlocked */
   2206                  __HAL_UNLOCK(hi2c);
   2207                  return HAL_TIMEOUT;
   2208                }
   2209              }
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \   00000080   0x....             B.N      ?Subroutine13
   2210              
   2211              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   2212              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \   00000082   0x8D22             LDRH     R2,[R4, #+40]
   \   00000084   0x2AFF             CMP      R2,#+255
   \   00000086   0xD108             BNE.N    ??HAL_I2C_Mem_Read_DMA_4
   \   00000088   0x8D60             LDRH     R0,[R4, #+42]
   \   0000008A   0x4282             CMP      R2,R0
   \   0000008C   0xD205             BCS.N    ??HAL_I2C_Mem_Read_DMA_4
   2213              {
   2214                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   0000008E   0xF44F 0x5010      MOV      R0,#+9216
   \   00000092   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000096   0x9000             STR      R0,[SP, #+0]
   \   00000098   0xE005             B.N      ??HAL_I2C_Mem_Read_DMA_5
   2215              }
   2216              else
   2217              {
   2218                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \   0000009A   0xF44F 0x5010      MOV      R0,#+9216
   \   0000009E   0xF04F 0x7300      MOV      R3,#+33554432
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   \   000000A4   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \   000000A6   0x4631             MOV      R1,R6
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       I2C_TransferConfig
   2219              }
   2220              
   2221              /* Wait until RXNE flag is set */
   2222              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   000000AE   0x.... 0x....      BL       HAL_GetTick
   \   000000B2   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6981             LDR      R1,[R0, #+24]
   \   000000B8   0x0749             LSLS     R1,R1,#+29
   \   000000BA   0xD409             BMI.N    ??HAL_I2C_Mem_Read_DMA_7
   \   000000BC   0x.... 0x....      BL       HAL_GetTick
   \   000000C0   0x1B80             SUBS     R0,R0,R6
   \   000000C2   0x281A             CMP      R0,#+26
   \   000000C4   0xD3F6             BCC.N    ??HAL_I2C_Mem_Read_DMA_6
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x7068             STRB     R0,[R5, #+1]
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x7028             STRB     R0,[R5, #+0]
   2223              {
   2224                return HAL_TIMEOUT;
   \   000000CE   0x....             B.N      ?Subroutine12
   2225              }
   2226              
   2227              /* Enable DMA Request */
   2228              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;  
   \                     ??HAL_I2C_Mem_Read_DMA_7: (+1)
   \   000000D0   0x6801             LDR      R1,[R0, #+0]
   \   000000D2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000D6   0x6001             STR      R1,[R0, #+0]
   2229              
   2230              /* Process Unlocked */
   2231              __HAL_UNLOCK(hi2c);
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x7028             STRB     R0,[R5, #+0]
   2232              
   2233              return HAL_OK;
   \   000000DC   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   2234            }
   2235            else
   2236            {
   2237              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \   000000E0   0x....             B.N      ?Subroutine11
   2238            }
   2239          }
   2240          
   2241          /**
   2242            * @brief  Checks if target device is ready for communication. 
   2243            * @note   This function is used with Memory devices
   2244            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2245            *                the configuration information for the specified I2C.
   2246            * @param  DevAddress: Target device address
   2247            * @param  Trials: Number of trials
   2248            * @param  Timeout: Timeout duration
   2249            * @retval HAL status
   2250            */

   \                                 In section .text, align 2, keep-with-next
   2251          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   2252          {  
   \                     HAL_I2C_IsDeviceReady: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
   2253            uint32_t tickstart = 0;
   2254            
   2255            __IO uint32_t I2C_Trials = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   2256            
   2257            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF104 0x0734      ADD      R7,R4,#+52
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x4692             MOV      R10,R2
   \   00000012   0x7878             LDRB     R0,[R7, #+1]
   \   00000014   0x461E             MOV      R6,R3
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xF040 0x8086      BNE.W    ??HAL_I2C_IsDeviceReady_0
   2258            {
   2259              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0400             LSLS     R0,R0,#+16
   \   00000022   0xF100 0x8081      BMI.W    ??HAL_I2C_IsDeviceReady_0
   2260              {
   2261                return HAL_BUSY;
   2262              }
   2263              
   2264              /* Process Locked */
   2265              __HAL_LOCK(hi2c);
   \   00000026   0x7838             LDRB     R0,[R7, #+0]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD07D             BEQ.N    ??HAL_I2C_IsDeviceReady_0
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7038             STRB     R0,[R7, #+0]
   2266              
   2267              hi2c->State = HAL_I2C_STATE_BUSY;
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x7078             STRB     R0,[R7, #+1]
   2268              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6078             STR      R0,[R7, #+4]
   \   00000038   0x0588             LSLS     R0,R1,#+22
   \   0000003A   0x0D80             LSRS     R0,R0,#+22
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x2002000
   \   00000040   0xF440 0x5820      ORR      R8,R0,#0x2800
   \   00000044   0xEA41 0x0900      ORR      R9,R1,R0
   2269              
   2270              do
   2271              {
   2272                /* Generate Start */
   2273                hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode,DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \   00000048   0x68E0             LDR      R0,[R4, #+12]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xBF0C             ITE      EQ 
   \   0000004E   0x4648             MOVEQ    R0,R9
   \   00000050   0x4640             MOVNE    R0,R8
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6048             STR      R0,[R1, #+4]
   2274                
   2275                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   2276                /* Wait until STOPF flag is set or a NACK flag is set*/
   2277                tickstart = HAL_GetTick();
   \   00000056   0x.... 0x....      BL       HAL_GetTick
   \   0000005A   0x4605             MOV      R5,R0
   2278                while((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET) && (hi2c->State != HAL_I2C_STATE_TIMEOUT))
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6981             LDR      R1,[R0, #+24]
   \   00000060   0x0689             LSLS     R1,R1,#+26
   \   00000062   0xD410             BMI.N    ??HAL_I2C_IsDeviceReady_3
   \   00000064   0x6981             LDR      R1,[R0, #+24]
   \   00000066   0x06C9             LSLS     R1,R1,#+27
   \   00000068   0xD40D             BMI.N    ??HAL_I2C_IsDeviceReady_3
   \   0000006A   0x7879             LDRB     R1,[R7, #+1]
   \   0000006C   0x2903             CMP      R1,#+3
   \   0000006E   0xD00A             BEQ.N    ??HAL_I2C_IsDeviceReady_3
   2279                {
   2280                	if(Timeout != HAL_MAX_DELAY)
   \   00000070   0xF116 0x0F01      CMN      R6,#+1
   \   00000074   0xD0F2             BEQ.N    ??HAL_I2C_IsDeviceReady_2
   2281                	{
   2282                    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000076   0x2E00             CMP      R6,#+0
   \   00000078   0xD04F             BEQ.N    ??HAL_I2C_IsDeviceReady_4
   \   0000007A   0x.... 0x....      BL       HAL_GetTick
   \   0000007E   0x1B40             SUBS     R0,R0,R5
   \   00000080   0x4286             CMP      R6,R0
   \   00000082   0xD2EB             BCS.N    ??HAL_I2C_IsDeviceReady_2
   \   00000084   0xE049             B.N      ??HAL_I2C_IsDeviceReady_4
   2283                    {
   2284                      /* Device is ready */
   2285                      hi2c->State = HAL_I2C_STATE_READY;
   2286                      /* Process Unlocked */
   2287                      __HAL_UNLOCK(hi2c);         
   2288                      return HAL_TIMEOUT;
   2289                    }
   2290                  } 
   2291                }
   2292                
   2293                /* Check if the NACKF flag has not been set */
   2294                if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \   00000086   0x6980             LDR      R0,[R0, #+24]
   \   00000088   0x06C0             LSLS     R0,R0,#+27
   \   0000008A   0xD410             BMI.N    ??HAL_I2C_IsDeviceReady_5
   2295                {
   2296                  /* Wait until STOPF flag is reset */ 
   2297                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \   0000008C   0x4633             MOV      R3,R6
   \   0000008E   0x2200             MOVS     R2,#+0
   \   00000090   0x2120             MOVS     R1,#+32
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD142             BNE.N    ??HAL_I2C_IsDeviceReady_6
   2298                  {
   2299                    return HAL_TIMEOUT;
   2300                  }
   2301                  
   2302                  /* Clear STOP Flag */
   2303                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x2020             MOVS     R0,#+32
   \   000000A0   0x61C8             STR      R0,[R1, #+28]
   2304                  
   2305                  /* Device is ready */
   2306                  hi2c->State = HAL_I2C_STATE_READY;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x7078             STRB     R0,[R7, #+1]
   2307                  
   2308                  /* Process Unlocked */
   2309                  __HAL_UNLOCK(hi2c);
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x7038             STRB     R0,[R7, #+0]
   2310                  
   2311                  return HAL_OK;
   \   000000AA   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   2312                }
   2313                else
   2314                {
   2315                  /* Wait until STOPF flag is reset */ 
   2316                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \   000000AE   0x.... 0x....      BL       HAL_GetTick
   \   000000B2   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0x6981             LDR      R1,[R0, #+24]
   \   000000B8   0x0689             LSLS     R1,R1,#+26
   \   000000BA   0xD409             BMI.N    ??HAL_I2C_IsDeviceReady_8
   \   000000BC   0xF116 0x0F01      CMN      R6,#+1
   \   000000C0   0xD0F8             BEQ.N    ??HAL_I2C_IsDeviceReady_7
   \   000000C2   0xB356             CBZ.N    R6,??HAL_I2C_IsDeviceReady_4
   \   000000C4   0x.... 0x....      BL       HAL_GetTick
   \   000000C8   0x1B40             SUBS     R0,R0,R5
   \   000000CA   0x4286             CMP      R6,R0
   \   000000CC   0xD2F2             BCS.N    ??HAL_I2C_IsDeviceReady_7
   \   000000CE   0xE024             B.N      ??HAL_I2C_IsDeviceReady_4
   2317                  {
   2318                    return HAL_TIMEOUT;
   2319                  }
   2320                  
   2321                  /* Clear NACK Flag */
   2322                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \   000000D0   0x2110             MOVS     R1,#+16
   \   000000D2   0x61C1             STR      R1,[R0, #+28]
   2323                  
   2324                  /* Clear STOP Flag, auto generated with autoend*/
   2325                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   000000D4   0x6821             LDR      R1,[R4, #+0]
   \   000000D6   0x2020             MOVS     R0,#+32
   \   000000D8   0x61C8             STR      R0,[R1, #+28]
   2326                }
   2327                
   2328                /* Check if the maximum allowed number of trials has been reached */
   2329                if (I2C_Trials++ == Trials)
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x1C41             ADDS     R1,R0,#+1
   \   000000DE   0x4550             CMP      R0,R10
   \   000000E0   0x9100             STR      R1,[SP, #+0]
   \   000000E2   0xD117             BNE.N    ??HAL_I2C_IsDeviceReady_9
   2330                {
   2331                  /* Generate Stop */
   2332                  hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6841             LDR      R1,[R0, #+4]
   \   000000E8   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000EC   0x6041             STR      R1,[R0, #+4]
   2333                  
   2334                  /* Wait until STOPF flag is reset */ 
   2335                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \   000000EE   0x.... 0x....      BL       HAL_GetTick
   \   000000F2   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_IsDeviceReady_10: (+1)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x6981             LDR      R1,[R0, #+24]
   \   000000F8   0x0689             LSLS     R1,R1,#+26
   \   000000FA   0xD409             BMI.N    ??HAL_I2C_IsDeviceReady_11
   \   000000FC   0xF116 0x0F01      CMN      R6,#+1
   \   00000100   0xD0F8             BEQ.N    ??HAL_I2C_IsDeviceReady_10
   \   00000102   0xB156             CBZ.N    R6,??HAL_I2C_IsDeviceReady_4
   \   00000104   0x.... 0x....      BL       HAL_GetTick
   \   00000108   0x1B40             SUBS     R0,R0,R5
   \   0000010A   0x4286             CMP      R6,R0
   \   0000010C   0xD2F2             BCS.N    ??HAL_I2C_IsDeviceReady_10
   \   0000010E   0xE004             B.N      ??HAL_I2C_IsDeviceReady_4
   2336                  {
   2337                    return HAL_TIMEOUT;
   2338                  }
   2339                  
   2340                  /* Clear STOP Flag */
   2341                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_IsDeviceReady_11: (+1)
   \   00000110   0x2120             MOVS     R1,#+32
   \   00000112   0x61C1             STR      R1,[R0, #+28]
   2342                }      
   2343              }while(I2C_Trials < Trials);
   \                     ??HAL_I2C_IsDeviceReady_9: (+1)
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   \   00000116   0x4550             CMP      R0,R10
   \   00000118   0xD396             BCC.N    ??HAL_I2C_IsDeviceReady_1
   2344              
   2345              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0x7078             STRB     R0,[R7, #+1]
   2346              
   2347              /* Process Unlocked */
   2348              __HAL_UNLOCK(hi2c);
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x7038             STRB     R0,[R7, #+0]
   2349              
   2350              return HAL_TIMEOUT;
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \   00000122   0x2003             MOVS     R0,#+3
   \   00000124   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   2351            }
   2352            else
   2353            {
   2354              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \   00000128   0x2002             MOVS     R0,#+2
   \   0000012A   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2355            }
   2356          }
   2357          /**
   2358            * @}
   2359            */
   2360          
   2361          /** @defgroup IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
   2362           * @{
   2363           */   
   2364          
   2365          /**
   2366            * @brief  This function handles I2C event interrupt request.
   2367            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2368            *                the configuration information for the specified I2C.
   2369            * @retval None
   2370            */

   \                                 In section .text, align 2, keep-with-next
   2371          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   2372          {
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2373            /* I2C in mode Transmitter ---------------------------------------------------*/
   2374            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI | I2C_IT_ADDRI)) == SET))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6981             LDR      R1,[R0, #+24]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD40E             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   0000000C   0x6981             LDR      R1,[R0, #+24]
   \   0000000E   0x0609             LSLS     R1,R1,#+24
   \   00000010   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000012   0x6981             LDR      R1,[R0, #+24]
   \   00000014   0x0649             LSLS     R1,R1,#+25
   \   00000016   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x0689             LSLS     R1,R1,#+26
   \   0000001C   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   0000001E   0x6981             LDR      R1,[R0, #+24]
   \   00000020   0x06C9             LSLS     R1,R1,#+27
   \   00000022   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000024   0x6981             LDR      R1,[R0, #+24]
   \   00000026   0x0709             LSLS     R1,R1,#+28
   \   00000028   0xD50A             BPL.N    ??HAL_I2C_EV_IRQHandler_1
   \                     ??HAL_I2C_EV_IRQHandler_0: (+1)
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF000 0x007A      AND      R0,R0,#0x7A
   \   00000030   0x287A             CMP      R0,#+122
   \   00000032   0xBF01             ITTTT    EQ 
   2375            {     
   2376              /* Slave mode selected */
   2377              if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX)
   \   00000034   0xF894 0x0035      LDRBEQ   R0,[R4, #+53]
   \   00000038   0x2832             CMPEQ    R0,#+50
   2378              {
   2379                I2C_SlaveTransmit_ISR(hi2c);
   \   0000003A   0x4620             MOVEQ    R0,R4
   \   0000003C   0x.... 0x....      BLEQ     I2C_SlaveTransmit_ISR
   2380              }
   2381            }
   2382            
   2383            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_1: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6981             LDR      R1,[R0, #+24]
   \   00000044   0x0789             LSLS     R1,R1,#+30
   \   00000046   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   00000048   0x6981             LDR      R1,[R0, #+24]
   \   0000004A   0x0609             LSLS     R1,R1,#+24
   \   0000004C   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   0000004E   0x6981             LDR      R1,[R0, #+24]
   \   00000050   0x0649             LSLS     R1,R1,#+25
   \   00000052   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   00000054   0x6981             LDR      R1,[R0, #+24]
   \   00000056   0x0689             LSLS     R1,R1,#+26
   \   00000058   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   0000005A   0x6981             LDR      R1,[R0, #+24]
   \   0000005C   0x06C9             LSLS     R1,R1,#+27
   \   0000005E   0xD50E             BPL.N    ??HAL_I2C_EV_IRQHandler_3
   \                     ??HAL_I2C_EV_IRQHandler_2: (+1)
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF000 0x0072      AND      R0,R0,#0x72
   \   00000066   0x2872             CMP      R0,#+114
   \   00000068   0xD109             BNE.N    ??HAL_I2C_EV_IRQHandler_3
   2384            {     
   2385              /* Master mode selected */
   2386              if ((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX))
   \   0000006A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000006E   0x2812             CMP      R0,#+18
   \   00000070   0xBF19             ITTEE    NE 
   \   00000072   0xF894 0x0035      LDRBNE   R0,[R4, #+53]
   \   00000076   0x2852             CMPNE    R0,#+82
   2387              {
   2388                I2C_MasterTransmit_ISR(hi2c);
   \   00000078   0x4620             MOVEQ    R0,R4
   \   0000007A   0x.... 0x....      BLEQ     I2C_MasterTransmit_ISR
   2389              }
   2390            }
   2391            
   2392            /* I2C in mode Receiver ----------------------------------------------------*/
   2393            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI | I2C_IT_ADDRI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_3: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6981             LDR      R1,[R0, #+24]
   \   00000082   0x0749             LSLS     R1,R1,#+29
   \   00000084   0xD40E             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000086   0x6981             LDR      R1,[R0, #+24]
   \   00000088   0x0609             LSLS     R1,R1,#+24
   \   0000008A   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000008C   0x6981             LDR      R1,[R0, #+24]
   \   0000008E   0x0649             LSLS     R1,R1,#+25
   \   00000090   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000092   0x6981             LDR      R1,[R0, #+24]
   \   00000094   0x0689             LSLS     R1,R1,#+26
   \   00000096   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000098   0x6981             LDR      R1,[R0, #+24]
   \   0000009A   0x06C9             LSLS     R1,R1,#+27
   \   0000009C   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000009E   0x6981             LDR      R1,[R0, #+24]
   \   000000A0   0x0709             LSLS     R1,R1,#+28
   \   000000A2   0xD50A             BPL.N    ??HAL_I2C_EV_IRQHandler_5
   \                     ??HAL_I2C_EV_IRQHandler_4: (+1)
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF000 0x007C      AND      R0,R0,#0x7C
   \   000000AA   0x287C             CMP      R0,#+124
   \   000000AC   0xBF01             ITTTT    EQ 
   2394            {
   2395              /* Slave mode selected */
   2396              if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX)
   \   000000AE   0xF894 0x0035      LDRBEQ   R0,[R4, #+53]
   \   000000B2   0x2842             CMPEQ    R0,#+66
   2397              {
   2398                I2C_SlaveReceive_ISR(hi2c);
   \   000000B4   0x4620             MOVEQ    R0,R4
   \   000000B6   0x.... 0x....      BLEQ     I2C_SlaveReceive_ISR
   2399              }
   2400            } 
   2401            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_5: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6981             LDR      R1,[R0, #+24]
   \   000000BE   0x0749             LSLS     R1,R1,#+29
   \   000000C0   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000C2   0x6981             LDR      R1,[R0, #+24]
   \   000000C4   0x0609             LSLS     R1,R1,#+24
   \   000000C6   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000C8   0x6981             LDR      R1,[R0, #+24]
   \   000000CA   0x0649             LSLS     R1,R1,#+25
   \   000000CC   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000CE   0x6981             LDR      R1,[R0, #+24]
   \   000000D0   0x0689             LSLS     R1,R1,#+26
   \   000000D2   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000D4   0x6981             LDR      R1,[R0, #+24]
   \   000000D6   0x06C9             LSLS     R1,R1,#+27
   \   000000D8   0xD510             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   \                     ??HAL_I2C_EV_IRQHandler_6: (+1)
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF000 0x0074      AND      R0,R0,#0x74
   \   000000E0   0x2874             CMP      R0,#+116
   \   000000E2   0xD10B             BNE.N    ??HAL_I2C_EV_IRQHandler_7
   2402            {
   2403              /* Master mode selected */
   2404              if ((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX))
   \   000000E4   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   000000E8   0x2822             CMP      R0,#+34
   \   000000EA   0xBF1C             ITT      NE 
   \   000000EC   0xF894 0x0035      LDRBNE   R0,[R4, #+53]
   \   000000F0   0x2862             CMPNE    R0,#+98
   \   000000F2   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_7
   2405              {
   2406                I2C_MasterReceive_ISR(hi2c);
   \   000000F4   0x4620             MOV      R0,R4
   \   000000F6   0xE8BD 0x4010      POP      {R4,LR}
   \   000000FA   0x....             B.N      I2C_MasterReceive_ISR
   2407              }
   2408            } 
   2409          }
   \                     ??HAL_I2C_EV_IRQHandler_7: (+1)
   \   000000FC   0xBD10             POP      {R4,PC}          ;; return
   2410          
   2411          /**
   2412            * @brief  This function handles I2C error interrupt request.
   2413            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2414            *                the configuration information for the specified I2C.
   2415            * @retval None
   2416            */

   \                                 In section .text, align 2, keep-with-next
   2417          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   2418          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2419            /* I2C Bus error interrupt occurred ------------------------------------*/
   2420            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x698A             LDR      R2,[R1, #+24]
   \   00000006   0x05D2             LSLS     R2,R2,#+23
   \   00000008   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x0612             LSLS     R2,R2,#+24
   \   0000000E   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   2421            { 
   2422              hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
   \   00000010   0x6B82             LDR      R2,[R0, #+56]
   \   00000012   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000016   0x6382             STR      R2,[R0, #+56]
   2423              
   2424              /* Clear BERR flag */
   2425              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \   00000018   0xF44F 0x7280      MOV      R2,#+256
   \   0000001C   0x61CA             STR      R2,[R1, #+28]
   2426            }
   2427            
   2428            /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
   2429            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x698A             LDR      R2,[R1, #+24]
   \   00000022   0x0552             LSLS     R2,R2,#+21
   \   00000024   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x0612             LSLS     R2,R2,#+24
   \   0000002A   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   2430            { 
   2431              hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
   \   0000002C   0x6B82             LDR      R2,[R0, #+56]
   \   0000002E   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000032   0x6382             STR      R2,[R0, #+56]
   2432              
   2433              /* Clear OVR flag */
   2434              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \   00000034   0xF44F 0x6280      MOV      R2,#+1024
   \   00000038   0x61CA             STR      R2,[R1, #+28]
   2435            }
   2436            
   2437            /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
   2438            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x698A             LDR      R2,[R1, #+24]
   \   0000003E   0x0592             LSLS     R2,R2,#+22
   \   00000040   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   \   00000042   0x680A             LDR      R2,[R1, #+0]
   \   00000044   0x0612             LSLS     R2,R2,#+24
   \   00000046   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   2439            { 
   2440              hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
   \   00000048   0x6B82             LDR      R2,[R0, #+56]
   \   0000004A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000004E   0x6382             STR      R2,[R0, #+56]
   2441              
   2442              /* Clear ARLO flag */
   2443              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \   00000050   0xF44F 0x7200      MOV      R2,#+512
   \   00000054   0x61CA             STR      R2,[R1, #+28]
   2444            }
   2445            
   2446            /* Call the Error Callback in case of Error detected */
   2447            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \   00000056   0x6B81             LDR      R1,[R0, #+56]
   \   00000058   0xB121             CBZ.N    R1,??HAL_I2C_ER_IRQHandler_3
   2448            {
   2449              hi2c->State = HAL_I2C_STATE_READY;
   \   0000005A   0x2101             MOVS     R1,#+1
   \   0000005C   0xF880 0x1035      STRB     R1,[R0, #+53]
   2450              
   2451              HAL_I2C_ErrorCallback(hi2c);
   \   00000060   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2452            }
   2453          }
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \   00000064   0xBD01             POP      {R0,PC}          ;; return
   2454          
   2455          /**
   2456            * @brief  Master Tx Transfer completed callbacks.
   2457            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2458            *                the configuration information for the specified I2C.
   2459            * @retval None
   2460            */

   \                                 In section .text, align 2, keep-with-next
   2461           __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2462          {
   2463            /* Prevent unused argument(s) compilation warning */
   2464            UNUSED(hi2c);
   2465            
   2466            /* NOTE : This function Should not be modified, when the callback is needed,
   2467                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2468             */ 
   2469          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2470          
   2471          /**
   2472            * @brief  Master Rx Transfer completed callbacks.
   2473            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2474            *                the configuration information for the specified I2C.
   2475            * @retval None
   2476            */

   \                                 In section .text, align 2, keep-with-next
   2477          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2478          {
   2479            /* Prevent unused argument(s) compilation warning */
   2480            UNUSED(hi2c);
   2481            
   2482            /* NOTE : This function Should not be modified, when the callback is needed,
   2483                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2484             */
   2485          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2486          
   2487          /** @brief  Slave Tx Transfer completed callbacks.
   2488            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2489            *                the configuration information for the specified I2C.
   2490            * @retval None
   2491            */

   \                                 In section .text, align 2, keep-with-next
   2492           __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2493          {
   2494            /* Prevent unused argument(s) compilation warning */
   2495            UNUSED(hi2c);
   2496            
   2497            /* NOTE : This function Should not be modified, when the callback is needed,
   2498                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2499             */ 
   2500          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2501          
   2502          /**
   2503            * @brief  Slave Rx Transfer completed callbacks.
   2504            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2505            *                the configuration information for the specified I2C.
   2506            * @retval None
   2507            */

   \                                 In section .text, align 2, keep-with-next
   2508          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2509          {
   2510            /* Prevent unused argument(s) compilation warning */
   2511            UNUSED(hi2c);
   2512            
   2513            /* NOTE : This function Should not be modified, when the callback is needed,
   2514                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2515             */
   2516          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2517          
   2518          /**
   2519            * @brief  Memory Tx Transfer completed callbacks.
   2520            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2521            *                the configuration information for the specified I2C.
   2522            * @retval None
   2523            */

   \                                 In section .text, align 2, keep-with-next
   2524           __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2525          {
   2526            /* Prevent unused argument(s) compilation warning */
   2527            UNUSED(hi2c);
   2528              
   2529            /* NOTE : This function Should not be modified, when the callback is needed,
   2530                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2531             */ 
   2532          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2533          
   2534          /**
   2535            * @brief  Memory Rx Transfer completed callbacks.
   2536            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2537            *                the configuration information for the specified I2C.
   2538            * @retval None
   2539            */

   \                                 In section .text, align 2, keep-with-next
   2540          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2541          {
   2542            /* Prevent unused argument(s) compilation warning */
   2543            UNUSED(hi2c);
   2544            
   2545            /* NOTE : This function Should not be modified, when the callback is needed,
   2546                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2547             */
   2548          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2549          
   2550          /**
   2551            * @brief  I2C error callbacks.
   2552            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2553            *                the configuration information for the specified I2C.
   2554            * @retval None
   2555            */

   \                                 In section .text, align 2, keep-with-next
   2556           __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   2557          {
   2558            /* Prevent unused argument(s) compilation warning */
   2559            UNUSED(hi2c);
   2560            
   2561            /* NOTE : This function Should not be modified, when the callback is needed,
   2562                      the HAL_I2C_ErrorCallback could be implemented in the user file
   2563             */ 
   2564          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2565          
   2566          /**
   2567            * @}
   2568            */
   2569          
   2570          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State and Errors functions
   2571           *  @brief   Peripheral State and Errors functions
   2572           *
   2573          @verbatim   
   2574           ===============================================================================
   2575                      ##### Peripheral State and Errors functions #####
   2576           ===============================================================================  
   2577              [..]
   2578              This subsection permit to get in run-time the status of the peripheral 
   2579              and the data flow.
   2580          
   2581          @endverbatim
   2582            * @{
   2583            */
   2584          
   2585          /**
   2586            * @brief  Returns the I2C state.
   2587            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2588            *                the configuration information for the specified I2C.
   2589            * @retval HAL state
   2590            */

   \                                 In section .text, align 2, keep-with-next
   2591          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   2592          {
   2593            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   2594          }
   2595          
   2596          /**
   2597            * @brief  Return the I2C error code
   2598            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2599            *              the configuration information for the specified I2C.
   2600          * @retval I2C Error Code
   2601          */

   \                                 In section .text, align 2, keep-with-next
   2602          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   2603          {
   2604            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
   2605          }
   2606          
   2607          /**
   2608            * @}
   2609            */  
   2610          
   2611          /**
   2612            * @}
   2613            */
   2614          
   2615          /** @addtogroup I2C_Private_Functions
   2616            * @{
   2617            */
   2618          
   2619          /**
   2620            * @brief  Handle Interrupt Flags Master Transmit Mode
   2621            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2622            *                the configuration information for the specified I2C.
   2623            * @retval HAL status
   2624            */

   \                                 In section .text, align 2, keep-with-next
   2625          static HAL_StatusTypeDef I2C_MasterTransmit_ISR(I2C_HandleTypeDef *hi2c) 
   2626          {
   \                     I2C_MasterTransmit_ISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2627            uint16_t DevAddress;
   2628            
   2629            /* Process Locked */
   2630            __HAL_LOCK(hi2c); 
   \   00000002   0xF100 0x0434      ADD      R4,R0,#+52
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD101             BNE.N    ??I2C_MasterTransmit_ISR_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD70             POP      {R4-R6,PC}
   \                     ??I2C_MasterTransmit_ISR_0: (+1)
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7021             STRB     R1,[R4, #+0]
   2631            
   2632            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x698A             LDR      R2,[R1, #+24]
   \   00000018   0x0792             LSLS     R2,R2,#+30
   \   0000001A   0xD50B             BPL.N    ??I2C_MasterTransmit_ISR_1
   2633            {
   2634              /* Write data to TXDR */
   2635              hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
   \   0000001C   0x6A42             LDR      R2,[R0, #+36]
   \   0000001E   0x1C53             ADDS     R3,R2,#+1
   \   00000020   0x6243             STR      R3,[R0, #+36]
   \   00000022   0x7812             LDRB     R2,[R2, #+0]
   \   00000024   0x628A             STR      R2,[R1, #+40]
   2636              hi2c->XferSize--;
   \   00000026   0x8D01             LDRH     R1,[R0, #+40]
   \   00000028   0x1E49             SUBS     R1,R1,#+1
   \   0000002A   0x8501             STRH     R1,[R0, #+40]
   2637              hi2c->XferCount--;	
   \   0000002C   0x8D41             LDRH     R1,[R0, #+42]
   \   0000002E   0x1E49             SUBS     R1,R1,#+1
   \   00000030   0x8541             STRH     R1,[R0, #+42]
   \   00000032   0xE07F             B.N      ??I2C_MasterTransmit_ISR_2
   2638            }
   2639            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
   \                     ??I2C_MasterTransmit_ISR_1: (+1)
   \   00000034   0x698A             LDR      R2,[R1, #+24]
   \   00000036   0x0612             LSLS     R2,R2,#+24
   \   00000038   0xD528             BPL.N    ??I2C_MasterTransmit_ISR_3
   2640            {
   2641              if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
   \   0000003A   0x8D02             LDRH     R2,[R0, #+40]
   \   0000003C   0xBB02             CBNZ.N   R2,??I2C_MasterTransmit_ISR_4
   \   0000003E   0x8D42             LDRH     R2,[R0, #+42]
   \   00000040   0xB1F2             CBZ.N    R2,??I2C_MasterTransmit_ISR_4
   2642              {
   2643                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   00000042   0x684A             LDR      R2,[R1, #+4]
   2644                
   2645                if(hi2c->XferCount > 255)
   \   00000044   0x8D45             LDRH     R5,[R0, #+42]
   \   00000046   0x.... 0x....      LDR.W    R3,??DataTable19  ;; 0xfc009800
   \   0000004A   0x0592             LSLS     R2,R2,#+22
   \   0000004C   0x2DFF             CMP      R5,#+255
   \   0000004E   0xDD09             BLE.N    ??I2C_MasterTransmit_ISR_5
   2646                {    
   2647                  I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   00000050   0x684D             LDR      R5,[R1, #+4]
   \   00000052   0x402B             ANDS     R3,R3,R5
   \   00000054   0xEA53 0x5292      ORRS     R2,R3,R2, LSR #+22
   \   00000058   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0x1ff0000
   \   0000005C   0x431A             ORRS     R2,R3,R2
   \   0000005E   0x604A             STR      R2,[R1, #+4]
   2648                  hi2c->XferSize = 255;
   \   00000060   0x21FF             MOVS     R1,#+255
   \   00000062   0xE00B             B.N      ??I2C_MasterTransmit_ISR_6
   2649                }
   2650                else
   2651                {
   2652                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_MasterTransmit_ISR_5: (+1)
   \   00000064   0x8D45             LDRH     R5,[R0, #+42]
   \   00000066   0x684E             LDR      R6,[R1, #+4]
   \   00000068   0x4033             ANDS     R3,R3,R6
   \   0000006A   0xEA53 0x5292      ORRS     R2,R3,R2, LSR #+22
   \   0000006E   0xB2ED             UXTB     R5,R5
   \   00000070   0xEA42 0x4205      ORR      R2,R2,R5, LSL #+16
   \   00000074   0xF042 0x7200      ORR      R2,R2,#0x2000000
   \   00000078   0x604A             STR      R2,[R1, #+4]
   2653                  hi2c->XferSize = hi2c->XferCount;
   \   0000007A   0x8D41             LDRH     R1,[R0, #+42]
   \                     ??I2C_MasterTransmit_ISR_6: (+1)
   \   0000007C   0x8501             STRH     R1,[R0, #+40]
   \   0000007E   0xE059             B.N      ??I2C_MasterTransmit_ISR_2
   2654                }
   2655              }
   2656              else
   2657              {
   2658                /* Process Unlocked */
   2659                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_4: (+1)
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x7021             STRB     R1,[R4, #+0]
   2660                
   2661                /* Wrong size Status regarding TCR flag event */
   2662                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   00000084   0x6861             LDR      R1,[R4, #+4]
   \   00000086   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000008A   0xE050             B.N      ??I2C_MasterTransmit_ISR_7
   2663                HAL_I2C_ErrorCallback(hi2c);
   2664              }
   2665            }
   2666            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET)
   \                     ??I2C_MasterTransmit_ISR_3: (+1)
   \   0000008C   0x698A             LDR      R2,[R1, #+24]
   \   0000008E   0x0652             LSLS     R2,R2,#+25
   \   00000090   0xD50C             BPL.N    ??I2C_MasterTransmit_ISR_8
   2667            {
   2668              if(hi2c->XferCount == 0)
   \   00000092   0x8D42             LDRH     R2,[R0, #+42]
   \   00000094   0xB922             CBNZ.N   R2,??I2C_MasterTransmit_ISR_9
   2669              {
   2670                /* Generate Stop */
   2671                hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   00000096   0x6848             LDR      R0,[R1, #+4]
   \   00000098   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000009C   0x6048             STR      R0,[R1, #+4]
   \   0000009E   0xE049             B.N      ??I2C_MasterTransmit_ISR_2
   2672              }
   2673              else
   2674              {
   2675                /* Process Unlocked */
   2676                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_9: (+1)
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x7021             STRB     R1,[R4, #+0]
   2677                
   2678                /* Wrong size Status regarding TCR flag event */
   2679                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   000000A4   0x6861             LDR      R1,[R4, #+4]
   \   000000A6   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000AA   0xE040             B.N      ??I2C_MasterTransmit_ISR_7
   2680                HAL_I2C_ErrorCallback(hi2c);
   2681              }
   2682            }
   2683            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \                     ??I2C_MasterTransmit_ISR_8: (+1)
   \   000000AC   0x698A             LDR      R2,[R1, #+24]
   \   000000AE   0x0692             LSLS     R2,R2,#+26
   \   000000B0   0x698A             LDR      R2,[R1, #+24]
   \   000000B2   0xD533             BPL.N    ??I2C_MasterTransmit_ISR_10
   2684            {
   2685              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   000000B4   0x06D2             LSLS     R2,R2,#+27
   \   000000B6   0xD505             BPL.N    ??I2C_MasterTransmit_ISR_11
   2686              {
   2687                /* Clear NACK Flag */
   2688                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   000000B8   0x2210             MOVS     R2,#+16
   \   000000BA   0x61CA             STR      R2,[R1, #+28]
   2689                
   2690                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   000000BC   0x6861             LDR      R1,[R4, #+4]
   \   000000BE   0xF041 0x0104      ORR      R1,R1,#0x4
   \   000000C2   0x6061             STR      R1,[R4, #+4]
   2691              }
   2692              
   2693              /* Disable ERR, TC, STOP, NACK, TXI interrupt */
   2694              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \                     ??I2C_MasterTransmit_ISR_11: (+1)
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
   2695              
   2696              /* Clear STOP Flag */
   2697              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2698              
   2699              /* Clear Configuration Register 2 */
   2700              I2C_RESET_CR2(hi2c);
   \   000000C6   0x.... 0x....      LDR.W    R3,??DataTable20_1  ;; 0xfe00e800
   \   000000CA   0x680A             LDR      R2,[R1, #+0]
   \   000000CC   0xF022 0x02F2      BIC      R2,R2,#0xF2
   \   000000D0   0x600A             STR      R2,[R1, #+0]
   \   000000D2   0x6802             LDR      R2,[R0, #+0]
   \   000000D4   0x2120             MOVS     R1,#+32
   \   000000D6   0x61D1             STR      R1,[R2, #+28]
   \   000000D8   0x6801             LDR      R1,[R0, #+0]
   \   000000DA   0x684A             LDR      R2,[R1, #+4]
   \   000000DC   0x401A             ANDS     R2,R3,R2
   \   000000DE   0x604A             STR      R2,[R1, #+4]
   2701              
   2702              /* Flush TX register if not empty */
   2703              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \   000000E0   0x6801             LDR      R1,[R0, #+0]
   \   000000E2   0x698A             LDR      R2,[R1, #+24]
   \   000000E4   0x07D2             LSLS     R2,R2,#+31
   \   000000E6   0xBF5C             ITT      PL 
   \   000000E8   0x2201             MOVPL    R2,#+1
   \   000000EA   0x61CA             STRPL    R2,[R1, #+28]
   2704              {
   2705                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
   2706              }
   2707              
   2708              /* Call the correct callback to inform upper layer */
   2709              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   000000EC   0x6861             LDR      R1,[R4, #+4]
   \   000000EE   0xB121             CBZ.N    R1,??I2C_MasterTransmit_ISR_12
   2710              {
   2711                hi2c->State = HAL_I2C_STATE_READY;
   \   000000F0   0x2101             MOVS     R1,#+1
   \   000000F2   0x7061             STRB     R1,[R4, #+1]
   2712                
   2713                /* Process Unlocked */
   2714                __HAL_UNLOCK(hi2c);
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0x7021             STRB     R1,[R4, #+0]
   2715                
   2716                HAL_I2C_ErrorCallback(hi2c);
   \   000000F8   0xE01A             B.N      ??I2C_MasterTransmit_ISR_13
   2717              }
   2718              else
   2719              {
   2720                if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
   \                     ??I2C_MasterTransmit_ISR_12: (+1)
   \   000000FA   0x7861             LDRB     R1,[R4, #+1]
   \   000000FC   0x2952             CMP      R1,#+82
   \   000000FE   0xD106             BNE.N    ??I2C_MasterTransmit_ISR_14
   2721                {
   2722                  hi2c->State = HAL_I2C_STATE_READY;
   \   00000100   0x2101             MOVS     R1,#+1
   \   00000102   0x7061             STRB     R1,[R4, #+1]
   2723                  
   2724                  /* Process Unlocked */
   2725                  __HAL_UNLOCK(hi2c);
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x7021             STRB     R1,[R4, #+0]
   2726                  
   2727                  HAL_I2C_MemTxCpltCallback(hi2c);
   \   00000108   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   0000010C   0xE012             B.N      ??I2C_MasterTransmit_ISR_2
   2728                }
   2729                else
   2730                {
   2731                  hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterTransmit_ISR_14: (+1)
   \   0000010E   0x2101             MOVS     R1,#+1
   \   00000110   0x7061             STRB     R1,[R4, #+1]
   2732                  
   2733                  /* Process Unlocked */
   2734                  __HAL_UNLOCK(hi2c);
   \   00000112   0x2100             MOVS     R1,#+0
   \   00000114   0x7021             STRB     R1,[R4, #+0]
   2735                  
   2736                  HAL_I2C_MasterTxCpltCallback(hi2c);
   \   00000116   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \   0000011A   0xE00B             B.N      ??I2C_MasterTransmit_ISR_2
   2737                }
   2738              }
   2739            }
   2740            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     ??I2C_MasterTransmit_ISR_10: (+1)
   \   0000011C   0x06D2             LSLS     R2,R2,#+27
   \   0000011E   0xD509             BPL.N    ??I2C_MasterTransmit_ISR_2
   2741            {
   2742              /* Clear NACK Flag */
   2743              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000120   0x2210             MOVS     R2,#+16
   \   00000122   0x61CA             STR      R2,[R1, #+28]
   2744              
   2745              /* Process Unlocked */
   2746              __HAL_UNLOCK(hi2c);
   \   00000124   0x2100             MOVS     R1,#+0
   \   00000126   0x7021             STRB     R1,[R4, #+0]
   2747              
   2748              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   00000128   0x6861             LDR      R1,[R4, #+4]
   \   0000012A   0xF041 0x0104      ORR      R1,R1,#0x4
   \                     ??I2C_MasterTransmit_ISR_7: (+1)
   \   0000012E   0x6061             STR      R1,[R4, #+4]
   2749              HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_MasterTransmit_ISR_13: (+1)
   \   00000130   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2750            }
   2751            
   2752            /* Process Unlocked */
   2753            __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_2: (+1)
   \   00000134   0x....             B.N      ?Subroutine15
   2754            
   2755            return HAL_OK;    
   2756          }  

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x7020             STRB     R0,[R4, #+0]
   \   00000004   0xBD70             POP      {R4-R6,PC}       ;; return
   2757          
   2758          /**
   2759            * @brief  Handle Interrupt Flags Master Receive Mode
   2760            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2761            *                the configuration information for the specified I2C.
   2762            * @retval HAL status
   2763            */

   \                                 In section .text, align 2, keep-with-next
   2764          static HAL_StatusTypeDef I2C_MasterReceive_ISR(I2C_HandleTypeDef *hi2c) 
   2765          {
   \                     I2C_MasterReceive_ISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2766            uint16_t DevAddress;
   2767            
   2768            /* Process Locked */
   2769            __HAL_LOCK(hi2c);
   \   00000002   0xF100 0x0434      ADD      R4,R0,#+52
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD101             BNE.N    ??I2C_MasterReceive_ISR_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD70             POP      {R4-R6,PC}
   \                     ??I2C_MasterReceive_ISR_0: (+1)
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7021             STRB     R1,[R4, #+0]
   2770            
   2771            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x698A             LDR      R2,[R1, #+24]
   \   00000018   0x0752             LSLS     R2,R2,#+29
   \   0000001A   0xD50B             BPL.N    ??I2C_MasterReceive_ISR_1
   2772            {  
   2773              /* Read data from RXDR */
   2774              (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
   \   0000001C   0x6A42             LDR      R2,[R0, #+36]
   \   0000001E   0x1C53             ADDS     R3,R2,#+1
   \   00000020   0x6243             STR      R3,[R0, #+36]
   \   00000022   0x6A49             LDR      R1,[R1, #+36]
   \   00000024   0x7011             STRB     R1,[R2, #+0]
   2775              hi2c->XferSize--;
   \   00000026   0x8D01             LDRH     R1,[R0, #+40]
   \   00000028   0x1E49             SUBS     R1,R1,#+1
   \   0000002A   0x8501             STRH     R1,[R0, #+40]
   2776              hi2c->XferCount--;
   \   0000002C   0x8D41             LDRH     R1,[R0, #+42]
   \   0000002E   0x1E49             SUBS     R1,R1,#+1
   \   00000030   0x8541             STRH     R1,[R0, #+42]
   \   00000032   0xE079             B.N      ??I2C_MasterReceive_ISR_2
   2777            }
   2778            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
   \                     ??I2C_MasterReceive_ISR_1: (+1)
   \   00000034   0x698A             LDR      R2,[R1, #+24]
   \   00000036   0x0612             LSLS     R2,R2,#+24
   \   00000038   0xD528             BPL.N    ??I2C_MasterReceive_ISR_3
   2779            {
   2780              if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
   \   0000003A   0x8D02             LDRH     R2,[R0, #+40]
   \   0000003C   0xBB02             CBNZ.N   R2,??I2C_MasterReceive_ISR_4
   \   0000003E   0x8D42             LDRH     R2,[R0, #+42]
   \   00000040   0xB1F2             CBZ.N    R2,??I2C_MasterReceive_ISR_4
   2781              {                  
   2782                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   00000042   0x684A             LDR      R2,[R1, #+4]
   2783                
   2784                if(hi2c->XferCount > 255)
   \   00000044   0x8D45             LDRH     R5,[R0, #+42]
   \   00000046   0x.... 0x....      LDR.W    R3,??DataTable19  ;; 0xfc009800
   \   0000004A   0x0592             LSLS     R2,R2,#+22
   \   0000004C   0x2DFF             CMP      R5,#+255
   \   0000004E   0xDD09             BLE.N    ??I2C_MasterReceive_ISR_5
   2785                {
   2786                  I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   00000050   0x684D             LDR      R5,[R1, #+4]
   \   00000052   0x402B             ANDS     R3,R3,R5
   \   00000054   0xEA53 0x5292      ORRS     R2,R3,R2, LSR #+22
   \   00000058   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0x1ff0000
   \   0000005C   0x431A             ORRS     R2,R3,R2
   \   0000005E   0x604A             STR      R2,[R1, #+4]
   2787                  hi2c->XferSize = 255;
   \   00000060   0x21FF             MOVS     R1,#+255
   \   00000062   0xE00B             B.N      ??I2C_MasterReceive_ISR_6
   2788                }      
   2789                else
   2790                {    
   2791                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_MasterReceive_ISR_5: (+1)
   \   00000064   0x8D45             LDRH     R5,[R0, #+42]
   \   00000066   0x684E             LDR      R6,[R1, #+4]
   \   00000068   0x4033             ANDS     R3,R3,R6
   \   0000006A   0xEA53 0x5292      ORRS     R2,R3,R2, LSR #+22
   \   0000006E   0xB2ED             UXTB     R5,R5
   \   00000070   0xEA42 0x4205      ORR      R2,R2,R5, LSL #+16
   \   00000074   0xF042 0x7200      ORR      R2,R2,#0x2000000
   \   00000078   0x604A             STR      R2,[R1, #+4]
   2792                  hi2c->XferSize = hi2c->XferCount;
   \   0000007A   0x8D41             LDRH     R1,[R0, #+42]
   \                     ??I2C_MasterReceive_ISR_6: (+1)
   \   0000007C   0x8501             STRH     R1,[R0, #+40]
   \   0000007E   0xE053             B.N      ??I2C_MasterReceive_ISR_2
   2793                } 
   2794              } 
   2795              else
   2796              {
   2797                /* Process Unlocked */
   2798                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterReceive_ISR_4: (+1)
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x7021             STRB     R1,[R4, #+0]
   2799                
   2800                /* Wrong size Status regarding TCR flag event */
   2801                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   00000084   0x6861             LDR      R1,[R4, #+4]
   \   00000086   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000008A   0xE04A             B.N      ??I2C_MasterReceive_ISR_7
   2802                HAL_I2C_ErrorCallback(hi2c);
   2803              }
   2804            }
   2805            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET)
   \                     ??I2C_MasterReceive_ISR_3: (+1)
   \   0000008C   0x698A             LDR      R2,[R1, #+24]
   \   0000008E   0x0652             LSLS     R2,R2,#+25
   \   00000090   0xD50C             BPL.N    ??I2C_MasterReceive_ISR_8
   2806            {
   2807              if(hi2c->XferCount == 0)
   \   00000092   0x8D42             LDRH     R2,[R0, #+42]
   \   00000094   0xB922             CBNZ.N   R2,??I2C_MasterReceive_ISR_9
   2808              {
   2809                /* Generate Stop */
   2810                hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   00000096   0x6848             LDR      R0,[R1, #+4]
   \   00000098   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000009C   0x6048             STR      R0,[R1, #+4]
   \   0000009E   0xE043             B.N      ??I2C_MasterReceive_ISR_2
   2811              }
   2812              else
   2813              {
   2814                /* Process Unlocked */
   2815                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterReceive_ISR_9: (+1)
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x7021             STRB     R1,[R4, #+0]
   2816                
   2817                /* Wrong size Status regarding TCR flag event */
   2818                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   000000A4   0x6861             LDR      R1,[R4, #+4]
   \   000000A6   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000AA   0xE03A             B.N      ??I2C_MasterReceive_ISR_7
   2819                HAL_I2C_ErrorCallback(hi2c);
   2820              }
   2821            }
   2822            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \                     ??I2C_MasterReceive_ISR_8: (+1)
   \   000000AC   0x698A             LDR      R2,[R1, #+24]
   \   000000AE   0x0692             LSLS     R2,R2,#+26
   \   000000B0   0x698A             LDR      R2,[R1, #+24]
   \   000000B2   0xD52D             BPL.N    ??I2C_MasterReceive_ISR_10
   2823            {
   2824              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   000000B4   0x06D2             LSLS     R2,R2,#+27
   \   000000B6   0xD505             BPL.N    ??I2C_MasterReceive_ISR_11
   2825              {
   2826                /* Clear NACK Flag */
   2827                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   000000B8   0x2210             MOVS     R2,#+16
   \   000000BA   0x61CA             STR      R2,[R1, #+28]
   2828                
   2829                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   000000BC   0x6861             LDR      R1,[R4, #+4]
   \   000000BE   0xF041 0x0104      ORR      R1,R1,#0x4
   \   000000C2   0x6061             STR      R1,[R4, #+4]
   2830              }
   2831              
   2832              /* Disable ERR, TC, STOP, NACK, TXI interrupt */
   2833              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
   \                     ??I2C_MasterReceive_ISR_11: (+1)
   \   000000C4   0x6801             LDR      R1,[R0, #+0]
   2834              
   2835              /* Clear STOP Flag */
   2836              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2837              
   2838              /* Clear Configuration Register 2 */
   2839              I2C_RESET_CR2(hi2c);
   \   000000C6   0x.... 0x....      LDR.W    R3,??DataTable20_1  ;; 0xfe00e800
   \   000000CA   0x680A             LDR      R2,[R1, #+0]
   \   000000CC   0xF022 0x02F4      BIC      R2,R2,#0xF4
   \   000000D0   0x600A             STR      R2,[R1, #+0]
   \   000000D2   0x6802             LDR      R2,[R0, #+0]
   \   000000D4   0x2120             MOVS     R1,#+32
   \   000000D6   0x61D1             STR      R1,[R2, #+28]
   \   000000D8   0x6801             LDR      R1,[R0, #+0]
   \   000000DA   0x684A             LDR      R2,[R1, #+4]
   \   000000DC   0x401A             ANDS     R2,R3,R2
   \   000000DE   0x604A             STR      R2,[R1, #+4]
   2840              
   2841              /* Call the correct callback to inform upper layer */
   2842              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   000000E0   0x6861             LDR      R1,[R4, #+4]
   \   000000E2   0xB121             CBZ.N    R1,??I2C_MasterReceive_ISR_12
   2843              {
   2844                hi2c->State = HAL_I2C_STATE_READY;
   \   000000E4   0x2101             MOVS     R1,#+1
   \   000000E6   0x7061             STRB     R1,[R4, #+1]
   2845                
   2846                /* Process Unlocked */
   2847                __HAL_UNLOCK(hi2c);
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x7021             STRB     R1,[R4, #+0]
   2848                
   2849                HAL_I2C_ErrorCallback(hi2c);
   \   000000EC   0xE01A             B.N      ??I2C_MasterReceive_ISR_13
   2850              }
   2851              else
   2852              {
   2853                if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX)
   \                     ??I2C_MasterReceive_ISR_12: (+1)
   \   000000EE   0x7861             LDRB     R1,[R4, #+1]
   \   000000F0   0x2962             CMP      R1,#+98
   \   000000F2   0xD106             BNE.N    ??I2C_MasterReceive_ISR_14
   2854                {
   2855                  hi2c->State = HAL_I2C_STATE_READY;
   \   000000F4   0x2101             MOVS     R1,#+1
   \   000000F6   0x7061             STRB     R1,[R4, #+1]
   2856                  
   2857                  /* Process Unlocked */
   2858                  __HAL_UNLOCK(hi2c);
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x7021             STRB     R1,[R4, #+0]
   2859                  
   2860                  HAL_I2C_MemRxCpltCallback(hi2c);
   \   000000FC   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   00000100   0xE012             B.N      ??I2C_MasterReceive_ISR_2
   2861                }
   2862                else
   2863                {
   2864                  hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterReceive_ISR_14: (+1)
   \   00000102   0x2101             MOVS     R1,#+1
   \   00000104   0x7061             STRB     R1,[R4, #+1]
   2865                  
   2866                  /* Process Unlocked */
   2867                  __HAL_UNLOCK(hi2c);
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x7021             STRB     R1,[R4, #+0]
   2868                  
   2869                  HAL_I2C_MasterRxCpltCallback(hi2c);
   \   0000010A   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \   0000010E   0xE00B             B.N      ??I2C_MasterReceive_ISR_2
   2870                }
   2871              }
   2872            }
   2873            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     ??I2C_MasterReceive_ISR_10: (+1)
   \   00000110   0x06D2             LSLS     R2,R2,#+27
   \   00000112   0xD509             BPL.N    ??I2C_MasterReceive_ISR_2
   2874            {
   2875              /* Clear NACK Flag */
   2876              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000114   0x2210             MOVS     R2,#+16
   \   00000116   0x61CA             STR      R2,[R1, #+28]
   2877              
   2878              /* Process Unlocked */
   2879              __HAL_UNLOCK(hi2c);
   \   00000118   0x2100             MOVS     R1,#+0
   \   0000011A   0x7021             STRB     R1,[R4, #+0]
   2880              
   2881              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   0000011C   0x6861             LDR      R1,[R4, #+4]
   \   0000011E   0xF041 0x0104      ORR      R1,R1,#0x4
   \                     ??I2C_MasterReceive_ISR_7: (+1)
   \   00000122   0x6061             STR      R1,[R4, #+4]
   2882              HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_MasterReceive_ISR_13: (+1)
   \   00000124   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2883            }
   2884            
   2885            /* Process Unlocked */
   2886            __HAL_UNLOCK(hi2c); 
   \                     ??I2C_MasterReceive_ISR_2: (+1)
   \   00000128                      REQUIRE ?Subroutine15
   \   00000128                      ;; // Fall through to label ?Subroutine15
   2887            
   2888            return HAL_OK; 
   2889            
   2890          }  
   2891          
   2892          /**
   2893            * @brief  Handle Interrupt Flags Slave Transmit Mode
   2894            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2895            *                the configuration information for the specified I2C.
   2896            * @retval HAL status
   2897            */

   \                                 In section .text, align 2, keep-with-next
   2898          static HAL_StatusTypeDef I2C_SlaveTransmit_ISR(I2C_HandleTypeDef *hi2c) 
   2899          {
   \                     I2C_SlaveTransmit_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2900            /* Process locked */
   2901            __HAL_LOCK(hi2c);
   \   00000002   0xF100 0x0434      ADD      R4,R0,#+52
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD101             BNE.N    ??I2C_SlaveTransmit_ISR_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_0: (+1)
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7021             STRB     R1,[R4, #+0]
   2902            
   2903            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x698A             LDR      R2,[R1, #+24]
   \   00000018   0x06D2             LSLS     R2,R2,#+27
   \   0000001A   0xD511             BPL.N    ??I2C_SlaveTransmit_ISR_1
   2904            {
   2905              /* Check that I2C transfer finished */
   2906              /* if yes, normal usecase, a NACK is sent by the MASTER when Transfer is finished */
   2907              /* Mean XferCount == 0*/
   2908              /* So clear Flag NACKF only */
   2909              if(hi2c->XferCount == 0)
   \   0000001C   0x8D42             LDRH     R2,[R0, #+42]
   \   0000001E   0xB922             CBNZ.N   R2,??I2C_SlaveTransmit_ISR_2
   2910              {
   2911                /* Clear NACK Flag */
   2912                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000020   0x2010             MOVS     R0,#+16
   \   00000022   0x61C8             STR      R0,[R1, #+28]
   2913                
   2914                /* Process Unlocked */
   2915                __HAL_UNLOCK(hi2c);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7020             STRB     R0,[R4, #+0]
   \   00000028   0xE033             B.N      ??I2C_SlaveTransmit_ISR_3
   2916              }
   2917              else
   2918              {
   2919                /* if no, error usecase, a Non-Acknowledge of last Data is generated by the MASTER*/
   2920                /* Clear NACK Flag */
   2921                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_SlaveTransmit_ISR_2: (+1)
   \   0000002A   0x2210             MOVS     R2,#+16
   \   0000002C   0x61CA             STR      R2,[R1, #+28]
   2922                
   2923                /* Set ErrorCode corresponding to a Non-Acknowledge */
   2924                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   0000002E   0x6861             LDR      R1,[R4, #+4]
   \   00000030   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000034   0x6061             STR      R1,[R4, #+4]
   2925                
   2926                /* Process Unlocked */
   2927                __HAL_UNLOCK(hi2c);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x7021             STRB     R1,[R4, #+0]
   2928                
   2929                /* Call the Error callback to prevent upper layer */
   2930                HAL_I2C_ErrorCallback(hi2c);
   \   0000003A   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   0000003E   0xE028             B.N      ??I2C_SlaveTransmit_ISR_3
   2931              }
   2932            }
   2933            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   \                     ??I2C_SlaveTransmit_ISR_1: (+1)
   \   00000040   0x698A             LDR      R2,[R1, #+24]
   \   00000042   0x0712             LSLS     R2,R2,#+28
   \   00000044   0xD502             BPL.N    ??I2C_SlaveTransmit_ISR_4
   2934            {
   2935              /* Clear ADDR flag */
   2936              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \   00000046   0x2008             MOVS     R0,#+8
   \   00000048   0x61C8             STR      R0,[R1, #+28]
   \   0000004A   0xE022             B.N      ??I2C_SlaveTransmit_ISR_3
   2937            }
   2938            /* Check first if STOPF is set          */
   2939            /* to prevent a Write Data in TX buffer */
   2940            /* which is stuck in TXDR until next    */
   2941            /* communication with Master            */
   2942            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \                     ??I2C_SlaveTransmit_ISR_4: (+1)
   \   0000004C   0x698A             LDR      R2,[R1, #+24]
   \   0000004E   0x0692             LSLS     R2,R2,#+26
   \   00000050   0xD512             BPL.N    ??I2C_SlaveTransmit_ISR_5
   2943            {
   2944              /* Disable ERRI, TCI, STOPI, NACKI, ADDRI, RXI, TXI interrupt */
   2945              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI );
   \   00000052   0x680A             LDR      R2,[R1, #+0]
   \   00000054   0xF022 0x02FE      BIC      R2,R2,#0xFE
   \   00000058   0x600A             STR      R2,[R1, #+0]
   2946              
   2947              /* Disable Address Acknowledge */
   2948              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x684A             LDR      R2,[R1, #+4]
   \   0000005E   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000062   0x604A             STR      R2,[R1, #+4]
   2949              
   2950              /* Clear STOP Flag */
   2951              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   00000064   0x6802             LDR      R2,[R0, #+0]
   \   00000066   0x2120             MOVS     R1,#+32
   \   00000068   0x61D1             STR      R1,[R2, #+28]
   2952              
   2953              hi2c->State = HAL_I2C_STATE_READY;
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x7061             STRB     R1,[R4, #+1]
   2954              
   2955              /* Process Unlocked */
   2956              __HAL_UNLOCK(hi2c);
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x7021             STRB     R1,[R4, #+0]
   2957              
   2958              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \   00000072   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   \   00000076   0xE00C             B.N      ??I2C_SlaveTransmit_ISR_3
   2959            }
   2960            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
   \                     ??I2C_SlaveTransmit_ISR_5: (+1)
   \   00000078   0x698A             LDR      R2,[R1, #+24]
   \   0000007A   0x0792             LSLS     R2,R2,#+30
   \   0000007C   0xD509             BPL.N    ??I2C_SlaveTransmit_ISR_3
   2961            {
   2962              /* Write data to TXDR only if XferCount not reach "0" */
   2963              /* A TXIS flag can be set, during STOP treatment      */
   2964              if(hi2c->XferCount > 0)
   \   0000007E   0x8D42             LDRH     R2,[R0, #+42]
   \   00000080   0xB13A             CBZ.N    R2,??I2C_SlaveTransmit_ISR_3
   2965              {
   2966                /* Write data to TXDR */
   2967                hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
   \   00000082   0x6A42             LDR      R2,[R0, #+36]
   \   00000084   0x1C53             ADDS     R3,R2,#+1
   \   00000086   0x6243             STR      R3,[R0, #+36]
   \   00000088   0x7812             LDRB     R2,[R2, #+0]
   \   0000008A   0x628A             STR      R2,[R1, #+40]
   2968                hi2c->XferCount--;
   \   0000008C   0x8D41             LDRH     R1,[R0, #+42]
   \   0000008E   0x1E49             SUBS     R1,R1,#+1
   \   00000090   0x8541             STRH     R1,[R0, #+42]
   2969              }
   2970            }
   2971            
   2972            /* Process Unlocked */
   2973            __HAL_UNLOCK(hi2c);
   \                     ??I2C_SlaveTransmit_ISR_3: (+1)
   \   00000092   0x....             B.N      ?Subroutine1
   2974            
   2975            return HAL_OK;
   2976          }  

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x7020             STRB     R0,[R4, #+0]
   \   00000004   0xBD10             POP      {R4,PC}          ;; return
   2977          
   2978          /**
   2979            * @brief  Handle Interrupt Flags Slave Receive Mode
   2980            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2981            *                the configuration information for the specified I2C.
   2982            * @retval HAL status
   2983            */

   \                                 In section .text, align 2, keep-with-next
   2984          static HAL_StatusTypeDef I2C_SlaveReceive_ISR(I2C_HandleTypeDef *hi2c) 
   2985          {
   \                     I2C_SlaveReceive_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2986            /* Process Locked */
   2987            __HAL_LOCK(hi2c);
   \   00000002   0xF100 0x0434      ADD      R4,R0,#+52
   \   00000006   0x7821             LDRB     R1,[R4, #+0]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD101             BNE.N    ??I2C_SlaveReceive_ISR_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_0: (+1)
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x7021             STRB     R1,[R4, #+0]
   2988            
   2989            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x698A             LDR      R2,[R1, #+24]
   \   00000018   0x06D2             LSLS     R2,R2,#+27
   \   0000001A   0xD50A             BPL.N    ??I2C_SlaveReceive_ISR_1
   2990            {
   2991              /* Clear NACK Flag */
   2992              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000001C   0x2210             MOVS     R2,#+16
   \   0000001E   0x61CA             STR      R2,[R1, #+28]
   2993              
   2994              /* Process Unlocked */
   2995              __HAL_UNLOCK(hi2c);
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7021             STRB     R1,[R4, #+0]
   2996              
   2997              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   00000024   0x6861             LDR      R1,[R4, #+4]
   \   00000026   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000002A   0x6061             STR      R1,[R4, #+4]
   2998              HAL_I2C_ErrorCallback(hi2c);
   \   0000002C   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000030   0xE029             B.N      ??I2C_SlaveReceive_ISR_2
   2999            }
   3000            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   \                     ??I2C_SlaveReceive_ISR_1: (+1)
   \   00000032   0x698A             LDR      R2,[R1, #+24]
   \   00000034   0x0712             LSLS     R2,R2,#+28
   \   00000036   0xD502             BPL.N    ??I2C_SlaveReceive_ISR_3
   3001            {
   3002              /* Clear ADDR flag */
   3003              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \   00000038   0x2008             MOVS     R0,#+8
   \   0000003A   0x61C8             STR      R0,[R1, #+28]
   \   0000003C   0xE023             B.N      ??I2C_SlaveReceive_ISR_2
   3004            }
   3005            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \                     ??I2C_SlaveReceive_ISR_3: (+1)
   \   0000003E   0x698A             LDR      R2,[R1, #+24]
   \   00000040   0x0752             LSLS     R2,R2,#+29
   \   00000042   0xD50B             BPL.N    ??I2C_SlaveReceive_ISR_4
   3006            {
   3007              /* Read data from RXDR */
   3008              (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
   \   00000044   0x6A42             LDR      R2,[R0, #+36]
   \   00000046   0x1C53             ADDS     R3,R2,#+1
   \   00000048   0x6243             STR      R3,[R0, #+36]
   \   0000004A   0x6A49             LDR      R1,[R1, #+36]
   \   0000004C   0x7011             STRB     R1,[R2, #+0]
   3009              hi2c->XferSize--;
   \   0000004E   0x8D01             LDRH     R1,[R0, #+40]
   \   00000050   0x1E49             SUBS     R1,R1,#+1
   \   00000052   0x8501             STRH     R1,[R0, #+40]
   3010              hi2c->XferCount--;
   \   00000054   0x8D41             LDRH     R1,[R0, #+42]
   \   00000056   0x1E49             SUBS     R1,R1,#+1
   \   00000058   0x8541             STRH     R1,[R0, #+42]
   \   0000005A   0xE014             B.N      ??I2C_SlaveReceive_ISR_2
   3011            }
   3012            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \                     ??I2C_SlaveReceive_ISR_4: (+1)
   \   0000005C   0x698A             LDR      R2,[R1, #+24]
   \   0000005E   0x0692             LSLS     R2,R2,#+26
   \   00000060   0xD511             BPL.N    ??I2C_SlaveReceive_ISR_2
   3013            {
   3014              /* Disable ERRI, TCI, STOPI, NACKI, ADDRI, RXI, TXI interrupt */
   3015              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_RXI );
   \   00000062   0x680A             LDR      R2,[R1, #+0]
   \   00000064   0xF022 0x02FC      BIC      R2,R2,#0xFC
   \   00000068   0x600A             STR      R2,[R1, #+0]
   3016              
   3017              /* Disable Address Acknowledge */
   3018              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x684A             LDR      R2,[R1, #+4]
   \   0000006E   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000072   0x604A             STR      R2,[R1, #+4]
   3019              
   3020              /* Clear STOP Flag */
   3021              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   00000074   0x6802             LDR      R2,[R0, #+0]
   \   00000076   0x2120             MOVS     R1,#+32
   \   00000078   0x61D1             STR      R1,[R2, #+28]
   3022              
   3023              hi2c->State = HAL_I2C_STATE_READY;
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0x7061             STRB     R1,[R4, #+1]
   3024              
   3025              /* Process Unlocked */
   3026              __HAL_UNLOCK(hi2c);
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x7021             STRB     R1,[R4, #+0]
   3027              
   3028              HAL_I2C_SlaveRxCpltCallback(hi2c);
   \   00000082   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   3029            }
   3030            
   3031            /* Process Unlocked */
   3032            __HAL_UNLOCK(hi2c);
   \                     ??I2C_SlaveReceive_ISR_2: (+1)
   \   00000086                      REQUIRE ?Subroutine1
   \   00000086                      ;; // Fall through to label ?Subroutine1
   3033            
   3034            return HAL_OK;     
   3035          }  
   3036          
   3037          /**
   3038            * @brief  Master sends target device address followed by internal memory address for write request.
   3039            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3040            *                the configuration information for the specified I2C.
   3041            * @param  DevAddress: Target device address
   3042            * @param  MemAddress: Internal memory address
   3043            * @param  MemAddSize: Size of internal memory address
   3044            * @param  Timeout: Timeout duration
   3045            * @retval HAL status
   3046            */

   \                                 In section .text, align 2, keep-with-next
   3047          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)   
   3048          {
   \                     I2C_RequestMemoryWrite: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   3049            I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   00000004   0xF44F 0x5000      MOV      R0,#+8192
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0xF04F 0x7380      MOV      R3,#+16777216
   \   00000012   0xB2F2             UXTB     R2,R6
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       I2C_TransferConfig
   \   0000001A   0x9F06             LDR      R7,[SP, #+24]
   3050            
   3051            /* Wait until TXIS flag is set */
   3052            if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x4639             MOV      R1,R7
   \   00000020   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \   00000024   0xB118             CBZ.N    R0,??I2C_RequestMemoryWrite_0
   3053            {
   3054              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000026   0x6BA0             LDR      R0,[R4, #+56]
   \   00000028   0x2804             CMP      R0,#+4
   \   0000002A   0xD119             BNE.N    ??I2C_RequestMemoryWrite_1
   3055              {
   3056                return HAL_ERROR;
   \   0000002C   0xE00C             B.N      ??I2C_RequestMemoryWrite_2
   3057              }
   3058              else
   3059              {
   3060                return HAL_TIMEOUT;
   3061              }
   3062            }
   3063            
   3064            /* If Memory address size is 8Bit */
   3065            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryWrite_0: (+1)
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xD00C             BEQ.N    ??I2C_RequestMemoryWrite_3
   3066            {
   3067              /* Send Memory Address */
   3068              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);    
   3069            }      
   3070            /* If Memory address size is 16Bit */
   3071            else
   3072            {
   3073              /* Send MSB of Memory Address */
   3074              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress); 
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x0A28             LSRS     R0,R5,#+8
   \   00000036   0x6288             STR      R0,[R1, #+40]
   3075              
   3076              /* Wait until TXIS flag is set */
   3077              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   00000038   0x4639             MOV      R1,R7
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \   00000040   0xB120             CBZ.N    R0,??I2C_RequestMemoryWrite_3
   3078              {
   3079                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000042   0x6BA0             LDR      R0,[R4, #+56]
   \   00000044   0x2804             CMP      R0,#+4
   \   00000046   0xD10B             BNE.N    ??I2C_RequestMemoryWrite_1
   3080                {
   3081                  return HAL_ERROR;
   \                     ??I2C_RequestMemoryWrite_2: (+1)
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
   3082                }
   3083                else
   3084                {
   3085                  return HAL_TIMEOUT;
   3086                }
   3087              }
   3088              
   3089              /* Send LSB of Memory Address */
   3090              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);  
   \                     ??I2C_RequestMemoryWrite_3: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0xB2ED             UXTB     R5,R5
   3091            }
   3092            
   3093            /* Wait until TCR flag is set */
   3094            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   \   00000050   0x463B             MOV      R3,R7
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x6285             STR      R5,[R0, #+40]
   \   00000056   0x2180             MOVS     R1,#+128
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000005E   0xB100             CBZ.N    R0,??I2C_RequestMemoryWrite_4
   3095            {
   3096              return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_1: (+1)
   \   00000060   0x2003             MOVS     R0,#+3
   3097            }
   3098            
   3099            return HAL_OK;
   \                     ??I2C_RequestMemoryWrite_4: (+1)
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3100          }
   3101          
   3102          /**
   3103            * @brief  Master sends target device address followed by internal memory address for read request.
   3104            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3105            *                the configuration information for the specified I2C.
   3106            * @param  DevAddress: Target device address
   3107            * @param  MemAddress: Internal memory address
   3108            * @param  MemAddSize: Size of internal memory address
   3109            * @param  Timeout: Timeout duration
   3110            * @retval HAL status
   3111            */

   \                                 In section .text, align 2, keep-with-next
   3112          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
   3113          {
   \                     I2C_RequestMemoryRead: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   3114            I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
   \   00000004   0xF44F 0x5000      MOV      R0,#+8192
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0xB2F2             UXTB     R2,R6
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       I2C_TransferConfig
   \   00000018   0x9F06             LDR      R7,[SP, #+24]
   3115            
   3116            /* Wait until TXIS flag is set */
   3117            if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x4639             MOV      R1,R7
   \   0000001E   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \   00000022   0xB118             CBZ.N    R0,??I2C_RequestMemoryRead_0
   3118            {
   3119              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000024   0x6BA0             LDR      R0,[R4, #+56]
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD119             BNE.N    ??I2C_RequestMemoryRead_1
   3120              {
   3121                return HAL_ERROR;
   \   0000002A   0xE00C             B.N      ??I2C_RequestMemoryRead_2
   3122              }
   3123              else
   3124              {
   3125                return HAL_TIMEOUT;
   3126              }
   3127            }
   3128            
   3129            /* If Memory address size is 8Bit */
   3130            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryRead_0: (+1)
   \   0000002C   0x2E01             CMP      R6,#+1
   \   0000002E   0xD00C             BEQ.N    ??I2C_RequestMemoryRead_3
   3131            {
   3132              /* Send Memory Address */
   3133              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);    
   3134            }      
   3135            /* If Memory address size is 16Bit */
   3136            else
   3137            {
   3138              /* Send MSB of Memory Address */
   3139              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress); 
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x0A28             LSRS     R0,R5,#+8
   \   00000034   0x6288             STR      R0,[R1, #+40]
   3140              
   3141              /* Wait until TXIS flag is set */
   3142              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   \   00000036   0x4639             MOV      R1,R7
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \   0000003E   0xB120             CBZ.N    R0,??I2C_RequestMemoryRead_3
   3143              {
   3144                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000040   0x6BA0             LDR      R0,[R4, #+56]
   \   00000042   0x2804             CMP      R0,#+4
   \   00000044   0xD10B             BNE.N    ??I2C_RequestMemoryRead_1
   3145                {
   3146                  return HAL_ERROR;
   \                     ??I2C_RequestMemoryRead_2: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xBDF2             POP      {R1,R4-R7,PC}
   3147                }
   3148                else
   3149                {
   3150                  return HAL_TIMEOUT;
   3151                }
   3152              }
   3153              
   3154              /* Send LSB of Memory Address */
   3155              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);  
   \                     ??I2C_RequestMemoryRead_3: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0xB2ED             UXTB     R5,R5
   3156            }
   3157            
   3158            /* Wait until TC flag is set */
   3159            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout) != HAL_OK)      
   \   0000004E   0x463B             MOV      R3,R7
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x6285             STR      R5,[R0, #+40]
   \   00000054   0x2140             MOVS     R1,#+64
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \   0000005C   0xB100             CBZ.N    R0,??I2C_RequestMemoryRead_4
   3160            {
   3161              return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_1: (+1)
   \   0000005E   0x2003             MOVS     R0,#+3
   3162            }
   3163            
   3164            return HAL_OK;
   \                     ??I2C_RequestMemoryRead_4: (+1)
   \   00000060   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3165          }
   3166          
   3167          /**
   3168            * @brief  DMA I2C master transmit process complete callback.
   3169            * @param  hdma: DMA handle
   3170            * @retval None
   3171            */

   \                                 In section .text, align 2, keep-with-next
   3172          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma) 
   3173          {
   \                     I2C_DMAMasterTransmitCplt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   3174            uint16_t DevAddress;
   3175            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3176            
   3177            /* Check if last DMA request was done with RELOAD */
   3178            /* Set NBYTES to write and reload if size > 255 */
   3179            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x808E      BNE.W    ??I2C_DMAMasterTransmitCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x808A      BCS.W    ??I2C_DMAMasterTransmitCplt_0
   3180            {
   3181              /* Wait until TCR flag is set */
   3182              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMasterTransmitCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMasterTransmitCplt_1
   \   0000002E   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7068             STRB     R0,[R5, #+1]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7028             STRB     R0,[R5, #+0]
   3183              {
   3184                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6868             LDR      R0,[R5, #+4]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x6068             STR      R0,[R5, #+4]
   3185              }
   3186              
   3187              /* Disable DMA Request */
   3188              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMAMasterTransmitCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   3189              
   3190              /* Check if Errors has been detected during transfer */
   3191              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000044   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   \   00000050   0x6868             LDR      R0,[R5, #+4]
   \   00000052   0xB1E0             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_3
   3192              {
   3193                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3194                /* Wait until STOPF flag is reset */ 
   3195                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000054   0x2119             MOVS     R1,#+25
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000005C   0xB140             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_4
   3196                {
   3197                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000005E   0x6868             LDR      R0,[R5, #+4]
   \   00000060   0x2804             CMP      R0,#+4
   \   00000062   0x6868             LDR      R0,[R5, #+4]
   \   00000064   0xBF0C             ITE      EQ 
   \   00000066   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000006A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3198                  {
   3199                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3200                  }
   3201                  else
   3202                  {
   3203                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000006E   0x6068             STR      R0,[R5, #+4]
   3204                  }
   3205                }
   3206                
   3207                /* Clear STOP Flag */
   3208                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterTransmitCplt_4: (+1)
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x2020             MOVS     R0,#+32
   3209                
   3210                /* Clear Configuration Register 2 */
   3211                I2C_RESET_CR2(hi2c);
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000078   0x61C8             STR      R0,[R1, #+28]
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6841             LDR      R1,[R0, #+4]
   \   0000007E   0x4011             ANDS     R1,R2,R1
   \   00000080   0x6041             STR      R1,[R0, #+4]
   3212                
   3213                hi2c->XferCount = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x8560             STRH     R0,[R4, #+42]
   3214                
   3215                hi2c->State = HAL_I2C_STATE_READY;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x7068             STRB     R0,[R5, #+1]
   3216                HAL_I2C_ErrorCallback(hi2c);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0xE073             B.N      ??I2C_DMAMasterTransmitCplt_5
   3217              }
   3218              else
   3219              {
   3220                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMasterTransmitCplt_3: (+1)
   \   0000008E   0x8D20             LDRH     R0,[R4, #+40]
   \   00000090   0x6A61             LDR      R1,[R4, #+36]
   \   00000092   0x1841             ADDS     R1,R0,R1
   \   00000094   0x6261             STR      R1,[R4, #+36]
   3221                hi2c->XferCount -= hi2c->XferSize;
   \   00000096   0x8D62             LDRH     R2,[R4, #+42]
   \   00000098   0x1A10             SUBS     R0,R2,R0
   \   0000009A   0x8560             STRH     R0,[R4, #+42]
   3222                if(hi2c->XferCount > 255)
   \   0000009C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000009E   0x28FF             CMP      R0,#+255
   \   000000A0   0xBFCC             ITE      GT 
   \   000000A2   0x20FF             MOVGT    R0,#+255
   \   000000A4   0x8D60             LDRHLE   R0,[R4, #+42]
   3223                {
   3224                  hi2c->XferSize = 255;
   3225                }
   3226                else
   3227                {
   3228                  hi2c->XferSize = hi2c->XferCount;
   \   000000A6   0x8520             STRH     R0,[R4, #+40]
   3229                }
   3230                
   3231                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6842             LDR      R2,[R0, #+4]
   3232                
   3233                /* Enable the DMA channel */
   3234                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   000000AC   0x8D23             LDRH     R3,[R4, #+40]
   \   000000AE   0x0596             LSLS     R6,R2,#+22
   \   000000B0   0xF100 0x0228      ADD      R2,R0,#+40
   \   000000B4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B6   0x0DB6             LSRS     R6,R6,#+22
   \   000000B8   0x.... 0x....      BL       HAL_DMA_Start_IT
   3235                
   3236                /* Send Slave Address */
   3237                /* Set NBYTES to write and reload if size > 255 */
   3238                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000BC   0x8D22             LDRH     R2,[R4, #+40]
   \   000000BE   0x2AFF             CMP      R2,#+255
   \   000000C0   0xD107             BNE.N    ??I2C_DMAMasterTransmitCplt_6
   \   000000C2   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C4   0x4282             CMP      R2,R0
   \   000000C6   0xD204             BCS.N    ??I2C_DMAMasterTransmitCplt_6
   3239                {
   3240                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF04F 0x7380      MOV      R3,#+16777216
   \   000000CE   0x9000             STR      R0,[SP, #+0]
   \   000000D0   0xE004             B.N      ??I2C_DMAMasterTransmitCplt_7
   3241                }
   3242                else
   3243                {
   3244                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMasterTransmitCplt_6: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF04F 0x7300      MOV      R3,#+33554432
   \   000000D8   0x9000             STR      R0,[SP, #+0]
   \   000000DA   0xB2D2             UXTB     R2,R2
   \                     ??I2C_DMAMasterTransmitCplt_7: (+1)
   \   000000DC   0x4631             MOV      R1,R6
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       I2C_TransferConfig
   3245                }  
   3246                
   3247                /* Wait until TXIS flag is set */
   3248                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   000000E4   0x2119             MOVS     R1,#+25
   \   000000E6   0x4620             MOV      R0,R4
   \   000000E8   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \   000000EC   0xB1E0             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_8
   3249                {
   3250                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3251                  /* Wait until STOPF flag is reset */ 
   3252                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   000000EE   0x2119             MOVS     R1,#+25
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   000000F6   0xB140             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_9
   3253                  {
   3254                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000F8   0x6868             LDR      R0,[R5, #+4]
   \   000000FA   0x2804             CMP      R0,#+4
   \   000000FC   0x6868             LDR      R0,[R5, #+4]
   \   000000FE   0xBF0C             ITE      EQ 
   \   00000100   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000104   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3255                    {
   3256                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3257                    }
   3258                    else
   3259                    {
   3260                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000108   0x6068             STR      R0,[R5, #+4]
   3261                    }
   3262                  }
   3263                  
   3264                  /* Clear STOP Flag */
   3265                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterTransmitCplt_9: (+1)
   \   0000010A   0x6821             LDR      R1,[R4, #+0]
   \   0000010C   0x2020             MOVS     R0,#+32
   3266                  
   3267                  /* Clear Configuration Register 2 */
   3268                  I2C_RESET_CR2(hi2c);
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000112   0x61C8             STR      R0,[R1, #+28]
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6841             LDR      R1,[R0, #+4]
   \   00000118   0x4011             ANDS     R1,R2,R1
   \   0000011A   0x6041             STR      R1,[R0, #+4]
   3269                  
   3270                  hi2c->XferCount = 0;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x8560             STRH     R0,[R4, #+42]
   3271                  
   3272                  hi2c->State = HAL_I2C_STATE_READY;
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0x7068             STRB     R0,[R5, #+1]
   3273                  HAL_I2C_ErrorCallback(hi2c);
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0xE026             B.N      ??I2C_DMAMasterTransmitCplt_5
   3274                }
   3275                else
   3276                {
   3277                  /* Enable DMA Request */
   3278                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??I2C_DMAMasterTransmitCplt_8: (+1)
   \   00000128   0x....             B.N      ?Subroutine16
   3279                }
   3280              }
   3281            }
   3282            else
   3283            {
   3284              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3285              /* Wait until STOPF flag is reset */ 
   3286              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??I2C_DMAMasterTransmitCplt_0: (+1)
   \   0000012A   0x2119             MOVS     R1,#+25
   \   0000012C   0x4620             MOV      R0,R4
   \   0000012E   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000132   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000136   0xB140             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_10
   3287              {
   3288                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000138   0x6868             LDR      R0,[R5, #+4]
   \   0000013A   0x2804             CMP      R0,#+4
   \   0000013C   0x6868             LDR      R0,[R5, #+4]
   \   0000013E   0xBF0C             ITE      EQ 
   \   00000140   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000144   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3289                {
   3290                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3291                }
   3292                else
   3293                {
   3294                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000148   0x6068             STR      R0,[R5, #+4]
   3295                }
   3296              }
   3297              
   3298              /* Clear STOP Flag */
   3299              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterTransmitCplt_10: (+1)
   \   0000014A   0x6821             LDR      R1,[R4, #+0]
   \   0000014C   0x2020             MOVS     R0,#+32
   3300            	
   3301              /* Clear Configuration Register 2 */
   3302              I2C_RESET_CR2(hi2c);
   \   0000014E   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000152   0x61C8             STR      R0,[R1, #+28]
   \   00000154   0x6820             LDR      R0,[R4, #+0]
   \   00000156   0x6841             LDR      R1,[R0, #+4]
   \   00000158   0x4011             ANDS     R1,R2,R1
   \   0000015A   0x6041             STR      R1,[R0, #+4]
   3303              
   3304              /* Disable DMA Request */
   3305              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \   0000015C   0x6820             LDR      R0,[R4, #+0]
   \   0000015E   0x6801             LDR      R1,[R0, #+0]
   \   00000160   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000164   0x6001             STR      R1,[R0, #+0]
   3306              
   3307              hi2c->XferCount = 0;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x8560             STRH     R0,[R4, #+42]
   3308              
   3309              hi2c->State = HAL_I2C_STATE_READY;
   \   0000016A   0x2001             MOVS     R0,#+1
   \   0000016C   0x7068             STRB     R0,[R5, #+1]
   3310              
   3311              /* Check if Errors has been detected during transfer */
   3312              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000016E   0x6868             LDR      R0,[R5, #+4]
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0x4620             MOV      R0,R4
   \   00000174   0xD000             BEQ.N    ??I2C_DMAMasterTransmitCplt_11
   3313              {
   3314                HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_DMAMasterTransmitCplt_5: (+1)
   \   00000176   0x....             B.N      ?Subroutine18
   3315              }
   3316              else
   3317              {
   3318                HAL_I2C_MasterTxCpltCallback(hi2c);
   \                     ??I2C_DMAMasterTransmitCplt_11: (+1)
   \   00000178   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   3319              }
   3320            }
   3321          }
   \   0000017C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \   00000000   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000004   0xBD73             POP      {R0,R1,R4-R6,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0xBD73             POP      {R0,R1,R4-R6,PC}
   3322          
   3323          /**
   3324            * @brief  DMA I2C slave transmit process complete callback. 
   3325            * @param  hdma: DMA handle
   3326            * @retval None
   3327            */

   \                                 In section .text, align 2, keep-with-next
   3328          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma) 
   3329          {
   \                     I2C_DMASlaveTransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   3330            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   3331            
   3332            /* Wait until STOP flag is set */
   3333            if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000004   0x2119             MOVS     R1,#+25
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000000C   0xB148             CBZ.N    R0,??I2C_DMASlaveTransmitCplt_0
   3334            {
   3335              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000000E   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x2904             CMP      R1,#+4
   \   00000016   0xBF0E             ITEE     EQ 
   \   00000018   0x2100             MOVEQ    R1,#+0
   \   0000001A   0x6841             LDRNE    R1,[R0, #+4]
   \   0000001C   0xF041 0x0120      ORRNE    R1,R1,#0x20
   3336              {
   3337                /* Normal Use case, a AF is generated by master */
   3338                /* to inform slave the end of transfer */
   3339                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3340              }
   3341              else
   3342              {
   3343                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000020   0x6041             STR      R1,[R0, #+4]
   3344              }
   3345            }
   3346            
   3347            /* Clear STOP flag */
   3348            __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
   \                     ??I2C_DMASlaveTransmitCplt_0: (+1)
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x2020             MOVS     R0,#+32
   \   00000026   0x61C8             STR      R0,[R1, #+28]
   3349            
   3350            /* Wait until BUSY flag is reset */ 
   3351            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \   00000028   0x.... 0x....      BL       HAL_GetTick
   \   0000002C   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveTransmitCplt_1: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x6980             LDR      R0,[R0, #+24]
   \   00000032   0x0400             LSLS     R0,R0,#+16
   \   00000034   0xD50E             BPL.N    ??I2C_DMASlaveTransmitCplt_2
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0x1B40             SUBS     R0,R0,R5
   \   0000003C   0x281A             CMP      R0,#+26
   \   0000003E   0xD3F6             BCC.N    ??I2C_DMASlaveTransmitCplt_1
   \   00000040   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x7041             STRB     R1,[R0, #+1]
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
   3352            {
   3353              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000004C   0x6841             LDR      R1,[R0, #+4]
   \   0000004E   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000052   0x6041             STR      R1,[R0, #+4]
   3354            }
   3355            
   3356            /* Disable DMA Request */
   3357            hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMASlaveTransmitCplt_2: (+1)
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6801             LDR      R1,[R0, #+0]
   \   00000058   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000005C   0x6001             STR      R1,[R0, #+0]
   3358            
   3359            hi2c->XferCount = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x8560             STRH     R0,[R4, #+42]
   3360            
   3361            hi2c->State = HAL_I2C_STATE_READY;
   \   00000062   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x7041             STRB     R1,[R0, #+1]
   3362            
   3363            /* Check if Errors has been detected during transfer */
   3364            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000006A   0x6840             LDR      R0,[R0, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0xD000             BEQ.N    ??I2C_DMASlaveTransmitCplt_3
   3365            {
   3366              HAL_I2C_ErrorCallback(hi2c);
   \   00000072   0x....             B.N      ?Subroutine19
   3367            }
   3368            else
   3369            {
   3370              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \                     ??I2C_DMASlaveTransmitCplt_3: (+1)
   \   00000074   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   3371            }
   3372          }
   \   00000078   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \   00000000   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000004   0xBD31             POP      {R0,R4,R5,PC}
   3373          
   3374          /**
   3375            * @brief DMA I2C master receive process complete callback 
   3376            * @param  hdma: DMA handle
   3377            * @retval None
   3378            */

   \                                 In section .text, align 2, keep-with-next
   3379          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma) 
   3380          {
   \                     I2C_DMAMasterReceiveCplt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   3381            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3382            uint16_t DevAddress;
   3383            
   3384            /* Check if last DMA request was done with RELOAD */
   3385            /* Set NBYTES to write and reload if size > 255 */
   3386            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x809F      BNE.W    ??I2C_DMAMasterReceiveCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x809B      BCS.W    ??I2C_DMAMasterReceiveCplt_0
   3387            {
   3388              /* Wait until TCR flag is set */
   3389              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMasterReceiveCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMasterReceiveCplt_1
   \   0000002E   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7068             STRB     R0,[R5, #+1]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7028             STRB     R0,[R5, #+0]
   3390              {
   3391                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6868             LDR      R0,[R5, #+4]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x6068             STR      R0,[R5, #+4]
   3392              }
   3393              
   3394              /* Disable DMA Request */
   3395              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMAMasterReceiveCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   3396              
   3397              /* Check if Errors has been detected during transfer */
   3398              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000044   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   \   00000050   0x6868             LDR      R0,[R5, #+4]
   \   00000052   0xB1E0             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_3
   3399              {
   3400                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3401                /* Wait until STOPF flag is reset */ 
   3402                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000054   0x2119             MOVS     R1,#+25
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000005C   0xB140             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_4
   3403                {
   3404                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000005E   0x6868             LDR      R0,[R5, #+4]
   \   00000060   0x2804             CMP      R0,#+4
   \   00000062   0x6868             LDR      R0,[R5, #+4]
   \   00000064   0xBF0C             ITE      EQ 
   \   00000066   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000006A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3405                  {
   3406                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3407                  }
   3408                  else
   3409                  {
   3410                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000006E   0x6068             STR      R0,[R5, #+4]
   3411                  }
   3412                }
   3413                
   3414                /* Clear STOP Flag */
   3415                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterReceiveCplt_4: (+1)
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x2020             MOVS     R0,#+32
   3416                
   3417                /* Clear Configuration Register 2 */
   3418                I2C_RESET_CR2(hi2c);
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000078   0x61C8             STR      R0,[R1, #+28]
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6841             LDR      R1,[R0, #+4]
   \   0000007E   0x4011             ANDS     R1,R2,R1
   \   00000080   0x6041             STR      R1,[R0, #+4]
   3419                
   3420                hi2c->XferCount = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x8560             STRH     R0,[R4, #+42]
   3421                
   3422                hi2c->State = HAL_I2C_STATE_READY;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x7068             STRB     R0,[R5, #+1]
   3423                HAL_I2C_ErrorCallback(hi2c);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0xE084             B.N      ??I2C_DMAMasterReceiveCplt_5
   3424              }
   3425              else
   3426              {
   3427                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMasterReceiveCplt_3: (+1)
   \   0000008E   0x8D20             LDRH     R0,[R4, #+40]
   \   00000090   0x6A61             LDR      R1,[R4, #+36]
   \   00000092   0x1842             ADDS     R2,R0,R1
   \   00000094   0x6262             STR      R2,[R4, #+36]
   3428                hi2c->XferCount -= hi2c->XferSize;
   \   00000096   0x8D61             LDRH     R1,[R4, #+42]
   \   00000098   0x1A08             SUBS     R0,R1,R0
   \   0000009A   0x8560             STRH     R0,[R4, #+42]
   3429                if(hi2c->XferCount > 255)
   \   0000009C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000009E   0x28FF             CMP      R0,#+255
   \   000000A0   0xBFCC             ITE      GT 
   \   000000A2   0x20FF             MOVGT    R0,#+255
   \   000000A4   0x8D60             LDRHLE   R0,[R4, #+42]
   3430                {
   3431                  hi2c->XferSize = 255;
   3432                }
   3433                else
   3434                {
   3435                  hi2c->XferSize = hi2c->XferCount;
   \   000000A6   0x8520             STRH     R0,[R4, #+40]
   3436                }
   3437                
   3438                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6841             LDR      R1,[R0, #+4]
   3439                
   3440                /* Enable the DMA channel */
   3441                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000AC   0x8D23             LDRH     R3,[R4, #+40]
   \   000000AE   0x058E             LSLS     R6,R1,#+22
   \   000000B0   0xF100 0x0124      ADD      R1,R0,#+36
   \   000000B4   0x6B20             LDR      R0,[R4, #+48]
   \   000000B6   0x0DB6             LSRS     R6,R6,#+22
   \   000000B8   0x.... 0x....      BL       HAL_DMA_Start_IT
   3442                
   3443                /* Send Slave Address */
   3444                /* Set NBYTES to write and reload if size > 255 */
   3445                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000BC   0x8D22             LDRH     R2,[R4, #+40]
   \   000000BE   0x2AFF             CMP      R2,#+255
   \   000000C0   0xD107             BNE.N    ??I2C_DMAMasterReceiveCplt_6
   \   000000C2   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C4   0x4282             CMP      R2,R0
   \   000000C6   0xD204             BCS.N    ??I2C_DMAMasterReceiveCplt_6
   3446                {
   3447                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF04F 0x7380      MOV      R3,#+16777216
   \   000000CE   0x9000             STR      R0,[SP, #+0]
   \   000000D0   0xE004             B.N      ??I2C_DMAMasterReceiveCplt_7
   3448                }
   3449                else
   3450                {
   3451                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMasterReceiveCplt_6: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF04F 0x7300      MOV      R3,#+33554432
   \   000000D8   0x9000             STR      R0,[SP, #+0]
   \   000000DA   0xB2D2             UXTB     R2,R2
   \                     ??I2C_DMAMasterReceiveCplt_7: (+1)
   \   000000DC   0x4631             MOV      R1,R6
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       I2C_TransferConfig
   3452                }  
   3453                
   3454                /* Wait until RXNE flag is set */
   3455                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   000000E4   0x.... 0x....      BL       HAL_GetTick
   \   000000E8   0x4606             MOV      R6,R0
   \                     ??I2C_DMAMasterReceiveCplt_8: (+1)
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6980             LDR      R0,[R0, #+24]
   \   000000EE   0x0740             LSLS     R0,R0,#+29
   \   000000F0   0xD40C             BMI.N    ??I2C_DMAMasterReceiveCplt_9
   \   000000F2   0x.... 0x....      BL       HAL_GetTick
   \   000000F6   0x1B80             SUBS     R0,R0,R6
   \   000000F8   0x281A             CMP      R0,#+26
   \   000000FA   0xD3F6             BCC.N    ??I2C_DMAMasterReceiveCplt_8
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0x7068             STRB     R0,[R5, #+1]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x7028             STRB     R0,[R5, #+0]
   3456                {
   3457                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000104   0x6868             LDR      R0,[R5, #+4]
   \   00000106   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010A   0x6068             STR      R0,[R5, #+4]
   3458                }
   3459                
   3460                /* Check if Errors has been detected during transfer */
   3461                if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??I2C_DMAMasterReceiveCplt_9: (+1)
   \   0000010C   0x6868             LDR      R0,[R5, #+4]
   \   0000010E   0xB1E0             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_10
   3462                {
   3463                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3464                  /* Wait until STOPF flag is reset */ 
   3465                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000110   0x2119             MOVS     R1,#+25
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000118   0xB140             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_11
   3466                  {
   3467                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000011A   0x6868             LDR      R0,[R5, #+4]
   \   0000011C   0x2804             CMP      R0,#+4
   \   0000011E   0x6868             LDR      R0,[R5, #+4]
   \   00000120   0xBF0C             ITE      EQ 
   \   00000122   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000126   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3468                    {
   3469                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3470                    }
   3471                    else
   3472                    {
   3473                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000012A   0x6068             STR      R0,[R5, #+4]
   3474                    }
   3475                  }
   3476                  
   3477                  /* Clear STOP Flag */
   3478                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterReceiveCplt_11: (+1)
   \   0000012C   0x6821             LDR      R1,[R4, #+0]
   \   0000012E   0x2020             MOVS     R0,#+32
   3479                  
   3480                  /* Clear Configuration Register 2 */
   3481                  I2C_RESET_CR2(hi2c);
   \   00000130   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000134   0x61C8             STR      R0,[R1, #+28]
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x6841             LDR      R1,[R0, #+4]
   \   0000013A   0x4011             ANDS     R1,R2,R1
   \   0000013C   0x6041             STR      R1,[R0, #+4]
   3482                  
   3483                  hi2c->XferCount = 0;
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x8560             STRH     R0,[R4, #+42]
   3484                  
   3485                  hi2c->State = HAL_I2C_STATE_READY;
   \   00000142   0x2001             MOVS     R0,#+1
   \   00000144   0x7068             STRB     R0,[R5, #+1]
   3486                  
   3487                  HAL_I2C_ErrorCallback(hi2c);
   \   00000146   0x4620             MOV      R0,R4
   \   00000148   0xE026             B.N      ??I2C_DMAMasterReceiveCplt_5
   3488                }
   3489                else
   3490                {
   3491                  /* Enable DMA Request */
   3492                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??I2C_DMAMasterReceiveCplt_10: (+1)
   \   0000014A   0x....             B.N      ?Subroutine17
   3493                }
   3494              }
   3495            }
   3496            else
   3497            {
   3498              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3499              /* Wait until STOPF flag is reset */ 
   3500              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??I2C_DMAMasterReceiveCplt_0: (+1)
   \   0000014C   0x2119             MOVS     R1,#+25
   \   0000014E   0x4620             MOV      R0,R4
   \   00000150   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000154   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000158   0xB140             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_12
   3501              {
   3502                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000015A   0x6868             LDR      R0,[R5, #+4]
   \   0000015C   0x2804             CMP      R0,#+4
   \   0000015E   0x6868             LDR      R0,[R5, #+4]
   \   00000160   0xBF0C             ITE      EQ 
   \   00000162   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000166   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3503                {
   3504                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3505                }
   3506                else
   3507                {
   3508                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000016A   0x6068             STR      R0,[R5, #+4]
   3509                }
   3510              }
   3511              
   3512              /* Clear STOP Flag */
   3513              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterReceiveCplt_12: (+1)
   \   0000016C   0x6821             LDR      R1,[R4, #+0]
   \   0000016E   0x2020             MOVS     R0,#+32
   3514            	
   3515              /* Clear Configuration Register 2 */
   3516              I2C_RESET_CR2(hi2c);
   \   00000170   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000174   0x61C8             STR      R0,[R1, #+28]
   \   00000176   0x6820             LDR      R0,[R4, #+0]
   \   00000178   0x6841             LDR      R1,[R0, #+4]
   \   0000017A   0x4011             ANDS     R1,R2,R1
   \   0000017C   0x6041             STR      R1,[R0, #+4]
   3517              
   3518              /* Disable DMA Request */
   3519              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \   0000017E   0x6820             LDR      R0,[R4, #+0]
   \   00000180   0x6801             LDR      R1,[R0, #+0]
   \   00000182   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000186   0x6001             STR      R1,[R0, #+0]
   3520              
   3521              hi2c->XferCount = 0;
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x8560             STRH     R0,[R4, #+42]
   3522              
   3523              hi2c->State = HAL_I2C_STATE_READY;
   \   0000018C   0x2001             MOVS     R0,#+1
   \   0000018E   0x7068             STRB     R0,[R5, #+1]
   3524              
   3525              /* Check if Errors has been detected during transfer */
   3526              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000190   0x6868             LDR      R0,[R5, #+4]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0x4620             MOV      R0,R4
   \   00000196   0xD000             BEQ.N    ??I2C_DMAMasterReceiveCplt_13
   3527              {
   3528                HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_DMAMasterReceiveCplt_5: (+1)
   \   00000198   0x....             B.N      ?Subroutine18
   3529              }
   3530              else
   3531              {
   3532                HAL_I2C_MasterRxCpltCallback(hi2c);
   \                     ??I2C_DMAMasterReceiveCplt_13: (+1)
   \   0000019A   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   3533              }
   3534            }
   3535          }
   \   0000019E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \   00000000   0x6820             LDR      R0,[R4, #+0]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000008   0x6001             STR      R1,[R0, #+0]
   \   0000000A   0xBD73             POP      {R0,R1,R4-R6,PC}
   3536          
   3537          /**
   3538            * @brief  DMA I2C slave receive process complete callback.
   3539            * @param  hdma: DMA handle
   3540            * @retval None
   3541            */

   \                                 In section .text, align 2, keep-with-next
   3542          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma) 
   3543          {  
   \                     I2C_DMASlaveReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   3544            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   3545            
   3546            /* Wait until STOPF flag is reset */ 
   3547            if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000004   0x2119             MOVS     R1,#+25
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000000C   0xB150             CBZ.N    R0,??I2C_DMASlaveReceiveCplt_0
   3548            {
   3549              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000000E   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x2904             CMP      R1,#+4
   \   00000016   0x6841             LDR      R1,[R0, #+4]
   \   00000018   0xBF0C             ITE      EQ 
   \   0000001A   0xF041 0x0104      ORREQ    R1,R1,#0x4
   \   0000001E   0xF041 0x0120      ORRNE    R1,R1,#0x20
   3550              {
   3551                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3552              }
   3553              else
   3554              {
   3555                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000022   0x6041             STR      R1,[R0, #+4]
   3556              }
   3557            }
   3558            
   3559            /* Clear STOPF flag */
   3560            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMASlaveReceiveCplt_0: (+1)
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x2020             MOVS     R0,#+32
   \   00000028   0x61C8             STR      R0,[R1, #+28]
   3561            
   3562            /* Wait until BUSY flag is reset */ 
   3563            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveReceiveCplt_1: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6980             LDR      R0,[R0, #+24]
   \   00000034   0x0400             LSLS     R0,R0,#+16
   \   00000036   0xD50E             BPL.N    ??I2C_DMASlaveReceiveCplt_2
   \   00000038   0x.... 0x....      BL       HAL_GetTick
   \   0000003C   0x1B40             SUBS     R0,R0,R5
   \   0000003E   0x281A             CMP      R0,#+26
   \   00000040   0xD3F6             BCC.N    ??I2C_DMASlaveReceiveCplt_1
   \   00000042   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000046   0x2101             MOVS     R1,#+1
   \   00000048   0x7041             STRB     R1,[R0, #+1]
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x7001             STRB     R1,[R0, #+0]
   3564            {
   3565              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000054   0x6041             STR      R1,[R0, #+4]
   3566            }
   3567            
   3568            /* Disable DMA Request */
   3569            hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMASlaveReceiveCplt_2: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000005E   0x6001             STR      R1,[R0, #+0]
   3570            
   3571            /* Disable Address Acknowledge */
   3572            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x6841             LDR      R1,[R0, #+4]
   \   00000064   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000068   0x6041             STR      R1,[R0, #+4]
   3573            
   3574            hi2c->XferCount = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x8560             STRH     R0,[R4, #+42]
   3575            
   3576            hi2c->State = HAL_I2C_STATE_READY;
   \   0000006E   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000072   0x2101             MOVS     R1,#+1
   \   00000074   0x7041             STRB     R1,[R0, #+1]
   3577            
   3578            /* Check if Errors has been detected during transfer */
   3579            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000076   0x6840             LDR      R0,[R0, #+4]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0xD000             BEQ.N    ??I2C_DMASlaveReceiveCplt_3
   3580            {
   3581              HAL_I2C_ErrorCallback(hi2c);
   \   0000007E   0x....             B.N      ?Subroutine19
   3582            }
   3583            else
   3584            {
   3585              HAL_I2C_SlaveRxCpltCallback(hi2c);
   \                     ??I2C_DMASlaveReceiveCplt_3: (+1)
   \   00000080   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   3586            }
   3587          }
   \   00000084   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3588          
   3589          /**
   3590            * @brief DMA I2C Memory Write process complete callback 
   3591            * @param hdma : DMA handle
   3592            * @retval None
   3593            */

   \                                 In section .text, align 4, keep-with-next
   3594          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma)   
   3595          {
   \                     I2C_DMAMemTransmitCplt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   3596            uint16_t DevAddress;
   3597            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3598            
   3599            /* Check if last DMA request was done with RELOAD */
   3600            /* Set NBYTES to write and reload if size > 255 */
   3601            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x808E      BNE.W    ??I2C_DMAMemTransmitCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x808A      BCS.W    ??I2C_DMAMemTransmitCplt_0
   3602            {
   3603              /* Wait until TCR flag is set */
   3604              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMemTransmitCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMemTransmitCplt_1
   \   0000002E   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7068             STRB     R0,[R5, #+1]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7028             STRB     R0,[R5, #+0]
   3605              {
   3606                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6868             LDR      R0,[R5, #+4]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x6068             STR      R0,[R5, #+4]
   3607              }
   3608              
   3609              /* Disable DMA Request */
   3610              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMAMemTransmitCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   3611              
   3612              /* Check if Errors has been detected during transfer */
   3613              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000044   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   \   00000050   0x6868             LDR      R0,[R5, #+4]
   \   00000052   0xB1E0             CBZ.N    R0,??I2C_DMAMemTransmitCplt_3
   3614              {
   3615                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3616                /* Wait until STOPF flag is reset */ 
   3617                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000054   0x2119             MOVS     R1,#+25
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000005C   0xB140             CBZ.N    R0,??I2C_DMAMemTransmitCplt_4
   3618                {
   3619                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000005E   0x6868             LDR      R0,[R5, #+4]
   \   00000060   0x2804             CMP      R0,#+4
   \   00000062   0x6868             LDR      R0,[R5, #+4]
   \   00000064   0xBF0C             ITE      EQ 
   \   00000066   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000006A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3620                  {
   3621                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3622                  }
   3623                  else
   3624                  {
   3625                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000006E   0x6068             STR      R0,[R5, #+4]
   3626                  }
   3627                }
   3628                
   3629                /* Clear STOP Flag */
   3630                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemTransmitCplt_4: (+1)
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x2020             MOVS     R0,#+32
   3631                
   3632                /* Clear Configuration Register 2 */
   3633                I2C_RESET_CR2(hi2c);
   \   00000074   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000078   0x61C8             STR      R0,[R1, #+28]
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6841             LDR      R1,[R0, #+4]
   \   0000007E   0x4011             ANDS     R1,R2,R1
   \   00000080   0x6041             STR      R1,[R0, #+4]
   3634                
   3635                hi2c->XferCount = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x8560             STRH     R0,[R4, #+42]
   3636                
   3637                hi2c->State = HAL_I2C_STATE_READY;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0x7068             STRB     R0,[R5, #+1]
   3638                HAL_I2C_ErrorCallback(hi2c);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0xE073             B.N      ??I2C_DMAMemTransmitCplt_5
   3639              }
   3640              else
   3641              {
   3642                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMemTransmitCplt_3: (+1)
   \   0000008E   0x8D20             LDRH     R0,[R4, #+40]
   \   00000090   0x6A61             LDR      R1,[R4, #+36]
   \   00000092   0x1841             ADDS     R1,R0,R1
   \   00000094   0x6261             STR      R1,[R4, #+36]
   3643                hi2c->XferCount -= hi2c->XferSize;
   \   00000096   0x8D62             LDRH     R2,[R4, #+42]
   \   00000098   0x1A10             SUBS     R0,R2,R0
   \   0000009A   0x8560             STRH     R0,[R4, #+42]
   3644                if(hi2c->XferCount > 255)
   \   0000009C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000009E   0x28FF             CMP      R0,#+255
   \   000000A0   0xBFCC             ITE      GT 
   \   000000A2   0x20FF             MOVGT    R0,#+255
   \   000000A4   0x8D60             LDRHLE   R0,[R4, #+42]
   3645                {
   3646                  hi2c->XferSize = 255;
   3647                }
   3648                else
   3649                {
   3650                  hi2c->XferSize = hi2c->XferCount;
   \   000000A6   0x8520             STRH     R0,[R4, #+40]
   3651                }
   3652                
   3653                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6842             LDR      R2,[R0, #+4]
   3654                
   3655                /* Enable the DMA channel */
   3656                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   000000AC   0x8D23             LDRH     R3,[R4, #+40]
   \   000000AE   0x0596             LSLS     R6,R2,#+22
   \   000000B0   0xF100 0x0228      ADD      R2,R0,#+40
   \   000000B4   0x6AE0             LDR      R0,[R4, #+44]
   \   000000B6   0x0DB6             LSRS     R6,R6,#+22
   \   000000B8   0x.... 0x....      BL       HAL_DMA_Start_IT
   3657                
   3658                /* Send Slave Address */
   3659                /* Set NBYTES to write and reload if size > 255 */
   3660                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000BC   0x8D22             LDRH     R2,[R4, #+40]
   \   000000BE   0x2AFF             CMP      R2,#+255
   \   000000C0   0xD107             BNE.N    ??I2C_DMAMemTransmitCplt_6
   \   000000C2   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C4   0x4282             CMP      R2,R0
   \   000000C6   0xD204             BCS.N    ??I2C_DMAMemTransmitCplt_6
   3661                {
   3662                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF04F 0x7380      MOV      R3,#+16777216
   \   000000CE   0x9000             STR      R0,[SP, #+0]
   \   000000D0   0xE004             B.N      ??I2C_DMAMemTransmitCplt_7
   3663                }
   3664                else
   3665                {
   3666                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMemTransmitCplt_6: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF04F 0x7300      MOV      R3,#+33554432
   \   000000D8   0x9000             STR      R0,[SP, #+0]
   \   000000DA   0xB2D2             UXTB     R2,R2
   \                     ??I2C_DMAMemTransmitCplt_7: (+1)
   \   000000DC   0x4631             MOV      R1,R6
   \   000000DE   0x4620             MOV      R0,R4
   \   000000E0   0x.... 0x....      BL       I2C_TransferConfig
   3667                }  
   3668                
   3669                /* Wait until TXIS flag is set */
   3670                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   000000E4   0x2119             MOVS     R1,#+25
   \   000000E6   0x4620             MOV      R0,R4
   \   000000E8   0x.... 0x....      BL       I2C_WaitOnTXISFlagUntilTimeout
   \   000000EC   0xB1E0             CBZ.N    R0,??I2C_DMAMemTransmitCplt_8
   3671                {
   3672                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3673                  /* Wait until STOPF flag is reset */ 
   3674                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   000000EE   0x2119             MOVS     R1,#+25
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   000000F6   0xB140             CBZ.N    R0,??I2C_DMAMemTransmitCplt_9
   3675                  {
   3676                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000F8   0x6868             LDR      R0,[R5, #+4]
   \   000000FA   0x2804             CMP      R0,#+4
   \   000000FC   0x6868             LDR      R0,[R5, #+4]
   \   000000FE   0xBF0C             ITE      EQ 
   \   00000100   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000104   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3677                    {
   3678                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3679                    }
   3680                    else
   3681                    {
   3682                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000108   0x6068             STR      R0,[R5, #+4]
   3683                    }
   3684                  }
   3685                  
   3686                  /* Clear STOP Flag */
   3687                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemTransmitCplt_9: (+1)
   \   0000010A   0x6821             LDR      R1,[R4, #+0]
   \   0000010C   0x2020             MOVS     R0,#+32
   3688                  
   3689                  /* Clear Configuration Register 2 */
   3690                  I2C_RESET_CR2(hi2c);
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000112   0x61C8             STR      R0,[R1, #+28]
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6841             LDR      R1,[R0, #+4]
   \   00000118   0x4011             ANDS     R1,R2,R1
   \   0000011A   0x6041             STR      R1,[R0, #+4]
   3691                  
   3692                  hi2c->XferCount = 0;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x8560             STRH     R0,[R4, #+42]
   3693                  
   3694                  hi2c->State = HAL_I2C_STATE_READY;
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0x7068             STRB     R0,[R5, #+1]
   3695                  HAL_I2C_ErrorCallback(hi2c);
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0xE026             B.N      ??I2C_DMAMemTransmitCplt_5
   3696                }
   3697                else
   3698                {
   3699                  /* Enable DMA Request */
   3700                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??I2C_DMAMemTransmitCplt_8: (+1)
   \   00000128   0x....             B.N      ?Subroutine16
   3701                }
   3702              }
   3703            }
   3704            else
   3705            {
   3706              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3707              /* Wait until STOPF flag is reset */ 
   3708              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??I2C_DMAMemTransmitCplt_0: (+1)
   \   0000012A   0x2119             MOVS     R1,#+25
   \   0000012C   0x4620             MOV      R0,R4
   \   0000012E   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000132   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000136   0xB140             CBZ.N    R0,??I2C_DMAMemTransmitCplt_10
   3709              {
   3710                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000138   0x6868             LDR      R0,[R5, #+4]
   \   0000013A   0x2804             CMP      R0,#+4
   \   0000013C   0x6868             LDR      R0,[R5, #+4]
   \   0000013E   0xBF0C             ITE      EQ 
   \   00000140   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000144   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3711                {
   3712                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3713                }
   3714                else
   3715                {
   3716                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000148   0x6068             STR      R0,[R5, #+4]
   3717                }
   3718              }
   3719              
   3720              /* Clear STOP Flag */
   3721              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemTransmitCplt_10: (+1)
   \   0000014A   0x6821             LDR      R1,[R4, #+0]
   \   0000014C   0x2020             MOVS     R0,#+32
   3722            	
   3723              /* Clear Configuration Register 2 */
   3724              I2C_RESET_CR2(hi2c);
   \   0000014E   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000152   0x61C8             STR      R0,[R1, #+28]
   \   00000154   0x6820             LDR      R0,[R4, #+0]
   \   00000156   0x6841             LDR      R1,[R0, #+4]
   \   00000158   0x4011             ANDS     R1,R2,R1
   \   0000015A   0x6041             STR      R1,[R0, #+4]
   3725              
   3726              /* Disable DMA Request */
   3727              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \   0000015C   0x6820             LDR      R0,[R4, #+0]
   \   0000015E   0x6801             LDR      R1,[R0, #+0]
   \   00000160   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000164   0x6001             STR      R1,[R0, #+0]
   3728              
   3729              hi2c->XferCount = 0;
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0x8560             STRH     R0,[R4, #+42]
   3730              
   3731              hi2c->State = HAL_I2C_STATE_READY;
   \   0000016A   0x2001             MOVS     R0,#+1
   \   0000016C   0x7068             STRB     R0,[R5, #+1]
   3732              
   3733              /* Check if Errors has been detected during transfer */
   3734              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000016E   0x6868             LDR      R0,[R5, #+4]
   \   00000170   0x2800             CMP      R0,#+0
   \   00000172   0x4620             MOV      R0,R4
   \   00000174   0xD000             BEQ.N    ??I2C_DMAMemTransmitCplt_11
   3735              {
   3736                HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_DMAMemTransmitCplt_5: (+1)
   \   00000176   0x....             B.N      ?Subroutine18
   3737              }
   3738              else
   3739              {
   3740                HAL_I2C_MemTxCpltCallback(hi2c);
   \                     ??I2C_DMAMemTransmitCplt_11: (+1)
   \   00000178   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   3741              }
   3742            }
   3743          }
   \   0000017C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   3744          
   3745          /**
   3746            * @brief  DMA I2C Memory Read process complete callback
   3747            * @param  hdma: DMA handle
   3748            * @retval None
   3749            */

   \                                 In section .text, align 2, keep-with-next
   3750          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma)   
   3751          {  
   \                     I2C_DMAMemReceiveCplt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   3752            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3753            uint16_t DevAddress;
   3754            
   3755            /* Check if last DMA request was done with RELOAD */
   3756            /* Set NBYTES to write and reload if size > 255 */
   3757            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x809D      BNE.W    ??I2C_DMAMemReceiveCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x8099      BCS.W    ??I2C_DMAMemReceiveCplt_0
   3758            {
   3759              /* Wait until TCR flag is set */
   3760              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMemReceiveCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMemReceiveCplt_1
   \   0000002E   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7068             STRB     R0,[R5, #+1]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7028             STRB     R0,[R5, #+0]
   3761              {
   3762                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6868             LDR      R0,[R5, #+4]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x6068             STR      R0,[R5, #+4]
   3763              }
   3764              
   3765              /* Disable DMA Request */
   3766              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMAMemReceiveCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   3767              
   3768              /* Check if Errors has been detected during transfer */
   3769              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000044   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   \   00000050   0x6868             LDR      R0,[R5, #+4]
   \   00000052   0xB1D8             CBZ.N    R0,??I2C_DMAMemReceiveCplt_3
   3770              {
   3771                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3772                /* Wait until STOPF flag is reset */ 
   3773                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000054   0x2119             MOVS     R1,#+25
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   0000005C   0xB140             CBZ.N    R0,??I2C_DMAMemReceiveCplt_4
   3774                {
   3775                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   0000005E   0x6868             LDR      R0,[R5, #+4]
   \   00000060   0x2804             CMP      R0,#+4
   \   00000062   0x6868             LDR      R0,[R5, #+4]
   \   00000064   0xBF0C             ITE      EQ 
   \   00000066   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000006A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3776                  {
   3777                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3778                  }
   3779                  else
   3780                  {
   3781                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000006E   0x6068             STR      R0,[R5, #+4]
   3782                  }
   3783                }
   3784                
   3785                /* Clear STOP Flag */
   3786                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemReceiveCplt_4: (+1)
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x2020             MOVS     R0,#+32
   3787                
   3788                /* Clear Configuration Register 2 */
   3789                I2C_RESET_CR2(hi2c);
   \   00000074   0x....             LDR.N    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000076   0x61C8             STR      R0,[R1, #+28]
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6841             LDR      R1,[R0, #+4]
   \   0000007C   0x4011             ANDS     R1,R2,R1
   \   0000007E   0x6041             STR      R1,[R0, #+4]
   3790                
   3791                hi2c->XferCount = 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x8560             STRH     R0,[R4, #+42]
   3792                
   3793                hi2c->State = HAL_I2C_STATE_READY;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x7068             STRB     R0,[R5, #+1]
   3794                HAL_I2C_ErrorCallback(hi2c);
   \   00000088   0x4620             MOV      R0,R4
   \   0000008A   0xE082             B.N      ??I2C_DMAMemReceiveCplt_5
   3795              }
   3796              else
   3797              {
   3798                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMemReceiveCplt_3: (+1)
   \   0000008C   0x8D20             LDRH     R0,[R4, #+40]
   \   0000008E   0x6A61             LDR      R1,[R4, #+36]
   \   00000090   0x1842             ADDS     R2,R0,R1
   \   00000092   0x6262             STR      R2,[R4, #+36]
   3799                hi2c->XferCount -= hi2c->XferSize;
   \   00000094   0x8D61             LDRH     R1,[R4, #+42]
   \   00000096   0x1A08             SUBS     R0,R1,R0
   \   00000098   0x8560             STRH     R0,[R4, #+42]
   3800                if(hi2c->XferCount > 255)
   \   0000009A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000009C   0x28FF             CMP      R0,#+255
   \   0000009E   0xBFCC             ITE      GT 
   \   000000A0   0x20FF             MOVGT    R0,#+255
   \   000000A2   0x8D60             LDRHLE   R0,[R4, #+42]
   3801                {
   3802                  hi2c->XferSize = 255;
   3803                }
   3804                else
   3805                {
   3806                  hi2c->XferSize = hi2c->XferCount;
   \   000000A4   0x8520             STRH     R0,[R4, #+40]
   3807                }
   3808                
   3809                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6841             LDR      R1,[R0, #+4]
   3810                
   3811                /* Enable the DMA channel */
   3812                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000AA   0x8D23             LDRH     R3,[R4, #+40]
   \   000000AC   0x058E             LSLS     R6,R1,#+22
   \   000000AE   0xF100 0x0124      ADD      R1,R0,#+36
   \   000000B2   0x6B20             LDR      R0,[R4, #+48]
   \   000000B4   0x0DB6             LSRS     R6,R6,#+22
   \   000000B6   0x.... 0x....      BL       HAL_DMA_Start_IT
   3813                
   3814                /* Send Slave Address */
   3815                /* Set NBYTES to write and reload if size > 255 */
   3816                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000BA   0x8D22             LDRH     R2,[R4, #+40]
   \   000000BC   0x2AFF             CMP      R2,#+255
   \   000000BE   0xD107             BNE.N    ??I2C_DMAMemReceiveCplt_6
   \   000000C0   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C2   0x4282             CMP      R2,R0
   \   000000C4   0xD204             BCS.N    ??I2C_DMAMemReceiveCplt_6
   3817                {
   3818                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF04F 0x7380      MOV      R3,#+16777216
   \   000000CC   0x9000             STR      R0,[SP, #+0]
   \   000000CE   0xE004             B.N      ??I2C_DMAMemReceiveCplt_7
   3819                }
   3820                else
   3821                {
   3822                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMemReceiveCplt_6: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xF04F 0x7300      MOV      R3,#+33554432
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0xB2D2             UXTB     R2,R2
   \                     ??I2C_DMAMemReceiveCplt_7: (+1)
   \   000000DA   0x4631             MOV      R1,R6
   \   000000DC   0x4620             MOV      R0,R4
   \   000000DE   0x.... 0x....      BL       I2C_TransferConfig
   3823                }  
   3824                
   3825                /* Wait until RXNE flag is set */
   3826                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   000000E2   0x.... 0x....      BL       HAL_GetTick
   \   000000E6   0x4606             MOV      R6,R0
   \                     ??I2C_DMAMemReceiveCplt_8: (+1)
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6980             LDR      R0,[R0, #+24]
   \   000000EC   0x0740             LSLS     R0,R0,#+29
   \   000000EE   0xD40C             BMI.N    ??I2C_DMAMemReceiveCplt_9
   \   000000F0   0x.... 0x....      BL       HAL_GetTick
   \   000000F4   0x1B80             SUBS     R0,R0,R6
   \   000000F6   0x281A             CMP      R0,#+26
   \   000000F8   0xD3F6             BCC.N    ??I2C_DMAMemReceiveCplt_8
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x7068             STRB     R0,[R5, #+1]
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x7028             STRB     R0,[R5, #+0]
   3827                {
   3828                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000102   0x6868             LDR      R0,[R5, #+4]
   \   00000104   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000108   0x6068             STR      R0,[R5, #+4]
   3829                }
   3830                
   3831                /* Check if Errors has been detected during transfer */
   3832                if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??I2C_DMAMemReceiveCplt_9: (+1)
   \   0000010A   0x6868             LDR      R0,[R5, #+4]
   \   0000010C   0xB1D8             CBZ.N    R0,??I2C_DMAMemReceiveCplt_10
   3833                {
   3834                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3835                  /* Wait until STOPF flag is reset */ 
   3836                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   0000010E   0x2119             MOVS     R1,#+25
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000116   0xB140             CBZ.N    R0,??I2C_DMAMemReceiveCplt_11
   3837                  {
   3838                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000118   0x6868             LDR      R0,[R5, #+4]
   \   0000011A   0x2804             CMP      R0,#+4
   \   0000011C   0x6868             LDR      R0,[R5, #+4]
   \   0000011E   0xBF0C             ITE      EQ 
   \   00000120   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000124   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3839                    {
   3840                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3841                    }
   3842                    else
   3843                    {
   3844                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000128   0x6068             STR      R0,[R5, #+4]
   3845                    }
   3846                  }
   3847                  
   3848                  /* Clear STOP Flag */
   3849                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemReceiveCplt_11: (+1)
   \   0000012A   0x6821             LDR      R1,[R4, #+0]
   \   0000012C   0x2020             MOVS     R0,#+32
   3850                  
   3851                  /* Clear Configuration Register 2 */
   3852                  I2C_RESET_CR2(hi2c);
   \   0000012E   0x....             LDR.N    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000130   0x61C8             STR      R0,[R1, #+28]
   \   00000132   0x6820             LDR      R0,[R4, #+0]
   \   00000134   0x6841             LDR      R1,[R0, #+4]
   \   00000136   0x4011             ANDS     R1,R2,R1
   \   00000138   0x6041             STR      R1,[R0, #+4]
   3853                  
   3854                  hi2c->XferCount = 0;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0x8560             STRH     R0,[R4, #+42]
   3855                  
   3856                  hi2c->State = HAL_I2C_STATE_READY;
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0x7068             STRB     R0,[R5, #+1]
   3857                  HAL_I2C_ErrorCallback(hi2c);
   \   00000142   0x4620             MOV      R0,R4
   \   00000144   0xE025             B.N      ??I2C_DMAMemReceiveCplt_5
   3858                }
   3859                else
   3860                {
   3861                  /* Enable DMA Request */
   3862                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??I2C_DMAMemReceiveCplt_10: (+1)
   \   00000146   0x....             B.N      ?Subroutine17
   3863                }
   3864              }
   3865            }
   3866            else
   3867            {
   3868              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3869              /* Wait until STOPF flag is reset */ 
   3870              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??I2C_DMAMemReceiveCplt_0: (+1)
   \   00000148   0x2119             MOVS     R1,#+25
   \   0000014A   0x4620             MOV      R0,R4
   \   0000014C   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \   00000150   0xF104 0x0534      ADD      R5,R4,#+52
   \   00000154   0xB140             CBZ.N    R0,??I2C_DMAMemReceiveCplt_12
   3871              {
   3872                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   00000156   0x6868             LDR      R0,[R5, #+4]
   \   00000158   0x2804             CMP      R0,#+4
   \   0000015A   0x6868             LDR      R0,[R5, #+4]
   \   0000015C   0xBF0C             ITE      EQ 
   \   0000015E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000162   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3873                {
   3874                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3875                }
   3876                else
   3877                {
   3878                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000166   0x6068             STR      R0,[R5, #+4]
   3879                }
   3880              }
   3881              
   3882              /* Clear STOP Flag */
   3883              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemReceiveCplt_12: (+1)
   \   00000168   0x6821             LDR      R1,[R4, #+0]
   \   0000016A   0x2020             MOVS     R0,#+32
   3884            	
   3885              /* Clear Configuration Register 2 */
   3886              I2C_RESET_CR2(hi2c);
   \   0000016C   0x....             LDR.N    R2,??DataTable20_1  ;; 0xfe00e800
   \   0000016E   0x61C8             STR      R0,[R1, #+28]
   \   00000170   0x6820             LDR      R0,[R4, #+0]
   \   00000172   0x6841             LDR      R1,[R0, #+4]
   \   00000174   0x4011             ANDS     R1,R2,R1
   \   00000176   0x6041             STR      R1,[R0, #+4]
   3887              
   3888              /* Disable DMA Request */
   3889              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \   00000178   0x6820             LDR      R0,[R4, #+0]
   \   0000017A   0x6801             LDR      R1,[R0, #+0]
   \   0000017C   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000180   0x6001             STR      R1,[R0, #+0]
   3890              
   3891              hi2c->XferCount = 0;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x8560             STRH     R0,[R4, #+42]
   3892              
   3893              hi2c->State = HAL_I2C_STATE_READY;
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0x7068             STRB     R0,[R5, #+1]
   3894              
   3895              /* Check if Errors has been detected during transfer */
   3896              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000018A   0x6868             LDR      R0,[R5, #+4]
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0x4620             MOV      R0,R4
   \   00000190   0xD000             BEQ.N    ??I2C_DMAMemReceiveCplt_13
   3897              {
   3898                HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_DMAMemReceiveCplt_5: (+1)
   \   00000192   0x....             B.N      ?Subroutine18
   3899              }
   3900              else
   3901              {
   3902                HAL_I2C_MemRxCpltCallback(hi2c);
   \                     ??I2C_DMAMemReceiveCplt_13: (+1)
   \   00000194   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   3903              }
   3904            }
   3905          }
   \   00000198   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   3906          
   3907          /**
   3908            * @brief  DMA I2C communication error callback. 
   3909            * @param hdma : DMA handle
   3910            * @retval None
   3911            */

   \                                 In section .text, align 2, keep-with-next
   3912          static void I2C_DMAError(DMA_HandleTypeDef *hdma)   
   3913          {
   \                     I2C_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3914            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   3915            
   3916            /* Disable Acknowledge */
   3917            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   0000000C   0x604A             STR      R2,[R1, #+4]
   3918            
   3919            hi2c->XferCount = 0;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8541             STRH     R1,[R0, #+42]
   3920            
   3921            hi2c->State = HAL_I2C_STATE_READY;
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF880 0x1035      STRB     R1,[R0, #+53]
   3922            
   3923            hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \   00000018   0x6B81             LDR      R1,[R0, #+56]
   \   0000001A   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000001E   0x6381             STR      R1,[R0, #+56]
   3924            
   3925            HAL_I2C_ErrorCallback(hi2c);
   \   00000020   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3926          }
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
   3927          
   3928          /**
   3929            * @brief  This function handles I2C Communication Timeout.
   3930            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3931            *                the configuration information for the specified I2C.
   3932            * @param  Flag: specifies the I2C flag to check.
   3933            * @param  Status: The new Flag status (SET or RESET).
   3934            * @param  Timeout: Timeout duration
   3935            * @retval HAL status
   3936            */

   \                                 In section .text, align 2, keep-with-next
   3937          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
   3938          {  
   \                     I2C_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461E             MOV      R6,R3
   3939            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
   3940            
   3941            /* Wait until flag is set */
   3942            if(Status == RESET)
   \   00000010   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000014   0x4607             MOV      R7,R0
   \   00000016   0xD112             BNE.N    ??I2C_WaitOnFlagUntilTimeout_0
   3943            {    
   3944              while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??I2C_WaitOnFlagUntilTimeout_1: (+1)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x03E9             LSLS     R1,R5,#+15
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0x4028             ANDS     R0,R0,R5
   \   00000020   0x03C0             LSLS     R0,R0,#+15
   \   00000022   0x0BC0             LSRS     R0,R0,#+15
   \   00000024   0xEBB0 0x3FD1      CMP      R0,R1, LSR #+15
   \   00000028   0xD024             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_2
   3945              {
   3946                /* Check for the Timeout */
   3947                if(Timeout != HAL_MAX_DELAY)
   \   0000002A   0xF116 0x0F01      CMN      R6,#+1
   \   0000002E   0xD0F3             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_1
   3948                {
   3949                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000030   0xB1BE             CBZ.N    R6,??I2C_WaitOnFlagUntilTimeout_3
   \   00000032   0x.... 0x....      BL       HAL_GetTick
   \   00000036   0x1BC0             SUBS     R0,R0,R7
   \   00000038   0x4286             CMP      R6,R0
   \   0000003A   0xD2ED             BCS.N    ??I2C_WaitOnFlagUntilTimeout_1
   \   0000003C   0xE011             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   3950                  {
   3951                    hi2c->State= HAL_I2C_STATE_READY;
   3952                    /* Process Unlocked */
   3953                    __HAL_UNLOCK(hi2c);
   3954                    return HAL_TIMEOUT;
   3955                  }
   3956                }
   3957              }
   3958            }
   3959            else
   3960            {
   3961              while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
   \                     ??I2C_WaitOnFlagUntilTimeout_0: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x03E9             LSLS     R1,R5,#+15
   \   00000042   0x6980             LDR      R0,[R0, #+24]
   \   00000044   0x4028             ANDS     R0,R0,R5
   \   00000046   0x03C0             LSLS     R0,R0,#+15
   \   00000048   0x0BC0             LSRS     R0,R0,#+15
   \   0000004A   0xEBB0 0x3FD1      CMP      R0,R1, LSR #+15
   \   0000004E   0xD111             BNE.N    ??I2C_WaitOnFlagUntilTimeout_2
   3962              {
   3963                /* Check for the Timeout */
   3964                if(Timeout != HAL_MAX_DELAY)
   \   00000050   0xF116 0x0F01      CMN      R6,#+1
   \   00000054   0xD0F3             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_0
   3965                {
   3966                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000056   0xB126             CBZ.N    R6,??I2C_WaitOnFlagUntilTimeout_3
   \   00000058   0x.... 0x....      BL       HAL_GetTick
   \   0000005C   0x1BC0             SUBS     R0,R0,R7
   \   0000005E   0x4286             CMP      R6,R0
   \   00000060   0xD2ED             BCS.N    ??I2C_WaitOnFlagUntilTimeout_0
   3967                  {
   3968                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_WaitOnFlagUntilTimeout_3: (+1)
   \   00000062   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x7041             STRB     R1,[R0, #+1]
   3969                    /* Process Unlocked */
   3970                    __HAL_UNLOCK(hi2c);
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
   3971                    return HAL_TIMEOUT;
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3972                  }
   3973                }
   3974              }
   3975            }
   3976            return HAL_OK;
   \                     ??I2C_WaitOnFlagUntilTimeout_2: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3977          }
   3978          
   3979          /**
   3980            * @brief  This function handles I2C Communication Timeout for specific usage of TXIS flag.
   3981            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3982            *                the configuration information for the specified I2C.
   3983            * @param  Timeout: Timeout duration
   3984            * @retval HAL status
   3985            */

   \                                 In section .text, align 2, keep-with-next
   3986          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
   3987          {  
   \                     I2C_WaitOnTXISFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3988            uint32_t tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   3989            
   3990            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x0780             LSLS     R0,R0,#+30
   \   00000012   0xD410             BMI.N    ??I2C_WaitOnTXISFlagUntilTimeout_1
   3991            {
   3992              /* Check if a NACK is detected */
   3993              if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001C   0xB108             CBZ.N    R0,??I2C_WaitOnTXISFlagUntilTimeout_2
   3994              {
   3995                return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD70             POP      {R4-R6,PC}
   3996              }
   3997              
   3998              /* Check for the Timeout */
   3999              if(Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_2: (+1)
   \   00000022   0xF115 0x0F01      CMN      R5,#+1
   \   00000026   0xD0F1             BEQ.N    ??I2C_WaitOnTXISFlagUntilTimeout_0
   4000              {
   4001                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000028   0xB125             CBZ.N    R5,??I2C_WaitOnTXISFlagUntilTimeout_3
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x1B80             SUBS     R0,R0,R6
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD2EB             BCS.N    ??I2C_WaitOnTXISFlagUntilTimeout_0
   4002                {
   4003                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_3: (+1)
   \   00000034   0x....             B.N      ?Subroutine14
   4004                  hi2c->State= HAL_I2C_STATE_READY;
   4005                  
   4006                  /* Process Unlocked */
   4007                  __HAL_UNLOCK(hi2c);
   4008                  
   4009                  return HAL_TIMEOUT;
   4010                }
   4011              }
   4012            }
   4013            return HAL_OK;      
   \                     ??I2C_WaitOnTXISFlagUntilTimeout_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   4014          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \   00000000   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000004   0x6841             LDR      R1,[R0, #+4]
   \   00000006   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   \   0000000C                      REQUIRE ??Subroutine20_0
   \   0000000C                      ;; // Fall through to label ??Subroutine20_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine20_0: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x7041             STRB     R1,[R0, #+1]
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   4015          
   4016          /**
   4017            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   4018            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   4019            *                the configuration information for the specified I2C.
   4020            * @param  Timeout: Timeout duration
   4021            * @retval HAL status
   4022            */

   \                                 In section .text, align 2, keep-with-next
   4023          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   4024          {  
   \                     I2C_WaitOnSTOPFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   4025            uint32_t tickstart = 0x00;
   4026            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   4027            
   4028            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD40D             BMI.N    ??I2C_WaitOnSTOPFlagUntilTimeout_1
   4029            {
   4030              /* Check if a NACK is detected */
   4031              if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001C   0xB108             CBZ.N    R0,??I2C_WaitOnSTOPFlagUntilTimeout_2
   4032              {
   4033                return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD70             POP      {R4-R6,PC}
   4034              }
   4035              
   4036              /* Check for the Timeout */
   4037              if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_2: (+1)
   \   00000022   0xB125             CBZ.N    R5,??I2C_WaitOnSTOPFlagUntilTimeout_3
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B80             SUBS     R0,R0,R6
   \   0000002A   0x4285             CMP      R5,R0
   \   0000002C   0xD2EE             BCS.N    ??I2C_WaitOnSTOPFlagUntilTimeout_0
   4038              {
   4039                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_3: (+1)
   \   0000002E   0x....             B.N      ?Subroutine14
   4040                hi2c->State= HAL_I2C_STATE_READY;
   4041                
   4042                /* Process Unlocked */
   4043                __HAL_UNLOCK(hi2c);
   4044                
   4045                return HAL_TIMEOUT;
   4046              }
   4047            }
   4048            return HAL_OK;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_1: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
   4049          }
   4050          
   4051          /**
   4052            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   4053            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   4054            *                the configuration information for the specified I2C.
   4055            * @param  Timeout: Timeout duration
   4056            * @retval HAL status
   4057            */

   \                                 In section .text, align 2, keep-with-next
   4058          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   4059          {  
   \                     I2C_WaitOnRXNEFlagUntilTimeout: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   4060            uint32_t tickstart = 0x00;
   4061            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   4062            
   4063            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x0740             LSLS     R0,R0,#+29
   \   00000012   0xD420             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_1
   4064            {
   4065              /* Check if a NACK is detected */
   4066              if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001C   0xB990             CBNZ.N   R0,??I2C_WaitOnRXNEFlagUntilTimeout_2
   4067              {
   4068                return HAL_ERROR;
   4069              }
   4070              
   4071              /* Check if a STOPF is detected */
   4072              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6981             LDR      R1,[R0, #+24]
   \   00000022   0x0689             LSLS     R1,R1,#+26
   \   00000024   0xD510             BPL.N    ??I2C_WaitOnRXNEFlagUntilTimeout_3
   4073              {
   4074                /* Clear STOP Flag */
   4075                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   00000026   0x2120             MOVS     R1,#+32
   4076                
   4077                /* Clear Configuration Register 2 */
   4078                I2C_RESET_CR2(hi2c);
   \   00000028   0x....             LDR.N    R2,??DataTable20_1  ;; 0xfe00e800
   \   0000002A   0x61C1             STR      R1,[R0, #+28]
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6841             LDR      R1,[R0, #+4]
   \   00000030   0x4011             ANDS     R1,R2,R1
   \   00000032   0x6041             STR      R1,[R0, #+4]
   4079                
   4080                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000034   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x6041             STR      R1,[R0, #+4]
   4081                hi2c->State= HAL_I2C_STATE_READY;
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x7041             STRB     R1,[R0, #+1]
   4082                
   4083                /* Process Unlocked */
   4084                __HAL_UNLOCK(hi2c);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x7001             STRB     R1,[R0, #+0]
   4085                
   4086                return HAL_ERROR;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_2: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xBD70             POP      {R4-R6,PC}
   4087              }
   4088              
   4089              /* Check for the Timeout */
   4090              if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_3: (+1)
   \   00000048   0xB125             CBZ.N    R5,??I2C_WaitOnRXNEFlagUntilTimeout_4
   \   0000004A   0x.... 0x....      BL       HAL_GetTick
   \   0000004E   0x1B80             SUBS     R0,R0,R6
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD2DB             BCS.N    ??I2C_WaitOnRXNEFlagUntilTimeout_0
   4091              {
   4092                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_4: (+1)
   \   00000054   0x....             B.N      ?Subroutine14
   4093                hi2c->State= HAL_I2C_STATE_READY;
   4094                
   4095                /* Process Unlocked */
   4096                __HAL_UNLOCK(hi2c);
   4097                
   4098                return HAL_TIMEOUT;
   4099              }
   4100            }
   4101            return HAL_OK;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_1: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
   4102          }
   4103          
   4104          /**
   4105            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   4106            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   4107            *                the configuration information for the specified I2C.
   4108            * @param  Timeout: Timeout duration
   4109            * @retval HAL status
   4110            */

   \                                 In section .text, align 2, keep-with-next
   4111          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   4112          {
   \                     I2C_IsAcknowledgeFailed: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   4113            uint32_t tickstart = 0x00;
   4114            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   4115            
   4116            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x06C0             LSLS     R0,R0,#+27
   \   00000012   0xD529             BPL.N    ??I2C_IsAcknowledgeFailed_0
   4117            {
   4118              /* Wait until STOP Flag is reset */
   4119              /* AutoEnd should be initiate after AF */
   4120              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_IsAcknowledgeFailed_1: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6981             LDR      R1,[R0, #+24]
   \   00000018   0x0689             LSLS     R1,R1,#+26
   \   0000001A   0xD40B             BMI.N    ??I2C_IsAcknowledgeFailed_2
   4121              {
   4122                /* Check for the Timeout */
   4123                if(Timeout != HAL_MAX_DELAY)
   \   0000001C   0xF115 0x0F01      CMN      R5,#+1
   \   00000020   0xD0F8             BEQ.N    ??I2C_IsAcknowledgeFailed_1
   4124                {
   4125                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000022   0xB125             CBZ.N    R5,??I2C_IsAcknowledgeFailed_3
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B80             SUBS     R0,R0,R6
   \   0000002A   0x4285             CMP      R5,R0
   \   0000002C   0xD2F2             BCS.N    ??I2C_IsAcknowledgeFailed_1
   4126                  {
   4127                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_IsAcknowledgeFailed_3: (+1)
   \   0000002E   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000032   0x....             B.N      ??Subroutine20_0
   4128                    /* Process Unlocked */
   4129                    __HAL_UNLOCK(hi2c);
   4130                    return HAL_TIMEOUT;
   4131                  }
   4132                }
   4133              }
   4134              
   4135              /* Clear NACKF Flag */
   4136              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_IsAcknowledgeFailed_2: (+1)
   \   00000034   0x2110             MOVS     R1,#+16
   4137              
   4138              /* Clear STOP Flag */
   4139              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   4140              
   4141              /* Flush TX register if not empty */
   4142              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   4143              {
   4144                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
   4145              }
   4146              
   4147              /* Clear Configuration Register 2 */
   4148              I2C_RESET_CR2(hi2c);
   \   00000036   0x....             LDR.N    R2,??DataTable20_1  ;; 0xfe00e800
   \   00000038   0x61C1             STR      R1,[R0, #+28]
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x2020             MOVS     R0,#+32
   \   0000003E   0x61C8             STR      R0,[R1, #+28]
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6981             LDR      R1,[R0, #+24]
   \   00000044   0x07C9             LSLS     R1,R1,#+31
   \   00000046   0xBF5C             ITT      PL 
   \   00000048   0x2101             MOVPL    R1,#+1
   \   0000004A   0x61C1             STRPL    R1,[R0, #+28]
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0x4011             ANDS     R1,R2,R1
   \   00000052   0x6041             STR      R1,[R0, #+4]
   4149              
   4150              hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   00000054   0xF104 0x0034      ADD      R0,R4,#+52
   \   00000058   0x2104             MOVS     R1,#+4
   \   0000005A   0x6041             STR      R1,[R0, #+4]
   4151              hi2c->State= HAL_I2C_STATE_READY;
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x7041             STRB     R1,[R0, #+1]
   4152              
   4153              /* Process Unlocked */
   4154              __HAL_UNLOCK(hi2c);
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x7001             STRB     R1,[R0, #+0]
   4155              
   4156              return HAL_ERROR;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xBD70             POP      {R4-R6,PC}
   4157            }
   4158            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
   4159          }
   4160          
   4161          /**
   4162            * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
   4163            * @param  hi2c: I2C handle.
   4164            * @param  DevAddress: specifies the slave address to be programmed.
   4165            * @param  Size: specifies the number of bytes to be programmed.
   4166            *   This parameter must be a value between 0 and 255.
   4167            * @param  Mode: new state of the I2C START condition generation.
   4168            *   This parameter can be one of the following values:
   4169            *     @arg I2C_RELOAD_MODE: Enable Reload mode .
   4170            *     @arg I2C_AUTOEND_MODE: Enable Automatic end mode.
   4171            *     @arg I2C_SOFTEND_MODE: Enable Software end mode.
   4172            * @param  Request: new state of the I2C START condition generation.
   4173            *   This parameter can be one of the following values:
   4174            *     @arg I2C_NO_STARTSTOP: Don't Generate stop and start condition.
   4175            *     @arg I2C_GENERATE_STOP: Generate stop condition (Size should be set to 0).
   4176            *     @arg I2C_GENERATE_START_READ: Generate Restart for read request.
   4177            *     @arg I2C_GENERATE_START_WRITE: Generate Restart for write request.
   4178            * @retval None
   4179            */

   \                                 In section .text, align 2, keep-with-next
   4180          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
   4181          {
   \                     I2C_TransferConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4182            uint32_t tmpreg = 0;
   4183            
   4184            /* Check the parameters */
   4185            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
   4186            assert_param(IS_TRANSFER_MODE(Mode));
   4187            assert_param(IS_TRANSFER_REQUEST(Request));
   4188            
   4189            /* Get the CR2 register value */
   4190            tmpreg = hi2c->Instance->CR2;
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   4191            
   4192            /* clear tmpreg specific bits */
   4193            tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
   4194            
   4195            /* update tmpreg */
   4196            tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
   4197              (uint32_t)Mode | (uint32_t)Request);
   4198            
   4199            /* update CR2 register */
   4200            hi2c->Instance->CR2 = tmpreg;  
   \   00000004   0x....             LDR.N    R5,??DataTable20_2  ;; 0xfc009800
   \   00000006   0x0589             LSLS     R1,R1,#+22
   \   00000008   0x6844             LDR      R4,[R0, #+4]
   \   0000000A   0x402C             ANDS     R4,R5,R4
   \   0000000C   0xEA54 0x5191      ORRS     R1,R4,R1, LSR #+22
   \   00000010   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000014   0x9A02             LDR      R2,[SP, #+8]
   \   00000016   0x4319             ORRS     R1,R3,R1
   \   00000018   0x4311             ORRS     R1,R2,R1
   \   0000001A   0x6041             STR      R1,[R0, #+4]
   4201          }  
   \   0000001C   0xBC30             POP      {R4,R5}
   \   0000001E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0xFE00E800         DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     I2C_DMAMasterTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     I2C_DMAMasterReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     I2C_DMASlaveTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     I2C_DMASlaveReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     I2C_DMAMemReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x02002000         DC32     0x2002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0xFE00E800         DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0xFC009800         DC32     0xfc009800
   4202          
   4203          /**
   4204            * @}
   4205            */
   4206          
   4207          /**
   4208            * @}
   4209            */
   4210          
   4211          #endif /* HAL_I2C_MODULE_ENABLED */
   4212          /**
   4213            * @}
   4214            */
   4215          
   4216          /**
   4217            * @}
   4218            */
   4219          
   4220          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_I2C_DeInit
         8   -> HAL_I2C_MspDeInit
       8   HAL_I2C_ER_IRQHandler
         8   -> HAL_I2C_ErrorCallback
       8   HAL_I2C_EV_IRQHandler
         0   -> I2C_MasterReceive_ISR
         8   -> I2C_MasterTransmit_ISR
         8   -> I2C_SlaveReceive_ISR
         8   -> I2C_SlaveTransmit_ISR
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetState
      16   HAL_I2C_Init
        16   -> HAL_I2C_MspInit
      40   HAL_I2C_IsDeviceReady
        40   -> HAL_GetTick
        40   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
      40   HAL_I2C_Master_Receive
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
        40   -> I2C_TransferConfig
        40   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   HAL_I2C_Master_Receive_DMA
        24   -> HAL_DMA_Abort
        24   -> HAL_DMA_Start_IT
        24   -> I2C_TransferConfig
        24   -> I2C_WaitOnRXNEFlagUntilTimeout
      16   HAL_I2C_Master_Receive_IT
        16   -> I2C_TransferConfig
      40   HAL_I2C_Master_Transmit
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
        40   -> I2C_TransferConfig
        40   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   HAL_I2C_Master_Transmit_DMA
        24   -> HAL_DMA_Abort
        24   -> HAL_DMA_Start_IT
        24   -> I2C_TransferConfig
        24   -> I2C_WaitOnTXISFlagUntilTimeout
      16   HAL_I2C_Master_Transmit_IT
        16   -> I2C_TransferConfig
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      40   HAL_I2C_Mem_Read
        40   -> HAL_GetTick
        40   -> I2C_RequestMemoryRead
        40   -> I2C_TransferConfig
        40   -> I2C_WaitOnSTOPFlagUntilTimeout
      32   HAL_I2C_Mem_Read_DMA
        32   -> HAL_DMA_Start_IT
        32   -> HAL_GetTick
        32   -> I2C_RequestMemoryRead
        32   -> I2C_TransferConfig
      24   HAL_I2C_Mem_Read_IT
        24   -> I2C_RequestMemoryRead
        24   -> I2C_TransferConfig
      40   HAL_I2C_Mem_Write
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
        40   -> I2C_RequestMemoryWrite
        40   -> I2C_TransferConfig
        40   -> I2C_WaitOnSTOPFlagUntilTimeout
      32   HAL_I2C_Mem_Write_DMA
        32   -> HAL_DMA_Start_IT
        32   -> I2C_RequestMemoryWrite
        32   -> I2C_TransferConfig
        32   -> I2C_WaitOnTXISFlagUntilTimeout
      24   HAL_I2C_Mem_Write_IT
        24   -> I2C_RequestMemoryWrite
        24   -> I2C_TransferConfig
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      32   HAL_I2C_Slave_Receive
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   HAL_I2C_Slave_Receive_DMA
        24   -> HAL_DMA_Start_IT
        24   -> HAL_GetTick
       8   HAL_I2C_Slave_Receive_IT
      32   HAL_I2C_Slave_Transmit
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   HAL_I2C_Slave_Transmit_DMA
        24   -> HAL_DMA_Start_IT
        24   -> HAL_GetTick
       8   HAL_I2C_Slave_Transmit_IT
       8   I2C_DMAError
         8   -> HAL_I2C_ErrorCallback
      24   I2C_DMAMasterReceiveCplt
        24   -> HAL_DMA_Start_IT
        24   -> HAL_GetTick
        24   -> HAL_I2C_ErrorCallback
        24   -> HAL_I2C_MasterRxCpltCallback
        24   -> I2C_TransferConfig
        24   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   I2C_DMAMasterTransmitCplt
        24   -> HAL_DMA_Start_IT
        24   -> HAL_GetTick
        24   -> HAL_I2C_ErrorCallback
        24   -> HAL_I2C_MasterTxCpltCallback
        24   -> I2C_TransferConfig
        24   -> I2C_WaitOnSTOPFlagUntilTimeout
        24   -> I2C_WaitOnTXISFlagUntilTimeout
      24   I2C_DMAMemReceiveCplt
        24   -> HAL_DMA_Start_IT
        24   -> HAL_GetTick
        24   -> HAL_I2C_ErrorCallback
        24   -> HAL_I2C_MemRxCpltCallback
        24   -> I2C_TransferConfig
        24   -> I2C_WaitOnSTOPFlagUntilTimeout
      24   I2C_DMAMemTransmitCplt
        24   -> HAL_DMA_Start_IT
        24   -> HAL_GetTick
        24   -> HAL_I2C_ErrorCallback
        24   -> HAL_I2C_MemTxCpltCallback
        24   -> I2C_TransferConfig
        24   -> I2C_WaitOnSTOPFlagUntilTimeout
        24   -> I2C_WaitOnTXISFlagUntilTimeout
      16   I2C_DMASlaveReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveRxCpltCallback
        16   -> I2C_WaitOnSTOPFlagUntilTimeout
      16   I2C_DMASlaveTransmitCplt
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveTxCpltCallback
        16   -> I2C_WaitOnSTOPFlagUntilTimeout
      16   I2C_IsAcknowledgeFailed
        16   -> HAL_GetTick
      16   I2C_MasterReceive_ISR
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterRxCpltCallback
        16   -> HAL_I2C_MemRxCpltCallback
      16   I2C_MasterTransmit_ISR
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterTxCpltCallback
        16   -> HAL_I2C_MemTxCpltCallback
      24   I2C_RequestMemoryRead
        24   -> I2C_TransferConfig
        24   -> I2C_WaitOnFlagUntilTimeout
        24   -> I2C_WaitOnTXISFlagUntilTimeout
      24   I2C_RequestMemoryWrite
        24   -> I2C_TransferConfig
        24   -> I2C_WaitOnFlagUntilTimeout
        24   -> I2C_WaitOnTXISFlagUntilTimeout
       8   I2C_SlaveReceive_ISR
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_SlaveRxCpltCallback
       8   I2C_SlaveTransmit_ISR
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_SlaveTxCpltCallback
       8   I2C_TransferConfig
      24   I2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
      16   I2C_WaitOnRXNEFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnSTOPFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_WaitOnTXISFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
      12  ??Subroutine20_0
       6  ?Subroutine0
       6  ?Subroutine1
       6  ?Subroutine10
       6  ?Subroutine11
       6  ?Subroutine12
       6  ?Subroutine13
      12  ?Subroutine14
       6  ?Subroutine15
      12  ?Subroutine16
      12  ?Subroutine17
       6  ?Subroutine18
       6  ?Subroutine19
      28  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
       8  ?Subroutine7
      22  ?Subroutine8
       8  ?Subroutine9
      40  HAL_I2C_DeInit
     102  HAL_I2C_ER_IRQHandler
     254  HAL_I2C_EV_IRQHandler
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetState
     158  HAL_I2C_Init
     302  HAL_I2C_IsDeviceReady
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
     376  HAL_I2C_Master_Receive
     188  HAL_I2C_Master_Receive_DMA
     122  HAL_I2C_Master_Receive_IT
     360  HAL_I2C_Master_Transmit
     200  HAL_I2C_Master_Transmit_DMA
     122  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     340  HAL_I2C_Mem_Read
     226  HAL_I2C_Mem_Read_DMA
     160  HAL_I2C_Mem_Read_IT
     360  HAL_I2C_Mem_Write
     220  HAL_I2C_Mem_Write_DMA
     148  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     330  HAL_I2C_Slave_Receive
     160  HAL_I2C_Slave_Receive_DMA
      76  HAL_I2C_Slave_Receive_IT
     338  HAL_I2C_Slave_Transmit
     194  HAL_I2C_Slave_Transmit_DMA
      76  HAL_I2C_Slave_Transmit_IT
      38  I2C_DMAError
     416  I2C_DMAMasterReceiveCplt
     382  I2C_DMAMasterTransmitCplt
     410  I2C_DMAMemReceiveCplt
     382  I2C_DMAMemTransmitCplt
     134  I2C_DMASlaveReceiveCplt
     122  I2C_DMASlaveTransmitCplt
     108  I2C_IsAcknowledgeFailed
     296  I2C_MasterReceive_ISR
     310  I2C_MasterTransmit_ISR
      98  I2C_RequestMemoryRead
     100  I2C_RequestMemoryWrite
     134  I2C_SlaveReceive_ISR
     148  I2C_SlaveTransmit_ISR
      32  I2C_TransferConfig
     122  I2C_WaitOnFlagUntilTimeout
      90  I2C_WaitOnRXNEFlagUntilTimeout
      52  I2C_WaitOnSTOPFlagUntilTimeout
      58  I2C_WaitOnTXISFlagUntilTimeout

 
 8 560 bytes in section .text
 
 8 560 bytes of CODE memory

Errors: none
Warnings: none
