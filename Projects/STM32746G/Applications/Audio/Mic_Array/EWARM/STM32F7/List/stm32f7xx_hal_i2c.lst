###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       12/Apr/2016  09:55:50
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_i2c.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_i2c.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   I2C HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral State and Errors functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19              The I2C HAL driver can be used as follows:
     20              
     21              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     22                  I2C_HandleTypeDef  hi2c; 
     23          
     24              (#)Initialize the I2C low level resources by implement the HAL_I2C_MspInit ()API:
     25                  (##) Enable the I2Cx interface clock
     26                  (##) I2C pins configuration
     27                      (+++) Enable the clock for the I2C GPIOs
     28                      (+++) Configure I2C pins as alternate function open-drain
     29                  (##) NVIC configuration if you need to use interrupt process
     30                      (+++) Configure the I2Cx interrupt priority
     31                      (+++) Enable the NVIC I2C IRQ Channel
     32                  (##) DMA Configuration if you need to use DMA process
     33                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     34                      (+++) Enable the DMAx interface clock using
     35                      (+++) Configure the DMA handle parameters
     36                      (+++) Configure the DMA Tx or Rx Stream
     37                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     38                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream
     39          
     40              (#) Configure the Communication Clock Timing, Own Address1, Master Addressing mode, Dual Addressing mode,
     41                  Own Address2, Own Address2 Mask, General call and Nostretch mode in the hi2c Init structure.
     42          
     43              (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware 
     44                  (GPIO, CLOCK, NVIC...etc) by calling the customed HAL_I2C_MspInit(&hi2c) API.
     45          
     46              (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()
     47          
     48              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     49          
     50              *** Polling mode IO operation ***
     51              =================================
     52              [..]
     53                (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()
     54                (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()
     55                (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()
     56                (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()
     57          
     58              *** Polling mode IO MEM operation ***
     59              =====================================
     60              [..]
     61                (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()
     62                (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()
     63          
     64          
     65              *** Interrupt mode IO operation ***
     66              ===================================
     67              [..]
     68                (+) Transmit in master mode an amount of data in non blocking mode using HAL_I2C_Master_Transmit_IT()
     69                (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback is executed and user can
     70                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback
     71                (+) Receive in master mode an amount of data in non blocking mode using HAL_I2C_Master_Receive_IT()
     72                (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback is executed and user can
     73                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback
     74                (+) Transmit in slave mode an amount of data in non blocking mode using HAL_I2C_Slave_Transmit_IT()
     75                (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback is executed and user can
     76                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback
     77                (+) Receive in slave mode an amount of data in non blocking mode using HAL_I2C_Slave_Receive_IT()
     78                (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback is executed and user can
     79                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback
     80                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     81                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
     82          
     83              *** Interrupt mode IO MEM operation ***
     84              =======================================
     85              [..]
     86                (+) Write an amount of data in no-blocking mode with Interrupt to a specific memory address using
     87                    HAL_I2C_Mem_Write_IT()
     88                (+) At Memory end of write transfer, HAL_I2C_MemTxCpltCallback is executed and user can
     89                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback
     90                (+) Read an amount of data in no-blocking mode with Interrupt from a specific memory address using
     91                    HAL_I2C_Mem_Read_IT()
     92                (+) At Memory end of read transfer, HAL_I2C_MemRxCpltCallback is executed and user can
     93                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback
     94                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     95                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
     96          
     97              *** DMA mode IO operation ***
     98              ==============================
     99              [..]
    100                (+) Transmit in master mode an amount of data in non blocking mode (DMA) using
    101                    HAL_I2C_Master_Transmit_DMA()
    102                (+) At transmission end of transfer, HAL_I2C_MasterTxCpltCallback is executed and user can
    103                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback
    104                (+) Receive in master mode an amount of data in non blocking mode (DMA) using
    105                    HAL_I2C_Master_Receive_DMA()
    106                (+) At reception end of transfer, HAL_I2C_MasterRxCpltCallback is executed and user can
    107                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback
    108                (+) Transmit in slave mode an amount of data in non blocking mode (DMA) using
    109                    HAL_I2C_Slave_Transmit_DMA()
    110                (+) At transmission end of transfer, HAL_I2C_SlaveTxCpltCallback is executed and user can
    111                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback
    112                (+) Receive in slave mode an amount of data in non blocking mode (DMA) using
    113                    HAL_I2C_Slave_Receive_DMA()
    114                (+) At reception end of transfer, HAL_I2C_SlaveRxCpltCallback is executed and user can
    115                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback
    116                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    117                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    118          
    119              *** DMA mode IO MEM operation ***
    120              =================================
    121              [..]
    122                (+) Write an amount of data in no-blocking mode with DMA to a specific memory address using
    123                    HAL_I2C_Mem_Write_DMA()
    124                (+) At Memory end of write transfer HAL_I2C_MemTxCpltCallback is executed and user can
    125                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback
    126                (+) Read an amount of data in no-blocking mode with DMA from a specific memory address using
    127                    HAL_I2C_Mem_Read_DMA()
    128                (+) At Memory end of read transfer HAL_I2C_MemRxCpltCallback is executed and user can
    129                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback
    130                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    131                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    132          
    133          
    134               *** I2C HAL driver macros list ***
    135               ==================================
    136               [..]
    137                 Below the list of most used macros in I2C HAL driver.
    138          
    139                (+) __HAL_I2C_ENABLE: Enable the I2C peripheral
    140                (+) __HAL_I2C_DISABLE: Disable the I2C peripheral
    141                (+) __HAL_I2C_GET_FLAG : Check whether the specified I2C flag is set or not
    142                (+) __HAL_I2C_CLEAR_FLAG : Clear the specified I2C pending flag
    143                (+) __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt
    144                (+) __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    145          
    146               [..]
    147                 (@) You can refer to the I2C HAL driver header file for more useful macros
    148          
    149            @endverbatim
    150            ******************************************************************************
    151            * @attention
    152            *
    153            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    154            *
    155            * Redistribution and use in source and binary forms, with or without modification,
    156            * are permitted provided that the following conditions are met:
    157            *   1. Redistributions of source code must retain the above copyright notice,
    158            *      this list of conditions and the following disclaimer.
    159            *   2. Redistributions in binary form must reproduce the above copyright notice,
    160            *      this list of conditions and the following disclaimer in the documentation
    161            *      and/or other materials provided with the distribution.
    162            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    163            *      may be used to endorse or promote products derived from this software
    164            *      without specific prior written permission.
    165            *
    166            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    167            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    168            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    169            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    170            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    171            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    172            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    173            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    174            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    175            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    176            *
    177            ******************************************************************************  
    178            */ 
    179          
    180          /* Includes ------------------------------------------------------------------*/
    181          #include "stm32f7xx_hal.h"
    182          
    183          /** @addtogroup STM32F7xx_HAL_Driver
    184            * @{
    185            */
    186          
    187          /** @defgroup I2C I2C HAL module driver
    188            * @brief I2C HAL module driver
    189            * @{
    190            */
    191          
    192          #ifdef HAL_I2C_MODULE_ENABLED
    193          
    194          /* Private typedef -----------------------------------------------------------*/
    195          /* Private constants ---------------------------------------------------------*/
    196          /** @addtogroup I2C_Private_Constants I2C Private Constants
    197            * @{
    198            */
    199          #define TIMING_CLEAR_MASK   ((uint32_t)0xF0FFFFFF)  /*<! I2C TIMING clear register Mask */
    200          #define I2C_TIMEOUT_ADDR    ((uint32_t)10000)       /* 10 s  */
    201          #define I2C_TIMEOUT_BUSY    ((uint32_t)25)          /* 25 ms */
    202          #define I2C_TIMEOUT_DIR     ((uint32_t)25)          /* 25 ms */
    203          #define I2C_TIMEOUT_RXNE    ((uint32_t)25)          /* 25 ms */
    204          #define I2C_TIMEOUT_STOPF   ((uint32_t)25)          /* 25 ms */
    205          #define I2C_TIMEOUT_TC      ((uint32_t)25)          /* 25 ms */
    206          #define I2C_TIMEOUT_TCR     ((uint32_t)25)          /* 25 ms */
    207          #define I2C_TIMEOUT_TXIS    ((uint32_t)25)          /* 25 ms */
    208          #define I2C_TIMEOUT_FLAG    ((uint32_t)25)          /* 25 ms */
    209          /**
    210            * @}
    211            */ 
    212          
    213          /* Private macro -------------------------------------------------------------*/
    214          /* Private variables ---------------------------------------------------------*/
    215          /* Private function prototypes -----------------------------------------------*/
    216          /** @addtogroup I2C_Private_Functions I2C Private Functions
    217            * @{
    218            */
    219          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);
    220          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);
    221          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);
    222          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);
    223          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma);
    224          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma);
    225          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    226          
    227          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    228          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    229          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    230          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    231          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    232          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    233          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    234          
    235          static HAL_StatusTypeDef I2C_MasterTransmit_ISR(I2C_HandleTypeDef *hi2c);
    236          static HAL_StatusTypeDef I2C_MasterReceive_ISR(I2C_HandleTypeDef *hi2c);
    237          
    238          static HAL_StatusTypeDef I2C_SlaveTransmit_ISR(I2C_HandleTypeDef *hi2c);
    239          static HAL_StatusTypeDef I2C_SlaveReceive_ISR(I2C_HandleTypeDef *hi2c);
    240          
    241          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request);
    242          /**
    243            * @}
    244            */ 
    245          
    246          /* Exported functions --------------------------------------------------------*/
    247          
    248          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    249            * @{
    250            */
    251          
    252          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    253           *  @brief    Initialization and Configuration functions 
    254           *
    255          @verbatim    
    256           ===============================================================================
    257                        ##### Initialization and de-initialization functions #####
    258           ===============================================================================
    259              [..]  This subsection provides a set of functions allowing to initialize and 
    260                    de-initialize the I2Cx peripheral:
    261          
    262                (+) User must Implement HAL_I2C_MspInit() function in which he configures 
    263                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    264          
    265                (+) Call the function HAL_I2C_Init() to configure the selected device with 
    266                    the selected configuration:
    267                  (++) Clock Timing
    268                  (++) Own Address 1
    269                  (++) Addressing mode (Master, Slave)
    270                  (++) Dual Addressing mode
    271                  (++) Own Address 2
    272                  (++) Own Address 2 Mask
    273                  (++) General call mode
    274                  (++) Nostretch mode
    275          
    276                (+) Call the function HAL_I2C_DeInit() to restore the default configuration 
    277                    of the selected I2Cx peripheral.       
    278          
    279          @endverbatim
    280            * @{
    281            */
    282          
    283          /**
    284            * @brief  Initializes the I2C according to the specified parameters 
    285            *         in the I2C_InitTypeDef and create the associated handle.
    286            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    287            *                the configuration information for the specified I2C.
    288            * @retval HAL status
    289            */

   \                                 In section .text, align 2, keep-with-next
    290          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    291          { 
   \                     HAL_I2C_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    292            /* Check the I2C handle allocation */
    293            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_Init_0
    294            {
    295              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    296            }
    297            
    298            /* Check the parameters */
    299            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    300            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    301            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    302            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    303            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    304            assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    305            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    306            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    307          
    308            if(hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0xB920             CBNZ.N   R0,??HAL_I2C_Init_1
    309            {
    310              /* Allocate lock resource and initialize it */
    311              hi2c->Lock = HAL_UNLOCKED;
   \   00000010   0xF884 0x0034      STRB     R0,[R4, #+52]
    312              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    313              HAL_I2C_MspInit(hi2c);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_I2C_MspInit
    314            }
    315          
    316            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0035      STRB     R0,[R4, #+53]
    317            
    318            /* Disable the selected I2C peripheral */
    319            __HAL_I2C_DISABLE(hi2c);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    320            
    321            /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
    322            /* Configure I2Cx: Frequency range */
    323            hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
   \   0000002A   0x6860             LDR      R0,[R4, #+4]
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0xF020 0x6070      BIC      R0,R0,#0xF000000
   \   00000032   0x6108             STR      R0,[R1, #+16]
    324            
    325            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    326            /* Configure I2Cx: Own Address1 and ack own address1 mode */
    327            hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6881             LDR      R1,[R0, #+8]
   \   00000038   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000003C   0x6081             STR      R1,[R0, #+8]
    328            if(hi2c->Init.OwnAddress1 != 0)
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0xB140             CBZ.N    R0,??HAL_I2C_Init_2
    329            {
    330              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \   00000042   0x68E1             LDR      R1,[R4, #+12]
   \   00000044   0x2901             CMP      R1,#+1
   \   00000046   0xBF0C             ITE      EQ 
   \   00000048   0xF440 0x4000      ORREQ    R0,R0,#0x8000
   \   0000004C   0xF440 0x4004      ORRNE    R0,R0,#0x8400
    331              {
    332                hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    333              }
    334              else /* I2C_ADDRESSINGMODE_10BIT */
    335              {
    336                hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6088             STR      R0,[R1, #+8]
    337              }
    338            }
    339            
    340            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    341            /* Configure I2Cx: Addressing Master mode */
    342            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \                     ??HAL_I2C_Init_2: (+1)
   \   00000054   0x68E0             LDR      R0,[R4, #+12]
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD103             BNE.N    ??HAL_I2C_Init_3
    343            {
    344              hi2c->Instance->CR2 = (I2C_CR2_ADD10);
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0xF44F 0x6000      MOV      R0,#+2048
   \   00000060   0x6048             STR      R0,[R1, #+4]
    345            }
    346            /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
    347            hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
   \                     ??HAL_I2C_Init_3: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6841             LDR      R1,[R0, #+4]
   \   00000066   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000006A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000006E   0x6041             STR      R1,[R0, #+4]
    348            
    349            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    350            /* Configure I2Cx: Dual mode and Own Address2 */
    351            hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
   \   00000070   0x6920             LDR      R0,[R4, #+16]
   \   00000072   0x6961             LDR      R1,[R4, #+20]
   \   00000074   0x4308             ORRS     R0,R1,R0
   \   00000076   0x69A1             LDR      R1,[R4, #+24]
   \   00000078   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x60C8             STR      R0,[R1, #+12]
    352          
    353            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    354            /* Configure I2Cx: Generalcall and NoStretch mode */
    355            hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
   \   00000080   0x69E0             LDR      R0,[R4, #+28]
   \   00000082   0x6A21             LDR      R1,[R4, #+32]
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x6008             STR      R0,[R1, #+0]
    356            
    357            /* Enable the selected I2C peripheral */
    358            __HAL_I2C_ENABLE(hi2c);
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000092   0x6001             STR      R1,[R0, #+0]
    359            
    360            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x63A0             STR      R0,[R4, #+56]
    361            hi2c->State = HAL_I2C_STATE_READY;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xF884 0x0035      STRB     R0,[R4, #+53]
    362            
    363            return HAL_OK;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xBD10             POP      {R4,PC}          ;; return
    364          }
    365          
    366          /**
    367            * @brief  DeInitializes the I2C peripheral. 
    368            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    369            *                the configuration information for the specified I2C.
    370            * @retval HAL status
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    373          {
   \                     HAL_I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    374            /* Check the I2C handle allocation */
    375            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    376            {
    377              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    378            }
    379            
    380            /* Check the parameters */
    381            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    382            
    383            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xF884 0x0035      STRB     R0,[R4, #+53]
    384            
    385            /* Disable the I2C Peripheral Clock */
    386            __HAL_I2C_DISABLE(hi2c);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    387            
    388            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    389            HAL_I2C_MspDeInit(hi2c);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_I2C_MspDeInit
    390            
    391            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x63A0             STR      R0,[R4, #+56]
    392          
    393            hi2c->State = HAL_I2C_STATE_RESET;
   \   00000024   0xF884 0x0035      STRB     R0,[R4, #+53]
    394            
    395            /* Release Lock */
    396            __HAL_UNLOCK(hi2c);
   \   00000028   0xF884 0x0034      STRB     R0,[R4, #+52]
    397          
    398            return HAL_OK;
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    399          }
    400          
    401          /**
    402            * @brief I2C MSP Init.
    403            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    404            *                the configuration information for the specified I2C.
    405            * @retval None
    406            */

   \                                 In section .text, align 2, keep-with-next
    407           __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    408          {
    409            /* Prevent unused argument(s) compilation warning */
    410            UNUSED(hi2c);
    411            
    412            /* NOTE : This function Should not be modified, when the callback is needed,
    413                      the HAL_I2C_MspInit could be implemented in the user file
    414             */ 
    415          }
   \                     HAL_I2C_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    416          
    417          /**
    418            * @brief I2C MSP DeInit
    419            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    420            *                the configuration information for the specified I2C.
    421            * @retval None
    422            */

   \                                 In section .text, align 2, keep-with-next
    423           __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    424          {
    425            /* Prevent unused argument(s) compilation warning */
    426            UNUSED(hi2c);
    427            
    428            /* NOTE : This function Should not be modified, when the callback is needed,
    429                      the HAL_I2C_MspDeInit could be implemented in the user file
    430             */ 
    431          }
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    432          
    433          /**
    434            * @}
    435            */
    436          
    437          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
    438           *  @brief   Data transfers functions 
    439           *
    440          @verbatim   
    441           ===============================================================================
    442                                ##### IO operation functions #####
    443           ===============================================================================  
    444              [..]
    445              This subsection provides a set of functions allowing to manage the I2C data 
    446              transfers.
    447          
    448              (#) There are two modes of transfer:
    449                 (++) Blocking mode : The communication is performed in the polling mode. 
    450                      The status of all data processing is returned by the same function 
    451                      after finishing transfer.  
    452                 (++) No-Blocking mode : The communication is performed using Interrupts 
    453                      or DMA. These functions return the status of the transfer startup.
    454                      The end of the data processing will be indicated through the 
    455                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when 
    456                      using DMA mode.
    457          
    458              (#) Blocking mode functions are :
    459                  (++) HAL_I2C_Master_Transmit()
    460                  (++) HAL_I2C_Master_Receive()
    461                  (++) HAL_I2C_Slave_Transmit()
    462                  (++) HAL_I2C_Slave_Receive()
    463                  (++) HAL_I2C_Mem_Write()
    464                  (++) HAL_I2C_Mem_Read()
    465                  (++) HAL_I2C_IsDeviceReady()
    466                  
    467              (#) No-Blocking mode functions with Interrupt are :
    468                  (++) HAL_I2C_Master_Transmit_IT()
    469                  (++) HAL_I2C_Master_Receive_IT()
    470                  (++) HAL_I2C_Slave_Transmit_IT()
    471                  (++) HAL_I2C_Slave_Receive_IT()
    472                  (++) HAL_I2C_Mem_Write_IT()
    473                  (++) HAL_I2C_Mem_Read_IT()
    474          
    475              (#) No-Blocking mode functions with DMA are :
    476                  (++) HAL_I2C_Master_Transmit_DMA()
    477                  (++) HAL_I2C_Master_Receive_DMA()
    478                  (++) HAL_I2C_Slave_Transmit_DMA()
    479                  (++) HAL_I2C_Slave_Receive_DMA()
    480                  (++) HAL_I2C_Mem_Write_DMA()
    481                  (++) HAL_I2C_Mem_Read_DMA()
    482          
    483              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    484                  (++) HAL_I2C_MemTxCpltCallback()
    485                  (++) HAL_I2C_MemRxCpltCallback()
    486                  (++) HAL_I2C_MasterTxCpltCallback()
    487                  (++) HAL_I2C_MasterRxCpltCallback()
    488                  (++) HAL_I2C_SlaveTxCpltCallback()
    489                  (++) HAL_I2C_SlaveRxCpltCallback()
    490                  (++) HAL_I2C_ErrorCallback()
    491          
    492          @endverbatim
    493            * @{
    494            */
    495          
    496          /**
    497            * @brief  Transmits in master mode an amount of data in blocking mode.
    498            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    499            *                the configuration information for the specified I2C.
    500            * @param  DevAddress: Target device address
    501            * @param  pData: Pointer to data buffer
    502            * @param  Size: Amount of data to be sent
    503            * @param  Timeout: Timeout duration
    504            * @retval HAL status
    505            */

   \                                 In section .text, align 4, keep-with-next
    506          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    507          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x461E             MOV      R6,R3
    508            uint32_t sizetmp = 0;
    509            
    510            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80DA      BNE.W    ??HAL_I2C_Master_Transmit_0
    511            {    
    512              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2E00             CMPNE    R6,#+0
   \   0000001E   0xF000 0x80D5      BEQ.W    ??HAL_I2C_Master_Transmit_1
    513              {
    514                return  HAL_ERROR;                                    
    515              }
    516              
    517              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6982             LDR      R2,[R0, #+24]
   \   00000026   0x0412             LSLS     R2,R2,#+16
   \   00000028   0xF100 0x80CF      BMI.W    ??HAL_I2C_Master_Transmit_0
    518              {
    519                return HAL_BUSY;
    520              }
    521              
    522              /* Process Locked */
    523              __HAL_LOCK(hi2c);
   \   0000002C   0xF894 0x2034      LDRB     R2,[R4, #+52]
   \   00000030   0x2A01             CMP      R2,#+1
   \   00000032   0xF000 0x80CA      BEQ.W    ??HAL_I2C_Master_Transmit_0
   \   00000036   0x2201             MOVS     R2,#+1
    524              
    525              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
    526              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    527              
    528              /* Send Slave Address */
    529              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    530              /* Size > 255, need to set RELOAD bit */
    531              if(Size > 255)
   \   00000038   0x058F             LSLS     R7,R1,#+22
   \   0000003A   0xF884 0x2034      STRB     R2,[R4, #+52]
   \   0000003E   0x2212             MOVS     R2,#+18
   \   00000040   0xF884 0x2035      STRB     R2,[R4, #+53]
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x63A2             STR      R2,[R4, #+56]
   \   00000048   0x2EFF             CMP      R6,#+255
   \   0000004A   0x6841             LDR      R1,[R0, #+4]
   \   0000004C   0x.... 0x....      LDR.W    R8,??DataTable8  ;; 0xfc009800
   \   00000050   0xEA08 0x0101      AND      R1,R8,R1
   \   00000054   0xDD0A             BLE.N    ??HAL_I2C_Master_Transmit_2
    532              {
    533                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   00000056   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
    534                sizetmp = 255;
   \   0000005A   0x25FF             MOVS     R5,#+255
   \   0000005C   0xF041 0x71F0      ORR      R1,R1,#0x1E00000
   \   00000060   0xF441 0x11F9      ORR      R1,R1,#0x1F2000
   \   00000064   0x6041             STR      R1,[R0, #+4]
   \   00000066   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   0000006A   0xE016             B.N      ??HAL_I2C_Master_Transmit_3
    535              }
    536              else
    537              {
    538                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \   0000006C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000070   0xB2F2             UXTB     R2,R6
    539                sizetmp = Size;
   \   00000072   0x4635             MOV      R5,R6
   \   00000074   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000078   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000007C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000080   0x6041             STR      R1,[R0, #+4]
   \   00000082   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   00000086   0xE008             B.N      ??HAL_I2C_Master_Transmit_3
    540              }
    541              
    542              do
    543              {
    544                /* Wait until TXIS flag is set */
    545                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    546                {
    547                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    548                  {
    549                    return HAL_ERROR;
    550                  }
    551                  else
    552                  {
    553                    return HAL_TIMEOUT;
    554                  }
    555                }
    556                /* Write data to TXDR */
    557                hi2c->Instance->TXDR = (*pData++);
    558                sizetmp--;
    559                Size--;
    560                
    561                if((sizetmp == 0)&&(Size!=0))
    562                {
    563                  /* Wait until TCR flag is set */
    564                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
    565                  {
    566                    return HAL_TIMEOUT;
    567                  }
    568                  
    569                  if(Size > 255)
    570                  {
    571                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    572                    sizetmp = 255;
    573                  }
    574                  else
    575                  {
    576                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \   00000088   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   0000008C   0xB2F2             UXTB     R2,R6
    577                    sizetmp = Size;
   \   0000008E   0x4635             MOV      R5,R6
   \   00000090   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000094   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000098   0x6041             STR      R1,[R0, #+4]
    578                  }
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \   0000009A   0x.... 0x....      BL       HAL_GetTick
   \   0000009E   0x4683             MOV      R11,R0
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6981             LDR      R1,[R0, #+24]
   \   000000A4   0x0789             LSLS     R1,R1,#+30
   \   000000A6   0xD421             BMI.N    ??HAL_I2C_Master_Transmit_6
   \   000000A8   0x4649             MOV      R1,R9
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000B0   0xB9A8             CBNZ.N   R0,??HAL_I2C_Master_Transmit_7
   \   000000B2   0xF119 0x0F01      CMN      R9,#+1
   \   000000B6   0xD0F3             BEQ.N    ??HAL_I2C_Master_Transmit_5
   \   000000B8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BC   0xD005             BEQ.N    ??HAL_I2C_Master_Transmit_8
   \   000000BE   0x.... 0x....      BL       HAL_GetTick
   \   000000C2   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000C6   0x4581             CMP      R9,R0
   \   000000C8   0xD2EA             BCS.N    ??HAL_I2C_Master_Transmit_5
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \   000000CA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000D0   0x63A0             STR      R0,[R4, #+56]
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \   000000DE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E0   0x2804             CMP      R0,#+4
   \   000000E2   0xD16E             BNE.N    ??HAL_I2C_Master_Transmit_9
    579                }
    580                
    581              }while(Size > 0);
    582              
    583              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    584              /* Wait until STOPF flag is set */
    585              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    586              {
    587                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    588                {
    589                  return HAL_ERROR;
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0xB001             ADD      SP,SP,#+4
   \   000000E8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \   000000EC   0xF81A 0x1B01      LDRB     R1,[R10], #+1
   \   000000F0   0x1E6D             SUBS     R5,R5,#+1
   \   000000F2   0xF1A6 0x0601      SUB      R6,R6,#+1
   \   000000F6   0xB2B6             UXTH     R6,R6
   \   000000F8   0x6281             STR      R1,[R0, #+40]
   \   000000FA   0xD129             BNE.N    ??HAL_I2C_Master_Transmit_10
   \   000000FC   0xB356             CBZ.N    R6,??HAL_I2C_Master_Transmit_11
   \   000000FE   0x.... 0x....      BL       HAL_GetTick
   \   00000102   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Master_Transmit_12: (+1)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6981             LDR      R1,[R0, #+24]
   \   00000108   0x0609             LSLS     R1,R1,#+24
   \   0000010A   0xD414             BMI.N    ??HAL_I2C_Master_Transmit_13
   \   0000010C   0xF119 0x0F01      CMN      R9,#+1
   \   00000110   0xD0F8             BEQ.N    ??HAL_I2C_Master_Transmit_12
   \   00000112   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000116   0xD004             BEQ.N    ??HAL_I2C_Master_Transmit_14
   \   00000118   0x.... 0x....      BL       HAL_GetTick
   \   0000011C   0x1B40             SUBS     R0,R0,R5
   \   0000011E   0x4581             CMP      R9,R0
   \   00000120   0xD2F0             BCS.N    ??HAL_I2C_Master_Transmit_12
   \                     ??HAL_I2C_Master_Transmit_14: (+1)
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF884 0x0034      STRB     R0,[R4, #+52]
    590                }
    591                else
    592                {
    593                  return HAL_TIMEOUT;
   \   0000012E   0x2003             MOVS     R0,#+3
   \   00000130   0xB001             ADD      SP,SP,#+4
   \   00000132   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Transmit_13: (+1)
   \   00000136   0x2EFF             CMP      R6,#+255
   \   00000138   0x6841             LDR      R1,[R0, #+4]
   \   0000013A   0xEA08 0x0101      AND      R1,R8,R1
   \   0000013E   0xDDA3             BLE.N    ??HAL_I2C_Master_Transmit_4
   \   00000140   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000144   0x.... 0x....      LDR.W    R2,??DataTable8_1  ;; 0x1ff0000
   \   00000148   0x25FF             MOVS     R5,#+255
   \   0000014A   0x4311             ORRS     R1,R2,R1
   \   0000014C   0x6041             STR      R1,[R0, #+4]
   \   0000014E   0xE7A4             B.N      ??HAL_I2C_Master_Transmit_3
   \                     ??HAL_I2C_Master_Transmit_10: (+1)
   \   00000150   0x2E00             CMP      R6,#+0
   \   00000152   0xD1A2             BNE.N    ??HAL_I2C_Master_Transmit_3
   \                     ??HAL_I2C_Master_Transmit_11: (+1)
   \   00000154   0x.... 0x....      BL       HAL_GetTick
   \   00000158   0x4682             MOV      R10,R0
   \                     ??HAL_I2C_Master_Transmit_15: (+1)
   \   0000015A   0x6820             LDR      R0,[R4, #+0]
   \   0000015C   0x6981             LDR      R1,[R0, #+24]
   \   0000015E   0x0689             LSLS     R1,R1,#+26
   \   00000160   0xD41E             BMI.N    ??HAL_I2C_Master_Transmit_16
   \   00000162   0x4649             MOV      R1,R9
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000016A   0xB990             CBNZ.N   R0,??HAL_I2C_Master_Transmit_17
   \   0000016C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000170   0xD005             BEQ.N    ??HAL_I2C_Master_Transmit_18
   \   00000172   0x.... 0x....      BL       HAL_GetTick
   \   00000176   0xEBA0 0x000A      SUB      R0,R0,R10
   \   0000017A   0x4581             CMP      R9,R0
   \   0000017C   0xD2ED             BCS.N    ??HAL_I2C_Master_Transmit_15
   \                     ??HAL_I2C_Master_Transmit_18: (+1)
   \   0000017E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000180   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000184   0x63A0             STR      R0,[R4, #+56]
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000018C   0x2000             MOVS     R0,#+0
   \   0000018E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Master_Transmit_17: (+1)
   \   00000192   0x6BA0             LDR      R0,[R4, #+56]
   \   00000194   0x2804             CMP      R0,#+4
   \   00000196   0xD114             BNE.N    ??HAL_I2C_Master_Transmit_9
   \   00000198   0x2001             MOVS     R0,#+1
   \   0000019A   0xB001             ADD      SP,SP,#+4
   \   0000019C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    594                }
    595              }
    596              
    597              /* Clear STOP Flag */
    598              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Transmit_16: (+1)
   \   000001A0   0x2120             MOVS     R1,#+32
    599            	
    600              /* Clear Configuration Register 2 */
    601              I2C_RESET_CR2(hi2c);
   \   000001A2   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0xfe00e800
   \   000001A6   0x61C1             STR      R1,[R0, #+28]
   \   000001A8   0x6820             LDR      R0,[R4, #+0]
   \   000001AA   0x6841             LDR      R1,[R0, #+4]
   \   000001AC   0x4011             ANDS     R1,R2,R1
   \   000001AE   0x6041             STR      R1,[R0, #+4]
    602              
    603              hi2c->State = HAL_I2C_STATE_READY; 	  
   \   000001B0   0x2001             MOVS     R0,#+1
   \   000001B2   0xF884 0x0035      STRB     R0,[R4, #+53]
    604              
    605              /* Process Unlocked */
    606              __HAL_UNLOCK(hi2c);
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0xF884 0x0034      STRB     R0,[R4, #+52]
    607              
    608              return HAL_OK;
   \   000001BC   0xB001             ADD      SP,SP,#+4
   \   000001BE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Transmit_9: (+1)
   \   000001C2   0x2003             MOVS     R0,#+3
   \   000001C4   0xB001             ADD      SP,SP,#+4
   \   000001C6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    609            }
    610            else
    611            {
    612              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \   000001CA   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \   000001CC   0xB001             ADD      SP,SP,#+4
   \   000001CE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    613            }
    614          }
    615          
    616          /**
    617            * @brief  Receives in master mode an amount of data in blocking mode. 
    618            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    619            *                the configuration information for the specified I2C.
    620            * @param  DevAddress: Target device address
    621            * @param  pData: Pointer to data buffer
    622            * @param  Size: Amount of data to be sent
    623            * @param  Timeout: Timeout duration
    624            * @retval HAL status
    625            */

   \                                 In section .text, align 4, keep-with-next
    626          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    627          {
   \                     HAL_I2C_Master_Receive: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x461E             MOV      R6,R3
    628            uint32_t sizetmp = 0;
    629            
    630            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80DF      BNE.W    ??HAL_I2C_Master_Receive_0
    631            {    
    632              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2E00             CMPNE    R6,#+0
   \   0000001E   0xF000 0x80DA      BEQ.W    ??HAL_I2C_Master_Receive_1
    633              {
    634                return  HAL_ERROR;                                    
    635              }
    636              
    637              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6982             LDR      R2,[R0, #+24]
   \   00000026   0x0412             LSLS     R2,R2,#+16
   \   00000028   0xF100 0x80D4      BMI.W    ??HAL_I2C_Master_Receive_0
    638              {
    639                return HAL_BUSY;
    640              }
    641              
    642              /* Process Locked */
    643              __HAL_LOCK(hi2c);
   \   0000002C   0xF894 0x2034      LDRB     R2,[R4, #+52]
   \   00000030   0x2A01             CMP      R2,#+1
   \   00000032   0xF000 0x80CF      BEQ.W    ??HAL_I2C_Master_Receive_0
   \   00000036   0x2201             MOVS     R2,#+1
    644              
    645              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
    646              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    647              
    648              /* Send Slave Address */
    649              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    650              /* Size > 255, need to set RELOAD bit */
    651              if(Size > 255)
   \   00000038   0x058F             LSLS     R7,R1,#+22
   \   0000003A   0xF884 0x2034      STRB     R2,[R4, #+52]
   \   0000003E   0x2222             MOVS     R2,#+34
   \   00000040   0xF884 0x2035      STRB     R2,[R4, #+53]
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x63A2             STR      R2,[R4, #+56]
   \   00000048   0x2EFF             CMP      R6,#+255
   \   0000004A   0x6841             LDR      R1,[R0, #+4]
   \   0000004C   0x.... 0x....      LDR.W    R8,??DataTable8  ;; 0xfc009800
   \   00000050   0xEA08 0x0101      AND      R1,R8,R1
   \   00000054   0xDD0A             BLE.N    ??HAL_I2C_Master_Receive_2
    652              {
    653                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000056   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
    654                sizetmp = 255;
   \   0000005A   0x25FF             MOVS     R5,#+255
   \   0000005C   0xF041 0x71FE      ORR      R1,R1,#0x1FC0000
   \   00000060   0xF441 0x3149      ORR      R1,R1,#0x32400
   \   00000064   0x6041             STR      R1,[R0, #+4]
   \   00000066   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   0000006A   0xE016             B.N      ??HAL_I2C_Master_Receive_3
    655              }
    656              else
    657              {
    658                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \   0000006C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000070   0xB2F2             UXTB     R2,R6
    659                sizetmp = Size;
   \   00000072   0x4635             MOV      R5,R6
   \   00000074   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000078   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000007C   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   00000080   0x6041             STR      R1,[R0, #+4]
   \   00000082   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   00000086   0xE008             B.N      ??HAL_I2C_Master_Receive_3
    660              }
    661              
    662              do
    663              {
    664                /* Wait until RXNE flag is set */
    665                if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, I2C_FLAG_RXNE) != HAL_OK)      
    666                {
    667                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    668                  {
    669                    return HAL_ERROR;
    670                  }
    671                  else
    672                  {
    673                    return HAL_TIMEOUT;
    674                  }
    675          	  }
    676                
    677                /* Write data to RXDR */
    678                (*pData++) =hi2c->Instance->RXDR;
    679                sizetmp--;
    680                Size--;
    681                
    682                if((sizetmp == 0)&&(Size!=0))
    683                {
    684                  /* Wait until TCR flag is set */
    685                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
    686                  {
    687                    return HAL_TIMEOUT;
    688                  }
    689                  
    690                  if(Size > 255)
    691                  {
    692                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    693                    sizetmp = 255;
    694                  }
    695                  else
    696                  {
    697                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \   00000088   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   0000008C   0xB2F2             UXTB     R2,R6
    698                    sizetmp = Size;
   \   0000008E   0x4635             MOV      R5,R6
   \   00000090   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000094   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000098   0x6041             STR      R1,[R0, #+4]
    699                  }
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \   0000009A   0x.... 0x....      BL       HAL_GetTick
   \   0000009E   0x4683             MOV      R11,R0
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6981             LDR      R1,[R0, #+24]
   \   000000A4   0x0749             LSLS     R1,R1,#+29
   \   000000A6   0xD429             BMI.N    ??HAL_I2C_Master_Receive_6
   \   000000A8   0x2104             MOVS     R1,#+4
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000B0   0xB998             CBNZ.N   R0,??HAL_I2C_Master_Receive_7
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x6981             LDR      R1,[R0, #+24]
   \   000000B6   0x0689             LSLS     R1,R1,#+26
   \   000000B8   0xD516             BPL.N    ??HAL_I2C_Master_Receive_8
   \   000000BA   0x2120             MOVS     R1,#+32
   \   000000BC   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0xfe00e800
   \   000000C0   0x61C1             STR      R1,[R0, #+28]
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6841             LDR      R1,[R0, #+4]
   \   000000C6   0x4011             ANDS     R1,R2,R1
   \   000000C8   0x6041             STR      R1,[R0, #+4]
   \   000000CA   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Receive_9: (+1)
   \   000000CC   0x63A0             STR      R0,[R4, #+56]
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \   000000DA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000DC   0x2804             CMP      R0,#+4
   \   000000DE   0xD175             BNE.N    ??HAL_I2C_Master_Receive_10
    700                }
    701                
    702              }while(Size > 0);
    703              
    704              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    705              /* Wait until STOPF flag is set */
    706              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    707              {
    708                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    709                {
    710                  return HAL_ERROR;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0xB001             ADD      SP,SP,#+4
   \   000000E4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \   000000E8   0x.... 0x....      BL       HAL_GetTick
   \   000000EC   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000F0   0x2805             CMP      R0,#+5
   \   000000F2   0xD3D5             BCC.N    ??HAL_I2C_Master_Receive_5
   \   000000F4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F6   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000FA   0xE7E7             B.N      ??HAL_I2C_Master_Receive_9
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \   000000FC   0x6A40             LDR      R0,[R0, #+36]
   \   000000FE   0x1E6D             SUBS     R5,R5,#+1
   \   00000100   0xF1A6 0x0601      SUB      R6,R6,#+1
   \   00000104   0xB2B6             UXTH     R6,R6
   \   00000106   0xF80A 0x0B01      STRB     R0,[R10], #+1
   \   0000010A   0xD129             BNE.N    ??HAL_I2C_Master_Receive_11
   \   0000010C   0xB356             CBZ.N    R6,??HAL_I2C_Master_Receive_12
   \   0000010E   0x.... 0x....      BL       HAL_GetTick
   \   00000112   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Master_Receive_13: (+1)
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6981             LDR      R1,[R0, #+24]
   \   00000118   0x0609             LSLS     R1,R1,#+24
   \   0000011A   0xD414             BMI.N    ??HAL_I2C_Master_Receive_14
   \   0000011C   0xF119 0x0F01      CMN      R9,#+1
   \   00000120   0xD0F8             BEQ.N    ??HAL_I2C_Master_Receive_13
   \   00000122   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000126   0xD004             BEQ.N    ??HAL_I2C_Master_Receive_15
   \   00000128   0x.... 0x....      BL       HAL_GetTick
   \   0000012C   0x1B40             SUBS     R0,R0,R5
   \   0000012E   0x4581             CMP      R9,R0
   \   00000130   0xD2F0             BCS.N    ??HAL_I2C_Master_Receive_13
   \                     ??HAL_I2C_Master_Receive_15: (+1)
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xF884 0x0034      STRB     R0,[R4, #+52]
    711                }
    712                else
    713                {
    714                  return HAL_TIMEOUT;
   \   0000013E   0x2003             MOVS     R0,#+3
   \   00000140   0xB001             ADD      SP,SP,#+4
   \   00000142   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Receive_14: (+1)
   \   00000146   0x2EFF             CMP      R6,#+255
   \   00000148   0x6841             LDR      R1,[R0, #+4]
   \   0000014A   0xEA08 0x0101      AND      R1,R8,R1
   \   0000014E   0xDD9B             BLE.N    ??HAL_I2C_Master_Receive_4
   \   00000150   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000154   0x.... 0x....      LDR.W    R2,??DataTable8_1  ;; 0x1ff0000
   \   00000158   0x25FF             MOVS     R5,#+255
   \   0000015A   0x4311             ORRS     R1,R2,R1
   \   0000015C   0x6041             STR      R1,[R0, #+4]
   \   0000015E   0xE79C             B.N      ??HAL_I2C_Master_Receive_3
   \                     ??HAL_I2C_Master_Receive_11: (+1)
   \   00000160   0x2E00             CMP      R6,#+0
   \   00000162   0xD19A             BNE.N    ??HAL_I2C_Master_Receive_3
   \                     ??HAL_I2C_Master_Receive_12: (+1)
   \   00000164   0x.... 0x....      BL       HAL_GetTick
   \   00000168   0x4682             MOV      R10,R0
   \                     ??HAL_I2C_Master_Receive_16: (+1)
   \   0000016A   0x6820             LDR      R0,[R4, #+0]
   \   0000016C   0x6981             LDR      R1,[R0, #+24]
   \   0000016E   0x0689             LSLS     R1,R1,#+26
   \   00000170   0xD41B             BMI.N    ??HAL_I2C_Master_Receive_17
   \   00000172   0x2119             MOVS     R1,#+25
   \   00000174   0x4620             MOV      R0,R4
   \   00000176   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000017A   0xB978             CBNZ.N   R0,??HAL_I2C_Master_Receive_18
   \   0000017C   0x.... 0x....      BL       HAL_GetTick
   \   00000180   0xEBA0 0x000A      SUB      R0,R0,R10
   \   00000184   0x281A             CMP      R0,#+26
   \   00000186   0xD3F0             BCC.N    ??HAL_I2C_Master_Receive_16
   \   00000188   0x6BA0             LDR      R0,[R4, #+56]
   \   0000018A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000018E   0x63A0             STR      R0,[R4, #+56]
   \   00000190   0x2001             MOVS     R0,#+1
   \   00000192   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Master_Receive_18: (+1)
   \   0000019C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000019E   0x2804             CMP      R0,#+4
   \   000001A0   0xD114             BNE.N    ??HAL_I2C_Master_Receive_10
   \   000001A2   0x2001             MOVS     R0,#+1
   \   000001A4   0xB001             ADD      SP,SP,#+4
   \   000001A6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    715                }
    716              }
    717              
    718              /* Clear STOP Flag */
    719              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Receive_17: (+1)
   \   000001AA   0x2120             MOVS     R1,#+32
    720            	
    721              /* Clear Configuration Register 2 */
    722              I2C_RESET_CR2(hi2c);
   \   000001AC   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0xfe00e800
   \   000001B0   0x61C1             STR      R1,[R0, #+28]
   \   000001B2   0x6820             LDR      R0,[R4, #+0]
   \   000001B4   0x6841             LDR      R1,[R0, #+4]
   \   000001B6   0x4011             ANDS     R1,R2,R1
   \   000001B8   0x6041             STR      R1,[R0, #+4]
    723              
    724              hi2c->State = HAL_I2C_STATE_READY; 	  
   \   000001BA   0x2001             MOVS     R0,#+1
   \   000001BC   0xF884 0x0035      STRB     R0,[R4, #+53]
    725              
    726              /* Process Unlocked */
    727              __HAL_UNLOCK(hi2c);
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0xF884 0x0034      STRB     R0,[R4, #+52]
    728              
    729              return HAL_OK;
   \   000001C6   0xB001             ADD      SP,SP,#+4
   \   000001C8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Receive_10: (+1)
   \   000001CC   0x2003             MOVS     R0,#+3
   \   000001CE   0xB001             ADD      SP,SP,#+4
   \   000001D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    730            }
    731            else
    732            {
    733              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \   000001D4   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \   000001D6   0xB001             ADD      SP,SP,#+4
   \   000001D8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    734            }
    735          }
    736          
    737          /**
    738            * @brief  Transmits in slave mode an amount of data in blocking mode. 
    739            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    740            *                the configuration information for the specified I2C.
    741            * @param  pData: Pointer to data buffer
    742            * @param  Size: Amount of data to be sent
    743            * @param  Timeout: Timeout duration
    744            * @retval HAL status
    745            */

   \                                 In section .text, align 4, keep-with-next
    746          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    747          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    748            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80FE      BNE.W    ??HAL_I2C_Slave_Transmit_0
    749            {    
    750              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2E00             CMPNE    R6,#+0
   \   0000001E   0xF000 0x80F9      BEQ.W    ??HAL_I2C_Slave_Transmit_1
    751              {
    752                return  HAL_ERROR;                                    
    753              }
    754              
    755              /* Process Locked */
    756              __HAL_LOCK(hi2c);
   \   00000022   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xF000 0x80F3      BEQ.W    ??HAL_I2C_Slave_Transmit_0
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
    757              
    758              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   \   00000032   0x2042             MOVS     R0,#+66
   \   00000034   0xF884 0x0035      STRB     R0,[R4, #+53]
    759              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x63A0             STR      R0,[R4, #+56]
    760              
    761              /* Enable Address Acknowledge */
    762              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6841             LDR      R1,[R0, #+4]
   \   00000040   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000044   0x6041             STR      R1,[R0, #+4]
    763              
    764              /* Wait until ADDR flag is set */
    765              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
   \   00000046   0x.... 0x....      BL       HAL_GetTick
   \   0000004A   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6981             LDR      R1,[R0, #+24]
   \   00000050   0x0709             LSLS     R1,R1,#+28
   \   00000052   0xD416             BMI.N    ??HAL_I2C_Slave_Transmit_3
   \   00000054   0xF117 0x0F01      CMN      R7,#+1
   \   00000058   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Transmit_2
   \   0000005A   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Transmit_4
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0x1B40             SUBS     R0,R0,R5
   \   00000062   0x4287             CMP      R7,R0
   \   00000064   0xD2F2             BCS.N    ??HAL_I2C_Slave_Transmit_2
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0034      STRB     R0,[R4, #+52]
    766              {
    767                /* Disable Address Acknowledge */
    768                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6841             LDR      R1,[R0, #+4]
   \   00000076   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000007A   0x6041             STR      R1,[R0, #+4]
    769                return HAL_TIMEOUT;
    770              }
    771              
    772              /* Clear ADDR flag */
    773              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
    774              
    775              /* If 10bit addressing mode is selected */
    776              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    777              {
    778                /* Wait until ADDR flag is set */
    779                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
    780                {
    781                  /* Disable Address Acknowledge */
    782                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    783                  return HAL_TIMEOUT;
    784                }
    785                
    786                /* Clear ADDR flag */
    787                __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
    788              }
    789              
    790              /* Wait until DIR flag is set Transmitter mode */
    791              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout) != HAL_OK)      
    792              {
    793                /* Disable Address Acknowledge */
    794                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    795                return HAL_TIMEOUT;
    796              }
    797              
    798              do
    799              {
    800                /* Wait until TXIS flag is set */
    801                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    802                {
    803                  /* Disable Address Acknowledge */
    804                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    805                  
    806                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    807                  {
    808                    return HAL_ERROR;
    809                  }
    810                  else
    811                  {
    812                    return HAL_TIMEOUT;
    813                  }
    814                }
    815                
    816                /* Read data from TXDR */
    817                hi2c->Instance->TXDR = (*pData++);
    818                Size--;
    819              }while(Size > 0);
    820              
    821              /* Wait until STOP flag is set */
    822              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    823              {
    824                /* Disable Address Acknowledge */
    825                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    826                
    827                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    828                {
    829                  /* Normal use case for Transmitter mode */
    830                  /* A NACK is generated to confirm the end of transfer */
    831                  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    832                }
    833                else
    834                {
    835                  return HAL_TIMEOUT;
   \   0000007C   0x2003             MOVS     R0,#+3
   \   0000007E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \   00000082   0x2108             MOVS     R1,#+8
   \   00000084   0x61C1             STR      R1,[R0, #+28]
   \   00000086   0x68E0             LDR      R0,[R4, #+12]
   \   00000088   0x2802             CMP      R0,#+2
   \   0000008A   0xD11F             BNE.N    ??HAL_I2C_Slave_Transmit_5
   \   0000008C   0x.... 0x....      BL       HAL_GetTick
   \   00000090   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6981             LDR      R1,[R0, #+24]
   \   00000096   0x0709             LSLS     R1,R1,#+28
   \   00000098   0xD416             BMI.N    ??HAL_I2C_Slave_Transmit_7
   \   0000009A   0xF117 0x0F01      CMN      R7,#+1
   \   0000009E   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Transmit_6
   \   000000A0   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Transmit_8
   \   000000A2   0x.... 0x....      BL       HAL_GetTick
   \   000000A6   0x1B40             SUBS     R0,R0,R5
   \   000000A8   0x4287             CMP      R7,R0
   \   000000AA   0xD2F2             BCS.N    ??HAL_I2C_Slave_Transmit_6
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6841             LDR      R1,[R0, #+4]
   \   000000BC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000C0   0x6041             STR      R1,[R0, #+4]
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \   000000C8   0x2108             MOVS     R1,#+8
   \   000000CA   0x61C1             STR      R1,[R0, #+28]
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \   000000CC   0x.... 0x....      BL       HAL_GetTick
   \   000000D0   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6980             LDR      R0,[R0, #+24]
   \   000000D6   0x03C0             LSLS     R0,R0,#+15
   \   000000D8   0xD416             BMI.N    ??HAL_I2C_Slave_Transmit_10
   \   000000DA   0xF117 0x0F01      CMN      R7,#+1
   \   000000DE   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Transmit_9
   \   000000E0   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Transmit_11
   \   000000E2   0x.... 0x....      BL       HAL_GetTick
   \   000000E6   0x1B40             SUBS     R0,R0,R5
   \   000000E8   0x4287             CMP      R7,R0
   \   000000EA   0xD2F2             BCS.N    ??HAL_I2C_Slave_Transmit_9
   \                     ??HAL_I2C_Slave_Transmit_11: (+1)
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6841             LDR      R1,[R0, #+4]
   \   000000FC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000100   0x6041             STR      R1,[R0, #+4]
   \   00000102   0x2003             MOVS     R0,#+3
   \   00000104   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Transmit_10: (+1)
   \   00000108   0x.... 0x....      BL       HAL_GetTick
   \   0000010C   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_12: (+1)
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x6981             LDR      R1,[R0, #+24]
   \   00000112   0x0789             LSLS     R1,R1,#+30
   \   00000114   0xD422             BMI.N    ??HAL_I2C_Slave_Transmit_13
   \   00000116   0x4639             MOV      R1,R7
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000011E   0xB990             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_14
   \   00000120   0xF117 0x0F01      CMN      R7,#+1
   \   00000124   0xD0F3             BEQ.N    ??HAL_I2C_Slave_Transmit_12
   \   00000126   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Transmit_15
   \   00000128   0x.... 0x....      BL       HAL_GetTick
   \   0000012C   0x1B40             SUBS     R0,R0,R5
   \   0000012E   0x4287             CMP      R7,R0
   \   00000130   0xD2ED             BCS.N    ??HAL_I2C_Slave_Transmit_12
   \                     ??HAL_I2C_Slave_Transmit_15: (+1)
   \   00000132   0x6BA0             LDR      R0,[R4, #+56]
   \   00000134   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000138   0x63A0             STR      R0,[R4, #+56]
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Slave_Transmit_14: (+1)
   \   00000146   0x6820             LDR      R0,[R4, #+0]
   \   00000148   0x6841             LDR      R1,[R0, #+4]
   \   0000014A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000014E   0x6041             STR      R1,[R0, #+4]
   \   00000150   0x6BA0             LDR      R0,[R4, #+56]
   \   00000152   0x2804             CMP      R0,#+4
   \   00000154   0xD14E             BNE.N    ??HAL_I2C_Slave_Transmit_16
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Transmit_13: (+1)
   \   0000015C   0x1E76             SUBS     R6,R6,#+1
   \   0000015E   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \   00000162   0xB2B6             UXTH     R6,R6
   \   00000164   0x2E00             CMP      R6,#+0
   \   00000166   0x6281             STR      R1,[R0, #+40]
   \   00000168   0xD1CE             BNE.N    ??HAL_I2C_Slave_Transmit_10
   \   0000016A   0x.... 0x....      BL       HAL_GetTick
   \   0000016E   0x4680             MOV      R8,R0
   \                     ??HAL_I2C_Slave_Transmit_17: (+1)
   \   00000170   0x6820             LDR      R0,[R4, #+0]
   \   00000172   0x6980             LDR      R0,[R0, #+24]
   \   00000174   0x0680             LSLS     R0,R0,#+26
   \   00000176   0xD41E             BMI.N    ??HAL_I2C_Slave_Transmit_18
   \   00000178   0x2119             MOVS     R1,#+25
   \   0000017A   0x4620             MOV      R0,R4
   \   0000017C   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000180   0xB978             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_19
   \   00000182   0x.... 0x....      BL       HAL_GetTick
   \   00000186   0xEBA0 0x0008      SUB      R0,R0,R8
   \   0000018A   0x281A             CMP      R0,#+26
   \   0000018C   0xD3F0             BCC.N    ??HAL_I2C_Slave_Transmit_17
   \   0000018E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000190   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000194   0x63A0             STR      R0,[R4, #+56]
   \   00000196   0x2001             MOVS     R0,#+1
   \   00000198   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Slave_Transmit_19: (+1)
   \   000001A2   0x6820             LDR      R0,[R4, #+0]
   \   000001A4   0x6841             LDR      R1,[R0, #+4]
   \   000001A6   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001AA   0x6041             STR      R1,[R0, #+4]
   \   000001AC   0x6BA0             LDR      R0,[R4, #+56]
   \   000001AE   0x2804             CMP      R0,#+4
   \   000001B0   0xD120             BNE.N    ??HAL_I2C_Slave_Transmit_16
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x63A0             STR      R0,[R4, #+56]
    836                }
    837              }
    838              
    839              /* Clear STOP flag */
    840              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Slave_Transmit_18: (+1)
   \   000001B6   0x6821             LDR      R1,[R4, #+0]
   \   000001B8   0x2020             MOVS     R0,#+32
   \   000001BA   0x61C8             STR      R0,[R1, #+28]
    841              
    842              /* Wait until BUSY flag is reset */ 
    843              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
   \   000001BC   0x.... 0x....      BL       HAL_GetTick
   \   000001C0   0x4680             MOV      R8,R0
   \                     ??HAL_I2C_Slave_Transmit_20: (+1)
   \   000001C2   0x6820             LDR      R0,[R4, #+0]
   \   000001C4   0x6981             LDR      R1,[R0, #+24]
   \   000001C6   0x0409             LSLS     R1,R1,#+16
   \   000001C8   0xD517             BPL.N    ??HAL_I2C_Slave_Transmit_21
   \   000001CA   0xF117 0x0F01      CMN      R7,#+1
   \   000001CE   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Transmit_20
   \   000001D0   0xB12F             CBZ.N    R7,??HAL_I2C_Slave_Transmit_22
   \   000001D2   0x.... 0x....      BL       HAL_GetTick
   \   000001D6   0xEBA0 0x0008      SUB      R0,R0,R8
   \   000001DA   0x4287             CMP      R7,R0
   \   000001DC   0xD2F1             BCS.N    ??HAL_I2C_Slave_Transmit_20
   \                     ??HAL_I2C_Slave_Transmit_22: (+1)
   \   000001DE   0x2001             MOVS     R0,#+1
   \   000001E0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xF884 0x0034      STRB     R0,[R4, #+52]
    844              {
    845                /* Disable Address Acknowledge */
    846                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   000001EA   0x6820             LDR      R0,[R4, #+0]
   \   000001EC   0x6841             LDR      R1,[R0, #+4]
   \   000001EE   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001F2   0x6041             STR      R1,[R0, #+4]
    847                return HAL_TIMEOUT;
    848              }
   \                     ??HAL_I2C_Slave_Transmit_16: (+1)
   \   000001F4   0x2003             MOVS     R0,#+3
   \   000001F6   0xE8BD 0x81F0      POP      {R4-R8,PC}
    849              
    850              /* Disable Address Acknowledge */
    851              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Slave_Transmit_21: (+1)
   \   000001FA   0x6841             LDR      R1,[R0, #+4]
   \   000001FC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000200   0x6041             STR      R1,[R0, #+4]
    852              
    853              hi2c->State = HAL_I2C_STATE_READY;
   \   00000202   0x2001             MOVS     R0,#+1
   \   00000204   0xF884 0x0035      STRB     R0,[R4, #+53]
    854              
    855              /* Process Unlocked */
    856              __HAL_UNLOCK(hi2c);
   \   00000208   0x2000             MOVS     R0,#+0
   \   0000020A   0xF884 0x0034      STRB     R0,[R4, #+52]
    857              
    858              return HAL_OK;
   \   0000020E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    859            }
    860            else
    861            {
    862              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \   00000212   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \   00000214   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    863            }
    864          }
    865          
    866          /**
    867            * @brief  Receive in slave mode an amount of data in blocking mode 
    868            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    869            *                the configuration information for the specified I2C.
    870            * @param  pData: Pointer to data buffer
    871            * @param  Size: Amount of data to be sent
    872            * @param  Timeout: Timeout duration
    873            * @retval HAL status
    874            */

   \                                 In section .text, align 4, keep-with-next
    875          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    876          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
    877            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80D4      BNE.W    ??HAL_I2C_Slave_Receive_0
    878            {  
    879              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xBF18             IT       NE 
   \   0000001A   0xF1B8 0x0F00      CMPNE    R8,#+0
   \   0000001E   0xF000 0x80CF      BEQ.W    ??HAL_I2C_Slave_Receive_1
    880              {
    881                return  HAL_ERROR;                                    
    882              }
    883              
    884              /* Process Locked */
    885              __HAL_LOCK(hi2c);
   \   00000022   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xF000 0x80C9      BEQ.W    ??HAL_I2C_Slave_Receive_0
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
    886              
    887              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   \   00000032   0x2042             MOVS     R0,#+66
   \   00000034   0xF884 0x0035      STRB     R0,[R4, #+53]
    888              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x63A0             STR      R0,[R4, #+56]
    889              
    890              /* Enable Address Acknowledge */
    891              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6841             LDR      R1,[R0, #+4]
   \   00000040   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000044   0x6041             STR      R1,[R0, #+4]
    892              
    893              /* Wait until ADDR flag is set */
    894              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
   \   00000046   0x.... 0x....      BL       HAL_GetTick
   \   0000004A   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6981             LDR      R1,[R0, #+24]
   \   00000050   0x0709             LSLS     R1,R1,#+28
   \   00000052   0xD40B             BMI.N    ??HAL_I2C_Slave_Receive_3
   \   00000054   0xF117 0x0F01      CMN      R7,#+1
   \   00000058   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Receive_2
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xF000 0x8095      BEQ.W    ??HAL_I2C_Slave_Receive_4
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0x1B80             SUBS     R0,R0,R6
   \   00000066   0x4287             CMP      R7,R0
   \   00000068   0xD2F0             BCS.N    ??HAL_I2C_Slave_Receive_2
   \   0000006A   0xE08E             B.N      ??HAL_I2C_Slave_Receive_4
    895              {
    896                /* Disable Address Acknowledge */
    897                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    898                return HAL_TIMEOUT;
    899              }
    900              
    901              /* Clear ADDR flag */
    902              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \   0000006C   0x2108             MOVS     R1,#+8
   \   0000006E   0x61C1             STR      R1,[R0, #+28]
    903              
    904              /* Wait until DIR flag is reset Receiver mode */
    905              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout) != HAL_OK)      
   \   00000070   0x.... 0x....      BL       HAL_GetTick
   \   00000074   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6980             LDR      R0,[R0, #+24]
   \   0000007A   0x03C0             LSLS     R0,R0,#+15
   \   0000007C   0xD50C             BPL.N    ??HAL_I2C_Slave_Receive_6
   \   0000007E   0xF117 0x0F01      CMN      R7,#+1
   \   00000082   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Receive_5
   \   00000084   0x2F00             CMP      R7,#+0
   \   00000086   0xF000 0x8080      BEQ.W    ??HAL_I2C_Slave_Receive_4
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0x1B80             SUBS     R0,R0,R6
   \   00000090   0x4287             CMP      R7,R0
   \   00000092   0xD2F0             BCS.N    ??HAL_I2C_Slave_Receive_5
   \   00000094   0xE079             B.N      ??HAL_I2C_Slave_Receive_4
   \   00000096   0xBF00             Nop      
    906              {
    907                /* Disable Address Acknowledge */
    908                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    909                return HAL_TIMEOUT;
    910              }
    911              
    912              while(Size > 0)
    913              {
    914                /* Wait until RXNE flag is set */
    915                if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \   00000098   0x.... 0x....      BL       HAL_GetTick
   \   0000009C   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x6981             LDR      R1,[R0, #+24]
   \   000000A2   0x0749             LSLS     R1,R1,#+29
   \   000000A4   0xD433             BMI.N    ??HAL_I2C_Slave_Receive_8
   \   000000A6   0x4639             MOV      R1,R7
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000AE   0xB998             CBNZ.N   R0,??HAL_I2C_Slave_Receive_9
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6981             LDR      R1,[R0, #+24]
   \   000000B4   0x0689             LSLS     R1,R1,#+26
   \   000000B6   0xD520             BPL.N    ??HAL_I2C_Slave_Receive_10
   \   000000B8   0x2120             MOVS     R1,#+32
   \   000000BA   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0xfe00e800
   \   000000BE   0x61C1             STR      R1,[R0, #+28]
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6841             LDR      R1,[R0, #+4]
   \   000000C4   0x4011             ANDS     R1,R2,R1
   \   000000C6   0x6041             STR      R1,[R0, #+4]
   \   000000C8   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Slave_Receive_11: (+1)
   \   000000CA   0x63A0             STR      R0,[R4, #+56]
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF884 0x0034      STRB     R0,[R4, #+52]
    916                {
    917                  /* Disable Address Acknowledge */
    918                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6841             LDR      R1,[R0, #+4]
   \   000000DC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000E0   0x6041             STR      R1,[R0, #+4]
    919                  
    920                  /* Store Last receive data if any */
    921                  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6981             LDR      R1,[R0, #+24]
   \   000000E6   0x0749             LSLS     R1,R1,#+29
   \   000000E8   0xBF44             ITT      MI 
   \   000000EA   0x6A40             LDRMI    R0,[R0, #+36]
   \   000000EC   0x7028             STRBMI   R0,[R5, #+0]
    922                  {
    923                    /* Read data from RXDR */
    924                    (*pData++) = hi2c->Instance->RXDR;
    925                  }
    926                  
    927                  if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   000000EE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F0   0x2820             CMP      R0,#+32
   \   000000F2   0xD135             BNE.N    ??HAL_I2C_Slave_Receive_12
    928                  {
    929                    return HAL_TIMEOUT;
    930                  }
    931                  else
    932                  {
    933                    return HAL_ERROR;
    934                  }
    935                }
    936                
    937                /* Read data from RXDR */
    938                (*pData++) = hi2c->Instance->RXDR;
    939                Size--;
    940              }
    941              
    942              /* Wait until STOP flag is set */
    943              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    944              {
    945                /* Disable Address Acknowledge */
    946                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    947                
    948                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    949                {
    950                  return HAL_ERROR;
    951                }
    952                else
    953                {
    954                  return HAL_TIMEOUT;
    955                }
    956              }
    957              
    958              /* Clear STOP flag */
    959              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
    960              
    961              /* Wait until BUSY flag is reset */ 
    962              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
    963              {
    964                /* Disable Address Acknowledge */
    965                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    966                return HAL_TIMEOUT;
   \   000000F4   0x2003             MOVS     R0,#+3
   \   000000F6   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Receive_10: (+1)
   \   000000FA   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Receive_13
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0x1B80             SUBS     R0,R0,R6
   \   00000102   0x4287             CMP      R7,R0
   \   00000104   0xD2CB             BCS.N    ??HAL_I2C_Slave_Receive_7
   \                     ??HAL_I2C_Slave_Receive_13: (+1)
   \   00000106   0x6BA0             LDR      R0,[R4, #+56]
   \   00000108   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010C   0xE7DD             B.N      ??HAL_I2C_Slave_Receive_11
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \   0000010E   0x6A40             LDR      R0,[R0, #+36]
   \   00000110   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000114   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   00000118   0xD1BE             BNE.N    ??HAL_I2C_Slave_Receive_6
   \   0000011A   0x.... 0x....      BL       HAL_GetTick
   \   0000011E   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Receive_14: (+1)
   \   00000120   0x6820             LDR      R0,[R4, #+0]
   \   00000122   0x6981             LDR      R1,[R0, #+24]
   \   00000124   0x0689             LSLS     R1,R1,#+26
   \   00000126   0xD41E             BMI.N    ??HAL_I2C_Slave_Receive_15
   \   00000128   0x2119             MOVS     R1,#+25
   \   0000012A   0x4620             MOV      R0,R4
   \   0000012C   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000130   0xB970             CBNZ.N   R0,??HAL_I2C_Slave_Receive_16
   \   00000132   0x.... 0x....      BL       HAL_GetTick
   \   00000136   0x1B40             SUBS     R0,R0,R5
   \   00000138   0x281A             CMP      R0,#+26
   \   0000013A   0xD3F1             BCC.N    ??HAL_I2C_Slave_Receive_14
   \   0000013C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000013E   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000142   0x63A0             STR      R0,[R4, #+56]
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Slave_Receive_16: (+1)
   \   00000150   0x6820             LDR      R0,[R4, #+0]
   \   00000152   0x6841             LDR      R1,[R0, #+4]
   \   00000154   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000158   0x6041             STR      R1,[R0, #+4]
   \   0000015A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000015C   0x2804             CMP      R0,#+4
   \   0000015E   0xD11F             BNE.N    ??HAL_I2C_Slave_Receive_17
   \                     ??HAL_I2C_Slave_Receive_12: (+1)
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Receive_15: (+1)
   \   00000166   0x2120             MOVS     R1,#+32
   \   00000168   0x61C1             STR      R1,[R0, #+28]
   \   0000016A   0x.... 0x....      BL       HAL_GetTick
   \   0000016E   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Receive_18: (+1)
   \   00000170   0x6820             LDR      R0,[R4, #+0]
   \   00000172   0x6981             LDR      R1,[R0, #+24]
   \   00000174   0x0409             LSLS     R1,R1,#+16
   \   00000176   0xD516             BPL.N    ??HAL_I2C_Slave_Receive_19
   \   00000178   0xF117 0x0F01      CMN      R7,#+1
   \   0000017C   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Receive_18
   \   0000017E   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Receive_4
   \   00000180   0x.... 0x....      BL       HAL_GetTick
   \   00000184   0x1B40             SUBS     R0,R0,R5
   \   00000186   0x4287             CMP      R7,R0
   \   00000188   0xD2F2             BCS.N    ??HAL_I2C_Slave_Receive_18
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000196   0x6820             LDR      R0,[R4, #+0]
   \   00000198   0x6841             LDR      R1,[R0, #+4]
   \   0000019A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000019E   0x6041             STR      R1,[R0, #+4]
   \                     ??HAL_I2C_Slave_Receive_17: (+1)
   \   000001A0   0x2003             MOVS     R0,#+3
   \   000001A2   0xE8BD 0x81F0      POP      {R4-R8,PC}
    967              }
    968              
    969              
    970              /* Disable Address Acknowledge */
    971              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Slave_Receive_19: (+1)
   \   000001A6   0x6841             LDR      R1,[R0, #+4]
   \   000001A8   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001AC   0x6041             STR      R1,[R0, #+4]
    972              
    973              hi2c->State = HAL_I2C_STATE_READY;
   \   000001AE   0x2001             MOVS     R0,#+1
   \   000001B0   0xF884 0x0035      STRB     R0,[R4, #+53]
    974              
    975              /* Process Unlocked */
    976              __HAL_UNLOCK(hi2c);
   \   000001B4   0x2000             MOVS     R0,#+0
   \   000001B6   0xF884 0x0034      STRB     R0,[R4, #+52]
    977              
    978              return HAL_OK;
   \   000001BA   0xE8BD 0x81F0      POP      {R4-R8,PC}
    979            }
    980            else
    981            {
    982              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \   000001BE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \   000001C0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    983            } 
    984          }
    985          
    986          /**
    987            * @brief  Transmit in master mode an amount of data in no-blocking mode with Interrupt
    988            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    989            *                the configuration information for the specified I2C.
    990            * @param  DevAddress: Target device address
    991            * @param  pData: Pointer to data buffer
    992            * @param  Size: Amount of data to be sent
    993            * @retval HAL status
    994            */

   \                                 In section .text, align 2, keep-with-next
    995          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    996          {   
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    997            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000002   0xF890 0x4035      LDRB     R4,[R0, #+53]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD147             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
    998            {
    999              if((pData == NULL) || (Size == 0)) 
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xBF14             ITE      NE 
   \   0000000E   0x2B00             CMPNE    R3,#+0
   \   00000010   0x2001             MOVEQ    R0,#+1
   1000              {
   1001                return  HAL_ERROR;                                    
   \   00000012   0xD043             BEQ.N    ??HAL_I2C_Master_Transmit_IT_1
   1002              }
   1003              
   1004              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000014   0x6804             LDR      R4,[R0, #+0]
   \   00000016   0x69A5             LDR      R5,[R4, #+24]
   \   00000018   0x042D             LSLS     R5,R5,#+16
   \   0000001A   0xD43E             BMI.N    ??HAL_I2C_Master_Transmit_IT_0
   1005              {
   1006                return HAL_BUSY;
   1007              }
   1008              
   1009              /* Process Locked */
   1010              __HAL_LOCK(hi2c);
   \   0000001C   0xF890 0x5034      LDRB     R5,[R0, #+52]
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD03A             BEQ.N    ??HAL_I2C_Master_Transmit_IT_0
   \   00000024   0x2501             MOVS     R5,#+1
   \   00000026   0xF880 0x5034      STRB     R5,[R0, #+52]
   1011              
   1012              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
   \   0000002A   0x2512             MOVS     R5,#+18
   \   0000002C   0xF880 0x5035      STRB     R5,[R0, #+53]
   1013              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000030   0x2500             MOVS     R5,#+0
   \   00000032   0x6385             STR      R5,[R0, #+56]
   1014              
   1015              hi2c->pBuffPtr = pData;
   1016              hi2c->XferCount = Size;
   1017              if(Size > 255)
   \   00000034   0x2BFF             CMP      R3,#+255
   \   00000036   0x6242             STR      R2,[R0, #+36]
   \   00000038   0x8543             STRH     R3,[R0, #+42]
   \   0000003A   0xBFC6             ITTE     GT 
   \   0000003C   0x22FF             MOVGT    R2,#+255
   \   0000003E   0x8502             STRHGT   R2,[R0, #+40]
   \   00000040   0x8503             STRHLE   R3,[R0, #+40]
   1018              {
   1019                hi2c->XferSize = 255;
   1020              }
   1021              else
   1022              {
   1023                hi2c->XferSize = Size;
   1024              }
   1025              
   1026              /* Send Slave Address */
   1027              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1028              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000042   0x8D02             LDRH     R2,[R0, #+40]
   \   00000044   0x2AFF             CMP      R2,#+255
   \   00000046   0xD10E             BNE.N    ??HAL_I2C_Master_Transmit_IT_2
   \   00000048   0x8D43             LDRH     R3,[R0, #+42]
   \   0000004A   0x429A             CMP      R2,R3
   \   0000004C   0xD20B             BCS.N    ??HAL_I2C_Master_Transmit_IT_2
   1029              {
   1030                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   0000004E   0x6863             LDR      R3,[R4, #+4]
   \   00000050   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0xfc009800
   \   00000054   0x0589             LSLS     R1,R1,#+22
   \   00000056   0x402B             ANDS     R3,R5,R3
   \   00000058   0xEA53 0x5191      ORRS     R1,R3,R1, LSR #+22
   \   0000005C   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000060   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000064   0xE00B             B.N      ??HAL_I2C_Master_Transmit_IT_3
   1031              }
   1032              else
   1033              {
   1034                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_IT_2: (+1)
   \   00000066   0x6863             LDR      R3,[R4, #+4]
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0xfc009800
   \   0000006C   0x0589             LSLS     R1,R1,#+22
   \   0000006E   0xB2D2             UXTB     R2,R2
   \   00000070   0x402B             ANDS     R3,R5,R3
   \   00000072   0xEA53 0x5191      ORRS     R1,R3,R1, LSR #+22
   \   00000076   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000007A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Master_Transmit_IT_3: (+1)
   \   0000007E   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000082   0x6061             STR      R1,[R4, #+4]
   1035              }
   1036              
   1037              /* Process Unlocked */
   1038              __HAL_UNLOCK(hi2c); 
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0xF880 0x1034      STRB     R1,[R0, #+52]
   1039              
   1040              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1041              to avoid the risk of I2C interrupt handle execution before current
   1042              process unlock */
   1043              
   1044              
   1045              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1046              /* possible to enable all of these */
   1047              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1048              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x01F2      ORR      R1,R1,#0xF2
   \   00000092   0x6001             STR      R1,[R0, #+0]
   1049              
   1050              return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBC30             POP      {R4,R5}
   \   00000098   0x4770             BX       LR
   1051            }
   1052            else
   1053            {
   1054              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \   0000009A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_IT_1: (+1)
   \   0000009C   0xBC30             POP      {R4,R5}
   \   0000009E   0x4770             BX       LR               ;; return
   1055            } 
   1056          }
   1057          
   1058          /**
   1059            * @brief  Receive in master mode an amount of data in no-blocking mode with Interrupt
   1060            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1061            *                the configuration information for the specified I2C.
   1062            * @param  DevAddress: Target device address
   1063            * @param  pData: Pointer to data buffer
   1064            * @param  Size: Amount of data to be sent
   1065            * @retval HAL status
   1066            */

   \                                 In section .text, align 2, keep-with-next
   1067          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1068          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1069            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000002   0xF890 0x4035      LDRB     R4,[R0, #+53]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD147             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1070            {
   1071              if((pData == NULL) || (Size == 0)) 
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xBF14             ITE      NE 
   \   0000000E   0x2B00             CMPNE    R3,#+0
   \   00000010   0x2001             MOVEQ    R0,#+1
   1072              {
   1073                return  HAL_ERROR;                                    
   \   00000012   0xD043             BEQ.N    ??HAL_I2C_Master_Receive_IT_1
   1074              }
   1075              
   1076              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000014   0x6804             LDR      R4,[R0, #+0]
   \   00000016   0x69A5             LDR      R5,[R4, #+24]
   \   00000018   0x042D             LSLS     R5,R5,#+16
   \   0000001A   0xD43E             BMI.N    ??HAL_I2C_Master_Receive_IT_0
   1077              {
   1078                return HAL_BUSY;
   1079              }
   1080              
   1081              /* Process Locked */
   1082              __HAL_LOCK(hi2c);
   \   0000001C   0xF890 0x5034      LDRB     R5,[R0, #+52]
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD03A             BEQ.N    ??HAL_I2C_Master_Receive_IT_0
   \   00000024   0x2501             MOVS     R5,#+1
   \   00000026   0xF880 0x5034      STRB     R5,[R0, #+52]
   1083              
   1084              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
   \   0000002A   0x2522             MOVS     R5,#+34
   \   0000002C   0xF880 0x5035      STRB     R5,[R0, #+53]
   1085              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000030   0x2500             MOVS     R5,#+0
   \   00000032   0x6385             STR      R5,[R0, #+56]
   1086              
   1087              hi2c->pBuffPtr = pData;
   1088              hi2c->XferCount = Size;
   1089              if(Size > 255)
   \   00000034   0x2BFF             CMP      R3,#+255
   \   00000036   0x6242             STR      R2,[R0, #+36]
   \   00000038   0x8543             STRH     R3,[R0, #+42]
   \   0000003A   0xBFC6             ITTE     GT 
   \   0000003C   0x22FF             MOVGT    R2,#+255
   \   0000003E   0x8502             STRHGT   R2,[R0, #+40]
   \   00000040   0x8503             STRHLE   R3,[R0, #+40]
   1090              {
   1091                hi2c->XferSize = 255;
   1092              }
   1093              else
   1094              {
   1095                hi2c->XferSize = Size;
   1096              }
   1097              
   1098              /* Send Slave Address */
   1099              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1100              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000042   0x8D02             LDRH     R2,[R0, #+40]
   \   00000044   0x2AFF             CMP      R2,#+255
   \   00000046   0xD10E             BNE.N    ??HAL_I2C_Master_Receive_IT_2
   \   00000048   0x8D43             LDRH     R3,[R0, #+42]
   \   0000004A   0x429A             CMP      R2,R3
   \   0000004C   0xD20B             BCS.N    ??HAL_I2C_Master_Receive_IT_2
   1101              {
   1102                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   0000004E   0x6863             LDR      R3,[R4, #+4]
   \   00000050   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0xfc009800
   \   00000054   0x0589             LSLS     R1,R1,#+22
   \   00000056   0x402B             ANDS     R3,R5,R3
   \   00000058   0xEA53 0x5191      ORRS     R1,R3,R1, LSR #+22
   \   0000005C   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000060   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000064   0xE00B             B.N      ??HAL_I2C_Master_Receive_IT_3
   1103              }
   1104              else
   1105              {
   1106                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_IT_2: (+1)
   \   00000066   0x6863             LDR      R3,[R4, #+4]
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0xfc009800
   \   0000006C   0x0589             LSLS     R1,R1,#+22
   \   0000006E   0xB2D2             UXTB     R2,R2
   \   00000070   0x402B             ANDS     R3,R5,R3
   \   00000072   0xEA53 0x5191      ORRS     R1,R3,R1, LSR #+22
   \   00000076   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000007A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Master_Receive_IT_3: (+1)
   \   0000007E   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   00000082   0x6061             STR      R1,[R4, #+4]
   1107              }
   1108              
   1109              /* Process Unlocked */
   1110              __HAL_UNLOCK(hi2c); 
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0xF880 0x1034      STRB     R1,[R0, #+52]
   1111              
   1112              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1113              to avoid the risk of I2C interrupt handle execution before current
   1114              process unlock */
   1115              
   1116              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1117              /* possible to enable all of these */
   1118              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1119              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI );
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x01F4      ORR      R1,R1,#0xF4
   \   00000092   0x6001             STR      R1,[R0, #+0]
   1120              
   1121              return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBC30             POP      {R4,R5}
   \   00000098   0x4770             BX       LR
   1122            }
   1123            else
   1124            {
   1125              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \   0000009A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_IT_1: (+1)
   \   0000009C   0xBC30             POP      {R4,R5}
   \   0000009E   0x4770             BX       LR               ;; return
   1126            } 
   1127          }
   1128          
   1129          /**
   1130            * @brief  Transmit in slave mode an amount of data in no-blocking mode with Interrupt 
   1131            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1132            *                the configuration information for the specified I2C.
   1133            * @param  pData: Pointer to data buffer
   1134            * @param  Size: Amount of data to be sent
   1135            * @retval HAL status
   1136            */

   \                                 In section .text, align 2, keep-with-next
   1137          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1138          {
   1139            if(hi2c->State == HAL_I2C_STATE_READY)
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \   00000000   0xF890 0x3035      LDRB     R3,[R0, #+53]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD125             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1140            {
   1141              if((pData == NULL) || (Size == 0)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_1
   1142              {
   1143                return  HAL_ERROR;                                    
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   1144              }
   1145              
   1146              /* Process Locked */
   1147              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_IT_1: (+1)
   \   00000014   0xF890 0x3034      LDRB     R3,[R0, #+52]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD01B             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF880 0x3034      STRB     R3,[R0, #+52]
   1148              
   1149              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
   \   00000022   0x2332             MOVS     R3,#+50
   \   00000024   0xF880 0x3035      STRB     R3,[R0, #+53]
   1150              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x6383             STR      R3,[R0, #+56]
   1151              
   1152              /* Enable Address Acknowledge */
   1153              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   0000002C   0x6803             LDR      R3,[R0, #+0]
   \   0000002E   0xF8D3 0xC004      LDR      R12,[R3, #+4]
   \   00000032   0xF42C 0x4C00      BIC      R12,R12,#0x8000
   \   00000036   0xF8C3 0xC004      STR      R12,[R3, #+4]
   1154              
   1155              hi2c->pBuffPtr = pData;
   \   0000003A   0x6241             STR      R1,[R0, #+36]
   1156              hi2c->XferSize = Size;
   1157              hi2c->XferCount = Size;
   1158              
   1159              /* Process Unlocked */
   1160              __HAL_UNLOCK(hi2c); 
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x8502             STRH     R2,[R0, #+40]
   \   00000040   0x8542             STRH     R2,[R0, #+42]
   \   00000042   0xF880 0x1034      STRB     R1,[R0, #+52]
   1161              
   1162              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1163              to avoid the risk of I2C interrupt handle execution before current
   1164              process unlock */
   1165              
   1166              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1167              /* possible to enable all of these */
   1168              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1169              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_TXI );
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x01FA      ORR      R1,R1,#0xFA
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1170              
   1171              return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR
   1172            }
   1173            else
   1174            {
   1175              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x4770             BX       LR               ;; return
   1176            } 
   1177          }
   1178          
   1179          /**
   1180            * @brief  Receive in slave mode an amount of data in no-blocking mode with Interrupt 
   1181            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1182            *                the configuration information for the specified I2C.
   1183            * @param  pData: Pointer to data buffer
   1184            * @param  Size: Amount of data to be sent
   1185            * @retval HAL status
   1186            */

   \                                 In section .text, align 2, keep-with-next
   1187          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1188          {
   1189            if(hi2c->State == HAL_I2C_STATE_READY)
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \   00000000   0xF890 0x3035      LDRB     R3,[R0, #+53]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD125             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1190            {
   1191              if((pData == NULL) || (Size == 0)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_1
   1192              {
   1193                return  HAL_ERROR;                                    
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   1194              }
   1195              
   1196              /* Process Locked */
   1197              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_IT_1: (+1)
   \   00000014   0xF890 0x3034      LDRB     R3,[R0, #+52]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD01B             BEQ.N    ??HAL_I2C_Slave_Receive_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF880 0x3034      STRB     R3,[R0, #+52]
   1198              
   1199              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   \   00000022   0x2342             MOVS     R3,#+66
   \   00000024   0xF880 0x3035      STRB     R3,[R0, #+53]
   1200              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x6383             STR      R3,[R0, #+56]
   1201              
   1202              /* Enable Address Acknowledge */
   1203              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   0000002C   0x6803             LDR      R3,[R0, #+0]
   \   0000002E   0xF8D3 0xC004      LDR      R12,[R3, #+4]
   \   00000032   0xF42C 0x4C00      BIC      R12,R12,#0x8000
   \   00000036   0xF8C3 0xC004      STR      R12,[R3, #+4]
   1204              
   1205              hi2c->pBuffPtr = pData;
   \   0000003A   0x6241             STR      R1,[R0, #+36]
   1206              hi2c->XferSize = Size;
   1207              hi2c->XferCount = Size;
   1208              
   1209              /* Process Unlocked */
   1210              __HAL_UNLOCK(hi2c); 
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x8502             STRH     R2,[R0, #+40]
   \   00000040   0x8542             STRH     R2,[R0, #+42]
   \   00000042   0xF880 0x1034      STRB     R1,[R0, #+52]
   1211              
   1212              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1213              to avoid the risk of I2C interrupt handle execution before current
   1214              process unlock */
   1215              
   1216              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1217              /* possible to enable all of these */
   1218              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1219              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI);
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x01FC      ORR      R1,R1,#0xFC
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1220              
   1221              return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR
   1222            }
   1223            else
   1224            {
   1225              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x4770             BX       LR               ;; return
   1226            }
   1227          }
   1228          
   1229          /**
   1230            * @brief  Transmit in master mode an amount of data in no-blocking mode with DMA
   1231            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1232            *                the configuration information for the specified I2C.
   1233            * @param  DevAddress: Target device address
   1234            * @param  pData: Pointer to data buffer
   1235            * @param  Size: Amount of data to be sent
   1236            * @retval HAL status
   1237            */

   \                                 In section .text, align 2, keep-with-next
   1238          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1239          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
   1240            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD17D             BNE.N    ??HAL_I2C_Master_Transmit_DMA_0
   1241            {
   1242              if((pData == NULL) || (Size == 0)) 
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2B00             CMPNE    R3,#+0
   \   00000018   0xD07A             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_1
   1243              {
   1244                return  HAL_ERROR;                                    
   1245              }     
   1246              
   1247              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0x0400             LSLS     R0,R0,#+16
   \   00000020   0xD475             BMI.N    ??HAL_I2C_Master_Transmit_DMA_0
   1248              {
   1249                return HAL_BUSY;
   1250              }
   1251              
   1252              /* Process Locked */
   1253              __HAL_LOCK(hi2c);
   \   00000022   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD071             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_0
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x0034      STRB     R0,[R4, #+52]
   1254              
   1255              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
   \   00000030   0x2012             MOVS     R0,#+18
   \   00000032   0xF884 0x0035      STRB     R0,[R4, #+53]
   1256              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x63A0             STR      R0,[R4, #+56]
   1257              
   1258              hi2c->pBuffPtr = pData;
   1259              hi2c->XferCount = Size;
   1260              if(Size > 255)
   \   0000003A   0x2BFF             CMP      R3,#+255
   \   0000003C   0x6261             STR      R1,[R4, #+36]
   \   0000003E   0x8563             STRH     R3,[R4, #+42]
   \   00000040   0xBFC6             ITTE     GT 
   \   00000042   0x20FF             MOVGT    R0,#+255
   \   00000044   0x8520             STRHGT   R0,[R4, #+40]
   \   00000046   0x8523             STRHLE   R3,[R4, #+40]
   1261              {
   1262                hi2c->XferSize = 255;
   1263              }
   1264              else
   1265              {
   1266                hi2c->XferSize = Size;
   1267              }
   1268              
   1269              /* Set the I2C DMA transfer complete callback */
   1270              hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \   00000048   0x6AE2             LDR      R2,[R4, #+44]
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000004E   0x63D0             STR      R0,[R2, #+60]
   1271              
   1272              /* Set the DMA error callback */
   1273              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   00000050   0x6AE2             LDR      R2,[R4, #+44]
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000056   0x6490             STR      R0,[R2, #+72]
   1274              
   1275              /* Enable the DMA channel */
   1276              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x8D23             LDRH     R3,[R4, #+40]
   \   0000005C   0xF100 0x0228      ADD      R2,R0,#+40
   \   00000060   0x6AE0             LDR      R0,[R4, #+44]
   \   00000062   0x.... 0x....      BL       HAL_DMA_Start_IT
   1277              
   1278              /* Send Slave Address */
   1279              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1280              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000066   0x8D21             LDRH     R1,[R4, #+40]
   \   00000068   0x29FF             CMP      R1,#+255
   \   0000006A   0xD10E             BNE.N    ??HAL_I2C_Master_Transmit_DMA_2
   \   0000006C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000006E   0x4281             CMP      R1,R0
   \   00000070   0xD20B             BCS.N    ??HAL_I2C_Master_Transmit_DMA_2
   1281              {
   1282                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x....             LDR.N    R3,??DataTable8  ;; 0xfc009800
   \   00000076   0x6842             LDR      R2,[R0, #+4]
   \   00000078   0x401A             ANDS     R2,R3,R2
   \   0000007A   0x05AB             LSLS     R3,R5,#+22
   \   0000007C   0xEA52 0x5293      ORRS     R2,R2,R3, LSR #+22
   \   00000080   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000084   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000088   0xE00B             B.N      ??HAL_I2C_Master_Transmit_DMA_3
   1283              }
   1284              else
   1285              {
   1286                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x....             LDR.N    R3,??DataTable8  ;; 0xfc009800
   \   0000008E   0xB2C9             UXTB     R1,R1
   \   00000090   0x6842             LDR      R2,[R0, #+4]
   \   00000092   0x401A             ANDS     R2,R3,R2
   \   00000094   0x05AB             LSLS     R3,R5,#+22
   \   00000096   0xEA52 0x5293      ORRS     R2,R2,R3, LSR #+22
   \   0000009A   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000009E   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \   000000A2   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   1287              }  
   1288              
   1289              /* Wait until TXIS flag is set */
   1290              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   000000A8   0x.... 0x....      BL       HAL_GetTick
   \   000000AC   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6981             LDR      R1,[R0, #+24]
   \   000000B2   0x0789             LSLS     R1,R1,#+30
   \   000000B4   0xD422             BMI.N    ??HAL_I2C_Master_Transmit_DMA_5
   \   000000B6   0x2119             MOVS     R1,#+25
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000BE   0xB970             CBNZ.N   R0,??HAL_I2C_Master_Transmit_DMA_6
   \   000000C0   0x.... 0x....      BL       HAL_GetTick
   \   000000C4   0x1B40             SUBS     R0,R0,R5
   \   000000C6   0x281A             CMP      R0,#+26
   \   000000C8   0xD3F1             BCC.N    ??HAL_I2C_Master_Transmit_DMA_4
   \   000000CA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000D0   0x63A0             STR      R0,[R4, #+56]
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x0034      STRB     R0,[R4, #+52]
   1291              {
   1292                /* Disable Address Acknowledge */
   1293                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Master_Transmit_DMA_6: (+1)
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6841             LDR      R1,[R0, #+4]
   \   000000E2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000E6   0x6041             STR      R1,[R0, #+4]
   1294                
   1295                /* Abort DMA */
   1296                HAL_DMA_Abort(hi2c->hdmatx);
   \   000000E8   0x6AE0             LDR      R0,[R4, #+44]
   \   000000EA   0x.... 0x....      BL       HAL_DMA_Abort
   1297                
   1298                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000EE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F0   0x2804             CMP      R0,#+4
   \   000000F2   0xBF14             ITE      NE 
   \   000000F4   0x2003             MOVNE    R0,#+3
   \   000000F6   0x2001             MOVEQ    R0,#+1
   1299                {
   1300                  return HAL_ERROR;
   1301                }
   1302                else
   1303                {
   1304                  return HAL_TIMEOUT;
   \   000000F8   0xB001             ADD      SP,SP,#+4
   \   000000FA   0xBD30             POP      {R4,R5,PC}
   1305                }
   1306              }
   1307              
   1308              /* Enable DMA Request */
   1309              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;   
   \                     ??HAL_I2C_Master_Transmit_DMA_5: (+1)
   \   000000FC   0x6801             LDR      R1,[R0, #+0]
   \   000000FE   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000102   0x6001             STR      R1,[R0, #+0]
   1310              
   1311              /* Process Unlocked */
   1312              __HAL_UNLOCK(hi2c);
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF884 0x0034      STRB     R0,[R4, #+52]
   1313              
   1314              return HAL_OK;
   \   0000010A   0xB001             ADD      SP,SP,#+4
   \   0000010C   0xBD30             POP      {R4,R5,PC}
   1315            }
   1316            else
   1317            {
   1318              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \   0000010E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \   00000110   0xB001             ADD      SP,SP,#+4
   \   00000112   0xBD30             POP      {R4,R5,PC}       ;; return
   1319            }
   1320          }
   1321          
   1322          /**
   1323            * @brief  Receive in master mode an amount of data in no-blocking mode with DMA 
   1324            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1325            *                the configuration information for the specified I2C.
   1326            * @param  DevAddress: Target device address
   1327            * @param  pData: Pointer to data buffer
   1328            * @param  Size: Amount of data to be sent
   1329            * @retval HAL status
   1330            */

   \                                 In section .text, align 2, keep-with-next
   1331          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1332          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   1333            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xF040 0x8087      BNE.W    ??HAL_I2C_Master_Receive_DMA_0
   1334            {
   1335              if((pData == NULL) || (Size == 0)) 
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2B00             CMPNE    R3,#+0
   \   00000018   0xF000 0x8083      BEQ.W    ??HAL_I2C_Master_Receive_DMA_1
   1336              {
   1337                return  HAL_ERROR;                                    
   1338              }  
   1339              
   1340              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0400             LSLS     R0,R0,#+16
   \   00000022   0xD47D             BMI.N    ??HAL_I2C_Master_Receive_DMA_0
   1341              {
   1342                return HAL_BUSY;
   1343              }
   1344              
   1345              /* Process Locked */
   1346              __HAL_LOCK(hi2c);
   \   00000024   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD079             BEQ.N    ??HAL_I2C_Master_Receive_DMA_0
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
   1347              
   1348              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
   \   00000032   0x2022             MOVS     R0,#+34
   \   00000034   0xF884 0x0035      STRB     R0,[R4, #+53]
   1349              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x63A0             STR      R0,[R4, #+56]
   1350              
   1351              hi2c->pBuffPtr = pData;
   1352              hi2c->XferCount = Size;
   1353              if(Size > 255)
   \   0000003C   0x2BFF             CMP      R3,#+255
   \   0000003E   0x6262             STR      R2,[R4, #+36]
   \   00000040   0x8563             STRH     R3,[R4, #+42]
   \   00000042   0xBFC6             ITTE     GT 
   \   00000044   0x20FF             MOVGT    R0,#+255
   \   00000046   0x8520             STRHGT   R0,[R4, #+40]
   \   00000048   0x8523             STRHLE   R3,[R4, #+40]
   1354              {
   1355                hi2c->XferSize = 255;
   1356              }
   1357              else
   1358              {
   1359                hi2c->XferSize = Size;
   1360              }
   1361              
   1362              /* Set the I2C DMA transfer complete callback */
   1363              hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \   0000004A   0x6B21             LDR      R1,[R4, #+48]
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000050   0x63C8             STR      R0,[R1, #+60]
   1364              
   1365              /* Set the DMA error callback */
   1366              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   00000052   0x6B21             LDR      R1,[R4, #+48]
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000058   0x6488             STR      R0,[R1, #+72]
   1367              
   1368              /* Enable the DMA channel */
   1369              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x8D23             LDRH     R3,[R4, #+40]
   \   0000005E   0xF100 0x0124      ADD      R1,R0,#+36
   \   00000062   0x6B20             LDR      R0,[R4, #+48]
   \   00000064   0x.... 0x....      BL       HAL_DMA_Start_IT
   1370              
   1371              /* Send Slave Address */
   1372              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1373              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000068   0x8D21             LDRH     R1,[R4, #+40]
   \   0000006A   0x29FF             CMP      R1,#+255
   \   0000006C   0xD10E             BNE.N    ??HAL_I2C_Master_Receive_DMA_2
   \   0000006E   0x8D60             LDRH     R0,[R4, #+42]
   \   00000070   0x4281             CMP      R1,R0
   \   00000072   0xD20B             BCS.N    ??HAL_I2C_Master_Receive_DMA_2
   1374              {
   1375                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x....             LDR.N    R3,??DataTable8  ;; 0xfc009800
   \   00000078   0x6842             LDR      R2,[R0, #+4]
   \   0000007A   0x401A             ANDS     R2,R3,R2
   \   0000007C   0x05AB             LSLS     R3,R5,#+22
   \   0000007E   0xEA52 0x5293      ORRS     R2,R2,R3, LSR #+22
   \   00000082   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000086   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   0000008A   0xE00B             B.N      ??HAL_I2C_Master_Receive_DMA_3
   1376              }
   1377              else
   1378              {
   1379                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x....             LDR.N    R3,??DataTable8  ;; 0xfc009800
   \   00000090   0xB2C9             UXTB     R1,R1
   \   00000092   0x6842             LDR      R2,[R0, #+4]
   \   00000094   0x401A             ANDS     R2,R3,R2
   \   00000096   0x05AB             LSLS     R3,R5,#+22
   \   00000098   0xEA52 0x5293      ORRS     R2,R2,R3, LSR #+22
   \   0000009C   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   000000A0   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \   000000A4   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   1380              }
   1381              
   1382              /* Wait until RXNE flag is set */
   1383              if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, I2C_FLAG_RXNE) != HAL_OK)      
   \   000000AA   0x.... 0x....      BL       HAL_GetTick
   \   000000AE   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6981             LDR      R1,[R0, #+24]
   \   000000B4   0x0749             LSLS     R1,R1,#+29
   \   000000B6   0xD42A             BMI.N    ??HAL_I2C_Master_Receive_DMA_5
   \   000000B8   0x2104             MOVS     R1,#+4
   \   000000BA   0x4620             MOV      R0,R4
   \   000000BC   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000C0   0xB990             CBNZ.N   R0,??HAL_I2C_Master_Receive_DMA_6
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x6981             LDR      R1,[R0, #+24]
   \   000000C6   0x0689             LSLS     R1,R1,#+26
   \   000000C8   0xD518             BPL.N    ??HAL_I2C_Master_Receive_DMA_7
   \   000000CA   0x2120             MOVS     R1,#+32
   \   000000CC   0x....             LDR.N    R2,??DataTable8_2  ;; 0xfe00e800
   \   000000CE   0x61C1             STR      R1,[R0, #+28]
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6841             LDR      R1,[R0, #+4]
   \   000000D4   0x4011             ANDS     R1,R2,R1
   \   000000D6   0x6041             STR      R1,[R0, #+4]
   \   000000D8   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Receive_DMA_8: (+1)
   \   000000DA   0x63A0             STR      R0,[R4, #+56]
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF884 0x0034      STRB     R0,[R4, #+52]
   1384              {
   1385                /* Abort DMA */
   1386                HAL_DMA_Abort(hi2c->hdmarx);
   \                     ??HAL_I2C_Master_Receive_DMA_6: (+1)
   \   000000E8   0x6B20             LDR      R0,[R4, #+48]
   \   000000EA   0x.... 0x....      BL       HAL_DMA_Abort
   1387                
   1388                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000EE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000F0   0x2804             CMP      R0,#+4
   \   000000F2   0xBF14             ITE      NE 
   \   000000F4   0x2003             MOVNE    R0,#+3
   \   000000F6   0x2001             MOVEQ    R0,#+1
   1389                {
   1390                  return HAL_ERROR;
   1391                }
   1392                else
   1393                {
   1394                  return HAL_TIMEOUT;
   \   000000F8   0xB001             ADD      SP,SP,#+4
   \   000000FA   0xBD30             POP      {R4,R5,PC}
   1395                }
   1396          	}
   \                     ??HAL_I2C_Master_Receive_DMA_7: (+1)
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0x1B40             SUBS     R0,R0,R5
   \   00000102   0x2805             CMP      R0,#+5
   \   00000104   0xD3D4             BCC.N    ??HAL_I2C_Master_Receive_DMA_4
   \   00000106   0x6BA0             LDR      R0,[R4, #+56]
   \   00000108   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010C   0xE7E5             B.N      ??HAL_I2C_Master_Receive_DMA_8
   1397              
   1398              /* Enable DMA Request */
   1399              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;   
   \                     ??HAL_I2C_Master_Receive_DMA_5: (+1)
   \   0000010E   0x6801             LDR      R1,[R0, #+0]
   \   00000110   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000114   0x6001             STR      R1,[R0, #+0]
   1400              
   1401              /* Process Unlocked */
   1402              __HAL_UNLOCK(hi2c);
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF884 0x0034      STRB     R0,[R4, #+52]
   1403              
   1404              return HAL_OK;
   \   0000011C   0xB001             ADD      SP,SP,#+4
   \   0000011E   0xBD30             POP      {R4,R5,PC}
   1405            }
   1406            else
   1407            {
   1408              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \   00000120   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \   00000122   0xB001             ADD      SP,SP,#+4
   \   00000124   0xBD30             POP      {R4,R5,PC}       ;; return
   1409            }
   1410          }
   1411          
   1412          /**
   1413            * @brief  Transmit in slave mode an amount of data in no-blocking mode with DMA 
   1414            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1415            *                the configuration information for the specified I2C.
   1416            * @param  pData: Pointer to data buffer
   1417            * @param  Size: Amount of data to be sent
   1418            * @retval HAL status
   1419            */

   \                                 In section .text, align 2, keep-with-next
   1420          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1421          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1422            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD16A             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   1423            {
   1424              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD067             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_1
   1425              {
   1426                return  HAL_ERROR;                                    
   1427              }   
   1428              /* Process Locked */
   1429              __HAL_LOCK(hi2c); 
   \   00000014   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD062             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_0
   \   0000001C   0x2001             MOVS     R0,#+1
   1430              
   1431              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
   1432              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1433              
   1434              hi2c->pBuffPtr = pData;
   1435              hi2c->XferCount = Size;
   1436              hi2c->XferSize = Size;
   1437              
   1438              /* Set the I2C DMA transfer complete callback */
   1439              hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   1440              
   1441              /* Set the DMA error callback */
   1442              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   1443              
   1444              /* Enable the DMA channel */
   1445              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   0000001E   0xF242 0x7511      MOVW     R5,#+10001
   \   00000022   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000026   0x2032             MOVS     R0,#+50
   \   00000028   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000034   0x6261             STR      R1,[R4, #+36]
   \   00000036   0x8562             STRH     R2,[R4, #+42]
   \   00000038   0x8522             STRH     R2,[R4, #+40]
   \   0000003A   0x6AE2             LDR      R2,[R4, #+44]
   \   0000003C   0x63D0             STR      R0,[R2, #+60]
   \   0000003E   0x6AE2             LDR      R2,[R4, #+44]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000044   0x6490             STR      R0,[R2, #+72]
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x8D23             LDRH     R3,[R4, #+40]
   \   0000004A   0xF100 0x0228      ADD      R2,R0,#+40
   \   0000004E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000050   0x.... 0x....      BL       HAL_DMA_Start_IT
   1446              
   1447              /* Enable Address Acknowledge */
   1448              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6841             LDR      R1,[R0, #+4]
   \   00000058   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000005C   0x6041             STR      R1,[R0, #+4]
   1449              
   1450              /* Wait until ADDR flag is set */
   1451              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   0000005E   0x.... 0x....      BL       HAL_GetTick
   \   00000062   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6981             LDR      R1,[R0, #+24]
   \   00000068   0x0709             LSLS     R1,R1,#+28
   \   0000006A   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_3
   \   0000006C   0x.... 0x....      BL       HAL_GetTick
   \   00000070   0x1B80             SUBS     R0,R0,R6
   \   00000072   0x42A8             CMP      R0,R5
   \   00000074   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_2
   \   00000076   0xE01F             B.N      ??HAL_I2C_Slave_Transmit_DMA_4
   1452              {
   1453                /* Disable Address Acknowledge */
   1454                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1455                return HAL_TIMEOUT;
   1456              }
   1457              
   1458              /* Clear ADDR flag */
   1459              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \   00000078   0x2108             MOVS     R1,#+8
   \   0000007A   0x61C1             STR      R1,[R0, #+28]
   1460              
   1461              /* If 10bits addressing mode is selected */
   1462              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD10E             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_5
   1463              {
   1464                /* Wait until ADDR flag is set */
   1465                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   00000082   0x.... 0x....      BL       HAL_GetTick
   \   00000086   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_6: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6981             LDR      R1,[R0, #+24]
   \   0000008C   0x0709             LSLS     R1,R1,#+28
   \   0000008E   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_7
   \   00000090   0x.... 0x....      BL       HAL_GetTick
   \   00000094   0x1B80             SUBS     R0,R0,R6
   \   00000096   0x42A8             CMP      R0,R5
   \   00000098   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_6
   \   0000009A   0xE00D             B.N      ??HAL_I2C_Slave_Transmit_DMA_4
   1466                {
   1467                  /* Disable Address Acknowledge */
   1468                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1469                  return HAL_TIMEOUT;
   1470                }
   1471                
   1472                /* Clear ADDR flag */
   1473                __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Transmit_DMA_7: (+1)
   \   0000009C   0x2108             MOVS     R1,#+8
   \   0000009E   0x61C1             STR      R1,[R0, #+28]
   1474              }
   1475              
   1476              /* Wait until DIR flag is set Transmitter mode */
   1477              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \                     ??HAL_I2C_Slave_Transmit_DMA_5: (+1)
   \   000000A0   0x.... 0x....      BL       HAL_GetTick
   \   000000A4   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_8: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6981             LDR      R1,[R0, #+24]
   \   000000AA   0x03C9             LSLS     R1,R1,#+15
   \   000000AC   0xD411             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_9
   \   000000AE   0x.... 0x....      BL       HAL_GetTick
   \   000000B2   0x1B40             SUBS     R0,R0,R5
   \   000000B4   0x281A             CMP      R0,#+26
   \   000000B6   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_8
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF884 0x0034      STRB     R0,[R4, #+52]
   1478              {
   1479                /* Disable Address Acknowledge */
   1480                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6841             LDR      R1,[R0, #+4]
   \   000000C8   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000CC   0x6041             STR      R1,[R0, #+4]
   1481                return HAL_TIMEOUT;
   \   000000CE   0x2003             MOVS     R0,#+3
   \   000000D0   0xBD70             POP      {R4-R6,PC}
   1482              }
   1483              
   1484              /* Enable DMA Request */
   1485              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN; 
   \                     ??HAL_I2C_Slave_Transmit_DMA_9: (+1)
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000D8   0x6001             STR      R1,[R0, #+0]
   1486              
   1487              /* Process Unlocked */
   1488              __HAL_UNLOCK(hi2c);
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xF884 0x0034      STRB     R0,[R4, #+52]
   1489              
   1490              return HAL_OK;
   \   000000E0   0xBD70             POP      {R4-R6,PC}
   1491            }
   1492            else
   1493            {
   1494              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \   000000E4   0xBD70             POP      {R4-R6,PC}       ;; return
   1495            }
   1496          }
   1497          
   1498          /**
   1499            * @brief  Receive in slave mode an amount of data in no-blocking mode with DMA 
   1500            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1501            *                the configuration information for the specified I2C.
   1502            * @param  pData: Pointer to data buffer
   1503            * @param  Size: Amount of data to be sent
   1504            * @retval HAL status
   1505            */

   \                                 In section .text, align 2, keep-with-next
   1506          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1507          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1508            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD159             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   1509            {
   1510              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD056             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_1
   1511              {
   1512                return  HAL_ERROR;                                    
   1513              }   
   1514              /* Process Locked */
   1515              __HAL_LOCK(hi2c);
   \   00000014   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD051             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_0
   \   0000001C   0x2001             MOVS     R0,#+1
   1516              
   1517              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   1518              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1519              
   1520              hi2c->pBuffPtr = pData;
   1521              hi2c->XferSize = Size;
   1522              hi2c->XferCount = Size;
   1523              
   1524              /* Set the I2C DMA transfer complete callback */
   1525              hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   1526              
   1527              /* Set the DMA error callback */
   1528              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   1529              
   1530              /* Enable the DMA channel */
   1531              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, Size);
   \   0000001E   0xF242 0x7611      MOVW     R6,#+10001
   \   00000022   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000026   0x2042             MOVS     R0,#+66
   \   00000028   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000034   0x6261             STR      R1,[R4, #+36]
   \   00000036   0x8522             STRH     R2,[R4, #+40]
   \   00000038   0x8562             STRH     R2,[R4, #+42]
   \   0000003A   0x6B23             LDR      R3,[R4, #+48]
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
   \   0000003E   0x6B23             LDR      R3,[R4, #+48]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000044   0x6498             STR      R0,[R3, #+72]
   \   00000046   0x4613             MOV      R3,R2
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x460A             MOV      R2,R1
   \   0000004C   0xF100 0x0124      ADD      R1,R0,#+36
   \   00000050   0x6B20             LDR      R0,[R4, #+48]
   \   00000052   0x.... 0x....      BL       HAL_DMA_Start_IT
   1532              
   1533              /* Enable Address Acknowledge */
   1534              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6841             LDR      R1,[R0, #+4]
   \   0000005A   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000005E   0x6041             STR      R1,[R0, #+4]
   1535              
   1536              /* Wait until ADDR flag is set */
   1537              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6981             LDR      R1,[R0, #+24]
   \   0000006A   0x0709             LSLS     R1,R1,#+28
   \   0000006C   0xD405             BMI.N    ??HAL_I2C_Slave_Receive_DMA_3
   \   0000006E   0x.... 0x....      BL       HAL_GetTick
   \   00000072   0x1B40             SUBS     R0,R0,R5
   \   00000074   0x42B0             CMP      R0,R6
   \   00000076   0xD3F6             BCC.N    ??HAL_I2C_Slave_Receive_DMA_2
   \   00000078   0xE00D             B.N      ??HAL_I2C_Slave_Receive_DMA_4
   1538              {
   1539                /* Disable Address Acknowledge */
   1540                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1541                return HAL_TIMEOUT;
   1542              }
   1543              
   1544              /* Clear ADDR flag */
   1545              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \   0000007A   0x2108             MOVS     R1,#+8
   \   0000007C   0x61C1             STR      R1,[R0, #+28]
   1546              
   1547              /* Wait until DIR flag is set Receiver mode */
   1548              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, I2C_TIMEOUT_DIR) != HAL_OK)      
   \   0000007E   0x.... 0x....      BL       HAL_GetTick
   \   00000082   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Receive_DMA_5: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6981             LDR      R1,[R0, #+24]
   \   00000088   0x03C9             LSLS     R1,R1,#+15
   \   0000008A   0xD511             BPL.N    ??HAL_I2C_Slave_Receive_DMA_6
   \   0000008C   0x.... 0x....      BL       HAL_GetTick
   \   00000090   0x1B40             SUBS     R0,R0,R5
   \   00000092   0x281A             CMP      R0,#+26
   \   00000094   0xD3F6             BCC.N    ??HAL_I2C_Slave_Receive_DMA_5
   \                     ??HAL_I2C_Slave_Receive_DMA_4: (+1)
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x0034      STRB     R0,[R4, #+52]
   1549              {
   1550                /* Disable Address Acknowledge */
   1551                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000AA   0x6041             STR      R1,[R0, #+4]
   1552                return HAL_TIMEOUT;
   \   000000AC   0x2003             MOVS     R0,#+3
   \   000000AE   0xBD70             POP      {R4-R6,PC}
   1553              }
   1554              
   1555              /* Enable DMA Request */
   1556              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;  
   \                     ??HAL_I2C_Slave_Receive_DMA_6: (+1)
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000B6   0x6001             STR      R1,[R0, #+0]
   1557              
   1558              /* Process Unlocked */
   1559              __HAL_UNLOCK(hi2c);
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF884 0x0034      STRB     R0,[R4, #+52]
   1560              
   1561              return HAL_OK;
   \   000000BE   0xBD70             POP      {R4-R6,PC}
   1562            }
   1563            else
   1564            {
   1565              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \   000000C0   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \   000000C2   0xBD70             POP      {R4-R6,PC}       ;; return
   1566            }
   1567          }
   1568          /**
   1569            * @brief  Write an amount of data in blocking mode to a specific memory address
   1570            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1571            *                the configuration information for the specified I2C.
   1572            * @param  DevAddress: Target device address
   1573            * @param  MemAddress: Internal memory address
   1574            * @param  MemAddSize: Size of internal memory address
   1575            * @param  pData: Pointer to data buffer
   1576            * @param  Size: Amount of data to be sent
   1577            * @param  Timeout: Timeout duration
   1578            * @retval HAL status
   1579            */

   \                                 In section .text, align 4, keep-with-next
   1580          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1581          {
   \                     HAL_I2C_Mem_Write: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4699             MOV      R9,R3
   1582            uint32_t Sizetmp = 0;
   1583            
   1584            /* Check the parameters */
   1585            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1586            
   1587            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x814C      BNE.W    ??HAL_I2C_Mem_Write_0
   \   00000016   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1588            { 
   1589              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x9C0B             LDRNE    R4,[SP, #+44]
   \   00000022   0x2C00             CMPNE    R4,#+0
   \   00000024   0xF000 0x8144      BEQ.W    ??HAL_I2C_Mem_Write_1
   1590              {
   1591                return  HAL_ERROR;                                    
   1592              }
   1593              
   1594              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x6982             LDR      R2,[R0, #+24]
   \   0000002C   0x0412             LSLS     R2,R2,#+16
   \   0000002E   0xF100 0x813E      BMI.W    ??HAL_I2C_Mem_Write_0
   1595              {
   1596                return HAL_BUSY;
   1597              }
   1598              
   1599              /* Process Locked */
   1600              __HAL_LOCK(hi2c);
   \   00000032   0xF895 0x2034      LDRB     R2,[R5, #+52]
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xF000 0x8139      BEQ.W    ??HAL_I2C_Mem_Write_0
   \   0000003C   0x2201             MOVS     R2,#+1
   1601              
   1602              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   1603              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1604              
   1605              /* Send Slave Address and Memory Address */
   1606              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   0000003E   0x058F             LSLS     R7,R1,#+22
   \   00000040   0xF885 0x2034      STRB     R2,[R5, #+52]
   \   00000044   0x2252             MOVS     R2,#+82
   \   00000046   0xF885 0x2035      STRB     R2,[R5, #+53]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x63AA             STR      R2,[R5, #+56]
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0x.... 0x....      LDR.W    R10,??DataTable15  ;; 0xfc009800
   \   00000054   0xFA5F 0xF289      UXTB     R2,R9
   \   00000058   0xEA0A 0x0101      AND      R1,R10,R1
   \   0000005C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000060   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000064   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000068   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006C   0x6041             STR      R1,[R0, #+4]
   \   0000006E   0x.... 0x....      BL       HAL_GetTick
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \   00000078   0x6829             LDR      R1,[R5, #+0]
   \   0000007A   0x6988             LDR      R0,[R1, #+24]
   \   0000007C   0x0780             LSLS     R0,R0,#+30
   \   0000007E   0xD425             BMI.N    ??HAL_I2C_Mem_Write_3
   \   00000080   0x4659             MOV      R1,R11
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000088   0xB9A8             CBNZ.N   R0,??HAL_I2C_Mem_Write_4
   \   0000008A   0xF11B 0x0F01      CMN      R11,#+1
   \   0000008E   0xD0F3             BEQ.N    ??HAL_I2C_Mem_Write_2
   \   00000090   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000094   0xD005             BEQ.N    ??HAL_I2C_Mem_Write_5
   \   00000096   0x.... 0x....      BL       HAL_GetTick
   \   0000009A   0x9900             LDR      R1,[SP, #+0]
   \   0000009C   0x1A40             SUBS     R0,R0,R1
   \   0000009E   0x4583             CMP      R11,R0
   \   000000A0   0xD2EA             BCS.N    ??HAL_I2C_Mem_Write_2
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \   000000A2   0x6BA8             LDR      R0,[R5, #+56]
   \   000000A4   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000A8   0x63A8             STR      R0,[R5, #+56]
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \   000000B6   0x6BA8             LDR      R0,[R5, #+56]
   1607              {
   1608                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \   000000B8   0x6BA8             LDR      R0,[R5, #+56]
   \   000000BA   0x2804             CMP      R0,#+4
   \   000000BC   0xD158             BNE.N    ??HAL_I2C_Mem_Write_7
   1609                {
   1610                  /* Process Unlocked */
   1611                  __HAL_UNLOCK(hi2c);
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF885 0x0034      STRB     R0,[R5, #+52]
   1612                  return HAL_ERROR;
   1613                }
   1614                else
   1615                {
   1616                  /* Process Unlocked */
   1617                  __HAL_UNLOCK(hi2c);
   1618                  return HAL_TIMEOUT;
   1619                }
   1620              }
   1621              
   1622              /* Set NBYTES to write and reload if size > 255 */
   1623              /* Size > 255, need to set RELOAD bit */
   1624              if(Size > 255)
   1625              {
   1626                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   1627                Sizetmp = 255;
   1628              }
   1629              else
   1630              {
   1631                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   1632                Sizetmp = Size;
   1633              }
   1634              
   1635              do
   1636              {
   1637                /* Wait until TXIS flag is set */
   1638                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   1639                {
   1640                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1641                  {
   1642                    return HAL_ERROR;
   1643                  }
   1644                  else
   1645                  {
   1646                    return HAL_TIMEOUT;
   1647                  }
   1648                }
   1649                
   1650                /* Write data to DR */
   1651                hi2c->Instance->TXDR = (*pData++);
   1652                Sizetmp--;
   1653                Size--;
   1654                
   1655                if((Sizetmp == 0)&&(Size!=0))
   1656                {
   1657                  /* Wait until TCR flag is set */
   1658                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   1659                  {
   1660                    return HAL_TIMEOUT;
   1661                  }
   1662                  
   1663                  
   1664                  if(Size > 255)
   1665                  {
   1666                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   1667                    Sizetmp = 255;
   1668                  }
   1669                  else
   1670                  {
   1671                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   1672                    Sizetmp = Size;
   1673                  }
   1674                }
   1675                
   1676              }while(Size > 0);
   1677              
   1678              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1679              /* Wait until STOPF flag is reset */ 
   1680              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   1681              {
   1682                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1683                {
   1684                  return HAL_ERROR;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0xB001             ADD      SP,SP,#+4
   \   000000C8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \   000000CC   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000D0   0xD025             BEQ.N    ??HAL_I2C_Mem_Write_8
   \   000000D2   0x0A30             LSRS     R0,R6,#+8
   \   000000D4   0x6288             STR      R0,[R1, #+40]
   \   000000D6   0x.... 0x....      BL       HAL_GetTick
   \   000000DA   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Write_9: (+1)
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0x6980             LDR      R0,[R0, #+24]
   \   000000E0   0x0780             LSLS     R0,R0,#+30
   \   000000E2   0xD41C             BMI.N    ??HAL_I2C_Mem_Write_8
   \   000000E4   0x4659             MOV      R1,R11
   \   000000E6   0x4628             MOV      R0,R5
   \   000000E8   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD1E2             BNE.N    ??HAL_I2C_Mem_Write_4
   \   000000F0   0xF11B 0x0F01      CMN      R11,#+1
   \   000000F4   0xD0F2             BEQ.N    ??HAL_I2C_Mem_Write_9
   \   000000F6   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000FA   0xD005             BEQ.N    ??HAL_I2C_Mem_Write_10
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000104   0x4583             CMP      R11,R0
   \   00000106   0xD2E9             BCS.N    ??HAL_I2C_Mem_Write_9
   \                     ??HAL_I2C_Mem_Write_10: (+1)
   \   00000108   0x6BA8             LDR      R0,[R5, #+56]
   \   0000010A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010E   0x63A8             STR      R0,[R5, #+56]
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   0000011C   0xE7CB             B.N      ??HAL_I2C_Mem_Write_4
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \   0000011E   0x6828             LDR      R0,[R5, #+0]
   \   00000120   0xB2F6             UXTB     R6,R6
   \   00000122   0x6286             STR      R6,[R0, #+40]
   \   00000124   0x.... 0x....      BL       HAL_GetTick
   \   00000128   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Write_11: (+1)
   \   0000012A   0x6828             LDR      R0,[R5, #+0]
   \   0000012C   0x6981             LDR      R1,[R0, #+24]
   \   0000012E   0x0609             LSLS     R1,R1,#+24
   \   00000130   0xD411             BMI.N    ??HAL_I2C_Mem_Write_12
   \   00000132   0xF11B 0x0F01      CMN      R11,#+1
   \   00000136   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Write_11
   \   00000138   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000013C   0xD004             BEQ.N    ??HAL_I2C_Mem_Write_13
   \   0000013E   0x.... 0x....      BL       HAL_GetTick
   \   00000142   0x1B80             SUBS     R0,R0,R6
   \   00000144   0x4583             CMP      R11,R0
   \   00000146   0xD2F0             BCS.N    ??HAL_I2C_Mem_Write_11
   \                     ??HAL_I2C_Mem_Write_13: (+1)
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000154   0xE7B0             B.N      ??HAL_I2C_Mem_Write_6
   \                     ??HAL_I2C_Mem_Write_12: (+1)
   \   00000156   0x2CFF             CMP      R4,#+255
   \   00000158   0x6841             LDR      R1,[R0, #+4]
   \   0000015A   0xEA0A 0x0101      AND      R1,R10,R1
   \   0000015E   0xDD0E             BLE.N    ??HAL_I2C_Mem_Write_14
   \   00000160   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \                     ??HAL_I2C_Mem_Write_15: (+1)
   \   00000164   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0x1ff0000
   \   00000168   0x26FF             MOVS     R6,#+255
   \   0000016A   0x4311             ORRS     R1,R2,R1
   \   0000016C   0x6041             STR      R1,[R0, #+4]
   \   0000016E   0xE00F             B.N      ??HAL_I2C_Mem_Write_16
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xF885 0x0034      STRB     R0,[R5, #+52]
   1685                }
   1686                else
   1687                {
   1688                  return HAL_TIMEOUT;
   \   00000176   0x2003             MOVS     R0,#+3
   \   00000178   0xB001             ADD      SP,SP,#+4
   \   0000017A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_14: (+1)
   \   0000017E   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000182   0xB2E2             UXTB     R2,R4
   \   00000184   0x4626             MOV      R6,R4
   \   00000186   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000018A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000018E   0x6041             STR      R1,[R0, #+4]
   \                     ??HAL_I2C_Mem_Write_16: (+1)
   \   00000190   0x.... 0x....      BL       HAL_GetTick
   \   00000194   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Write_17: (+1)
   \   00000196   0x6828             LDR      R0,[R5, #+0]
   \   00000198   0x6981             LDR      R1,[R0, #+24]
   \   0000019A   0x0789             LSLS     R1,R1,#+30
   \   0000019C   0xD421             BMI.N    ??HAL_I2C_Mem_Write_18
   \   0000019E   0x4659             MOV      R1,R11
   \   000001A0   0x4628             MOV      R0,R5
   \   000001A2   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001A6   0xB9A8             CBNZ.N   R0,??HAL_I2C_Mem_Write_19
   \   000001A8   0xF11B 0x0F01      CMN      R11,#+1
   \   000001AC   0xD0F3             BEQ.N    ??HAL_I2C_Mem_Write_17
   \   000001AE   0xF1BB 0x0F00      CMP      R11,#+0
   \   000001B2   0xD005             BEQ.N    ??HAL_I2C_Mem_Write_20
   \   000001B4   0x.... 0x....      BL       HAL_GetTick
   \   000001B8   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000001BC   0x4583             CMP      R11,R0
   \   000001BE   0xD2EA             BCS.N    ??HAL_I2C_Mem_Write_17
   \                     ??HAL_I2C_Mem_Write_20: (+1)
   \   000001C0   0x6BA8             LDR      R0,[R5, #+56]
   \   000001C2   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001C6   0x63A8             STR      R0,[R5, #+56]
   \   000001C8   0x2001             MOVS     R0,#+1
   \   000001CA   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Write_19: (+1)
   \   000001D4   0x6BA8             LDR      R0,[R5, #+56]
   \   000001D6   0x2804             CMP      R0,#+4
   \   000001D8   0xD165             BNE.N    ??HAL_I2C_Mem_Write_21
   \   000001DA   0x2001             MOVS     R0,#+1
   \   000001DC   0xB001             ADD      SP,SP,#+4
   \   000001DE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_18: (+1)
   \   000001E2   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \   000001E6   0x1E76             SUBS     R6,R6,#+1
   \   000001E8   0xF1A4 0x0401      SUB      R4,R4,#+1
   \   000001EC   0xB2A4             UXTH     R4,R4
   \   000001EE   0x6281             STR      R1,[R0, #+40]
   \   000001F0   0xD124             BNE.N    ??HAL_I2C_Mem_Write_22
   \   000001F2   0xB32C             CBZ.N    R4,??HAL_I2C_Mem_Write_23
   \   000001F4   0x.... 0x....      BL       HAL_GetTick
   \   000001F8   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Write_24: (+1)
   \   000001FA   0x6828             LDR      R0,[R5, #+0]
   \   000001FC   0x6981             LDR      R1,[R0, #+24]
   \   000001FE   0x0609             LSLS     R1,R1,#+24
   \   00000200   0xD414             BMI.N    ??HAL_I2C_Mem_Write_25
   \   00000202   0xF11B 0x0F01      CMN      R11,#+1
   \   00000206   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Write_24
   \   00000208   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000020C   0xD004             BEQ.N    ??HAL_I2C_Mem_Write_26
   \   0000020E   0x.... 0x....      BL       HAL_GetTick
   \   00000212   0x1B80             SUBS     R0,R0,R6
   \   00000214   0x4583             CMP      R11,R0
   \   00000216   0xD2F0             BCS.N    ??HAL_I2C_Mem_Write_24
   \                     ??HAL_I2C_Mem_Write_26: (+1)
   \   00000218   0x2001             MOVS     R0,#+1
   \   0000021A   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000224   0x2003             MOVS     R0,#+3
   \   00000226   0xB001             ADD      SP,SP,#+4
   \   00000228   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_25: (+1)
   \   0000022C   0x2CFF             CMP      R4,#+255
   \   0000022E   0x6841             LDR      R1,[R0, #+4]
   \   00000230   0xEA0A 0x0101      AND      R1,R10,R1
   \   00000234   0xDDA3             BLE.N    ??HAL_I2C_Mem_Write_14
   \   00000236   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   0000023A   0xE793             B.N      ??HAL_I2C_Mem_Write_15
   \                     ??HAL_I2C_Mem_Write_22: (+1)
   \   0000023C   0x2C00             CMP      R4,#+0
   \   0000023E   0xD1A7             BNE.N    ??HAL_I2C_Mem_Write_16
   \                     ??HAL_I2C_Mem_Write_23: (+1)
   \   00000240   0x.... 0x....      BL       HAL_GetTick
   \   00000244   0x4604             MOV      R4,R0
   \                     ??HAL_I2C_Mem_Write_27: (+1)
   \   00000246   0x6828             LDR      R0,[R5, #+0]
   \   00000248   0x6981             LDR      R1,[R0, #+24]
   \   0000024A   0x0689             LSLS     R1,R1,#+26
   \   0000024C   0xD41A             BMI.N    ??HAL_I2C_Mem_Write_28
   \   0000024E   0x2119             MOVS     R1,#+25
   \   00000250   0x4628             MOV      R0,R5
   \   00000252   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000256   0xB970             CBNZ.N   R0,??HAL_I2C_Mem_Write_29
   \   00000258   0x.... 0x....      BL       HAL_GetTick
   \   0000025C   0x1B00             SUBS     R0,R0,R4
   \   0000025E   0x281A             CMP      R0,#+26
   \   00000260   0xD3F1             BCC.N    ??HAL_I2C_Mem_Write_27
   \   00000262   0x6BA8             LDR      R0,[R5, #+56]
   \   00000264   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000268   0x63A8             STR      R0,[R5, #+56]
   \   0000026A   0x2001             MOVS     R0,#+1
   \   0000026C   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Write_29: (+1)
   \   00000276   0x6BA8             LDR      R0,[R5, #+56]
   \   00000278   0x2804             CMP      R0,#+4
   \   0000027A   0xD114             BNE.N    ??HAL_I2C_Mem_Write_21
   \   0000027C   0x2001             MOVS     R0,#+1
   \   0000027E   0xB001             ADD      SP,SP,#+4
   \   00000280   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1689                }
   1690              }
   1691              
   1692              /* Clear STOP Flag */
   1693              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Write_28: (+1)
   \   00000284   0x2120             MOVS     R1,#+32
   1694            	
   1695              /* Clear Configuration Register 2 */
   1696              I2C_RESET_CR2(hi2c);
   \   00000286   0x.... 0x....      LDR.W    R2,??DataTable15_2  ;; 0xfe00e800
   \   0000028A   0x61C1             STR      R1,[R0, #+28]
   \   0000028C   0x6828             LDR      R0,[R5, #+0]
   \   0000028E   0x6841             LDR      R1,[R0, #+4]
   \   00000290   0x4011             ANDS     R1,R2,R1
   \   00000292   0x6041             STR      R1,[R0, #+4]
   1697              
   1698              hi2c->State = HAL_I2C_STATE_READY; 	  
   \   00000294   0x2001             MOVS     R0,#+1
   \   00000296   0xF885 0x0035      STRB     R0,[R5, #+53]
   1699              
   1700              /* Process Unlocked */
   1701              __HAL_UNLOCK(hi2c);
   \   0000029A   0x2000             MOVS     R0,#+0
   \   0000029C   0xF885 0x0034      STRB     R0,[R5, #+52]
   1702              
   1703              return HAL_OK;
   \   000002A0   0xB001             ADD      SP,SP,#+4
   \   000002A2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_21: (+1)
   \   000002A6   0x2003             MOVS     R0,#+3
   \   000002A8   0xB001             ADD      SP,SP,#+4
   \   000002AA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1704            }
   1705            else
   1706            {
   1707              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \   000002AE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \   000002B0   0xB001             ADD      SP,SP,#+4
   \   000002B2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1708            }
   1709          }
   1710          
   1711          /**
   1712            * @brief  Read an amount of data in blocking mode from a specific memory address
   1713            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1714            *                the configuration information for the specified I2C.
   1715            * @param  DevAddress: Target device address
   1716            * @param  MemAddress: Internal memory address
   1717            * @param  MemAddSize: Size of internal memory address
   1718            * @param  pData: Pointer to data buffer
   1719            * @param  Size: Amount of data to be sent
   1720            * @param  Timeout: Timeout duration
   1721            * @retval HAL status
   1722            */

   \                                 In section .text, align 4, keep-with-next
   1723          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1724          {
   \                     HAL_I2C_Mem_Read: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4699             MOV      R9,R3
   1725            uint32_t Sizetmp = 0;
   1726            
   1727            /* Check the parameters */
   1728            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1729            
   1730            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x814F      BNE.W    ??HAL_I2C_Mem_Read_0
   \   00000016   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1731            {    
   1732              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x9C0B             LDRNE    R4,[SP, #+44]
   \   00000022   0x2C00             CMPNE    R4,#+0
   \   00000024   0xF000 0x8147      BEQ.W    ??HAL_I2C_Mem_Read_1
   1733              {
   1734                return  HAL_ERROR;                                    
   1735              }
   1736              
   1737              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x6982             LDR      R2,[R0, #+24]
   \   0000002C   0x0412             LSLS     R2,R2,#+16
   \   0000002E   0xF100 0x8141      BMI.W    ??HAL_I2C_Mem_Read_0
   1738              {
   1739                return HAL_BUSY;
   1740              }
   1741              
   1742              /* Process Locked */
   1743              __HAL_LOCK(hi2c);
   \   00000032   0xF895 0x2034      LDRB     R2,[R5, #+52]
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xF000 0x813C      BEQ.W    ??HAL_I2C_Mem_Read_0
   \   0000003C   0x2201             MOVS     R2,#+1
   1744              
   1745              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   1746              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1747              
   1748              /* Send Slave Address and Memory Address */
   1749              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   0000003E   0x058F             LSLS     R7,R1,#+22
   \   00000040   0xF885 0x2034      STRB     R2,[R5, #+52]
   \   00000044   0x2262             MOVS     R2,#+98
   \   00000046   0xF885 0x2035      STRB     R2,[R5, #+53]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x63AA             STR      R2,[R5, #+56]
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0x.... 0x....      LDR.W    R10,??DataTable15  ;; 0xfc009800
   \   00000054   0xFA5F 0xF289      UXTB     R2,R9
   \   00000058   0xEA0A 0x0101      AND      R1,R10,R1
   \   0000005C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000060   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000064   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000068   0x6041             STR      R1,[R0, #+4]
   \   0000006A   0x.... 0x....      BL       HAL_GetTick
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \   00000074   0x6829             LDR      R1,[R5, #+0]
   \   00000076   0x6988             LDR      R0,[R1, #+24]
   \   00000078   0x0780             LSLS     R0,R0,#+30
   \   0000007A   0xD425             BMI.N    ??HAL_I2C_Mem_Read_3
   \   0000007C   0x4659             MOV      R1,R11
   \   0000007E   0x4628             MOV      R0,R5
   \   00000080   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000084   0xB9A8             CBNZ.N   R0,??HAL_I2C_Mem_Read_4
   \   00000086   0xF11B 0x0F01      CMN      R11,#+1
   \   0000008A   0xD0F3             BEQ.N    ??HAL_I2C_Mem_Read_2
   \   0000008C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000090   0xD005             BEQ.N    ??HAL_I2C_Mem_Read_5
   \   00000092   0x.... 0x....      BL       HAL_GetTick
   \   00000096   0x9900             LDR      R1,[SP, #+0]
   \   00000098   0x1A40             SUBS     R0,R0,R1
   \   0000009A   0x4583             CMP      R11,R0
   \   0000009C   0xD2EA             BCS.N    ??HAL_I2C_Mem_Read_2
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \   0000009E   0x6BA8             LDR      R0,[R5, #+56]
   \   000000A0   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000A4   0x63A8             STR      R0,[R5, #+56]
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \   000000B2   0x6BA8             LDR      R0,[R5, #+56]
   1750              {
   1751                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \   000000B4   0x6BA8             LDR      R0,[R5, #+56]
   \   000000B6   0x2804             CMP      R0,#+4
   \   000000B8   0xD159             BNE.N    ??HAL_I2C_Mem_Read_7
   1752                {
   1753                  /* Process Unlocked */
   1754                  __HAL_UNLOCK(hi2c);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF885 0x0034      STRB     R0,[R5, #+52]
   1755                  return HAL_ERROR;
   1756                }
   1757                else
   1758                {
   1759                  /* Process Unlocked */
   1760                  __HAL_UNLOCK(hi2c);
   1761                  return HAL_TIMEOUT;
   1762                }
   1763              }
   1764              
   1765              /* Send Slave Address */
   1766              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1767              /* Size > 255, need to set RELOAD bit */
   1768              if(Size > 255)
   1769              {
   1770                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   1771                Sizetmp = 255;
   1772              }
   1773              else
   1774              {
   1775                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   1776                Sizetmp = Size;
   1777              }
   1778              
   1779              do
   1780              {  
   1781                /* Wait until RXNE flag is set */
   1782                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)      
   1783                {
   1784                  return HAL_TIMEOUT;
   1785                }
   1786                
   1787                /* Read data from RXDR */
   1788                (*pData++) = hi2c->Instance->RXDR;
   1789                
   1790                /* Decrement the Size counter */
   1791                Sizetmp--;
   1792                Size--;   
   1793                
   1794                if((Sizetmp == 0)&&(Size!=0))
   1795                {
   1796                  /* Wait until TCR flag is set */
   1797                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   1798                  {
   1799                    return HAL_TIMEOUT;
   1800                  }
   1801                  
   1802                  if(Size > 255)
   1803                  {
   1804                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   1805                    Sizetmp = 255;
   1806                  }
   1807                  else
   1808                  {
   1809                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   1810                    Sizetmp = Size;
   1811                  }
   1812                }
   1813                
   1814              }while(Size > 0);
   1815              
   1816              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1817              /* Wait until STOPF flag is reset */ 
   1818              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   1819              {
   1820                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1821                {
   1822                  return HAL_ERROR;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xB001             ADD      SP,SP,#+4
   \   000000C4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \   000000C8   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000CC   0xD025             BEQ.N    ??HAL_I2C_Mem_Read_8
   \   000000CE   0x0A30             LSRS     R0,R6,#+8
   \   000000D0   0x6288             STR      R0,[R1, #+40]
   \   000000D2   0x.... 0x....      BL       HAL_GetTick
   \   000000D6   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x6980             LDR      R0,[R0, #+24]
   \   000000DC   0x0780             LSLS     R0,R0,#+30
   \   000000DE   0xD41C             BMI.N    ??HAL_I2C_Mem_Read_8
   \   000000E0   0x4659             MOV      R1,R11
   \   000000E2   0x4628             MOV      R0,R5
   \   000000E4   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD1E2             BNE.N    ??HAL_I2C_Mem_Read_4
   \   000000EC   0xF11B 0x0F01      CMN      R11,#+1
   \   000000F0   0xD0F2             BEQ.N    ??HAL_I2C_Mem_Read_9
   \   000000F2   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000F6   0xD005             BEQ.N    ??HAL_I2C_Mem_Read_10
   \   000000F8   0x.... 0x....      BL       HAL_GetTick
   \   000000FC   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000100   0x4583             CMP      R11,R0
   \   00000102   0xD2E9             BCS.N    ??HAL_I2C_Mem_Read_9
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \   00000104   0x6BA8             LDR      R0,[R5, #+56]
   \   00000106   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010A   0x63A8             STR      R0,[R5, #+56]
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000118   0xE7CB             B.N      ??HAL_I2C_Mem_Read_4
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \   0000011A   0x6828             LDR      R0,[R5, #+0]
   \   0000011C   0xB2F6             UXTB     R6,R6
   \   0000011E   0x6286             STR      R6,[R0, #+40]
   \   00000120   0x.... 0x....      BL       HAL_GetTick
   \   00000124   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \   00000126   0x6828             LDR      R0,[R5, #+0]
   \   00000128   0x6981             LDR      R1,[R0, #+24]
   \   0000012A   0x0649             LSLS     R1,R1,#+25
   \   0000012C   0xD411             BMI.N    ??HAL_I2C_Mem_Read_12
   \   0000012E   0xF11B 0x0F01      CMN      R11,#+1
   \   00000132   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Read_11
   \   00000134   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000138   0xD004             BEQ.N    ??HAL_I2C_Mem_Read_13
   \   0000013A   0x.... 0x....      BL       HAL_GetTick
   \   0000013E   0x1B80             SUBS     R0,R0,R6
   \   00000140   0x4583             CMP      R11,R0
   \   00000142   0xD2F0             BCS.N    ??HAL_I2C_Mem_Read_11
   \                     ??HAL_I2C_Mem_Read_13: (+1)
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000150   0xE7B0             B.N      ??HAL_I2C_Mem_Read_6
   \                     ??HAL_I2C_Mem_Read_12: (+1)
   \   00000152   0x2CFF             CMP      R4,#+255
   \   00000154   0x6841             LDR      R1,[R0, #+4]
   \   00000156   0xEA0A 0x0101      AND      R1,R10,R1
   \   0000015A   0xDD0F             BLE.N    ??HAL_I2C_Mem_Read_14
   \   0000015C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000160   0x26FF             MOVS     R6,#+255
   \   00000162   0xF041 0x71FE      ORR      R1,R1,#0x1FC0000
   \   00000166   0xF441 0x3149      ORR      R1,R1,#0x32400
   \   0000016A   0x6041             STR      R1,[R0, #+4]
   \   0000016C   0xE01A             B.N      ??HAL_I2C_Mem_Read_15
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF885 0x0034      STRB     R0,[R5, #+52]
   1823                }
   1824                else
   1825                {
   1826                  return HAL_TIMEOUT;
   \   00000174   0x2003             MOVS     R0,#+3
   \   00000176   0xB001             ADD      SP,SP,#+4
   \   00000178   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_14: (+1)
   \   0000017C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000180   0xB2E2             UXTB     R2,R4
   \   00000182   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000186   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000018A   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   0000018E   0xE006             B.N      ??HAL_I2C_Mem_Read_16
   \                     ??HAL_I2C_Mem_Read_17: (+1)
   \   00000190   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000194   0xB2E2             UXTB     R2,R4
   \   00000196   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000019A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Read_16: (+1)
   \   0000019E   0x6041             STR      R1,[R0, #+4]
   \   000001A0   0xEA4F 0x0604      MOV.W    R6,R4
   \                     ??HAL_I2C_Mem_Read_15: (+1)
   \   000001A4   0x.... 0x....      BL       HAL_GetTick
   \   000001A8   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Read_18: (+1)
   \   000001AA   0x6828             LDR      R0,[R5, #+0]
   \   000001AC   0x6981             LDR      R1,[R0, #+24]
   \   000001AE   0x0749             LSLS     R1,R1,#+29
   \   000001B0   0xD415             BMI.N    ??HAL_I2C_Mem_Read_19
   \   000001B2   0xF11B 0x0F01      CMN      R11,#+1
   \   000001B6   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Read_18
   \   000001B8   0xF1BB 0x0F00      CMP      R11,#+0
   \   000001BC   0xD005             BEQ.N    ??HAL_I2C_Mem_Read_20
   \   000001BE   0x.... 0x....      BL       HAL_GetTick
   \   000001C2   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000001C6   0x4583             CMP      R11,R0
   \   000001C8   0xD2EF             BCS.N    ??HAL_I2C_Mem_Read_18
   \                     ??HAL_I2C_Mem_Read_20: (+1)
   \   000001CA   0x2001             MOVS     R0,#+1
   \   000001CC   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   000001D0   0x2000             MOVS     R0,#+0
   \   000001D2   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   000001D6   0x2003             MOVS     R0,#+3
   \   000001D8   0xB001             ADD      SP,SP,#+4
   \   000001DA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_19: (+1)
   \   000001DE   0x6A40             LDR      R0,[R0, #+36]
   \   000001E0   0x1E76             SUBS     R6,R6,#+1
   \   000001E2   0xF1A4 0x0401      SUB      R4,R4,#+1
   \   000001E6   0xB2A4             UXTH     R4,R4
   \   000001E8   0xF808 0x0B01      STRB     R0,[R8], #+1
   \   000001EC   0xD129             BNE.N    ??HAL_I2C_Mem_Read_21
   \   000001EE   0xB354             CBZ.N    R4,??HAL_I2C_Mem_Read_22
   \   000001F0   0x.... 0x....      BL       HAL_GetTick
   \   000001F4   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Read_23: (+1)
   \   000001F6   0x6828             LDR      R0,[R5, #+0]
   \   000001F8   0x6981             LDR      R1,[R0, #+24]
   \   000001FA   0x0609             LSLS     R1,R1,#+24
   \   000001FC   0xD414             BMI.N    ??HAL_I2C_Mem_Read_24
   \   000001FE   0xF11B 0x0F01      CMN      R11,#+1
   \   00000202   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Read_23
   \   00000204   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000208   0xD004             BEQ.N    ??HAL_I2C_Mem_Read_25
   \   0000020A   0x.... 0x....      BL       HAL_GetTick
   \   0000020E   0x1B80             SUBS     R0,R0,R6
   \   00000210   0x4583             CMP      R11,R0
   \   00000212   0xD2F0             BCS.N    ??HAL_I2C_Mem_Read_23
   \                     ??HAL_I2C_Mem_Read_25: (+1)
   \   00000214   0x2001             MOVS     R0,#+1
   \   00000216   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000021A   0x2000             MOVS     R0,#+0
   \   0000021C   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000220   0x2003             MOVS     R0,#+3
   \   00000222   0xB001             ADD      SP,SP,#+4
   \   00000224   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_24: (+1)
   \   00000228   0x2CFF             CMP      R4,#+255
   \   0000022A   0x6841             LDR      R1,[R0, #+4]
   \   0000022C   0xEA0A 0x0101      AND      R1,R10,R1
   \   00000230   0xDDAE             BLE.N    ??HAL_I2C_Mem_Read_17
   \   00000232   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000236   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0x1ff0000
   \   0000023A   0x26FF             MOVS     R6,#+255
   \   0000023C   0x4311             ORRS     R1,R2,R1
   \   0000023E   0x6041             STR      R1,[R0, #+4]
   \   00000240   0xE7B0             B.N      ??HAL_I2C_Mem_Read_15
   \                     ??HAL_I2C_Mem_Read_21: (+1)
   \   00000242   0x2C00             CMP      R4,#+0
   \   00000244   0xD1AE             BNE.N    ??HAL_I2C_Mem_Read_15
   \                     ??HAL_I2C_Mem_Read_22: (+1)
   \   00000246   0x.... 0x....      BL       HAL_GetTick
   \   0000024A   0x4604             MOV      R4,R0
   \                     ??HAL_I2C_Mem_Read_26: (+1)
   \   0000024C   0x6828             LDR      R0,[R5, #+0]
   \   0000024E   0x6981             LDR      R1,[R0, #+24]
   \   00000250   0x0689             LSLS     R1,R1,#+26
   \   00000252   0xD41A             BMI.N    ??HAL_I2C_Mem_Read_27
   \   00000254   0x2119             MOVS     R1,#+25
   \   00000256   0x4628             MOV      R0,R5
   \   00000258   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000025C   0xB970             CBNZ.N   R0,??HAL_I2C_Mem_Read_28
   \   0000025E   0x.... 0x....      BL       HAL_GetTick
   \   00000262   0x1B00             SUBS     R0,R0,R4
   \   00000264   0x281A             CMP      R0,#+26
   \   00000266   0xD3F1             BCC.N    ??HAL_I2C_Mem_Read_26
   \   00000268   0x6BA8             LDR      R0,[R5, #+56]
   \   0000026A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000026E   0x63A8             STR      R0,[R5, #+56]
   \   00000270   0x2001             MOVS     R0,#+1
   \   00000272   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Read_28: (+1)
   \   0000027C   0x6BA8             LDR      R0,[R5, #+56]
   \   0000027E   0x2804             CMP      R0,#+4
   \   00000280   0xD114             BNE.N    ??HAL_I2C_Mem_Read_29
   \   00000282   0x2001             MOVS     R0,#+1
   \   00000284   0xB001             ADD      SP,SP,#+4
   \   00000286   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1827                }
   1828              }
   1829              
   1830              /* Clear STOP Flag */
   1831              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Read_27: (+1)
   \   0000028A   0x2120             MOVS     R1,#+32
   1832            	
   1833              /* Clear Configuration Register 2 */
   1834              I2C_RESET_CR2(hi2c);
   \   0000028C   0x.... 0x....      LDR.W    R2,??DataTable15_2  ;; 0xfe00e800
   \   00000290   0x61C1             STR      R1,[R0, #+28]
   \   00000292   0x6828             LDR      R0,[R5, #+0]
   \   00000294   0x6841             LDR      R1,[R0, #+4]
   \   00000296   0x4011             ANDS     R1,R2,R1
   \   00000298   0x6041             STR      R1,[R0, #+4]
   1835              
   1836              hi2c->State = HAL_I2C_STATE_READY;
   \   0000029A   0x2001             MOVS     R0,#+1
   \   0000029C   0xF885 0x0035      STRB     R0,[R5, #+53]
   1837              
   1838              /* Process Unlocked */
   1839              __HAL_UNLOCK(hi2c);
   \   000002A0   0x2000             MOVS     R0,#+0
   \   000002A2   0xF885 0x0034      STRB     R0,[R5, #+52]
   1840              
   1841              return HAL_OK;
   \   000002A6   0xB001             ADD      SP,SP,#+4
   \   000002A8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_29: (+1)
   \   000002AC   0x2003             MOVS     R0,#+3
   \   000002AE   0xB001             ADD      SP,SP,#+4
   \   000002B0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1842            }
   1843            else
   1844            {
   1845              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \   000002B4   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \   000002B6   0xB001             ADD      SP,SP,#+4
   \   000002B8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1846            }
   1847          }
   1848          /**
   1849            * @brief  Write an amount of data in no-blocking mode with Interrupt to a specific memory address
   1850            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1851            *                the configuration information for the specified I2C.
   1852            * @param  DevAddress: Target device address
   1853            * @param  MemAddress: Internal memory address
   1854            * @param  MemAddSize: Size of internal memory address
   1855            * @param  pData: Pointer to data buffer
   1856            * @param  Size: Amount of data to be sent
   1857            * @retval HAL status
   1858            */

   \                                 In section .text, align 2, keep-with-next
   1859          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   1860          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
   1861            /* Check the parameters */
   1862            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1863            
   1864            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80BA      BNE.W    ??HAL_I2C_Mem_Write_IT_0
   \   00000016   0x9B08             LDR      R3,[SP, #+32]
   1865            {
   1866              if((pData == NULL) || (Size == 0)) 
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x9809             LDRNE    R0,[SP, #+36]
   \   0000001E   0x2800             CMPNE    R0,#+0
   \   00000020   0xD04A             BEQ.N    ??HAL_I2C_Mem_Write_IT_1
   1867              {
   1868                return  HAL_ERROR;                                    
   1869              }
   1870              
   1871              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000022   0x6822             LDR      R2,[R4, #+0]
   \   00000024   0x6997             LDR      R7,[R2, #+24]
   \   00000026   0x043F             LSLS     R7,R7,#+16
   \   00000028   0xF100 0x80AF      BMI.W    ??HAL_I2C_Mem_Write_IT_0
   1872              {
   1873                return HAL_BUSY;
   1874              }
   1875              
   1876              /* Process Locked */
   1877              __HAL_LOCK(hi2c);
   \   0000002C   0xF894 0x7034      LDRB     R7,[R4, #+52]
   \   00000030   0x2F01             CMP      R7,#+1
   \   00000032   0xF000 0x80AA      BEQ.W    ??HAL_I2C_Mem_Write_IT_0
   \   00000036   0x2701             MOVS     R7,#+1
   1878              
   1879              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   1880              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1881              
   1882              hi2c->pBuffPtr = pData;
   1883              hi2c->XferCount = Size;
   1884              if(Size > 255)
   1885              {
   1886                hi2c->XferSize = 255;
   1887              }
   1888              else
   1889              {
   1890                hi2c->XferSize = Size;
   1891              }
   1892              
   1893              /* Send Slave Address and Memory Address */
   1894              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000038   0x.... 0x....      LDR.W    R8,??DataTable15  ;; 0xfc009800
   \   0000003C   0xF884 0x7034      STRB     R7,[R4, #+52]
   \   00000040   0x2752             MOVS     R7,#+82
   \   00000042   0xF884 0x7035      STRB     R7,[R4, #+53]
   \   00000046   0x2700             MOVS     R7,#+0
   \   00000048   0x63A7             STR      R7,[R4, #+56]
   \   0000004A   0x28FF             CMP      R0,#+255
   \   0000004C   0x6263             STR      R3,[R4, #+36]
   \   0000004E   0x8560             STRH     R0,[R4, #+42]
   \   00000050   0xBFC8             IT       GT 
   \   00000052   0x20FF             MOVGT    R0,#+255
   \   00000054   0x8520             STRH     R0,[R4, #+40]
   \   00000056   0x058F             LSLS     R7,R1,#+22
   \   00000058   0x6850             LDR      R0,[R2, #+4]
   \   0000005A   0xB2F1             UXTB     R1,R6
   \   0000005C   0xEA08 0x0000      AND      R0,R8,R0
   \   00000060   0xEA50 0x5097      ORRS     R0,R0,R7, LSR #+22
   \   00000064   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000068   0xF040 0x7080      ORR      R0,R0,#0x1000000
   \   0000006C   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000070   0x6050             STR      R0,[R2, #+4]
   \   00000072   0x.... 0x....      BL       HAL_GetTick
   \   00000076   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6988             LDR      R0,[R1, #+24]
   \   0000007C   0x0780             LSLS     R0,R0,#+30
   \   0000007E   0xD41F             BMI.N    ??HAL_I2C_Mem_Write_IT_3
   \   00000080   0x2119             MOVS     R1,#+25
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000088   0xB978             CBNZ.N   R0,??HAL_I2C_Mem_Write_IT_4
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000092   0x281A             CMP      R0,#+26
   \   00000094   0xD3F0             BCC.N    ??HAL_I2C_Mem_Write_IT_2
   \   00000096   0x6BA0             LDR      R0,[R4, #+56]
   \   00000098   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000009C   0x63A0             STR      R0,[R4, #+56]
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \   000000AA   0x6BA0             LDR      R0,[R4, #+56]
   1895              {
   1896                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Write_IT_5: (+1)
   \   000000AC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000AE   0x2804             CMP      R0,#+4
   \   000000B0   0xD14D             BNE.N    ??HAL_I2C_Mem_Write_IT_6
   1897                {
   1898                  /* Process Unlocked */
   1899                  __HAL_UNLOCK(hi2c);
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF884 0x0034      STRB     R0,[R4, #+52]
   1900                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xB001             ADD      SP,SP,#+4
   \   000000BC   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1901                }
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \   000000C0   0x2E01             CMP      R6,#+1
   \   000000C2   0xD01E             BEQ.N    ??HAL_I2C_Mem_Write_IT_7
   \   000000C4   0x0A28             LSRS     R0,R5,#+8
   \   000000C6   0x6288             STR      R0,[R1, #+40]
   \   000000C8   0x.... 0x....      BL       HAL_GetTick
   \   000000CC   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Write_IT_8: (+1)
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x6980             LDR      R0,[R0, #+24]
   \   000000D2   0x0780             LSLS     R0,R0,#+30
   \   000000D4   0xD415             BMI.N    ??HAL_I2C_Mem_Write_IT_7
   \   000000D6   0x2119             MOVS     R1,#+25
   \   000000D8   0x4620             MOV      R0,R4
   \   000000DA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD1E3             BNE.N    ??HAL_I2C_Mem_Write_IT_4
   \   000000E2   0x.... 0x....      BL       HAL_GetTick
   \   000000E6   0x1B80             SUBS     R0,R0,R6
   \   000000E8   0x281A             CMP      R0,#+26
   \   000000EA   0xD3F0             BCC.N    ??HAL_I2C_Mem_Write_IT_8
   \   000000EC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000EE   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000F2   0x63A0             STR      R0,[R4, #+56]
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000100   0xE7D3             B.N      ??HAL_I2C_Mem_Write_IT_4
   \                     ??HAL_I2C_Mem_Write_IT_7: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0xB2ED             UXTB     R5,R5
   \   00000106   0x6285             STR      R5,[R0, #+40]
   \   00000108   0x.... 0x....      BL       HAL_GetTick
   \   0000010C   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Write_IT_9: (+1)
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x6981             LDR      R1,[R0, #+24]
   \   00000112   0x0609             LSLS     R1,R1,#+24
   \   00000114   0xD40B             BMI.N    ??HAL_I2C_Mem_Write_IT_10
   \   00000116   0x.... 0x....      BL       HAL_GetTick
   \   0000011A   0x1B40             SUBS     R0,R0,R5
   \   0000011C   0x281A             CMP      R0,#+26
   \   0000011E   0xD3F6             BCC.N    ??HAL_I2C_Mem_Write_IT_9
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000012C   0xE7BE             B.N      ??HAL_I2C_Mem_Write_IT_5
   1902                else
   1903                {
   1904                  /* Process Unlocked */
   1905                  __HAL_UNLOCK(hi2c);
   1906                  return HAL_TIMEOUT;
   1907                }
   1908              }
   1909              
   1910              /* Set NBYTES to write and reload if size > 255 */
   1911              /* Size > 255, need to set RELOAD bit */
   1912              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Write_IT_10: (+1)
   \   0000012E   0x8D21             LDRH     R1,[R4, #+40]
   \   00000130   0x29FF             CMP      R1,#+255
   \   00000132   0xD113             BNE.N    ??HAL_I2C_Mem_Write_IT_11
   \   00000134   0x8D62             LDRH     R2,[R4, #+42]
   \   00000136   0x4291             CMP      R1,R2
   \   00000138   0xD210             BCS.N    ??HAL_I2C_Mem_Write_IT_11
   1913              {
   1914                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   0000013A   0x6842             LDR      R2,[R0, #+4]
   \   0000013C   0xEA08 0x0202      AND      R2,R8,R2
   \   00000140   0xEA52 0x5297      ORRS     R2,R2,R7, LSR #+22
   \   00000144   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000148   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   0000014C   0xE010             B.N      ??HAL_I2C_Mem_Write_IT_12
   1915              }
   \                     ??HAL_I2C_Mem_Write_IT_6: (+1)
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000154   0x2003             MOVS     R0,#+3
   \   00000156   0xB001             ADD      SP,SP,#+4
   \   00000158   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1916              else
   1917              {
   1918                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Write_IT_11: (+1)
   \   0000015C   0x6842             LDR      R2,[R0, #+4]
   \   0000015E   0xB2C9             UXTB     R1,R1
   \   00000160   0xEA08 0x0202      AND      R2,R8,R2
   \   00000164   0xEA52 0x5297      ORRS     R2,R2,R7, LSR #+22
   \   00000168   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000016C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Write_IT_12: (+1)
   \   00000170   0x6041             STR      R1,[R0, #+4]
   1919              }  
   1920              
   1921              /* Process Unlocked */
   1922              __HAL_UNLOCK(hi2c); 
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0xF884 0x0034      STRB     R0,[R4, #+52]
   1923              
   1924              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1925              to avoid the risk of I2C interrupt handle execution before current
   1926              process unlock */
   1927              
   1928              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1929              /* possible to enable all of these */
   1930              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1931              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \   00000178   0x6820             LDR      R0,[R4, #+0]
   \   0000017A   0x6801             LDR      R1,[R0, #+0]
   \   0000017C   0xF041 0x01F2      ORR      R1,R1,#0xF2
   \   00000180   0x6001             STR      R1,[R0, #+0]
   1932              
   1933              return HAL_OK;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0xB001             ADD      SP,SP,#+4
   \   00000186   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1934            }
   1935            else
   1936            {
   1937              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \   0000018A   0x2002             MOVS     R0,#+2
   \   0000018C   0xB001             ADD      SP,SP,#+4
   \   0000018E   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1938            }
   1939          }
   1940          
   1941          /**
   1942            * @brief  Read an amount of data in no-blocking mode with Interrupt from a specific memory address
   1943            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1944            *                the configuration information for the specified I2C.
   1945            * @param  DevAddress: Target device address
   1946            * @param  MemAddress: Internal memory address
   1947            * @param  MemAddSize: Size of internal memory address
   1948            * @param  pData: Pointer to data buffer
   1949            * @param  Size: Amount of data to be sent
   1950            * @retval HAL status
   1951            */

   \                                 In section .text, align 2, keep-with-next
   1952          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   1953          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
   1954            /* Check the parameters */
   1955            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1956            
   1957            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80B8      BNE.W    ??HAL_I2C_Mem_Read_IT_0
   \   00000016   0x9B08             LDR      R3,[SP, #+32]
   1958            {
   1959              if((pData == NULL) || (Size == 0)) 
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x9809             LDRNE    R0,[SP, #+36]
   \   0000001E   0x2800             CMPNE    R0,#+0
   \   00000020   0xD046             BEQ.N    ??HAL_I2C_Mem_Read_IT_1
   1960              {
   1961                return  HAL_ERROR;                                    
   1962              }
   1963              
   1964              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000022   0x6822             LDR      R2,[R4, #+0]
   \   00000024   0x6997             LDR      R7,[R2, #+24]
   \   00000026   0x043F             LSLS     R7,R7,#+16
   \   00000028   0xF100 0x80AD      BMI.W    ??HAL_I2C_Mem_Read_IT_0
   1965              {
   1966                return HAL_BUSY;
   1967              }
   1968              
   1969              /* Process Locked */
   1970              __HAL_LOCK(hi2c);
   \   0000002C   0xF894 0x7034      LDRB     R7,[R4, #+52]
   \   00000030   0x2F01             CMP      R7,#+1
   \   00000032   0xF000 0x80A8      BEQ.W    ??HAL_I2C_Mem_Read_IT_0
   \   00000036   0x2701             MOVS     R7,#+1
   1971              
   1972              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   1973              
   1974              hi2c->pBuffPtr = pData;
   1975              hi2c->XferCount = Size;
   1976              if(Size > 255)
   1977              {
   1978                hi2c->XferSize = 255;
   1979              }
   1980              else
   1981              {
   1982                hi2c->XferSize = Size;
   1983              }
   1984              
   1985              /* Send Slave Address and Memory Address */
   1986              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000038   0x.... 0x....      LDR.W    R8,??DataTable15  ;; 0xfc009800
   \   0000003C   0xF884 0x7034      STRB     R7,[R4, #+52]
   \   00000040   0x2762             MOVS     R7,#+98
   \   00000042   0xF884 0x7035      STRB     R7,[R4, #+53]
   \   00000046   0x28FF             CMP      R0,#+255
   \   00000048   0x6263             STR      R3,[R4, #+36]
   \   0000004A   0x8560             STRH     R0,[R4, #+42]
   \   0000004C   0xBFC8             IT       GT 
   \   0000004E   0x20FF             MOVGT    R0,#+255
   \   00000050   0x8520             STRH     R0,[R4, #+40]
   \   00000052   0x058F             LSLS     R7,R1,#+22
   \   00000054   0x6850             LDR      R0,[R2, #+4]
   \   00000056   0xB2F1             UXTB     R1,R6
   \   00000058   0xEA08 0x0000      AND      R0,R8,R0
   \   0000005C   0xEA50 0x5097      ORRS     R0,R0,R7, LSR #+22
   \   00000060   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000064   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000068   0x6050             STR      R0,[R2, #+4]
   \   0000006A   0x.... 0x....      BL       HAL_GetTick
   \   0000006E   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6988             LDR      R0,[R1, #+24]
   \   00000074   0x0780             LSLS     R0,R0,#+30
   \   00000076   0xD41F             BMI.N    ??HAL_I2C_Mem_Read_IT_3
   \   00000078   0x2119             MOVS     R1,#+25
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000080   0xB978             CBNZ.N   R0,??HAL_I2C_Mem_Read_IT_4
   \   00000082   0x.... 0x....      BL       HAL_GetTick
   \   00000086   0xEBA0 0x0009      SUB      R0,R0,R9
   \   0000008A   0x281A             CMP      R0,#+26
   \   0000008C   0xD3F0             BCC.N    ??HAL_I2C_Mem_Read_IT_2
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000094   0x63A0             STR      R0,[R4, #+56]
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \   000000A2   0x6BA0             LDR      R0,[R4, #+56]
   1987              {
   1988                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Read_IT_5: (+1)
   \   000000A4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000A6   0x2804             CMP      R0,#+4
   \   000000A8   0xD14D             BNE.N    ??HAL_I2C_Mem_Read_IT_6
   1989                {
   1990                  /* Process Unlocked */
   1991                  __HAL_UNLOCK(hi2c);
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x0034      STRB     R0,[R4, #+52]
   1992                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xB001             ADD      SP,SP,#+4
   \   000000B4   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1993                }
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \   000000B8   0x2E01             CMP      R6,#+1
   \   000000BA   0xD01E             BEQ.N    ??HAL_I2C_Mem_Read_IT_7
   \   000000BC   0x0A28             LSRS     R0,R5,#+8
   \   000000BE   0x6288             STR      R0,[R1, #+40]
   \   000000C0   0x.... 0x....      BL       HAL_GetTick
   \   000000C4   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Read_IT_8: (+1)
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6980             LDR      R0,[R0, #+24]
   \   000000CA   0x0780             LSLS     R0,R0,#+30
   \   000000CC   0xD415             BMI.N    ??HAL_I2C_Mem_Read_IT_7
   \   000000CE   0x2119             MOVS     R1,#+25
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD1E3             BNE.N    ??HAL_I2C_Mem_Read_IT_4
   \   000000DA   0x.... 0x....      BL       HAL_GetTick
   \   000000DE   0x1B80             SUBS     R0,R0,R6
   \   000000E0   0x281A             CMP      R0,#+26
   \   000000E2   0xD3F0             BCC.N    ??HAL_I2C_Mem_Read_IT_8
   \   000000E4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E6   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000EA   0x63A0             STR      R0,[R4, #+56]
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000F8   0xE7D3             B.N      ??HAL_I2C_Mem_Read_IT_4
   \                     ??HAL_I2C_Mem_Read_IT_7: (+1)
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0xB2ED             UXTB     R5,R5
   \   000000FE   0x6285             STR      R5,[R0, #+40]
   \   00000100   0x.... 0x....      BL       HAL_GetTick
   \   00000104   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Read_IT_9: (+1)
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x6981             LDR      R1,[R0, #+24]
   \   0000010A   0x0649             LSLS     R1,R1,#+25
   \   0000010C   0xD40B             BMI.N    ??HAL_I2C_Mem_Read_IT_10
   \   0000010E   0x.... 0x....      BL       HAL_GetTick
   \   00000112   0x1B40             SUBS     R0,R0,R5
   \   00000114   0x281A             CMP      R0,#+26
   \   00000116   0xD3F6             BCC.N    ??HAL_I2C_Mem_Read_IT_9
   \   00000118   0x2001             MOVS     R0,#+1
   \   0000011A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000124   0xE7BE             B.N      ??HAL_I2C_Mem_Read_IT_5
   1994                else
   1995                {
   1996                  /* Process Unlocked */
   1997                  __HAL_UNLOCK(hi2c);
   1998                  return HAL_TIMEOUT;
   1999                }
   2000              }
   2001              
   2002              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   2003              /* Size > 255, need to set RELOAD bit */
   2004              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Read_IT_10: (+1)
   \   00000126   0x8D21             LDRH     R1,[R4, #+40]
   \   00000128   0x29FF             CMP      R1,#+255
   \   0000012A   0xD113             BNE.N    ??HAL_I2C_Mem_Read_IT_11
   \   0000012C   0x8D62             LDRH     R2,[R4, #+42]
   \   0000012E   0x4291             CMP      R1,R2
   \   00000130   0xD210             BCS.N    ??HAL_I2C_Mem_Read_IT_11
   2005              {
   2006                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000132   0x6842             LDR      R2,[R0, #+4]
   \   00000134   0xEA08 0x0202      AND      R2,R8,R2
   \   00000138   0xEA52 0x5297      ORRS     R2,R2,R7, LSR #+22
   \   0000013C   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000140   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000144   0xE010             B.N      ??HAL_I2C_Mem_Read_IT_12
   2007              }
   \                     ??HAL_I2C_Mem_Read_IT_6: (+1)
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000014C   0x2003             MOVS     R0,#+3
   \   0000014E   0xB001             ADD      SP,SP,#+4
   \   00000150   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2008              else
   2009              {
   2010                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_IT_11: (+1)
   \   00000154   0x6842             LDR      R2,[R0, #+4]
   \   00000156   0xB2C9             UXTB     R1,R1
   \   00000158   0xEA08 0x0202      AND      R2,R8,R2
   \   0000015C   0xEA52 0x5297      ORRS     R2,R2,R7, LSR #+22
   \   00000160   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000164   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Read_IT_12: (+1)
   \   00000168   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   0000016C   0x6041             STR      R1,[R0, #+4]
   2011              }
   2012              
   2013              /* Process Unlocked */
   2014              __HAL_UNLOCK(hi2c); 
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF884 0x0034      STRB     R0,[R4, #+52]
   2015              
   2016              /* Note : The I2C interrupts must be enabled after unlocking current process 
   2017              to avoid the risk of I2C interrupt handle execution before current
   2018              process unlock */
   2019              
   2020              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   2021              /* possible to enable all of these */
   2022              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   2023              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
   \   00000174   0x6820             LDR      R0,[R4, #+0]
   \   00000176   0x6801             LDR      R1,[R0, #+0]
   \   00000178   0xF041 0x01F4      ORR      R1,R1,#0xF4
   \   0000017C   0x6001             STR      R1,[R0, #+0]
   2024              
   2025              return HAL_OK;
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0xB001             ADD      SP,SP,#+4
   \   00000182   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2026            }
   2027            else
   2028            {
   2029              return HAL_BUSY; 
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \   00000186   0x2002             MOVS     R0,#+2
   \   00000188   0xB001             ADD      SP,SP,#+4
   \   0000018A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2030            }   
   2031          }
   2032          /**
   2033            * @brief  Write an amount of data in no-blocking mode with DMA to a specific memory address
   2034            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2035            *                the configuration information for the specified I2C.
   2036            * @param  DevAddress: Target device address
   2037            * @param  MemAddress: Internal memory address
   2038            * @param  MemAddSize: Size of internal memory address
   2039            * @param  pData: Pointer to data buffer
   2040            * @param  Size: Amount of data to be sent
   2041            * @retval HAL status
   2042            */

   \                                 In section .text, align 2, keep-with-next
   2043          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2044          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4615             MOV      R5,R2
   2045            /* Check the parameters */
   2046            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2047            
   2048            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x4698             MOV      R8,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x80EF      BNE.W    ??HAL_I2C_Mem_Write_DMA_0
   \   00000018   0x9908             LDR      R1,[SP, #+32]
   2049            {
   2050              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x9809             LDRNE    R0,[SP, #+36]
   \   00000020   0x2800             CMPNE    R0,#+0
   \   00000022   0xF000 0x80D6      BEQ.W    ??HAL_I2C_Mem_Write_DMA_1
   2051              {
   2052                return  HAL_ERROR;                                    
   2053              }
   2054              
   2055              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000026   0x6822             LDR      R2,[R4, #+0]
   \   00000028   0x6992             LDR      R2,[R2, #+24]
   \   0000002A   0x0412             LSLS     R2,R2,#+16
   \   0000002C   0xF100 0x80E3      BMI.W    ??HAL_I2C_Mem_Write_DMA_0
   2056              {
   2057                return HAL_BUSY;
   2058              }
   2059              
   2060              /* Process Locked */
   2061              __HAL_LOCK(hi2c);
   \   00000030   0xF894 0x2034      LDRB     R2,[R4, #+52]
   \   00000034   0x2A01             CMP      R2,#+1
   \   00000036   0xF000 0x80DE      BEQ.W    ??HAL_I2C_Mem_Write_DMA_0
   \   0000003A   0x2201             MOVS     R2,#+1
   2062              
   2063              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   2064              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2065              
   2066              hi2c->pBuffPtr = pData;
   2067              hi2c->XferCount = Size;
   2068              if(Size > 255)
   2069              {
   2070                hi2c->XferSize = 255;
   2071              }
   2072              else
   2073              {
   2074                hi2c->XferSize = Size;
   2075              }
   2076              
   2077              /* Set the I2C DMA transfer complete callback */
   2078              hi2c->hdmatx->XferCpltCallback = I2C_DMAMemTransmitCplt;
   2079              
   2080              /* Set the DMA error callback */
   2081              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   2082              
   2083              /* Enable the DMA channel */
   2084              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   0000003C   0x.... 0x....      LDR.W    R7,??DataTable15  ;; 0xfc009800
   \   00000040   0xF884 0x2034      STRB     R2,[R4, #+52]
   \   00000044   0x2252             MOVS     R2,#+82
   \   00000046   0xF884 0x2035      STRB     R2,[R4, #+53]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x63A2             STR      R2,[R4, #+56]
   \   0000004E   0x28FF             CMP      R0,#+255
   \   00000050   0x6261             STR      R1,[R4, #+36]
   \   00000052   0x8560             STRH     R0,[R4, #+42]
   \   00000054   0xBFC8             IT       GT 
   \   00000056   0x20FF             MOVGT    R0,#+255
   \   00000058   0x8520             STRH     R0,[R4, #+40]
   \   0000005A   0x6AE2             LDR      R2,[R4, #+44]
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000060   0x05B6             LSLS     R6,R6,#+22
   \   00000062   0x63D0             STR      R0,[R2, #+60]
   \   00000064   0x6AE2             LDR      R2,[R4, #+44]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000006A   0x6490             STR      R0,[R2, #+72]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x8D23             LDRH     R3,[R4, #+40]
   \   00000070   0xF100 0x0228      ADD      R2,R0,#+40
   \   00000074   0x6AE0             LDR      R0,[R4, #+44]
   \   00000076   0x.... 0x....      BL       HAL_DMA_Start_IT
   2085              
   2086              /* Send Slave Address and Memory Address */
   2087              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0xFA5F 0xF288      UXTB     R2,R8
   \   00000080   0x6841             LDR      R1,[R0, #+4]
   \   00000082   0x4039             ANDS     R1,R7,R1
   \   00000084   0xEA51 0x5196      ORRS     R1,R1,R6, LSR #+22
   \   00000088   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000008C   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000090   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000094   0x6041             STR      R1,[R0, #+4]
   \   00000096   0x.... 0x....      BL       HAL_GetTick
   \   0000009A   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6988             LDR      R0,[R1, #+24]
   \   000000A0   0x0780             LSLS     R0,R0,#+30
   \   000000A2   0xD41F             BMI.N    ??HAL_I2C_Mem_Write_DMA_3
   \   000000A4   0x2119             MOVS     R1,#+25
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000AC   0xB978             CBNZ.N   R0,??HAL_I2C_Mem_Write_DMA_4
   \   000000AE   0x.... 0x....      BL       HAL_GetTick
   \   000000B2   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000B6   0x281A             CMP      R0,#+26
   \   000000B8   0xD3F0             BCC.N    ??HAL_I2C_Mem_Write_DMA_2
   \   000000BA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000BC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000C0   0x63A0             STR      R0,[R4, #+56]
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \   000000CE   0x6BA0             LDR      R0,[R4, #+56]
   2088              {
   2089                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \   000000D0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D2   0x2804             CMP      R0,#+4
   \   000000D4   0xD14E             BNE.N    ??HAL_I2C_Mem_Write_DMA_6
   2090                {
   2091                  /* Process Unlocked */
   2092                  __HAL_UNLOCK(hi2c);
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xF884 0x0034      STRB     R0,[R4, #+52]
   2093                  return HAL_ERROR;
   2094                }
   2095                else
   2096                {
   2097                  /* Process Unlocked */
   2098                  __HAL_UNLOCK(hi2c);
   2099                  return HAL_TIMEOUT;
   2100                }
   2101              }
   2102              
   2103              /* Send Slave Address */
   2104              /* Set NBYTES to write and reload if size > 255 */
   2105              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   2106              {
   2107                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   2108              }
   2109              else
   2110              {
   2111                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   2112              }
   2113              
   2114              /* Wait until TXIS flag is set */
   2115              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   2116              {
   2117                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   2118                {
   2119                  return HAL_ERROR;
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xB001             ADD      SP,SP,#+4
   \   000000E0   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \   000000E4   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000E8   0xD01F             BEQ.N    ??HAL_I2C_Mem_Write_DMA_7
   \   000000EA   0x0A28             LSRS     R0,R5,#+8
   \   000000EC   0x6288             STR      R0,[R1, #+40]
   \   000000EE   0x.... 0x....      BL       HAL_GetTick
   \   000000F2   0x4680             MOV      R8,R0
   \                     ??HAL_I2C_Mem_Write_DMA_8: (+1)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x6980             LDR      R0,[R0, #+24]
   \   000000F8   0x0780             LSLS     R0,R0,#+30
   \   000000FA   0xD416             BMI.N    ??HAL_I2C_Mem_Write_DMA_7
   \   000000FC   0x2119             MOVS     R1,#+25
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD1E2             BNE.N    ??HAL_I2C_Mem_Write_DMA_4
   \   00000108   0x.... 0x....      BL       HAL_GetTick
   \   0000010C   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000110   0x281A             CMP      R0,#+26
   \   00000112   0xD3EF             BCC.N    ??HAL_I2C_Mem_Write_DMA_8
   \   00000114   0x6BA0             LDR      R0,[R4, #+56]
   \   00000116   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000011A   0x63A0             STR      R0,[R4, #+56]
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000128   0xE7D1             B.N      ??HAL_I2C_Mem_Write_DMA_4
   \                     ??HAL_I2C_Mem_Write_DMA_7: (+1)
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0xB2ED             UXTB     R5,R5
   \   0000012E   0x6285             STR      R5,[R0, #+40]
   \   00000130   0x.... 0x....      BL       HAL_GetTick
   \   00000134   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Write_DMA_9: (+1)
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x6981             LDR      R1,[R0, #+24]
   \   0000013A   0x0609             LSLS     R1,R1,#+24
   \   0000013C   0xD40B             BMI.N    ??HAL_I2C_Mem_Write_DMA_10
   \   0000013E   0x.... 0x....      BL       HAL_GetTick
   \   00000142   0x1B40             SUBS     R0,R0,R5
   \   00000144   0x281A             CMP      R0,#+26
   \   00000146   0xD3F6             BCC.N    ??HAL_I2C_Mem_Write_DMA_9
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000154   0xE7BC             B.N      ??HAL_I2C_Mem_Write_DMA_5
   \                     ??HAL_I2C_Mem_Write_DMA_10: (+1)
   \   00000156   0x8D21             LDRH     R1,[R4, #+40]
   \   00000158   0x29FF             CMP      R1,#+255
   \   0000015A   0xD112             BNE.N    ??HAL_I2C_Mem_Write_DMA_11
   \   0000015C   0x8D62             LDRH     R2,[R4, #+42]
   \   0000015E   0x4291             CMP      R1,R2
   \   00000160   0xD20F             BCS.N    ??HAL_I2C_Mem_Write_DMA_11
   \   00000162   0x6842             LDR      R2,[R0, #+4]
   \   00000164   0x403A             ANDS     R2,R7,R2
   \   00000166   0xEA52 0x5296      ORRS     R2,R2,R6, LSR #+22
   \   0000016A   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000016E   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000172   0xE00F             B.N      ??HAL_I2C_Mem_Write_DMA_12
   \                     ??HAL_I2C_Mem_Write_DMA_6: (+1)
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0xF884 0x0034      STRB     R0,[R4, #+52]
   2120                }
   2121                else
   2122                {
   2123                  return HAL_TIMEOUT;
   \   0000017A   0x2003             MOVS     R0,#+3
   \   0000017C   0xB001             ADD      SP,SP,#+4
   \   0000017E   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??HAL_I2C_Mem_Write_DMA_11: (+1)
   \   00000182   0x6842             LDR      R2,[R0, #+4]
   \   00000184   0xB2C9             UXTB     R1,R1
   \   00000186   0x403A             ANDS     R2,R7,R2
   \   00000188   0xEA52 0x5296      ORRS     R2,R2,R6, LSR #+22
   \   0000018C   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000190   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Write_DMA_12: (+1)
   \   00000194   0x6041             STR      R1,[R0, #+4]
   \   00000196   0x.... 0x....      BL       HAL_GetTick
   \   0000019A   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Write_DMA_13: (+1)
   \   0000019C   0x6820             LDR      R0,[R4, #+0]
   \   0000019E   0x6981             LDR      R1,[R0, #+24]
   \   000001A0   0x0789             LSLS     R1,R1,#+30
   \   000001A2   0xD41A             BMI.N    ??HAL_I2C_Mem_Write_DMA_14
   \   000001A4   0x2119             MOVS     R1,#+25
   \   000001A6   0x4620             MOV      R0,R4
   \   000001A8   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001AC   0xB970             CBNZ.N   R0,??HAL_I2C_Mem_Write_DMA_15
   \   000001AE   0x.... 0x....      BL       HAL_GetTick
   \   000001B2   0x1B40             SUBS     R0,R0,R5
   \   000001B4   0x281A             CMP      R0,#+26
   \   000001B6   0xD3F1             BCC.N    ??HAL_I2C_Mem_Write_DMA_13
   \   000001B8   0x6BA0             LDR      R0,[R4, #+56]
   \   000001BA   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001BE   0x63A0             STR      R0,[R4, #+56]
   \   000001C0   0x2001             MOVS     R0,#+1
   \   000001C2   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Write_DMA_15: (+1)
   \   000001CC   0x6BA0             LDR      R0,[R4, #+56]
   \   000001CE   0x2804             CMP      R0,#+4
   \   000001D0   0xD10D             BNE.N    ??HAL_I2C_Mem_Write_DMA_16
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \   000001D2   0x2001             MOVS     R0,#+1
   \   000001D4   0xB001             ADD      SP,SP,#+4
   \   000001D6   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2124                }
   2125              }
   2126              
   2127              /* Enable DMA Request */
   2128              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;  
   \                     ??HAL_I2C_Mem_Write_DMA_14: (+1)
   \   000001DA   0x6801             LDR      R1,[R0, #+0]
   \   000001DC   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000001E0   0x6001             STR      R1,[R0, #+0]
   2129              
   2130              /* Process Unlocked */
   2131              __HAL_UNLOCK(hi2c);
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0xF884 0x0034      STRB     R0,[R4, #+52]
   2132              
   2133              return HAL_OK;
   \   000001E8   0xB001             ADD      SP,SP,#+4
   \   000001EA   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??HAL_I2C_Mem_Write_DMA_16: (+1)
   \   000001EE   0x2003             MOVS     R0,#+3
   \   000001F0   0xB001             ADD      SP,SP,#+4
   \   000001F2   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2134            }
   2135            else
   2136            {
   2137              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \   000001F6   0x2002             MOVS     R0,#+2
   \   000001F8   0xB001             ADD      SP,SP,#+4
   \   000001FA   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2138            }
   2139          }
   2140          
   2141          /**
   2142            * @brief  Reads an amount of data in no-blocking mode with DMA from a specific memory address.
   2143            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2144            *                the configuration information for the specified I2C.
   2145            * @param  DevAddress: Target device address
   2146            * @param  MemAddress: Internal memory address
   2147            * @param  MemAddSize: Size of internal memory address
   2148            * @param  pData: Pointer to data buffer
   2149            * @param  Size: Amount of data to be read
   2150            * @retval HAL status
   2151            */

   \                                 In section .text, align 2, keep-with-next
   2152          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2153          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4615             MOV      R5,R2
   2154            /* Check the parameters */
   2155            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2156            
   2157            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x4698             MOV      R8,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x80D4      BNE.W    ??HAL_I2C_Mem_Read_DMA_0
   \   00000018   0x9A08             LDR      R2,[SP, #+32]
   2158            {
   2159              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x9809             LDRNE    R0,[SP, #+36]
   \   00000020   0x2800             CMPNE    R0,#+0
   \   00000022   0xD055             BEQ.N    ??HAL_I2C_Mem_Read_DMA_1
   2160              {
   2161                return  HAL_ERROR;                                    
   2162              }
   2163              
   2164              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6989             LDR      R1,[R1, #+24]
   \   00000028   0x0409             LSLS     R1,R1,#+16
   \   0000002A   0xF100 0x80C9      BMI.W    ??HAL_I2C_Mem_Read_DMA_0
   2165              {
   2166                return HAL_BUSY;
   2167              }
   2168              
   2169              /* Process Locked */
   2170              __HAL_LOCK(hi2c);
   \   0000002E   0xF894 0x1034      LDRB     R1,[R4, #+52]
   \   00000032   0x2901             CMP      R1,#+1
   \   00000034   0xF000 0x80C4      BEQ.W    ??HAL_I2C_Mem_Read_DMA_0
   \   00000038   0x2101             MOVS     R1,#+1
   2171              
   2172              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   2173              
   2174              hi2c->pBuffPtr = pData;
   2175              hi2c->XferCount = Size;
   2176              if(Size > 255)
   2177              {
   2178                hi2c->XferSize = 255;
   2179              }
   2180              else
   2181              {
   2182                hi2c->XferSize = Size;
   2183              }
   2184              
   2185              /* Set the I2C DMA transfer complete callback */
   2186              hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
   2187              
   2188              /* Set the DMA error callback */
   2189              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   2190              
   2191              /* Enable the DMA channel */
   2192              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   \   0000003A   0x....             LDR.N    R7,??DataTable15  ;; 0xfc009800
   \   0000003C   0xF884 0x1034      STRB     R1,[R4, #+52]
   \   00000040   0x2162             MOVS     R1,#+98
   \   00000042   0xF884 0x1035      STRB     R1,[R4, #+53]
   \   00000046   0x28FF             CMP      R0,#+255
   \   00000048   0x6262             STR      R2,[R4, #+36]
   \   0000004A   0x8560             STRH     R0,[R4, #+42]
   \   0000004C   0xBFC8             IT       GT 
   \   0000004E   0x20FF             MOVGT    R0,#+255
   \   00000050   0x8520             STRH     R0,[R4, #+40]
   \   00000052   0x6B21             LDR      R1,[R4, #+48]
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000058   0x05B6             LSLS     R6,R6,#+22
   \   0000005A   0x63C8             STR      R0,[R1, #+60]
   \   0000005C   0x6B21             LDR      R1,[R4, #+48]
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000062   0x6488             STR      R0,[R1, #+72]
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x8D23             LDRH     R3,[R4, #+40]
   \   00000068   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000006C   0x6B20             LDR      R0,[R4, #+48]
   \   0000006E   0x.... 0x....      BL       HAL_DMA_Start_IT
   2193              
   2194              /* Send Slave Address and Memory Address */
   2195              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xFA5F 0xF288      UXTB     R2,R8
   \   00000078   0x6841             LDR      R1,[R0, #+4]
   \   0000007A   0x4039             ANDS     R1,R7,R1
   \   0000007C   0xEA51 0x5196      ORRS     R1,R1,R6, LSR #+22
   \   00000080   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000084   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000088   0x6041             STR      R1,[R0, #+4]
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6988             LDR      R0,[R1, #+24]
   \   00000094   0x0780             LSLS     R0,R0,#+30
   \   00000096   0xD41F             BMI.N    ??HAL_I2C_Mem_Read_DMA_3
   \   00000098   0x2119             MOVS     R1,#+25
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000A0   0xB978             CBNZ.N   R0,??HAL_I2C_Mem_Read_DMA_4
   \   000000A2   0x.... 0x....      BL       HAL_GetTick
   \   000000A6   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000AA   0x281A             CMP      R0,#+26
   \   000000AC   0xD3F0             BCC.N    ??HAL_I2C_Mem_Read_DMA_2
   \   000000AE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B0   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000B4   0x63A0             STR      R0,[R4, #+56]
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \   000000C2   0x6BA0             LDR      R0,[R4, #+56]
   2196              {
   2197                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \   000000C4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000C6   0x2804             CMP      R0,#+4
   \   000000C8   0xD169             BNE.N    ??HAL_I2C_Mem_Read_DMA_6
   2198                {
   2199                  /* Process Unlocked */
   2200                  __HAL_UNLOCK(hi2c);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF884 0x0034      STRB     R0,[R4, #+52]
   2201                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xB001             ADD      SP,SP,#+4
   \   000000D4   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2202                }
   2203                else
   2204                {
   2205                  /* Process Unlocked */
   2206                  __HAL_UNLOCK(hi2c);
   2207                  return HAL_TIMEOUT;
   2208                }
   2209              }
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \   000000D8   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000DC   0xD01F             BEQ.N    ??HAL_I2C_Mem_Read_DMA_7
   \   000000DE   0x0A28             LSRS     R0,R5,#+8
   \   000000E0   0x6288             STR      R0,[R1, #+40]
   \   000000E2   0x.... 0x....      BL       HAL_GetTick
   \   000000E6   0x4680             MOV      R8,R0
   \                     ??HAL_I2C_Mem_Read_DMA_8: (+1)
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6980             LDR      R0,[R0, #+24]
   \   000000EC   0x0780             LSLS     R0,R0,#+30
   \   000000EE   0xD416             BMI.N    ??HAL_I2C_Mem_Read_DMA_7
   \   000000F0   0x2119             MOVS     R1,#+25
   \   000000F2   0x4620             MOV      R0,R4
   \   000000F4   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD1E2             BNE.N    ??HAL_I2C_Mem_Read_DMA_4
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000104   0x281A             CMP      R0,#+26
   \   00000106   0xD3EF             BCC.N    ??HAL_I2C_Mem_Read_DMA_8
   \   00000108   0x6BA0             LDR      R0,[R4, #+56]
   \   0000010A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010E   0x63A0             STR      R0,[R4, #+56]
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000011C   0xE7D1             B.N      ??HAL_I2C_Mem_Read_DMA_4
   \                     ??HAL_I2C_Mem_Read_DMA_7: (+1)
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0xB2ED             UXTB     R5,R5
   \   00000122   0x6285             STR      R5,[R0, #+40]
   \   00000124   0x.... 0x....      BL       HAL_GetTick
   \   00000128   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Read_DMA_9: (+1)
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x6981             LDR      R1,[R0, #+24]
   \   0000012E   0x0649             LSLS     R1,R1,#+25
   \   00000130   0xD40B             BMI.N    ??HAL_I2C_Mem_Read_DMA_10
   \   00000132   0x.... 0x....      BL       HAL_GetTick
   \   00000136   0x1B40             SUBS     R0,R0,R5
   \   00000138   0x281A             CMP      R0,#+26
   \   0000013A   0xD3F6             BCC.N    ??HAL_I2C_Mem_Read_DMA_9
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000148   0xE7BC             B.N      ??HAL_I2C_Mem_Read_DMA_5
   2210              
   2211              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   2212              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Read_DMA_10: (+1)
   \   0000014A   0x8D21             LDRH     R1,[R4, #+40]
   \   0000014C   0x29FF             CMP      R1,#+255
   \   0000014E   0xD10B             BNE.N    ??HAL_I2C_Mem_Read_DMA_11
   \   00000150   0x8D62             LDRH     R2,[R4, #+42]
   \   00000152   0x4291             CMP      R1,R2
   \   00000154   0xD208             BCS.N    ??HAL_I2C_Mem_Read_DMA_11
   2213              {
   2214                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000156   0x6842             LDR      R2,[R0, #+4]
   \   00000158   0x403A             ANDS     R2,R7,R2
   \   0000015A   0xEA52 0x5296      ORRS     R2,R2,R6, LSR #+22
   \   0000015E   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000162   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000166   0xE008             B.N      ??HAL_I2C_Mem_Read_DMA_12
   2215              }
   2216              else
   2217              {
   2218                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_DMA_11: (+1)
   \   00000168   0x6842             LDR      R2,[R0, #+4]
   \   0000016A   0xB2C9             UXTB     R1,R1
   \   0000016C   0x403A             ANDS     R2,R7,R2
   \   0000016E   0xEA52 0x5296      ORRS     R2,R2,R6, LSR #+22
   \   00000172   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000176   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Read_DMA_12: (+1)
   \   0000017A   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   0000017E   0x6041             STR      R1,[R0, #+4]
   2219              }
   2220              
   2221              /* Wait until RXNE flag is set */
   2222              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   00000180   0x.... 0x....      BL       HAL_GetTick
   \   00000184   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Read_DMA_13: (+1)
   \   00000186   0x6820             LDR      R0,[R4, #+0]
   \   00000188   0x6981             LDR      R1,[R0, #+24]
   \   0000018A   0x0749             LSLS     R1,R1,#+29
   \   0000018C   0xD40E             BMI.N    ??HAL_I2C_Mem_Read_DMA_14
   \   0000018E   0x.... 0x....      BL       HAL_GetTick
   \   00000192   0x1B40             SUBS     R0,R0,R5
   \   00000194   0x281A             CMP      R0,#+26
   \   00000196   0xD3F6             BCC.N    ??HAL_I2C_Mem_Read_DMA_13
   \   00000198   0x2001             MOVS     R0,#+1
   \   0000019A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0xF884 0x0034      STRB     R0,[R4, #+52]
   2223              {
   2224                return HAL_TIMEOUT;
   \   000001A4   0x2003             MOVS     R0,#+3
   \   000001A6   0xB001             ADD      SP,SP,#+4
   \   000001A8   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2225              }
   2226              
   2227              /* Enable DMA Request */
   2228              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;  
   \                     ??HAL_I2C_Mem_Read_DMA_14: (+1)
   \   000001AC   0x6801             LDR      R1,[R0, #+0]
   \   000001AE   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001B2   0x6001             STR      R1,[R0, #+0]
   2229              
   2230              /* Process Unlocked */
   2231              __HAL_UNLOCK(hi2c);
   \   000001B4   0x2000             MOVS     R0,#+0
   \   000001B6   0xF884 0x0034      STRB     R0,[R4, #+52]
   2232              
   2233              return HAL_OK;
   \   000001BA   0xB001             ADD      SP,SP,#+4
   \   000001BC   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2234            }
   2235            else
   2236            {
   2237              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \   000001C0   0x2002             MOVS     R0,#+2
   \   000001C2   0xB001             ADD      SP,SP,#+4
   \   000001C4   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2238            }
   2239          }
   2240          
   2241          /**
   2242            * @brief  Checks if target device is ready for communication. 
   2243            * @note   This function is used with Memory devices
   2244            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2245            *                the configuration information for the specified I2C.
   2246            * @param  DevAddress: Target device address
   2247            * @param  Trials: Number of trials
   2248            * @param  Timeout: Timeout duration
   2249            * @retval HAL status
   2250            */

   \                                 In section .text, align 2, keep-with-next
   2251          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   2252          {  
   \                     HAL_I2C_IsDeviceReady: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   2253            uint32_t tickstart = 0;
   2254            
   2255            __IO uint32_t I2C_Trials = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   2256            
   2257            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x461E             MOV      R6,R3
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xF040 0x809A      BNE.W    ??HAL_I2C_IsDeviceReady_0
   2258            {
   2259              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0x0400             LSLS     R0,R0,#+16
   \   00000020   0xF100 0x8095      BMI.W    ??HAL_I2C_IsDeviceReady_0
   2260              {
   2261                return HAL_BUSY;
   2262              }
   2263              
   2264              /* Process Locked */
   2265              __HAL_LOCK(hi2c);
   \   00000024   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xF000 0x8090      BEQ.W    ??HAL_I2C_IsDeviceReady_0
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
   2266              
   2267              hi2c->State = HAL_I2C_STATE_BUSY;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xF884 0x0035      STRB     R0,[R4, #+53]
   2268              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63A0             STR      R0,[R4, #+56]
   \   0000003E   0x0588             LSLS     R0,R1,#+22
   \   00000040   0x0D80             LSRS     R0,R0,#+22
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable19  ;; 0x2002000
   \   00000046   0xF440 0x5920      ORR      R9,R0,#0x2800
   \   0000004A   0xEA41 0x0800      ORR      R8,R1,R0
   2269              
   2270              do
   2271              {
   2272                /* Generate Start */
   2273                hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode,DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \   0000004E   0x68E0             LDR      R0,[R4, #+12]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xBF0C             ITE      EQ 
   \   00000054   0x4640             MOVEQ    R0,R8
   \   00000056   0x4648             MOVNE    R0,R9
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6048             STR      R0,[R1, #+4]
   2274                
   2275                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   2276                /* Wait until STOPF flag is set or a NACK flag is set*/
   2277                tickstart = HAL_GetTick();
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0x4607             MOV      R7,R0
   2278                while((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET) && (hi2c->State != HAL_I2C_STATE_TIMEOUT))
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6981             LDR      R1,[R0, #+24]
   \   00000066   0x0689             LSLS     R1,R1,#+26
   \   00000068   0xD411             BMI.N    ??HAL_I2C_IsDeviceReady_3
   \   0000006A   0x6981             LDR      R1,[R0, #+24]
   \   0000006C   0x06C9             LSLS     R1,R1,#+27
   \   0000006E   0xD40E             BMI.N    ??HAL_I2C_IsDeviceReady_3
   \   00000070   0xF894 0x1035      LDRB     R1,[R4, #+53]
   \   00000074   0x2903             CMP      R1,#+3
   \   00000076   0xD00A             BEQ.N    ??HAL_I2C_IsDeviceReady_3
   2279                {
   2280                	if(Timeout != HAL_MAX_DELAY)
   \   00000078   0xF116 0x0F01      CMN      R6,#+1
   \   0000007C   0xD0F1             BEQ.N    ??HAL_I2C_IsDeviceReady_2
   2281                	{
   2282                    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000007E   0x2E00             CMP      R6,#+0
   \   00000080   0xD05B             BEQ.N    ??HAL_I2C_IsDeviceReady_4
   \   00000082   0x.... 0x....      BL       HAL_GetTick
   \   00000086   0x1BC0             SUBS     R0,R0,R7
   \   00000088   0x4286             CMP      R6,R0
   \   0000008A   0xD2EA             BCS.N    ??HAL_I2C_IsDeviceReady_2
   \   0000008C   0xE055             B.N      ??HAL_I2C_IsDeviceReady_4
   2283                    {
   2284                      /* Device is ready */
   2285                      hi2c->State = HAL_I2C_STATE_READY;
   2286                      /* Process Unlocked */
   2287                      __HAL_UNLOCK(hi2c);         
   2288                      return HAL_TIMEOUT;
   2289                    }
   2290                  } 
   2291                }
   2292                
   2293                /* Check if the NACKF flag has not been set */
   2294                if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \   0000008E   0x6980             LDR      R0,[R0, #+24]
   \   00000090   0x06C0             LSLS     R0,R0,#+27
   \   00000092   0xD41C             BMI.N    ??HAL_I2C_IsDeviceReady_5
   2295                {
   2296                  /* Wait until STOPF flag is reset */ 
   2297                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \   00000094   0x.... 0x....      BL       HAL_GetTick
   \   00000098   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6981             LDR      R1,[R0, #+24]
   \   0000009E   0x0689             LSLS     R1,R1,#+26
   \   000000A0   0xD40A             BMI.N    ??HAL_I2C_IsDeviceReady_7
   \   000000A2   0xF116 0x0F01      CMN      R6,#+1
   \   000000A6   0xD0F8             BEQ.N    ??HAL_I2C_IsDeviceReady_6
   \   000000A8   0x2E00             CMP      R6,#+0
   \   000000AA   0xD046             BEQ.N    ??HAL_I2C_IsDeviceReady_4
   \   000000AC   0x.... 0x....      BL       HAL_GetTick
   \   000000B0   0x1B40             SUBS     R0,R0,R5
   \   000000B2   0x4286             CMP      R6,R0
   \   000000B4   0xD2F1             BCS.N    ??HAL_I2C_IsDeviceReady_6
   \   000000B6   0xE040             B.N      ??HAL_I2C_IsDeviceReady_4
   2298                  {
   2299                    return HAL_TIMEOUT;
   2300                  }
   2301                  
   2302                  /* Clear STOP Flag */
   2303                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \   000000B8   0x2120             MOVS     R1,#+32
   \   000000BA   0x61C1             STR      R1,[R0, #+28]
   2304                  
   2305                  /* Device is ready */
   2306                  hi2c->State = HAL_I2C_STATE_READY;
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0xF884 0x0035      STRB     R0,[R4, #+53]
   2307                  
   2308                  /* Process Unlocked */
   2309                  __HAL_UNLOCK(hi2c);
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF884 0x0034      STRB     R0,[R4, #+52]
   2310                  
   2311                  return HAL_OK;
   \   000000C8   0xB001             ADD      SP,SP,#+4
   \   000000CA   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2312                }
   2313                else
   2314                {
   2315                  /* Wait until STOPF flag is reset */ 
   2316                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \   000000CE   0x.... 0x....      BL       HAL_GetTick
   \   000000D2   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6981             LDR      R1,[R0, #+24]
   \   000000D8   0x0689             LSLS     R1,R1,#+26
   \   000000DA   0xD409             BMI.N    ??HAL_I2C_IsDeviceReady_9
   \   000000DC   0xF116 0x0F01      CMN      R6,#+1
   \   000000E0   0xD0F8             BEQ.N    ??HAL_I2C_IsDeviceReady_8
   \   000000E2   0xB356             CBZ.N    R6,??HAL_I2C_IsDeviceReady_4
   \   000000E4   0x.... 0x....      BL       HAL_GetTick
   \   000000E8   0x1BC0             SUBS     R0,R0,R7
   \   000000EA   0x4286             CMP      R6,R0
   \   000000EC   0xD2F2             BCS.N    ??HAL_I2C_IsDeviceReady_8
   \   000000EE   0xE024             B.N      ??HAL_I2C_IsDeviceReady_4
   2317                  {
   2318                    return HAL_TIMEOUT;
   2319                  }
   2320                  
   2321                  /* Clear NACK Flag */
   2322                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_IsDeviceReady_9: (+1)
   \   000000F0   0x2110             MOVS     R1,#+16
   \   000000F2   0x61C1             STR      R1,[R0, #+28]
   2323                  
   2324                  /* Clear STOP Flag, auto generated with autoend*/
   2325                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   000000F4   0x6821             LDR      R1,[R4, #+0]
   \   000000F6   0x2020             MOVS     R0,#+32
   \   000000F8   0x61C8             STR      R0,[R1, #+28]
   2326                }
   2327                
   2328                /* Check if the maximum allowed number of trials has been reached */
   2329                if (I2C_Trials++ == Trials)
   \   000000FA   0x9800             LDR      R0,[SP, #+0]
   \   000000FC   0x1C41             ADDS     R1,R0,#+1
   \   000000FE   0x42A8             CMP      R0,R5
   \   00000100   0x9100             STR      R1,[SP, #+0]
   \   00000102   0xD117             BNE.N    ??HAL_I2C_IsDeviceReady_10
   2330                {
   2331                  /* Generate Stop */
   2332                  hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6841             LDR      R1,[R0, #+4]
   \   00000108   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000010C   0x6041             STR      R1,[R0, #+4]
   2333                  
   2334                  /* Wait until STOPF flag is reset */ 
   2335                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \   0000010E   0x.... 0x....      BL       HAL_GetTick
   \   00000112   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_IsDeviceReady_11: (+1)
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6981             LDR      R1,[R0, #+24]
   \   00000118   0x0689             LSLS     R1,R1,#+26
   \   0000011A   0xD409             BMI.N    ??HAL_I2C_IsDeviceReady_12
   \   0000011C   0xF116 0x0F01      CMN      R6,#+1
   \   00000120   0xD0F8             BEQ.N    ??HAL_I2C_IsDeviceReady_11
   \   00000122   0xB156             CBZ.N    R6,??HAL_I2C_IsDeviceReady_4
   \   00000124   0x.... 0x....      BL       HAL_GetTick
   \   00000128   0x1BC0             SUBS     R0,R0,R7
   \   0000012A   0x4286             CMP      R6,R0
   \   0000012C   0xD2F2             BCS.N    ??HAL_I2C_IsDeviceReady_11
   \   0000012E   0xE004             B.N      ??HAL_I2C_IsDeviceReady_4
   2336                  {
   2337                    return HAL_TIMEOUT;
   2338                  }
   2339                  
   2340                  /* Clear STOP Flag */
   2341                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_IsDeviceReady_12: (+1)
   \   00000130   0x2120             MOVS     R1,#+32
   \   00000132   0x61C1             STR      R1,[R0, #+28]
   2342                }      
   2343              }while(I2C_Trials < Trials);
   \                     ??HAL_I2C_IsDeviceReady_10: (+1)
   \   00000134   0x9800             LDR      R0,[SP, #+0]
   \   00000136   0x42A8             CMP      R0,R5
   \   00000138   0xD389             BCC.N    ??HAL_I2C_IsDeviceReady_1
   2344              
   2345              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xF884 0x0035      STRB     R0,[R4, #+53]
   2346              
   2347              /* Process Unlocked */
   2348              __HAL_UNLOCK(hi2c);
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xF884 0x0034      STRB     R0,[R4, #+52]
   2349              
   2350              return HAL_TIMEOUT;
   \   00000146   0x2003             MOVS     R0,#+3
   \   00000148   0xB001             ADD      SP,SP,#+4
   \   0000014A   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2351            }
   2352            else
   2353            {
   2354              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \   0000014E   0x2002             MOVS     R0,#+2
   \   00000150   0xB001             ADD      SP,SP,#+4
   \   00000152   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2355            }
   2356          }
   2357          /**
   2358            * @}
   2359            */
   2360          
   2361          /** @defgroup IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
   2362           * @{
   2363           */   
   2364          
   2365          /**
   2366            * @brief  This function handles I2C event interrupt request.
   2367            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2368            *                the configuration information for the specified I2C.
   2369            * @retval None
   2370            */

   \                                 In section .text, align 2, keep-with-next
   2371          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   2372          {
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2373            /* I2C in mode Transmitter ---------------------------------------------------*/
   2374            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI | I2C_IT_ADDRI)) == SET))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6981             LDR      R1,[R0, #+24]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD40E             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   0000000C   0x6981             LDR      R1,[R0, #+24]
   \   0000000E   0x0609             LSLS     R1,R1,#+24
   \   00000010   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000012   0x6981             LDR      R1,[R0, #+24]
   \   00000014   0x0649             LSLS     R1,R1,#+25
   \   00000016   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x0689             LSLS     R1,R1,#+26
   \   0000001C   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   0000001E   0x6981             LDR      R1,[R0, #+24]
   \   00000020   0x06C9             LSLS     R1,R1,#+27
   \   00000022   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000024   0x6981             LDR      R1,[R0, #+24]
   \   00000026   0x0709             LSLS     R1,R1,#+28
   \   00000028   0xD50A             BPL.N    ??HAL_I2C_EV_IRQHandler_1
   \                     ??HAL_I2C_EV_IRQHandler_0: (+1)
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF000 0x007A      AND      R0,R0,#0x7A
   \   00000030   0x287A             CMP      R0,#+122
   \   00000032   0xBF01             ITTTT    EQ 
   2375            {     
   2376              /* Slave mode selected */
   2377              if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX)
   \   00000034   0xF894 0x0035      LDRBEQ   R0,[R4, #+53]
   \   00000038   0x2832             CMPEQ    R0,#+50
   2378              {
   2379                I2C_SlaveTransmit_ISR(hi2c);
   \   0000003A   0x4620             MOVEQ    R0,R4
   \   0000003C   0x.... 0x....      BLEQ     I2C_SlaveTransmit_ISR
   2380              }
   2381            }
   2382            
   2383            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_1: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6981             LDR      R1,[R0, #+24]
   \   00000044   0x0789             LSLS     R1,R1,#+30
   \   00000046   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   00000048   0x6981             LDR      R1,[R0, #+24]
   \   0000004A   0x0609             LSLS     R1,R1,#+24
   \   0000004C   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   0000004E   0x6981             LDR      R1,[R0, #+24]
   \   00000050   0x0649             LSLS     R1,R1,#+25
   \   00000052   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   00000054   0x6981             LDR      R1,[R0, #+24]
   \   00000056   0x0689             LSLS     R1,R1,#+26
   \   00000058   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   0000005A   0x6981             LDR      R1,[R0, #+24]
   \   0000005C   0x06C9             LSLS     R1,R1,#+27
   \   0000005E   0xD50E             BPL.N    ??HAL_I2C_EV_IRQHandler_3
   \                     ??HAL_I2C_EV_IRQHandler_2: (+1)
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF000 0x0072      AND      R0,R0,#0x72
   \   00000066   0x2872             CMP      R0,#+114
   \   00000068   0xD109             BNE.N    ??HAL_I2C_EV_IRQHandler_3
   2384            {     
   2385              /* Master mode selected */
   2386              if ((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX))
   \   0000006A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000006E   0x2812             CMP      R0,#+18
   \   00000070   0xBF19             ITTEE    NE 
   \   00000072   0xF894 0x0035      LDRBNE   R0,[R4, #+53]
   \   00000076   0x2852             CMPNE    R0,#+82
   2387              {
   2388                I2C_MasterTransmit_ISR(hi2c);
   \   00000078   0x4620             MOVEQ    R0,R4
   \   0000007A   0x.... 0x....      BLEQ     I2C_MasterTransmit_ISR
   2389              }
   2390            }
   2391            
   2392            /* I2C in mode Receiver ----------------------------------------------------*/
   2393            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI | I2C_IT_ADDRI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_3: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6981             LDR      R1,[R0, #+24]
   \   00000082   0x0749             LSLS     R1,R1,#+29
   \   00000084   0xD40E             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000086   0x6981             LDR      R1,[R0, #+24]
   \   00000088   0x0609             LSLS     R1,R1,#+24
   \   0000008A   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000008C   0x6981             LDR      R1,[R0, #+24]
   \   0000008E   0x0649             LSLS     R1,R1,#+25
   \   00000090   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000092   0x6981             LDR      R1,[R0, #+24]
   \   00000094   0x0689             LSLS     R1,R1,#+26
   \   00000096   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000098   0x6981             LDR      R1,[R0, #+24]
   \   0000009A   0x06C9             LSLS     R1,R1,#+27
   \   0000009C   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000009E   0x6981             LDR      R1,[R0, #+24]
   \   000000A0   0x0709             LSLS     R1,R1,#+28
   \   000000A2   0xD50A             BPL.N    ??HAL_I2C_EV_IRQHandler_5
   \                     ??HAL_I2C_EV_IRQHandler_4: (+1)
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF000 0x007C      AND      R0,R0,#0x7C
   \   000000AA   0x287C             CMP      R0,#+124
   \   000000AC   0xBF01             ITTTT    EQ 
   2394            {
   2395              /* Slave mode selected */
   2396              if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX)
   \   000000AE   0xF894 0x0035      LDRBEQ   R0,[R4, #+53]
   \   000000B2   0x2842             CMPEQ    R0,#+66
   2397              {
   2398                I2C_SlaveReceive_ISR(hi2c);
   \   000000B4   0x4620             MOVEQ    R0,R4
   \   000000B6   0x.... 0x....      BLEQ     I2C_SlaveReceive_ISR
   2399              }
   2400            } 
   2401            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_5: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6981             LDR      R1,[R0, #+24]
   \   000000BE   0x0749             LSLS     R1,R1,#+29
   \   000000C0   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000C2   0x6981             LDR      R1,[R0, #+24]
   \   000000C4   0x0609             LSLS     R1,R1,#+24
   \   000000C6   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000C8   0x6981             LDR      R1,[R0, #+24]
   \   000000CA   0x0649             LSLS     R1,R1,#+25
   \   000000CC   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000CE   0x6981             LDR      R1,[R0, #+24]
   \   000000D0   0x0689             LSLS     R1,R1,#+26
   \   000000D2   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000D4   0x6981             LDR      R1,[R0, #+24]
   \   000000D6   0x06C9             LSLS     R1,R1,#+27
   \   000000D8   0xD510             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   \                     ??HAL_I2C_EV_IRQHandler_6: (+1)
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF000 0x0074      AND      R0,R0,#0x74
   \   000000E0   0x2874             CMP      R0,#+116
   \   000000E2   0xD10B             BNE.N    ??HAL_I2C_EV_IRQHandler_7
   2402            {
   2403              /* Master mode selected */
   2404              if ((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX))
   \   000000E4   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   000000E8   0x2822             CMP      R0,#+34
   \   000000EA   0xBF1C             ITT      NE 
   \   000000EC   0xF894 0x0035      LDRBNE   R0,[R4, #+53]
   \   000000F0   0x2862             CMPNE    R0,#+98
   \   000000F2   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_7
   2405              {
   2406                I2C_MasterReceive_ISR(hi2c);
   \   000000F4   0x4620             MOV      R0,R4
   \   000000F6   0xE8BD 0x4010      POP      {R4,LR}
   \   000000FA   0x....             B.N      I2C_MasterReceive_ISR
   2407              }
   2408            } 
   2409          }
   \                     ??HAL_I2C_EV_IRQHandler_7: (+1)
   \   000000FC   0xBD10             POP      {R4,PC}          ;; return
   2410          
   2411          /**
   2412            * @brief  This function handles I2C error interrupt request.
   2413            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2414            *                the configuration information for the specified I2C.
   2415            * @retval None
   2416            */

   \                                 In section .text, align 2, keep-with-next
   2417          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   2418          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2419            /* I2C Bus error interrupt occurred ------------------------------------*/
   2420            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x698A             LDR      R2,[R1, #+24]
   \   00000008   0x05D2             LSLS     R2,R2,#+23
   \   0000000A   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0x0612             LSLS     R2,R2,#+24
   \   00000010   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   2421            { 
   2422              hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
   \   00000012   0x6B82             LDR      R2,[R0, #+56]
   \   00000014   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000018   0x6382             STR      R2,[R0, #+56]
   2423              
   2424              /* Clear BERR flag */
   2425              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \   0000001A   0xF44F 0x7280      MOV      R2,#+256
   \   0000001E   0x61CA             STR      R2,[R1, #+28]
   2426            }
   2427            
   2428            /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
   2429            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x698A             LDR      R2,[R1, #+24]
   \   00000024   0x0552             LSLS     R2,R2,#+21
   \   00000026   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x0612             LSLS     R2,R2,#+24
   \   0000002C   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   2430            { 
   2431              hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
   \   0000002E   0x6B82             LDR      R2,[R0, #+56]
   \   00000030   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000034   0x6382             STR      R2,[R0, #+56]
   2432              
   2433              /* Clear OVR flag */
   2434              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \   00000036   0xF44F 0x6280      MOV      R2,#+1024
   \   0000003A   0x61CA             STR      R2,[R1, #+28]
   2435            }
   2436            
   2437            /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
   2438            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x698A             LDR      R2,[R1, #+24]
   \   00000040   0x0592             LSLS     R2,R2,#+22
   \   00000042   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   \   00000044   0x680A             LDR      R2,[R1, #+0]
   \   00000046   0x0612             LSLS     R2,R2,#+24
   \   00000048   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   2439            { 
   2440              hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
   \   0000004A   0x6B82             LDR      R2,[R0, #+56]
   \   0000004C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000050   0x6382             STR      R2,[R0, #+56]
   2441              
   2442              /* Clear ARLO flag */
   2443              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \   00000052   0xF44F 0x7200      MOV      R2,#+512
   \   00000056   0x61CA             STR      R2,[R1, #+28]
   2444            }
   2445            
   2446            /* Call the Error Callback in case of Error detected */
   2447            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \   00000058   0x6B81             LDR      R1,[R0, #+56]
   \   0000005A   0xB121             CBZ.N    R1,??HAL_I2C_ER_IRQHandler_3
   2448            {
   2449              hi2c->State = HAL_I2C_STATE_READY;
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0xF880 0x1035      STRB     R1,[R0, #+53]
   2450              
   2451              HAL_I2C_ErrorCallback(hi2c);
   \   00000062   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2452            }
   2453          }
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0xBD00             POP      {PC}             ;; return
   2454          
   2455          /**
   2456            * @brief  Master Tx Transfer completed callbacks.
   2457            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2458            *                the configuration information for the specified I2C.
   2459            * @retval None
   2460            */

   \                                 In section .text, align 2, keep-with-next
   2461           __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2462          {
   2463            /* Prevent unused argument(s) compilation warning */
   2464            UNUSED(hi2c);
   2465            
   2466            /* NOTE : This function Should not be modified, when the callback is needed,
   2467                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2468             */ 
   2469          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2470          
   2471          /**
   2472            * @brief  Master Rx Transfer completed callbacks.
   2473            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2474            *                the configuration information for the specified I2C.
   2475            * @retval None
   2476            */

   \                                 In section .text, align 2, keep-with-next
   2477          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2478          {
   2479            /* Prevent unused argument(s) compilation warning */
   2480            UNUSED(hi2c);
   2481            
   2482            /* NOTE : This function Should not be modified, when the callback is needed,
   2483                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2484             */
   2485          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2486          
   2487          /** @brief  Slave Tx Transfer completed callbacks.
   2488            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2489            *                the configuration information for the specified I2C.
   2490            * @retval None
   2491            */

   \                                 In section .text, align 2, keep-with-next
   2492           __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2493          {
   2494            /* Prevent unused argument(s) compilation warning */
   2495            UNUSED(hi2c);
   2496            
   2497            /* NOTE : This function Should not be modified, when the callback is needed,
   2498                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2499             */ 
   2500          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2501          
   2502          /**
   2503            * @brief  Slave Rx Transfer completed callbacks.
   2504            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2505            *                the configuration information for the specified I2C.
   2506            * @retval None
   2507            */

   \                                 In section .text, align 2, keep-with-next
   2508          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2509          {
   2510            /* Prevent unused argument(s) compilation warning */
   2511            UNUSED(hi2c);
   2512            
   2513            /* NOTE : This function Should not be modified, when the callback is needed,
   2514                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2515             */
   2516          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2517          
   2518          /**
   2519            * @brief  Memory Tx Transfer completed callbacks.
   2520            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2521            *                the configuration information for the specified I2C.
   2522            * @retval None
   2523            */

   \                                 In section .text, align 2, keep-with-next
   2524           __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2525          {
   2526            /* Prevent unused argument(s) compilation warning */
   2527            UNUSED(hi2c);
   2528              
   2529            /* NOTE : This function Should not be modified, when the callback is needed,
   2530                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2531             */ 
   2532          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2533          
   2534          /**
   2535            * @brief  Memory Rx Transfer completed callbacks.
   2536            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2537            *                the configuration information for the specified I2C.
   2538            * @retval None
   2539            */

   \                                 In section .text, align 2, keep-with-next
   2540          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2541          {
   2542            /* Prevent unused argument(s) compilation warning */
   2543            UNUSED(hi2c);
   2544            
   2545            /* NOTE : This function Should not be modified, when the callback is needed,
   2546                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2547             */
   2548          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2549          
   2550          /**
   2551            * @brief  I2C error callbacks.
   2552            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2553            *                the configuration information for the specified I2C.
   2554            * @retval None
   2555            */

   \                                 In section .text, align 2, keep-with-next
   2556           __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   2557          {
   2558            /* Prevent unused argument(s) compilation warning */
   2559            UNUSED(hi2c);
   2560            
   2561            /* NOTE : This function Should not be modified, when the callback is needed,
   2562                      the HAL_I2C_ErrorCallback could be implemented in the user file
   2563             */ 
   2564          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2565          
   2566          /**
   2567            * @}
   2568            */
   2569          
   2570          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State and Errors functions
   2571           *  @brief   Peripheral State and Errors functions
   2572           *
   2573          @verbatim   
   2574           ===============================================================================
   2575                      ##### Peripheral State and Errors functions #####
   2576           ===============================================================================  
   2577              [..]
   2578              This subsection permit to get in run-time the status of the peripheral 
   2579              and the data flow.
   2580          
   2581          @endverbatim
   2582            * @{
   2583            */
   2584          
   2585          /**
   2586            * @brief  Returns the I2C state.
   2587            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2588            *                the configuration information for the specified I2C.
   2589            * @retval HAL state
   2590            */

   \                                 In section .text, align 2, keep-with-next
   2591          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   2592          {
   2593            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   2594          }
   2595          
   2596          /**
   2597            * @brief  Return the I2C error code
   2598            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2599            *              the configuration information for the specified I2C.
   2600          * @retval I2C Error Code
   2601          */

   \                                 In section .text, align 2, keep-with-next
   2602          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   2603          {
   2604            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
   2605          }
   2606          
   2607          /**
   2608            * @}
   2609            */  
   2610          
   2611          /**
   2612            * @}
   2613            */
   2614          
   2615          /** @addtogroup I2C_Private_Functions
   2616            * @{
   2617            */
   2618          
   2619          /**
   2620            * @brief  Handle Interrupt Flags Master Transmit Mode
   2621            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2622            *                the configuration information for the specified I2C.
   2623            * @retval HAL status
   2624            */

   \                                 In section .text, align 2, keep-with-next
   2625          static HAL_StatusTypeDef I2C_MasterTransmit_ISR(I2C_HandleTypeDef *hi2c) 
   2626          {
   \                     I2C_MasterTransmit_ISR: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   2627            uint16_t DevAddress;
   2628            
   2629            /* Process Locked */
   2630            __HAL_LOCK(hi2c); 
   \   00000006   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xF000 0x80A4      BEQ.W    ??I2C_MasterTransmit_ISR_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   2631            
   2632            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6981             LDR      R1,[R0, #+24]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD50B             BPL.N    ??I2C_MasterTransmit_ISR_1
   2633            {
   2634              /* Write data to TXDR */
   2635              hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
   \   00000022   0x6A61             LDR      R1,[R4, #+36]
   \   00000024   0x1C4A             ADDS     R2,R1,#+1
   \   00000026   0x6262             STR      R2,[R4, #+36]
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x6281             STR      R1,[R0, #+40]
   2636              hi2c->XferSize--;
   \   0000002C   0x8D20             LDRH     R0,[R4, #+40]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x8520             STRH     R0,[R4, #+40]
   2637              hi2c->XferCount--;	
   \   00000032   0x8D60             LDRH     R0,[R4, #+42]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x8560             STRH     R0,[R4, #+42]
   \   00000038   0xE08D             B.N      ??I2C_MasterTransmit_ISR_2
   2638            }
   2639            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
   \                     ??I2C_MasterTransmit_ISR_1: (+1)
   \   0000003A   0x6981             LDR      R1,[R0, #+24]
   \   0000003C   0x0609             LSLS     R1,R1,#+24
   \   0000003E   0xD52A             BPL.N    ??I2C_MasterTransmit_ISR_3
   2640            {
   2641              if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
   \   00000040   0x8D21             LDRH     R1,[R4, #+40]
   \   00000042   0xBB09             CBNZ.N   R1,??I2C_MasterTransmit_ISR_4
   \   00000044   0x8D61             LDRH     R1,[R4, #+42]
   \   00000046   0xB1F9             CBZ.N    R1,??I2C_MasterTransmit_ISR_4
   2642              {
   2643                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   00000048   0x6841             LDR      R1,[R0, #+4]
   2644                
   2645                if(hi2c->XferCount > 255)
   \   0000004A   0x8D63             LDRH     R3,[R4, #+42]
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable20  ;; 0xfc009800
   \   00000050   0x0589             LSLS     R1,R1,#+22
   \   00000052   0x2BFF             CMP      R3,#+255
   \   00000054   0xDD0A             BLE.N    ??I2C_MasterTransmit_ISR_5
   2646                {    
   2647                  I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   00000056   0x6843             LDR      R3,[R0, #+4]
   \   00000058   0x401A             ANDS     R2,R2,R3
   \   0000005A   0xEA52 0x5191      ORRS     R1,R2,R1, LSR #+22
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0x1ff0000
   \   00000062   0x4311             ORRS     R1,R2,R1
   \   00000064   0x6041             STR      R1,[R0, #+4]
   2648                  hi2c->XferSize = 255;
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0x8520             STRH     R0,[R4, #+40]
   \   0000006A   0xE074             B.N      ??I2C_MasterTransmit_ISR_2
   2649                }
   2650                else
   2651                {
   2652                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_MasterTransmit_ISR_5: (+1)
   \   0000006C   0x8D63             LDRH     R3,[R4, #+42]
   \   0000006E   0x6845             LDR      R5,[R0, #+4]
   \   00000070   0x402A             ANDS     R2,R2,R5
   \   00000072   0xEA52 0x5191      ORRS     R1,R2,R1, LSR #+22
   \   00000076   0xB2DB             UXTB     R3,R3
   \   00000078   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \   0000007C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000080   0x6041             STR      R1,[R0, #+4]
   2653                  hi2c->XferSize = hi2c->XferCount;
   \   00000082   0x8D60             LDRH     R0,[R4, #+42]
   \   00000084   0x8520             STRH     R0,[R4, #+40]
   \   00000086   0xE066             B.N      ??I2C_MasterTransmit_ISR_2
   2654                }
   2655              }
   2656              else
   2657              {
   2658                /* Process Unlocked */
   2659                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_4: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x0034      STRB     R0,[R4, #+52]
   2660                
   2661                /* Wrong size Status regarding TCR flag event */
   2662                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000094   0xE05B             B.N      ??I2C_MasterTransmit_ISR_6
   2663                HAL_I2C_ErrorCallback(hi2c);
   2664              }
   2665            }
   2666            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET)
   \                     ??I2C_MasterTransmit_ISR_3: (+1)
   \   00000096   0x6981             LDR      R1,[R0, #+24]
   \   00000098   0x0649             LSLS     R1,R1,#+25
   \   0000009A   0xD50D             BPL.N    ??I2C_MasterTransmit_ISR_7
   2667            {
   2668              if(hi2c->XferCount == 0)
   \   0000009C   0x8D61             LDRH     R1,[R4, #+42]
   \   0000009E   0xB921             CBNZ.N   R1,??I2C_MasterTransmit_ISR_8
   2669              {
   2670                /* Generate Stop */
   2671                hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   000000A0   0x6841             LDR      R1,[R0, #+4]
   \   000000A2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   \   000000A8   0xE055             B.N      ??I2C_MasterTransmit_ISR_2
   2672              }
   2673              else
   2674              {
   2675                /* Process Unlocked */
   2676                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_8: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x0034      STRB     R0,[R4, #+52]
   2677                
   2678                /* Wrong size Status regarding TCR flag event */
   2679                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   000000B0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B2   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000B6   0xE04A             B.N      ??I2C_MasterTransmit_ISR_6
   2680                HAL_I2C_ErrorCallback(hi2c);
   2681              }
   2682            }
   2683            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \                     ??I2C_MasterTransmit_ISR_7: (+1)
   \   000000B8   0x6981             LDR      R1,[R0, #+24]
   \   000000BA   0x0689             LSLS     R1,R1,#+26
   \   000000BC   0x6981             LDR      R1,[R0, #+24]
   \   000000BE   0xD53C             BPL.N    ??I2C_MasterTransmit_ISR_9
   2684            {
   2685              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   000000C0   0x06C9             LSLS     R1,R1,#+27
   \   000000C2   0xD505             BPL.N    ??I2C_MasterTransmit_ISR_10
   2686              {
   2687                /* Clear NACK Flag */
   2688                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   000000C4   0x2110             MOVS     R1,#+16
   \   000000C6   0x61C1             STR      R1,[R0, #+28]
   2689                
   2690                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   000000C8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CA   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000CE   0x63A0             STR      R0,[R4, #+56]
   2691              }
   2692              
   2693              /* Disable ERR, TC, STOP, NACK, TXI interrupt */
   2694              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \                     ??I2C_MasterTransmit_ISR_10: (+1)
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   2695              
   2696              /* Clear STOP Flag */
   2697              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2698              
   2699              /* Clear Configuration Register 2 */
   2700              I2C_RESET_CR2(hi2c);
   \   000000D2   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0xF021 0x01F2      BIC      R1,R1,#0xF2
   \   000000DC   0x6001             STR      R1,[R0, #+0]
   \   000000DE   0x6821             LDR      R1,[R4, #+0]
   \   000000E0   0x2020             MOVS     R0,#+32
   \   000000E2   0x61C8             STR      R0,[R1, #+28]
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6841             LDR      R1,[R0, #+4]
   \   000000E8   0x4011             ANDS     R1,R2,R1
   \   000000EA   0x6041             STR      R1,[R0, #+4]
   2701              
   2702              /* Flush TX register if not empty */
   2703              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6981             LDR      R1,[R0, #+24]
   \   000000F0   0x07C9             LSLS     R1,R1,#+31
   \   000000F2   0xBF5C             ITT      PL 
   \   000000F4   0x2101             MOVPL    R1,#+1
   \   000000F6   0x61C1             STRPL    R1,[R0, #+28]
   2704              {
   2705                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
   2706              }
   2707              
   2708              /* Call the correct callback to inform upper layer */
   2709              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   000000F8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000FA   0xB130             CBZ.N    R0,??I2C_MasterTransmit_ISR_11
   2710              {
   2711                hi2c->State = HAL_I2C_STATE_READY;
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0xF884 0x0035      STRB     R0,[R4, #+53]
   2712                
   2713                /* Process Unlocked */
   2714                __HAL_UNLOCK(hi2c);
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0xF884 0x0034      STRB     R0,[R4, #+52]
   2715                
   2716                HAL_I2C_ErrorCallback(hi2c);
   \   00000108   0xE022             B.N      ??I2C_MasterTransmit_ISR_12
   2717              }
   2718              else
   2719              {
   2720                if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
   \                     ??I2C_MasterTransmit_ISR_11: (+1)
   \   0000010A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000010E   0x2852             CMP      R0,#+82
   \   00000110   0xD109             BNE.N    ??I2C_MasterTransmit_ISR_13
   2721                {
   2722                  hi2c->State = HAL_I2C_STATE_READY;
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0xF884 0x0035      STRB     R0,[R4, #+53]
   2723                  
   2724                  /* Process Unlocked */
   2725                  __HAL_UNLOCK(hi2c);
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xF884 0x0034      STRB     R0,[R4, #+52]
   2726                  
   2727                  HAL_I2C_MemTxCpltCallback(hi2c);
   \   0000011E   0x4620             MOV      R0,R4
   \   00000120   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   00000124   0xE017             B.N      ??I2C_MasterTransmit_ISR_2
   2728                }
   2729                else
   2730                {
   2731                  hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterTransmit_ISR_13: (+1)
   \   00000126   0x2001             MOVS     R0,#+1
   \   00000128   0xF884 0x0035      STRB     R0,[R4, #+53]
   2732                  
   2733                  /* Process Unlocked */
   2734                  __HAL_UNLOCK(hi2c);
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xF884 0x0034      STRB     R0,[R4, #+52]
   2735                  
   2736                  HAL_I2C_MasterTxCpltCallback(hi2c);
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \   00000138   0xE00D             B.N      ??I2C_MasterTransmit_ISR_2
   2737                }
   2738              }
   2739            }
   2740            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     ??I2C_MasterTransmit_ISR_9: (+1)
   \   0000013A   0x06C9             LSLS     R1,R1,#+27
   \   0000013C   0xD50B             BPL.N    ??I2C_MasterTransmit_ISR_2
   2741            {
   2742              /* Clear NACK Flag */
   2743              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000013E   0x2110             MOVS     R1,#+16
   \   00000140   0x61C1             STR      R1,[R0, #+28]
   2744              
   2745              /* Process Unlocked */
   2746              __HAL_UNLOCK(hi2c);
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xF884 0x0034      STRB     R0,[R4, #+52]
   2747              
   2748              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   00000148   0x6BA0             LDR      R0,[R4, #+56]
   \   0000014A   0xF040 0x0004      ORR      R0,R0,#0x4
   \                     ??I2C_MasterTransmit_ISR_6: (+1)
   \   0000014E   0x63A0             STR      R0,[R4, #+56]
   2749              HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_MasterTransmit_ISR_12: (+1)
   \   00000150   0x4620             MOV      R0,R4
   \   00000152   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2750            }
   2751            
   2752            /* Process Unlocked */
   2753            __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_2: (+1)
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xF884 0x0034      STRB     R0,[R4, #+52]
   2754            
   2755            return HAL_OK;    
   \                     ??I2C_MasterTransmit_ISR_0: (+1)
   \   0000015C   0xB001             ADD      SP,SP,#+4
   \   0000015E   0xBD30             POP      {R4,R5,PC}       ;; return
   2756          }  
   2757          
   2758          /**
   2759            * @brief  Handle Interrupt Flags Master Receive Mode
   2760            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2761            *                the configuration information for the specified I2C.
   2762            * @retval HAL status
   2763            */

   \                                 In section .text, align 2, keep-with-next
   2764          static HAL_StatusTypeDef I2C_MasterReceive_ISR(I2C_HandleTypeDef *hi2c) 
   2765          {
   \                     I2C_MasterReceive_ISR: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   2766            uint16_t DevAddress;
   2767            
   2768            /* Process Locked */
   2769            __HAL_LOCK(hi2c);
   \   00000006   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xF000 0x809E      BEQ.W    ??I2C_MasterReceive_ISR_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   2770            
   2771            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6981             LDR      R1,[R0, #+24]
   \   0000001E   0x0749             LSLS     R1,R1,#+29
   \   00000020   0xD50B             BPL.N    ??I2C_MasterReceive_ISR_1
   2772            {  
   2773              /* Read data from RXDR */
   2774              (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
   \   00000022   0x6A61             LDR      R1,[R4, #+36]
   \   00000024   0x1C4A             ADDS     R2,R1,#+1
   \   00000026   0x6262             STR      R2,[R4, #+36]
   \   00000028   0x6A40             LDR      R0,[R0, #+36]
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   2775              hi2c->XferSize--;
   \   0000002C   0x8D20             LDRH     R0,[R4, #+40]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x8520             STRH     R0,[R4, #+40]
   2776              hi2c->XferCount--;
   \   00000032   0x8D60             LDRH     R0,[R4, #+42]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x8560             STRH     R0,[R4, #+42]
   \   00000038   0xE087             B.N      ??I2C_MasterReceive_ISR_2
   2777            }
   2778            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
   \                     ??I2C_MasterReceive_ISR_1: (+1)
   \   0000003A   0x6981             LDR      R1,[R0, #+24]
   \   0000003C   0x0609             LSLS     R1,R1,#+24
   \   0000003E   0xD52A             BPL.N    ??I2C_MasterReceive_ISR_3
   2779            {
   2780              if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
   \   00000040   0x8D21             LDRH     R1,[R4, #+40]
   \   00000042   0xBB09             CBNZ.N   R1,??I2C_MasterReceive_ISR_4
   \   00000044   0x8D61             LDRH     R1,[R4, #+42]
   \   00000046   0xB1F9             CBZ.N    R1,??I2C_MasterReceive_ISR_4
   2781              {                  
   2782                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   00000048   0x6841             LDR      R1,[R0, #+4]
   2783                
   2784                if(hi2c->XferCount > 255)
   \   0000004A   0x8D63             LDRH     R3,[R4, #+42]
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable20  ;; 0xfc009800
   \   00000050   0x0589             LSLS     R1,R1,#+22
   \   00000052   0x2BFF             CMP      R3,#+255
   \   00000054   0xDD0A             BLE.N    ??I2C_MasterReceive_ISR_5
   2785                {
   2786                  I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   00000056   0x6843             LDR      R3,[R0, #+4]
   \   00000058   0x401A             ANDS     R2,R2,R3
   \   0000005A   0xEA52 0x5191      ORRS     R1,R2,R1, LSR #+22
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0x1ff0000
   \   00000062   0x4311             ORRS     R1,R2,R1
   \   00000064   0x6041             STR      R1,[R0, #+4]
   2787                  hi2c->XferSize = 255;
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0x8520             STRH     R0,[R4, #+40]
   \   0000006A   0xE06E             B.N      ??I2C_MasterReceive_ISR_2
   2788                }      
   2789                else
   2790                {    
   2791                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_MasterReceive_ISR_5: (+1)
   \   0000006C   0x8D63             LDRH     R3,[R4, #+42]
   \   0000006E   0x6845             LDR      R5,[R0, #+4]
   \   00000070   0x402A             ANDS     R2,R2,R5
   \   00000072   0xEA52 0x5191      ORRS     R1,R2,R1, LSR #+22
   \   00000076   0xB2DB             UXTB     R3,R3
   \   00000078   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \   0000007C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000080   0x6041             STR      R1,[R0, #+4]
   2792                  hi2c->XferSize = hi2c->XferCount;
   \   00000082   0x8D60             LDRH     R0,[R4, #+42]
   \   00000084   0x8520             STRH     R0,[R4, #+40]
   \   00000086   0xE060             B.N      ??I2C_MasterReceive_ISR_2
   2793                } 
   2794              } 
   2795              else
   2796              {
   2797                /* Process Unlocked */
   2798                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterReceive_ISR_4: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x0034      STRB     R0,[R4, #+52]
   2799                
   2800                /* Wrong size Status regarding TCR flag event */
   2801                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000094   0xE055             B.N      ??I2C_MasterReceive_ISR_6
   2802                HAL_I2C_ErrorCallback(hi2c);
   2803              }
   2804            }
   2805            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET)
   \                     ??I2C_MasterReceive_ISR_3: (+1)
   \   00000096   0x6981             LDR      R1,[R0, #+24]
   \   00000098   0x0649             LSLS     R1,R1,#+25
   \   0000009A   0xD50D             BPL.N    ??I2C_MasterReceive_ISR_7
   2806            {
   2807              if(hi2c->XferCount == 0)
   \   0000009C   0x8D61             LDRH     R1,[R4, #+42]
   \   0000009E   0xB921             CBNZ.N   R1,??I2C_MasterReceive_ISR_8
   2808              {
   2809                /* Generate Stop */
   2810                hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   000000A0   0x6841             LDR      R1,[R0, #+4]
   \   000000A2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   \   000000A8   0xE04F             B.N      ??I2C_MasterReceive_ISR_2
   2811              }
   2812              else
   2813              {
   2814                /* Process Unlocked */
   2815                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterReceive_ISR_8: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x0034      STRB     R0,[R4, #+52]
   2816                
   2817                /* Wrong size Status regarding TCR flag event */
   2818                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   000000B0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B2   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000B6   0xE044             B.N      ??I2C_MasterReceive_ISR_6
   2819                HAL_I2C_ErrorCallback(hi2c);
   2820              }
   2821            }
   2822            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \                     ??I2C_MasterReceive_ISR_7: (+1)
   \   000000B8   0x6981             LDR      R1,[R0, #+24]
   \   000000BA   0x0689             LSLS     R1,R1,#+26
   \   000000BC   0x6981             LDR      R1,[R0, #+24]
   \   000000BE   0xD536             BPL.N    ??I2C_MasterReceive_ISR_9
   2823            {
   2824              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   000000C0   0x06C9             LSLS     R1,R1,#+27
   \   000000C2   0xD505             BPL.N    ??I2C_MasterReceive_ISR_10
   2825              {
   2826                /* Clear NACK Flag */
   2827                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   000000C4   0x2110             MOVS     R1,#+16
   \   000000C6   0x61C1             STR      R1,[R0, #+28]
   2828                
   2829                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   000000C8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CA   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000CE   0x63A0             STR      R0,[R4, #+56]
   2830              }
   2831              
   2832              /* Disable ERR, TC, STOP, NACK, TXI interrupt */
   2833              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
   \                     ??I2C_MasterReceive_ISR_10: (+1)
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   2834              
   2835              /* Clear STOP Flag */
   2836              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2837              
   2838              /* Clear Configuration Register 2 */
   2839              I2C_RESET_CR2(hi2c);
   \   000000D2   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0xF021 0x01F4      BIC      R1,R1,#0xF4
   \   000000DC   0x6001             STR      R1,[R0, #+0]
   \   000000DE   0x6821             LDR      R1,[R4, #+0]
   \   000000E0   0x2020             MOVS     R0,#+32
   \   000000E2   0x61C8             STR      R0,[R1, #+28]
   \   000000E4   0x6820             LDR      R0,[R4, #+0]
   \   000000E6   0x6841             LDR      R1,[R0, #+4]
   \   000000E8   0x4011             ANDS     R1,R2,R1
   \   000000EA   0x6041             STR      R1,[R0, #+4]
   2840              
   2841              /* Call the correct callback to inform upper layer */
   2842              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   000000EC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000EE   0xB130             CBZ.N    R0,??I2C_MasterReceive_ISR_11
   2843              {
   2844                hi2c->State = HAL_I2C_STATE_READY;
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0xF884 0x0035      STRB     R0,[R4, #+53]
   2845                
   2846                /* Process Unlocked */
   2847                __HAL_UNLOCK(hi2c);
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0xF884 0x0034      STRB     R0,[R4, #+52]
   2848                
   2849                HAL_I2C_ErrorCallback(hi2c);
   \   000000FC   0xE022             B.N      ??I2C_MasterReceive_ISR_12
   2850              }
   2851              else
   2852              {
   2853                if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX)
   \                     ??I2C_MasterReceive_ISR_11: (+1)
   \   000000FE   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000102   0x2862             CMP      R0,#+98
   \   00000104   0xD109             BNE.N    ??I2C_MasterReceive_ISR_13
   2854                {
   2855                  hi2c->State = HAL_I2C_STATE_READY;
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0xF884 0x0035      STRB     R0,[R4, #+53]
   2856                  
   2857                  /* Process Unlocked */
   2858                  __HAL_UNLOCK(hi2c);
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xF884 0x0034      STRB     R0,[R4, #+52]
   2859                  
   2860                  HAL_I2C_MemRxCpltCallback(hi2c);
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   00000118   0xE017             B.N      ??I2C_MasterReceive_ISR_2
   2861                }
   2862                else
   2863                {
   2864                  hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_MasterReceive_ISR_13: (+1)
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0xF884 0x0035      STRB     R0,[R4, #+53]
   2865                  
   2866                  /* Process Unlocked */
   2867                  __HAL_UNLOCK(hi2c);
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0xF884 0x0034      STRB     R0,[R4, #+52]
   2868                  
   2869                  HAL_I2C_MasterRxCpltCallback(hi2c);
   \   00000126   0x4620             MOV      R0,R4
   \   00000128   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \   0000012C   0xE00D             B.N      ??I2C_MasterReceive_ISR_2
   2870                }
   2871              }
   2872            }
   2873            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     ??I2C_MasterReceive_ISR_9: (+1)
   \   0000012E   0x06C9             LSLS     R1,R1,#+27
   \   00000130   0xD50B             BPL.N    ??I2C_MasterReceive_ISR_2
   2874            {
   2875              /* Clear NACK Flag */
   2876              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000132   0x2110             MOVS     R1,#+16
   \   00000134   0x61C1             STR      R1,[R0, #+28]
   2877              
   2878              /* Process Unlocked */
   2879              __HAL_UNLOCK(hi2c);
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0xF884 0x0034      STRB     R0,[R4, #+52]
   2880              
   2881              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   0000013C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000013E   0xF040 0x0004      ORR      R0,R0,#0x4
   \                     ??I2C_MasterReceive_ISR_6: (+1)
   \   00000142   0x63A0             STR      R0,[R4, #+56]
   2882              HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_MasterReceive_ISR_12: (+1)
   \   00000144   0x4620             MOV      R0,R4
   \   00000146   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2883            }
   2884            
   2885            /* Process Unlocked */
   2886            __HAL_UNLOCK(hi2c); 
   \                     ??I2C_MasterReceive_ISR_2: (+1)
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0xF884 0x0034      STRB     R0,[R4, #+52]
   2887            
   2888            return HAL_OK; 
   \                     ??I2C_MasterReceive_ISR_0: (+1)
   \   00000150   0xB001             ADD      SP,SP,#+4
   \   00000152   0xBD30             POP      {R4,R5,PC}       ;; return
   2889            
   2890          }  
   2891          
   2892          /**
   2893            * @brief  Handle Interrupt Flags Slave Transmit Mode
   2894            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2895            *                the configuration information for the specified I2C.
   2896            * @retval HAL status
   2897            */

   \                                 In section .text, align 2, keep-with-next
   2898          static HAL_StatusTypeDef I2C_SlaveTransmit_ISR(I2C_HandleTypeDef *hi2c) 
   2899          {
   \                     I2C_SlaveTransmit_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2900            /* Process locked */
   2901            __HAL_LOCK(hi2c);
   \   00000004   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??I2C_SlaveTransmit_ISR_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0034      STRB     R0,[R4, #+52]
   2902            
   2903            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x06C9             LSLS     R1,R1,#+27
   \   0000001C   0xD51A             BPL.N    ??I2C_SlaveTransmit_ISR_1
   2904            {
   2905              /* Check that I2C transfer finished */
   2906              /* if yes, normal usecase, a NACK is sent by the MASTER when Transfer is finished */
   2907              /* Mean XferCount == 0*/
   2908              /* So clear Flag NACKF only */
   2909              if(hi2c->XferCount == 0)
   \   0000001E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000020   0xB941             CBNZ.N   R1,??I2C_SlaveTransmit_ISR_2
   2910              {
   2911                /* Clear NACK Flag */
   2912                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000022   0x2110             MOVS     R1,#+16
   \   00000024   0x61C1             STR      R1,[R0, #+28]
   2913                
   2914                /* Process Unlocked */
   2915                __HAL_UNLOCK(hi2c);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF884 0x0034      STRB     R0,[R4, #+52]
   2916              }
   2917              else
   2918              {
   2919                /* if no, error usecase, a Non-Acknowledge of last Data is generated by the MASTER*/
   2920                /* Clear NACK Flag */
   2921                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   2922                
   2923                /* Set ErrorCode corresponding to a Non-Acknowledge */
   2924                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   2925                
   2926                /* Process Unlocked */
   2927                __HAL_UNLOCK(hi2c);
   2928                
   2929                /* Call the Error callback to prevent upper layer */
   2930                HAL_I2C_ErrorCallback(hi2c);
   2931              }
   2932            }
   2933            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   2934            {
   2935              /* Clear ADDR flag */
   2936              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   2937            }
   2938            /* Check first if STOPF is set          */
   2939            /* to prevent a Write Data in TX buffer */
   2940            /* which is stuck in TXDR until next    */
   2941            /* communication with Master            */
   2942            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   2943            {
   2944              /* Disable ERRI, TCI, STOPI, NACKI, ADDRI, RXI, TXI interrupt */
   2945              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI );
   2946              
   2947              /* Disable Address Acknowledge */
   2948              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   2949              
   2950              /* Clear STOP Flag */
   2951              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2952              
   2953              hi2c->State = HAL_I2C_STATE_READY;
   2954              
   2955              /* Process Unlocked */
   2956              __HAL_UNLOCK(hi2c);
   2957              
   2958              HAL_I2C_SlaveTxCpltCallback(hi2c);
   2959            }
   2960            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
   2961            {
   2962              /* Write data to TXDR only if XferCount not reach "0" */
   2963              /* A TXIS flag can be set, during STOP treatment      */
   2964              if(hi2c->XferCount > 0)
   2965              {
   2966                /* Write data to TXDR */
   2967                hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
   2968                hi2c->XferCount--;
   2969              }
   2970            }
   2971            
   2972            /* Process Unlocked */
   2973            __HAL_UNLOCK(hi2c);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
   2974            
   2975            return HAL_OK;
   \   00000032   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_2: (+1)
   \   00000034   0x2110             MOVS     R1,#+16
   \   00000036   0x61C1             STR      R1,[R0, #+28]
   \   00000038   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003A   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000003E   0x63A0             STR      R0,[R4, #+56]
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000052   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_1: (+1)
   \   00000054   0x6981             LDR      R1,[R0, #+24]
   \   00000056   0x0709             LSLS     R1,R1,#+28
   \   00000058   0xD505             BPL.N    ??I2C_SlaveTransmit_ISR_3
   \   0000005A   0x2108             MOVS     R1,#+8
   \   0000005C   0x61C1             STR      R1,[R0, #+28]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000064   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_3: (+1)
   \   00000066   0x6981             LDR      R1,[R0, #+24]
   \   00000068   0x0689             LSLS     R1,R1,#+26
   \   0000006A   0xD518             BPL.N    ??I2C_SlaveTransmit_ISR_4
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF021 0x01FE      BIC      R1,R1,#0xFE
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6841             LDR      R1,[R0, #+4]
   \   00000078   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000007C   0x6041             STR      R1,[R0, #+4]
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x2020             MOVS     R0,#+32
   \   00000082   0x61C8             STR      R0,[R1, #+28]
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000009C   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_4: (+1)
   \   0000009E   0x6981             LDR      R1,[R0, #+24]
   \   000000A0   0x0789             LSLS     R1,R1,#+30
   \   000000A2   0xD509             BPL.N    ??I2C_SlaveTransmit_ISR_5
   \   000000A4   0x8D61             LDRH     R1,[R4, #+42]
   \   000000A6   0xB139             CBZ.N    R1,??I2C_SlaveTransmit_ISR_5
   \   000000A8   0x6A61             LDR      R1,[R4, #+36]
   \   000000AA   0x1C4A             ADDS     R2,R1,#+1
   \   000000AC   0x6262             STR      R2,[R4, #+36]
   \   000000AE   0x7809             LDRB     R1,[R1, #+0]
   \   000000B0   0x6281             STR      R1,[R0, #+40]
   \   000000B2   0x8D60             LDRH     R0,[R4, #+42]
   \   000000B4   0x1E40             SUBS     R0,R0,#+1
   \   000000B6   0x8560             STRH     R0,[R4, #+42]
   \                     ??I2C_SlaveTransmit_ISR_5: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000BE   0xBD10             POP      {R4,PC}          ;; return
   2976          }  
   2977          
   2978          /**
   2979            * @brief  Handle Interrupt Flags Slave Receive Mode
   2980            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2981            *                the configuration information for the specified I2C.
   2982            * @retval HAL status
   2983            */

   \                                 In section .text, align 2, keep-with-next
   2984          static HAL_StatusTypeDef I2C_SlaveReceive_ISR(I2C_HandleTypeDef *hi2c) 
   2985          {
   \                     I2C_SlaveReceive_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2986            /* Process Locked */
   2987            __HAL_LOCK(hi2c);
   \   00000004   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??I2C_SlaveReceive_ISR_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0034      STRB     R0,[R4, #+52]
   2988            
   2989            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x06C9             LSLS     R1,R1,#+27
   \   0000001C   0xD50F             BPL.N    ??I2C_SlaveReceive_ISR_1
   2990            {
   2991              /* Clear NACK Flag */
   2992              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000001E   0x2110             MOVS     R1,#+16
   \   00000020   0x61C1             STR      R1,[R0, #+28]
   2993              
   2994              /* Process Unlocked */
   2995              __HAL_UNLOCK(hi2c);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x0034      STRB     R0,[R4, #+52]
   2996              
   2997              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   2998              HAL_I2C_ErrorCallback(hi2c);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2999            }
   3000            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   3001            {
   3002              /* Clear ADDR flag */
   3003              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   3004            }
   3005            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   3006            {
   3007              /* Read data from RXDR */
   3008              (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
   3009              hi2c->XferSize--;
   3010              hi2c->XferCount--;
   3011            }
   3012            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   3013            {
   3014              /* Disable ERRI, TCI, STOPI, NACKI, ADDRI, RXI, TXI interrupt */
   3015              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_RXI );
   3016              
   3017              /* Disable Address Acknowledge */
   3018              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   3019              
   3020              /* Clear STOP Flag */
   3021              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3022              
   3023              hi2c->State = HAL_I2C_STATE_READY;
   3024              
   3025              /* Process Unlocked */
   3026              __HAL_UNLOCK(hi2c);
   3027              
   3028              HAL_I2C_SlaveRxCpltCallback(hi2c);
   3029            }
   3030            
   3031            /* Process Unlocked */
   3032            __HAL_UNLOCK(hi2c);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF884 0x0034      STRB     R0,[R4, #+52]
   3033            
   3034            return HAL_OK;     
   \   0000003C   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_1: (+1)
   \   0000003E   0x6981             LDR      R1,[R0, #+24]
   \   00000040   0x0709             LSLS     R1,R1,#+28
   \   00000042   0xD505             BPL.N    ??I2C_SlaveReceive_ISR_2
   \   00000044   0x2108             MOVS     R1,#+8
   \   00000046   0x61C1             STR      R1,[R0, #+28]
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000004E   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_2: (+1)
   \   00000050   0x6981             LDR      R1,[R0, #+24]
   \   00000052   0x0749             LSLS     R1,R1,#+29
   \   00000054   0xD50E             BPL.N    ??I2C_SlaveReceive_ISR_3
   \   00000056   0x6A61             LDR      R1,[R4, #+36]
   \   00000058   0x1C4A             ADDS     R2,R1,#+1
   \   0000005A   0x6262             STR      R2,[R4, #+36]
   \   0000005C   0x6A40             LDR      R0,[R0, #+36]
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   \   00000060   0x8D20             LDRH     R0,[R4, #+40]
   \   00000062   0x1E40             SUBS     R0,R0,#+1
   \   00000064   0x8520             STRH     R0,[R4, #+40]
   \   00000066   0x8D60             LDRH     R0,[R4, #+42]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x8560             STRH     R0,[R4, #+42]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000072   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_3: (+1)
   \   00000074   0x6981             LDR      R1,[R0, #+24]
   \   00000076   0x0689             LSLS     R1,R1,#+26
   \   00000078   0xD514             BPL.N    ??I2C_SlaveReceive_ISR_4
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0xF021 0x01FC      BIC      R1,R1,#0xFC
   \   00000080   0x6001             STR      R1,[R0, #+0]
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6841             LDR      R1,[R0, #+4]
   \   00000086   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000008A   0x6041             STR      R1,[R0, #+4]
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x2020             MOVS     R0,#+32
   \   00000090   0x61C8             STR      R0,[R1, #+28]
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   \                     ??I2C_SlaveReceive_ISR_4: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000AA   0xBD10             POP      {R4,PC}          ;; return
   3035          }  
   3036          
   3037          /**
   3038            * @brief  Master sends target device address followed by internal memory address for write request.
   3039            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3040            *                the configuration information for the specified I2C.
   3041            * @param  DevAddress: Target device address
   3042            * @param  MemAddress: Internal memory address
   3043            * @param  MemAddSize: Size of internal memory address
   3044            * @param  Timeout: Timeout duration
   3045            * @retval HAL status
   3046            */
   3047          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)   
   3048          {
   3049            I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   3050            
   3051            /* Wait until TXIS flag is set */
   3052            if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   3053            {
   3054              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3055              {
   3056                return HAL_ERROR;
   3057              }
   3058              else
   3059              {
   3060                return HAL_TIMEOUT;
   3061              }
   3062            }
   3063            
   3064            /* If Memory address size is 8Bit */
   3065            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   3066            {
   3067              /* Send Memory Address */
   3068              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);    
   3069            }      
   3070            /* If Memory address size is 16Bit */
   3071            else
   3072            {
   3073              /* Send MSB of Memory Address */
   3074              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress); 
   3075              
   3076              /* Wait until TXIS flag is set */
   3077              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   3078              {
   3079                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3080                {
   3081                  return HAL_ERROR;
   3082                }
   3083                else
   3084                {
   3085                  return HAL_TIMEOUT;
   3086                }
   3087              }
   3088              
   3089              /* Send LSB of Memory Address */
   3090              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);  
   3091            }
   3092            
   3093            /* Wait until TCR flag is set */
   3094            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   3095            {
   3096              return HAL_TIMEOUT;
   3097            }
   3098            
   3099            return HAL_OK;
   3100          }
   3101          
   3102          /**
   3103            * @brief  Master sends target device address followed by internal memory address for read request.
   3104            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3105            *                the configuration information for the specified I2C.
   3106            * @param  DevAddress: Target device address
   3107            * @param  MemAddress: Internal memory address
   3108            * @param  MemAddSize: Size of internal memory address
   3109            * @param  Timeout: Timeout duration
   3110            * @retval HAL status
   3111            */
   3112          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
   3113          {
   3114            I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
   3115            
   3116            /* Wait until TXIS flag is set */
   3117            if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   3118            {
   3119              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3120              {
   3121                return HAL_ERROR;
   3122              }
   3123              else
   3124              {
   3125                return HAL_TIMEOUT;
   3126              }
   3127            }
   3128            
   3129            /* If Memory address size is 8Bit */
   3130            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   3131            {
   3132              /* Send Memory Address */
   3133              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);    
   3134            }      
   3135            /* If Memory address size is 16Bit */
   3136            else
   3137            {
   3138              /* Send MSB of Memory Address */
   3139              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress); 
   3140              
   3141              /* Wait until TXIS flag is set */
   3142              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   3143              {
   3144                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3145                {
   3146                  return HAL_ERROR;
   3147                }
   3148                else
   3149                {
   3150                  return HAL_TIMEOUT;
   3151                }
   3152              }
   3153              
   3154              /* Send LSB of Memory Address */
   3155              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);  
   3156            }
   3157            
   3158            /* Wait until TC flag is set */
   3159            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout) != HAL_OK)      
   3160            {
   3161              return HAL_TIMEOUT;
   3162            }
   3163            
   3164            return HAL_OK;
   3165          }
   3166          
   3167          /**
   3168            * @brief  DMA I2C master transmit process complete callback.
   3169            * @param  hdma: DMA handle
   3170            * @retval None
   3171            */

   \                                 In section .text, align 2, keep-with-next
   3172          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma) 
   3173          {
   \                     I2C_DMAMasterTransmitCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3174            uint16_t DevAddress;
   3175            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3176            
   3177            /* Check if last DMA request was done with RELOAD */
   3178            /* Set NBYTES to write and reload if size > 255 */
   3179            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x80E0      BNE.W    ??I2C_DMAMasterTransmitCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x80DC      BCS.W    ??I2C_DMAMasterTransmitCplt_0
   3180            {
   3181              /* Wait until TCR flag is set */
   3182              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMasterTransmitCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMasterTransmitCplt_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   3183              {
   3184                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   3185              }
   3186              
   3187              /* Disable DMA Request */
   3188              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMAMasterTransmitCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   3189              
   3190              /* Check if Errors has been detected during transfer */
   3191              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0xB398             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_3
   3192              {
   3193                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3194                /* Wait until STOPF flag is reset */ 
   3195                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6980             LDR      R0,[R0, #+24]
   \   0000005A   0x0680             LSLS     R0,R0,#+26
   \   0000005C   0xD41C             BMI.N    ??I2C_DMAMasterTransmitCplt_5
   \   0000005E   0x2119             MOVS     R1,#+25
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000066   0xB970             CBNZ.N   R0,??I2C_DMAMasterTransmitCplt_6
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1B40             SUBS     R0,R0,R5
   \   0000006E   0x281A             CMP      R0,#+26
   \   00000070   0xD3F1             BCC.N    ??I2C_DMAMasterTransmitCplt_4
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   3196                {
   3197                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMasterTransmitCplt_6: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000092   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3198                  {
   3199                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3200                  }
   3201                  else
   3202                  {
   3203                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000096   0x63A0             STR      R0,[R4, #+56]
   3204                  }
   3205                }
   3206                
   3207                /* Clear STOP Flag */
   3208                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterTransmitCplt_5: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x2020             MOVS     R0,#+32
   3209                
   3210                /* Clear Configuration Register 2 */
   3211                I2C_RESET_CR2(hi2c);
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000A0   0x61C8             STR      R0,[R1, #+28]
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0x4011             ANDS     R1,R2,R1
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   3212                
   3213                hi2c->XferCount = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x8560             STRH     R0,[R4, #+42]
   3214                
   3215                hi2c->State = HAL_I2C_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0035      STRB     R0,[R4, #+53]
   3216                HAL_I2C_ErrorCallback(hi2c);
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xE0C5             B.N      ??I2C_DMAMasterTransmitCplt_7
   3217              }
   3218              else
   3219              {
   3220                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMasterTransmitCplt_3: (+1)
   \   000000B8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000BA   0x6A61             LDR      R1,[R4, #+36]
   \   000000BC   0x1841             ADDS     R1,R0,R1
   \   000000BE   0x6261             STR      R1,[R4, #+36]
   3221                hi2c->XferCount -= hi2c->XferSize;
   \   000000C0   0x8D62             LDRH     R2,[R4, #+42]
   \   000000C2   0x1A10             SUBS     R0,R2,R0
   \   000000C4   0x8560             STRH     R0,[R4, #+42]
   3222                if(hi2c->XferCount > 255)
   \   000000C6   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C8   0x28FF             CMP      R0,#+255
   \   000000CA   0xBFCC             ITE      GT 
   \   000000CC   0x20FF             MOVGT    R0,#+255
   \   000000CE   0x8D60             LDRHLE   R0,[R4, #+42]
   3223                {
   3224                  hi2c->XferSize = 255;
   3225                }
   3226                else
   3227                {
   3228                  hi2c->XferSize = hi2c->XferCount;
   \   000000D0   0x8520             STRH     R0,[R4, #+40]
   3229                }
   3230                
   3231                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6842             LDR      R2,[R0, #+4]
   3232                
   3233                /* Enable the DMA channel */
   3234                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   000000D6   0x8D23             LDRH     R3,[R4, #+40]
   \   000000D8   0x0595             LSLS     R5,R2,#+22
   \   000000DA   0xF100 0x0228      ADD      R2,R0,#+40
   \   000000DE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3235                
   3236                /* Send Slave Address */
   3237                /* Set NBYTES to write and reload if size > 255 */
   3238                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000E4   0x8D21             LDRH     R1,[R4, #+40]
   \   000000E6   0x29FF             CMP      R1,#+255
   \   000000E8   0xD10E             BNE.N    ??I2C_DMAMasterTransmitCplt_8
   \   000000EA   0x8D60             LDRH     R0,[R4, #+42]
   \   000000EC   0x4281             CMP      R1,R0
   \   000000EE   0xD20B             BCS.N    ??I2C_DMAMasterTransmitCplt_8
   3239                {
   3240                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0xfc009800
   \   000000F6   0x6842             LDR      R2,[R0, #+4]
   \   000000F8   0x401A             ANDS     R2,R3,R2
   \   000000FA   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   000000FE   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000102   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000106   0xE00B             B.N      ??I2C_DMAMasterTransmitCplt_9
   3241                }
   3242                else
   3243                {
   3244                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMasterTransmitCplt_8: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0xfc009800
   \   0000010E   0xB2C9             UXTB     R1,R1
   \   00000110   0x6842             LDR      R2,[R0, #+4]
   \   00000112   0x401A             ANDS     R2,R3,R2
   \   00000114   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   00000118   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000011C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??I2C_DMAMasterTransmitCplt_9: (+1)
   \   00000120   0x6041             STR      R1,[R0, #+4]
   3245                }  
   3246                
   3247                /* Wait until TXIS flag is set */
   3248                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   00000122   0x.... 0x....      BL       HAL_GetTick
   \   00000126   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_10: (+1)
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0x6981             LDR      R1,[R0, #+24]
   \   0000012C   0x0789             LSLS     R1,R1,#+30
   \   0000012E   0xD437             BMI.N    ??I2C_DMAMasterTransmitCplt_11
   \   00000130   0x2119             MOVS     R1,#+25
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000138   0xB970             CBNZ.N   R0,??I2C_DMAMasterTransmitCplt_12
   \   0000013A   0x.... 0x....      BL       HAL_GetTick
   \   0000013E   0x1B40             SUBS     R0,R0,R5
   \   00000140   0x281A             CMP      R0,#+26
   \   00000142   0xD3F1             BCC.N    ??I2C_DMAMasterTransmitCplt_10
   \   00000144   0x6BA0             LDR      R0,[R4, #+56]
   \   00000146   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000014A   0x63A0             STR      R0,[R4, #+56]
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xF884 0x0034      STRB     R0,[R4, #+52]
   3249                {
   3250                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3251                  /* Wait until STOPF flag is reset */ 
   3252                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??I2C_DMAMasterTransmitCplt_12: (+1)
   \   00000158   0x.... 0x....      BL       HAL_GetTick
   \   0000015C   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_13: (+1)
   \   0000015E   0x6820             LDR      R0,[R4, #+0]
   \   00000160   0x6980             LDR      R0,[R0, #+24]
   \   00000162   0x0680             LSLS     R0,R0,#+26
   \   00000164   0xD423             BMI.N    ??I2C_DMAMasterTransmitCplt_14
   \   00000166   0x2119             MOVS     R1,#+25
   \   00000168   0x4620             MOV      R0,R4
   \   0000016A   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000016E   0xB970             CBNZ.N   R0,??I2C_DMAMasterTransmitCplt_15
   \   00000170   0x.... 0x....      BL       HAL_GetTick
   \   00000174   0x1B40             SUBS     R0,R0,R5
   \   00000176   0x281A             CMP      R0,#+26
   \   00000178   0xD3F1             BCC.N    ??I2C_DMAMasterTransmitCplt_13
   \   0000017A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000017C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000180   0x63A0             STR      R0,[R4, #+56]
   \   00000182   0x2001             MOVS     R0,#+1
   \   00000184   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0xF884 0x0034      STRB     R0,[R4, #+52]
   3253                  {
   3254                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMasterTransmitCplt_15: (+1)
   \   0000018E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000190   0x2804             CMP      R0,#+4
   \   00000192   0x6BA0             LDR      R0,[R4, #+56]
   \   00000194   0xBF0C             ITE      EQ 
   \   00000196   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000019A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3255                    {
   3256                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3257                    }
   3258                    else
   3259                    {
   3260                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000019E   0xE005             B.N      ??I2C_DMAMasterTransmitCplt_16
   3261                    }
   3262                  }
   3263                  
   3264                  /* Clear STOP Flag */
   3265                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3266                  
   3267                  /* Clear Configuration Register 2 */
   3268                  I2C_RESET_CR2(hi2c);
   3269                  
   3270                  hi2c->XferCount = 0;
   3271                  
   3272                  hi2c->State = HAL_I2C_STATE_READY;
   3273                  HAL_I2C_ErrorCallback(hi2c);
   3274                }
   3275                else
   3276                {
   3277                  /* Enable DMA Request */
   3278                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??I2C_DMAMasterTransmitCplt_11: (+1)
   \   000001A0   0x6801             LDR      R1,[R0, #+0]
   \   000001A2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000001A6   0x6001             STR      R1,[R0, #+0]
   3279                }
   3280              }
   3281            }
   3282            else
   3283            {
   3284              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3285              /* Wait until STOPF flag is reset */ 
   3286              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   3287              {
   3288                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3289                {
   3290                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3291                }
   3292                else
   3293                {
   3294                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3295                }
   3296              }
   3297              
   3298              /* Clear STOP Flag */
   3299              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3300            	
   3301              /* Clear Configuration Register 2 */
   3302              I2C_RESET_CR2(hi2c);
   3303              
   3304              /* Disable DMA Request */
   3305              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   3306              
   3307              hi2c->XferCount = 0;
   3308              
   3309              hi2c->State = HAL_I2C_STATE_READY;
   3310              
   3311              /* Check if Errors has been detected during transfer */
   3312              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   3313              {
   3314                HAL_I2C_ErrorCallback(hi2c);
   3315              }
   3316              else
   3317              {
   3318                HAL_I2C_MasterTxCpltCallback(hi2c);
   3319              }
   3320            }
   3321          }
   \   000001A8   0xB001             ADD      SP,SP,#+4
   \   000001AA   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMasterTransmitCplt_16: (+1)
   \   000001AC   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMasterTransmitCplt_14: (+1)
   \   000001AE   0x6821             LDR      R1,[R4, #+0]
   \   000001B0   0x2020             MOVS     R0,#+32
   \   000001B2   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000001B6   0x61C8             STR      R0,[R1, #+28]
   \   000001B8   0x6820             LDR      R0,[R4, #+0]
   \   000001BA   0x6841             LDR      R1,[R0, #+4]
   \   000001BC   0x4011             ANDS     R1,R2,R1
   \   000001BE   0x6041             STR      R1,[R0, #+4]
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0x8560             STRH     R0,[R4, #+42]
   \   000001C4   0x2001             MOVS     R0,#+1
   \   000001C6   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001CA   0x4620             MOV      R0,R4
   \   000001CC   0xE03A             B.N      ??I2C_DMAMasterTransmitCplt_7
   \                     ??I2C_DMAMasterTransmitCplt_0: (+1)
   \   000001CE   0x.... 0x....      BL       HAL_GetTick
   \   000001D2   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_17: (+1)
   \   000001D4   0x6820             LDR      R0,[R4, #+0]
   \   000001D6   0x6980             LDR      R0,[R0, #+24]
   \   000001D8   0x0680             LSLS     R0,R0,#+26
   \   000001DA   0xD41C             BMI.N    ??I2C_DMAMasterTransmitCplt_18
   \   000001DC   0x2119             MOVS     R1,#+25
   \   000001DE   0x4620             MOV      R0,R4
   \   000001E0   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001E4   0xB970             CBNZ.N   R0,??I2C_DMAMasterTransmitCplt_19
   \   000001E6   0x.... 0x....      BL       HAL_GetTick
   \   000001EA   0x1B40             SUBS     R0,R0,R5
   \   000001EC   0x281A             CMP      R0,#+26
   \   000001EE   0xD3F1             BCC.N    ??I2C_DMAMasterTransmitCplt_17
   \   000001F0   0x6BA0             LDR      R0,[R4, #+56]
   \   000001F2   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001F6   0x63A0             STR      R0,[R4, #+56]
   \   000001F8   0x2001             MOVS     R0,#+1
   \   000001FA   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??I2C_DMAMasterTransmitCplt_19: (+1)
   \   00000204   0x6BA0             LDR      R0,[R4, #+56]
   \   00000206   0x2804             CMP      R0,#+4
   \   00000208   0x6BA0             LDR      R0,[R4, #+56]
   \   0000020A   0xBF0C             ITE      EQ 
   \   0000020C   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000210   0xF040 0x0020      ORRNE    R0,R0,#0x20
   \   00000214   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMasterTransmitCplt_18: (+1)
   \   00000216   0x6821             LDR      R1,[R4, #+0]
   \   00000218   0x2020             MOVS     R0,#+32
   \   0000021A   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   0000021E   0x61C8             STR      R0,[R1, #+28]
   \   00000220   0x6820             LDR      R0,[R4, #+0]
   \   00000222   0x6841             LDR      R1,[R0, #+4]
   \   00000224   0x4011             ANDS     R1,R2,R1
   \   00000226   0x6041             STR      R1,[R0, #+4]
   \   00000228   0x6820             LDR      R0,[R4, #+0]
   \   0000022A   0x6801             LDR      R1,[R0, #+0]
   \   0000022C   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000230   0x6001             STR      R1,[R0, #+0]
   \   00000232   0x2000             MOVS     R0,#+0
   \   00000234   0x8560             STRH     R0,[R4, #+42]
   \   00000236   0x2001             MOVS     R0,#+1
   \   00000238   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000023C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000023E   0x2800             CMP      R0,#+0
   \   00000240   0x4620             MOV      R0,R4
   \   00000242   0xD003             BEQ.N    ??I2C_DMAMasterTransmitCplt_20
   \                     ??I2C_DMAMasterTransmitCplt_7: (+1)
   \   00000244   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000248   0xB001             ADD      SP,SP,#+4
   \   0000024A   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMasterTransmitCplt_20: (+1)
   \   0000024C   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \   00000250   0xB001             ADD      SP,SP,#+4
   \   00000252   0xBD30             POP      {R4,R5,PC}       ;; return
   3322          
   3323          /**
   3324            * @brief  DMA I2C slave transmit process complete callback. 
   3325            * @param  hdma: DMA handle
   3326            * @retval None
   3327            */

   \                                 In section .text, align 2, keep-with-next
   3328          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma) 
   3329          {
   \                     I2C_DMASlaveTransmitCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3330            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3331            
   3332            /* Wait until STOP flag is set */
   3333            if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveTransmitCplt_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD41B             BMI.N    ??I2C_DMASlaveTransmitCplt_1
   \   00000014   0x2119             MOVS     R1,#+25
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001C   0xB970             CBNZ.N   R0,??I2C_DMASlaveTransmitCplt_2
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x1B40             SUBS     R0,R0,R5
   \   00000024   0x281A             CMP      R0,#+26
   \   00000026   0xD3F1             BCC.N    ??I2C_DMASlaveTransmitCplt_0
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF884 0x0034      STRB     R0,[R4, #+52]
   3334            {
   3335              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMASlaveTransmitCplt_2: (+1)
   \   0000003C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003E   0x2804             CMP      R0,#+4
   \   00000040   0xBF0E             ITEE     EQ 
   \   00000042   0x2000             MOVEQ    R0,#+0
   \   00000044   0x6BA0             LDRNE    R0,[R4, #+56]
   \   00000046   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3336              {
   3337                /* Normal Use case, a AF is generated by master */
   3338                /* to inform slave the end of transfer */
   3339                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3340              }
   3341              else
   3342              {
   3343                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000004A   0x63A0             STR      R0,[R4, #+56]
   3344              }
   3345            }
   3346            
   3347            /* Clear STOP flag */
   3348            __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
   \                     ??I2C_DMASlaveTransmitCplt_1: (+1)
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0x61C8             STR      R0,[R1, #+28]
   3349            
   3350            /* Wait until BUSY flag is reset */ 
   3351            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \   00000052   0x.... 0x....      BL       HAL_GetTick
   \   00000056   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveTransmitCplt_3: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6980             LDR      R0,[R0, #+24]
   \   0000005C   0x0400             LSLS     R0,R0,#+16
   \   0000005E   0xD50E             BPL.N    ??I2C_DMASlaveTransmitCplt_4
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0x1B40             SUBS     R0,R0,R5
   \   00000066   0x281A             CMP      R0,#+26
   \   00000068   0xD3F6             BCC.N    ??I2C_DMASlaveTransmitCplt_3
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF884 0x0034      STRB     R0,[R4, #+52]
   3352            {
   3353              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000076   0x6BA0             LDR      R0,[R4, #+56]
   \   00000078   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000007C   0x63A0             STR      R0,[R4, #+56]
   3354            }
   3355            
   3356            /* Disable DMA Request */
   3357            hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMASlaveTransmitCplt_4: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6801             LDR      R1,[R0, #+0]
   \   00000082   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000086   0x6001             STR      R1,[R0, #+0]
   3358            
   3359            hi2c->XferCount = 0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x8560             STRH     R0,[R4, #+42]
   3360            
   3361            hi2c->State = HAL_I2C_STATE_READY;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xF884 0x0035      STRB     R0,[R4, #+53]
   3362            
   3363            /* Check if Errors has been detected during transfer */
   3364            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000092   0x6BA0             LDR      R0,[R4, #+56]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0xD003             BEQ.N    ??I2C_DMASlaveTransmitCplt_5
   3365            {
   3366              HAL_I2C_ErrorCallback(hi2c);
   \   0000009A   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3367            }
   3368            else
   3369            {
   3370              HAL_I2C_SlaveTxCpltCallback(hi2c);
   3371            }
   3372          }
   \   0000009E   0xB001             ADD      SP,SP,#+4
   \   000000A0   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMASlaveTransmitCplt_5: (+1)
   \   000000A2   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   \   000000A6   0xB001             ADD      SP,SP,#+4
   \   000000A8   0xBD30             POP      {R4,R5,PC}       ;; return
   3373          
   3374          /**
   3375            * @brief DMA I2C master receive process complete callback 
   3376            * @param  hdma: DMA handle
   3377            * @retval None
   3378            */

   \                                 In section .text, align 2, keep-with-next
   3379          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma) 
   3380          {
   \                     I2C_DMAMasterReceiveCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3381            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3382            uint16_t DevAddress;
   3383            
   3384            /* Check if last DMA request was done with RELOAD */
   3385            /* Set NBYTES to write and reload if size > 255 */
   3386            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x80DD      BNE.W    ??I2C_DMAMasterReceiveCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x80D9      BCS.W    ??I2C_DMAMasterReceiveCplt_0
   3387            {
   3388              /* Wait until TCR flag is set */
   3389              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMasterReceiveCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMasterReceiveCplt_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   3390              {
   3391                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   3392              }
   3393              
   3394              /* Disable DMA Request */
   3395              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMAMasterReceiveCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   3396              
   3397              /* Check if Errors has been detected during transfer */
   3398              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0xB398             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_3
   3399              {
   3400                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3401                /* Wait until STOPF flag is reset */ 
   3402                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6980             LDR      R0,[R0, #+24]
   \   0000005A   0x0680             LSLS     R0,R0,#+26
   \   0000005C   0xD41C             BMI.N    ??I2C_DMAMasterReceiveCplt_5
   \   0000005E   0x2119             MOVS     R1,#+25
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000066   0xB970             CBNZ.N   R0,??I2C_DMAMasterReceiveCplt_6
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1B40             SUBS     R0,R0,R5
   \   0000006E   0x281A             CMP      R0,#+26
   \   00000070   0xD3F1             BCC.N    ??I2C_DMAMasterReceiveCplt_4
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   3403                {
   3404                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMasterReceiveCplt_6: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000092   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3405                  {
   3406                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3407                  }
   3408                  else
   3409                  {
   3410                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000096   0x63A0             STR      R0,[R4, #+56]
   3411                  }
   3412                }
   3413                
   3414                /* Clear STOP Flag */
   3415                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterReceiveCplt_5: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x2020             MOVS     R0,#+32
   3416                
   3417                /* Clear Configuration Register 2 */
   3418                I2C_RESET_CR2(hi2c);
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000A0   0x61C8             STR      R0,[R1, #+28]
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0x4011             ANDS     R1,R2,R1
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   3419                
   3420                hi2c->XferCount = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x8560             STRH     R0,[R4, #+42]
   3421                
   3422                hi2c->State = HAL_I2C_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0035      STRB     R0,[R4, #+53]
   3423                HAL_I2C_ErrorCallback(hi2c);
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xE0C2             B.N      ??I2C_DMAMasterReceiveCplt_7
   3424              }
   3425              else
   3426              {
   3427                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMasterReceiveCplt_3: (+1)
   \   000000B8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000BA   0x6A61             LDR      R1,[R4, #+36]
   \   000000BC   0x1842             ADDS     R2,R0,R1
   \   000000BE   0x6262             STR      R2,[R4, #+36]
   3428                hi2c->XferCount -= hi2c->XferSize;
   \   000000C0   0x8D61             LDRH     R1,[R4, #+42]
   \   000000C2   0x1A08             SUBS     R0,R1,R0
   \   000000C4   0x8560             STRH     R0,[R4, #+42]
   3429                if(hi2c->XferCount > 255)
   \   000000C6   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C8   0x28FF             CMP      R0,#+255
   \   000000CA   0xBFCC             ITE      GT 
   \   000000CC   0x20FF             MOVGT    R0,#+255
   \   000000CE   0x8D60             LDRHLE   R0,[R4, #+42]
   3430                {
   3431                  hi2c->XferSize = 255;
   3432                }
   3433                else
   3434                {
   3435                  hi2c->XferSize = hi2c->XferCount;
   \   000000D0   0x8520             STRH     R0,[R4, #+40]
   3436                }
   3437                
   3438                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6841             LDR      R1,[R0, #+4]
   3439                
   3440                /* Enable the DMA channel */
   3441                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000D6   0x8D23             LDRH     R3,[R4, #+40]
   \   000000D8   0x058D             LSLS     R5,R1,#+22
   \   000000DA   0xF100 0x0124      ADD      R1,R0,#+36
   \   000000DE   0x6B20             LDR      R0,[R4, #+48]
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3442                
   3443                /* Send Slave Address */
   3444                /* Set NBYTES to write and reload if size > 255 */
   3445                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000E4   0x8D21             LDRH     R1,[R4, #+40]
   \   000000E6   0x29FF             CMP      R1,#+255
   \   000000E8   0xD10E             BNE.N    ??I2C_DMAMasterReceiveCplt_8
   \   000000EA   0x8D60             LDRH     R0,[R4, #+42]
   \   000000EC   0x4281             CMP      R1,R0
   \   000000EE   0xD20B             BCS.N    ??I2C_DMAMasterReceiveCplt_8
   3446                {
   3447                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0xfc009800
   \   000000F6   0x6842             LDR      R2,[R0, #+4]
   \   000000F8   0x401A             ANDS     R2,R3,R2
   \   000000FA   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   000000FE   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000102   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000106   0xE00B             B.N      ??I2C_DMAMasterReceiveCplt_9
   3448                }
   3449                else
   3450                {
   3451                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMasterReceiveCplt_8: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0xfc009800
   \   0000010E   0xB2C9             UXTB     R1,R1
   \   00000110   0x6842             LDR      R2,[R0, #+4]
   \   00000112   0x401A             ANDS     R2,R3,R2
   \   00000114   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   00000118   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000011C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??I2C_DMAMasterReceiveCplt_9: (+1)
   \   00000120   0x6041             STR      R1,[R0, #+4]
   3452                }  
   3453                
   3454                /* Wait until RXNE flag is set */
   3455                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   00000122   0x.... 0x....      BL       HAL_GetTick
   \   00000126   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_10: (+1)
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0x6980             LDR      R0,[R0, #+24]
   \   0000012C   0x0740             LSLS     R0,R0,#+29
   \   0000012E   0xD40E             BMI.N    ??I2C_DMAMasterReceiveCplt_11
   \   00000130   0x.... 0x....      BL       HAL_GetTick
   \   00000134   0x1B40             SUBS     R0,R0,R5
   \   00000136   0x281A             CMP      R0,#+26
   \   00000138   0xD3F6             BCC.N    ??I2C_DMAMasterReceiveCplt_10
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xF884 0x0034      STRB     R0,[R4, #+52]
   3456                {
   3457                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000146   0x6BA0             LDR      R0,[R4, #+56]
   \   00000148   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000014C   0x63A0             STR      R0,[R4, #+56]
   3458                }
   3459                
   3460                /* Check if Errors has been detected during transfer */
   3461                if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??I2C_DMAMasterReceiveCplt_11: (+1)
   \   0000014E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000150   0xB398             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_12
   3462                {
   3463                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3464                  /* Wait until STOPF flag is reset */ 
   3465                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000152   0x.... 0x....      BL       HAL_GetTick
   \   00000156   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_13: (+1)
   \   00000158   0x6820             LDR      R0,[R4, #+0]
   \   0000015A   0x6980             LDR      R0,[R0, #+24]
   \   0000015C   0x0680             LSLS     R0,R0,#+26
   \   0000015E   0xD41C             BMI.N    ??I2C_DMAMasterReceiveCplt_14
   \   00000160   0x2119             MOVS     R1,#+25
   \   00000162   0x4620             MOV      R0,R4
   \   00000164   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000168   0xB970             CBNZ.N   R0,??I2C_DMAMasterReceiveCplt_15
   \   0000016A   0x.... 0x....      BL       HAL_GetTick
   \   0000016E   0x1B40             SUBS     R0,R0,R5
   \   00000170   0x281A             CMP      R0,#+26
   \   00000172   0xD3F1             BCC.N    ??I2C_DMAMasterReceiveCplt_13
   \   00000174   0x6BA0             LDR      R0,[R4, #+56]
   \   00000176   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000017A   0x63A0             STR      R0,[R4, #+56]
   \   0000017C   0x2001             MOVS     R0,#+1
   \   0000017E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0xF884 0x0034      STRB     R0,[R4, #+52]
   3466                  {
   3467                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMasterReceiveCplt_15: (+1)
   \   00000188   0x6BA0             LDR      R0,[R4, #+56]
   \   0000018A   0x2804             CMP      R0,#+4
   \   0000018C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000018E   0xBF0C             ITE      EQ 
   \   00000190   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000194   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3468                    {
   3469                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3470                    }
   3471                    else
   3472                    {
   3473                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000198   0x63A0             STR      R0,[R4, #+56]
   3474                    }
   3475                  }
   3476                  
   3477                  /* Clear STOP Flag */
   3478                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterReceiveCplt_14: (+1)
   \   0000019A   0x6821             LDR      R1,[R4, #+0]
   \   0000019C   0x2020             MOVS     R0,#+32
   3479                  
   3480                  /* Clear Configuration Register 2 */
   3481                  I2C_RESET_CR2(hi2c);
   \   0000019E   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000001A2   0x61C8             STR      R0,[R1, #+28]
   \   000001A4   0x6820             LDR      R0,[R4, #+0]
   \   000001A6   0x6841             LDR      R1,[R0, #+4]
   \   000001A8   0x4011             ANDS     R1,R2,R1
   \   000001AA   0x6041             STR      R1,[R0, #+4]
   3482                  
   3483                  hi2c->XferCount = 0;
   \   000001AC   0x2000             MOVS     R0,#+0
   \   000001AE   0x8560             STRH     R0,[R4, #+42]
   3484                  
   3485                  hi2c->State = HAL_I2C_STATE_READY;
   \   000001B0   0x2001             MOVS     R0,#+1
   \   000001B2   0xF884 0x0035      STRB     R0,[R4, #+53]
   3486                  
   3487                  HAL_I2C_ErrorCallback(hi2c);
   \   000001B6   0x4620             MOV      R0,R4
   \   000001B8   0xE041             B.N      ??I2C_DMAMasterReceiveCplt_7
   3488                }
   3489                else
   3490                {
   3491                  /* Enable DMA Request */
   3492                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??I2C_DMAMasterReceiveCplt_12: (+1)
   \   000001BA   0x6820             LDR      R0,[R4, #+0]
   \   000001BC   0x6801             LDR      R1,[R0, #+0]
   \   000001BE   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001C2   0x6001             STR      R1,[R0, #+0]
   3493                }
   3494              }
   3495            }
   3496            else
   3497            {
   3498              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3499              /* Wait until STOPF flag is reset */ 
   3500              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   3501              {
   3502                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3503                {
   3504                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3505                }
   3506                else
   3507                {
   3508                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3509                }
   3510              }
   3511              
   3512              /* Clear STOP Flag */
   3513              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3514            	
   3515              /* Clear Configuration Register 2 */
   3516              I2C_RESET_CR2(hi2c);
   3517              
   3518              /* Disable DMA Request */
   3519              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   3520              
   3521              hi2c->XferCount = 0;
   3522              
   3523              hi2c->State = HAL_I2C_STATE_READY;
   3524              
   3525              /* Check if Errors has been detected during transfer */
   3526              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   3527              {
   3528                HAL_I2C_ErrorCallback(hi2c);
   3529              }
   3530              else
   3531              {
   3532                HAL_I2C_MasterRxCpltCallback(hi2c);
   3533              }
   3534            }
   3535          }
   \   000001C4   0xB001             ADD      SP,SP,#+4
   \   000001C6   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMasterReceiveCplt_0: (+1)
   \   000001C8   0x.... 0x....      BL       HAL_GetTick
   \   000001CC   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_16: (+1)
   \   000001CE   0x6820             LDR      R0,[R4, #+0]
   \   000001D0   0x6980             LDR      R0,[R0, #+24]
   \   000001D2   0x0680             LSLS     R0,R0,#+26
   \   000001D4   0xD41C             BMI.N    ??I2C_DMAMasterReceiveCplt_17
   \   000001D6   0x2119             MOVS     R1,#+25
   \   000001D8   0x4620             MOV      R0,R4
   \   000001DA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001DE   0xB970             CBNZ.N   R0,??I2C_DMAMasterReceiveCplt_18
   \   000001E0   0x.... 0x....      BL       HAL_GetTick
   \   000001E4   0x1B40             SUBS     R0,R0,R5
   \   000001E6   0x281A             CMP      R0,#+26
   \   000001E8   0xD3F1             BCC.N    ??I2C_DMAMasterReceiveCplt_16
   \   000001EA   0x6BA0             LDR      R0,[R4, #+56]
   \   000001EC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001F0   0x63A0             STR      R0,[R4, #+56]
   \   000001F2   0x2001             MOVS     R0,#+1
   \   000001F4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??I2C_DMAMasterReceiveCplt_18: (+1)
   \   000001FE   0x6BA0             LDR      R0,[R4, #+56]
   \   00000200   0x2804             CMP      R0,#+4
   \   00000202   0x6BA0             LDR      R0,[R4, #+56]
   \   00000204   0xBF0C             ITE      EQ 
   \   00000206   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000020A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   \   0000020E   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMasterReceiveCplt_17: (+1)
   \   00000210   0x6821             LDR      R1,[R4, #+0]
   \   00000212   0x2020             MOVS     R0,#+32
   \   00000214   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   00000218   0x61C8             STR      R0,[R1, #+28]
   \   0000021A   0x6820             LDR      R0,[R4, #+0]
   \   0000021C   0x6841             LDR      R1,[R0, #+4]
   \   0000021E   0x4011             ANDS     R1,R2,R1
   \   00000220   0x6041             STR      R1,[R0, #+4]
   \   00000222   0x6820             LDR      R0,[R4, #+0]
   \   00000224   0x6801             LDR      R1,[R0, #+0]
   \   00000226   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000022A   0x6001             STR      R1,[R0, #+0]
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0x8560             STRH     R0,[R4, #+42]
   \   00000230   0x2001             MOVS     R0,#+1
   \   00000232   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000236   0x6BA0             LDR      R0,[R4, #+56]
   \   00000238   0x2800             CMP      R0,#+0
   \   0000023A   0x4620             MOV      R0,R4
   \   0000023C   0xD003             BEQ.N    ??I2C_DMAMasterReceiveCplt_19
   \                     ??I2C_DMAMasterReceiveCplt_7: (+1)
   \   0000023E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000242   0xB001             ADD      SP,SP,#+4
   \   00000244   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMasterReceiveCplt_19: (+1)
   \   00000246   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \   0000024A   0xB001             ADD      SP,SP,#+4
   \   0000024C   0xBD30             POP      {R4,R5,PC}       ;; return
   3536          
   3537          /**
   3538            * @brief  DMA I2C slave receive process complete callback.
   3539            * @param  hdma: DMA handle
   3540            * @retval None
   3541            */

   \                                 In section .text, align 2, keep-with-next
   3542          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma) 
   3543          {  
   \                     I2C_DMASlaveReceiveCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3544            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3545            
   3546            /* Wait until STOPF flag is reset */ 
   3547            if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveReceiveCplt_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD41C             BMI.N    ??I2C_DMASlaveReceiveCplt_1
   \   00000014   0x2119             MOVS     R1,#+25
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001C   0xB970             CBNZ.N   R0,??I2C_DMASlaveReceiveCplt_2
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x1B40             SUBS     R0,R0,R5
   \   00000024   0x281A             CMP      R0,#+26
   \   00000026   0xD3F1             BCC.N    ??I2C_DMASlaveReceiveCplt_0
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF884 0x0034      STRB     R0,[R4, #+52]
   3548            {
   3549              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMASlaveReceiveCplt_2: (+1)
   \   0000003C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003E   0x2804             CMP      R0,#+4
   \   00000040   0x6BA0             LDR      R0,[R4, #+56]
   \   00000042   0xBF0C             ITE      EQ 
   \   00000044   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000048   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3550              {
   3551                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3552              }
   3553              else
   3554              {
   3555                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000004C   0x63A0             STR      R0,[R4, #+56]
   3556              }
   3557            }
   3558            
   3559            /* Clear STOPF flag */
   3560            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMASlaveReceiveCplt_1: (+1)
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x2020             MOVS     R0,#+32
   \   00000052   0x61C8             STR      R0,[R1, #+28]
   3561            
   3562            /* Wait until BUSY flag is reset */ 
   3563            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \   00000054   0x.... 0x....      BL       HAL_GetTick
   \   00000058   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveReceiveCplt_3: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6980             LDR      R0,[R0, #+24]
   \   0000005E   0x0400             LSLS     R0,R0,#+16
   \   00000060   0xD50E             BPL.N    ??I2C_DMASlaveReceiveCplt_4
   \   00000062   0x.... 0x....      BL       HAL_GetTick
   \   00000066   0x1B40             SUBS     R0,R0,R5
   \   00000068   0x281A             CMP      R0,#+26
   \   0000006A   0xD3F6             BCC.N    ??I2C_DMASlaveReceiveCplt_3
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF884 0x0034      STRB     R0,[R4, #+52]
   3564            {
   3565              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000078   0x6BA0             LDR      R0,[R4, #+56]
   \   0000007A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000007E   0x63A0             STR      R0,[R4, #+56]
   3566            }
   3567            
   3568            /* Disable DMA Request */
   3569            hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMASlaveReceiveCplt_4: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000088   0x6001             STR      R1,[R0, #+0]
   3570            
   3571            /* Disable Address Acknowledge */
   3572            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6841             LDR      R1,[R0, #+4]
   \   0000008E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000092   0x6041             STR      R1,[R0, #+4]
   3573            
   3574            hi2c->XferCount = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x8560             STRH     R0,[R4, #+42]
   3575            
   3576            hi2c->State = HAL_I2C_STATE_READY;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xF884 0x0035      STRB     R0,[R4, #+53]
   3577            
   3578            /* Check if Errors has been detected during transfer */
   3579            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000009E   0x6BA0             LDR      R0,[R4, #+56]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0xD003             BEQ.N    ??I2C_DMASlaveReceiveCplt_5
   3580            {
   3581              HAL_I2C_ErrorCallback(hi2c);
   \   000000A6   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3582            }
   3583            else
   3584            {
   3585              HAL_I2C_SlaveRxCpltCallback(hi2c);
   3586            }
   3587          }
   \   000000AA   0xB001             ADD      SP,SP,#+4
   \   000000AC   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMASlaveReceiveCplt_5: (+1)
   \   000000AE   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   \   000000B2   0xB001             ADD      SP,SP,#+4
   \   000000B4   0xBD30             POP      {R4,R5,PC}       ;; return
   3588          
   3589          /**
   3590            * @brief DMA I2C Memory Write process complete callback 
   3591            * @param hdma : DMA handle
   3592            * @retval None
   3593            */

   \                                 In section .text, align 2, keep-with-next
   3594          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma)   
   3595          {
   \                     I2C_DMAMemTransmitCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3596            uint16_t DevAddress;
   3597            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3598            
   3599            /* Check if last DMA request was done with RELOAD */
   3600            /* Set NBYTES to write and reload if size > 255 */
   3601            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x80DD      BNE.W    ??I2C_DMAMemTransmitCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x80D9      BCS.W    ??I2C_DMAMemTransmitCplt_0
   3602            {
   3603              /* Wait until TCR flag is set */
   3604              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMemTransmitCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMemTransmitCplt_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   3605              {
   3606                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   3607              }
   3608              
   3609              /* Disable DMA Request */
   3610              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMAMemTransmitCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   3611              
   3612              /* Check if Errors has been detected during transfer */
   3613              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0xB398             CBZ.N    R0,??I2C_DMAMemTransmitCplt_3
   3614              {
   3615                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3616                /* Wait until STOPF flag is reset */ 
   3617                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6980             LDR      R0,[R0, #+24]
   \   0000005A   0x0680             LSLS     R0,R0,#+26
   \   0000005C   0xD41C             BMI.N    ??I2C_DMAMemTransmitCplt_5
   \   0000005E   0x2119             MOVS     R1,#+25
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000066   0xB970             CBNZ.N   R0,??I2C_DMAMemTransmitCplt_6
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1B40             SUBS     R0,R0,R5
   \   0000006E   0x281A             CMP      R0,#+26
   \   00000070   0xD3F1             BCC.N    ??I2C_DMAMemTransmitCplt_4
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   3618                {
   3619                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMemTransmitCplt_6: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000092   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3620                  {
   3621                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3622                  }
   3623                  else
   3624                  {
   3625                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000096   0x63A0             STR      R0,[R4, #+56]
   3626                  }
   3627                }
   3628                
   3629                /* Clear STOP Flag */
   3630                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemTransmitCplt_5: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x2020             MOVS     R0,#+32
   3631                
   3632                /* Clear Configuration Register 2 */
   3633                I2C_RESET_CR2(hi2c);
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000A0   0x61C8             STR      R0,[R1, #+28]
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0x4011             ANDS     R1,R2,R1
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   3634                
   3635                hi2c->XferCount = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x8560             STRH     R0,[R4, #+42]
   3636                
   3637                hi2c->State = HAL_I2C_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0035      STRB     R0,[R4, #+53]
   3638                HAL_I2C_ErrorCallback(hi2c);
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xE0C1             B.N      ??I2C_DMAMemTransmitCplt_7
   3639              }
   3640              else
   3641              {
   3642                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMemTransmitCplt_3: (+1)
   \   000000B8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000BA   0x6A61             LDR      R1,[R4, #+36]
   \   000000BC   0x1841             ADDS     R1,R0,R1
   \   000000BE   0x6261             STR      R1,[R4, #+36]
   3643                hi2c->XferCount -= hi2c->XferSize;
   \   000000C0   0x8D62             LDRH     R2,[R4, #+42]
   \   000000C2   0x1A10             SUBS     R0,R2,R0
   \   000000C4   0x8560             STRH     R0,[R4, #+42]
   3644                if(hi2c->XferCount > 255)
   \   000000C6   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C8   0x28FF             CMP      R0,#+255
   \   000000CA   0xBFCC             ITE      GT 
   \   000000CC   0x20FF             MOVGT    R0,#+255
   \   000000CE   0x8D60             LDRHLE   R0,[R4, #+42]
   3645                {
   3646                  hi2c->XferSize = 255;
   3647                }
   3648                else
   3649                {
   3650                  hi2c->XferSize = hi2c->XferCount;
   \   000000D0   0x8520             STRH     R0,[R4, #+40]
   3651                }
   3652                
   3653                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6842             LDR      R2,[R0, #+4]
   3654                
   3655                /* Enable the DMA channel */
   3656                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   000000D6   0x8D23             LDRH     R3,[R4, #+40]
   \   000000D8   0x0595             LSLS     R5,R2,#+22
   \   000000DA   0xF100 0x0228      ADD      R2,R0,#+40
   \   000000DE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3657                
   3658                /* Send Slave Address */
   3659                /* Set NBYTES to write and reload if size > 255 */
   3660                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000E4   0x8D21             LDRH     R1,[R4, #+40]
   \   000000E6   0x29FF             CMP      R1,#+255
   \   000000E8   0xD10D             BNE.N    ??I2C_DMAMemTransmitCplt_8
   \   000000EA   0x8D60             LDRH     R0,[R4, #+42]
   \   000000EC   0x4281             CMP      R1,R0
   \   000000EE   0xD20A             BCS.N    ??I2C_DMAMemTransmitCplt_8
   3661                {
   3662                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x....             LDR.N    R3,??DataTable20  ;; 0xfc009800
   \   000000F4   0x6842             LDR      R2,[R0, #+4]
   \   000000F6   0x401A             ANDS     R2,R3,R2
   \   000000F8   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   000000FC   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000100   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000104   0xE00A             B.N      ??I2C_DMAMemTransmitCplt_9
   3663                }
   3664                else
   3665                {
   3666                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMemTransmitCplt_8: (+1)
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x....             LDR.N    R3,??DataTable20  ;; 0xfc009800
   \   0000010A   0xB2C9             UXTB     R1,R1
   \   0000010C   0x6842             LDR      R2,[R0, #+4]
   \   0000010E   0x401A             ANDS     R2,R3,R2
   \   00000110   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   00000114   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000118   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??I2C_DMAMemTransmitCplt_9: (+1)
   \   0000011C   0x6041             STR      R1,[R0, #+4]
   3667                }  
   3668                
   3669                /* Wait until TXIS flag is set */
   3670                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   0000011E   0x.... 0x....      BL       HAL_GetTick
   \   00000122   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_10: (+1)
   \   00000124   0x6820             LDR      R0,[R4, #+0]
   \   00000126   0x6981             LDR      R1,[R0, #+24]
   \   00000128   0x0789             LSLS     R1,R1,#+30
   \   0000012A   0xD437             BMI.N    ??I2C_DMAMemTransmitCplt_11
   \   0000012C   0x2119             MOVS     R1,#+25
   \   0000012E   0x4620             MOV      R0,R4
   \   00000130   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000134   0xB970             CBNZ.N   R0,??I2C_DMAMemTransmitCplt_12
   \   00000136   0x.... 0x....      BL       HAL_GetTick
   \   0000013A   0x1B40             SUBS     R0,R0,R5
   \   0000013C   0x281A             CMP      R0,#+26
   \   0000013E   0xD3F1             BCC.N    ??I2C_DMAMemTransmitCplt_10
   \   00000140   0x6BA0             LDR      R0,[R4, #+56]
   \   00000142   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000146   0x63A0             STR      R0,[R4, #+56]
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x0034      STRB     R0,[R4, #+52]
   3671                {
   3672                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3673                  /* Wait until STOPF flag is reset */ 
   3674                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??I2C_DMAMemTransmitCplt_12: (+1)
   \   00000154   0x.... 0x....      BL       HAL_GetTick
   \   00000158   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_13: (+1)
   \   0000015A   0x6820             LDR      R0,[R4, #+0]
   \   0000015C   0x6980             LDR      R0,[R0, #+24]
   \   0000015E   0x0680             LSLS     R0,R0,#+26
   \   00000160   0xD423             BMI.N    ??I2C_DMAMemTransmitCplt_14
   \   00000162   0x2119             MOVS     R1,#+25
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000016A   0xB970             CBNZ.N   R0,??I2C_DMAMemTransmitCplt_15
   \   0000016C   0x.... 0x....      BL       HAL_GetTick
   \   00000170   0x1B40             SUBS     R0,R0,R5
   \   00000172   0x281A             CMP      R0,#+26
   \   00000174   0xD3F1             BCC.N    ??I2C_DMAMemTransmitCplt_13
   \   00000176   0x6BA0             LDR      R0,[R4, #+56]
   \   00000178   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000017C   0x63A0             STR      R0,[R4, #+56]
   \   0000017E   0x2001             MOVS     R0,#+1
   \   00000180   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0xF884 0x0034      STRB     R0,[R4, #+52]
   3675                  {
   3676                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMemTransmitCplt_15: (+1)
   \   0000018A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000018C   0x2804             CMP      R0,#+4
   \   0000018E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000190   0xBF0C             ITE      EQ 
   \   00000192   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000196   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3677                    {
   3678                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3679                    }
   3680                    else
   3681                    {
   3682                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000019A   0xE005             B.N      ??I2C_DMAMemTransmitCplt_16
   3683                    }
   3684                  }
   3685                  
   3686                  /* Clear STOP Flag */
   3687                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3688                  
   3689                  /* Clear Configuration Register 2 */
   3690                  I2C_RESET_CR2(hi2c);
   3691                  
   3692                  hi2c->XferCount = 0;
   3693                  
   3694                  hi2c->State = HAL_I2C_STATE_READY;
   3695                  HAL_I2C_ErrorCallback(hi2c);
   3696                }
   3697                else
   3698                {
   3699                  /* Enable DMA Request */
   3700                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??I2C_DMAMemTransmitCplt_11: (+1)
   \   0000019C   0x6801             LDR      R1,[R0, #+0]
   \   0000019E   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000001A2   0x6001             STR      R1,[R0, #+0]
   3701                }
   3702              }
   3703            }
   3704            else
   3705            {
   3706              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3707              /* Wait until STOPF flag is reset */ 
   3708              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   3709              {
   3710                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3711                {
   3712                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3713                }
   3714                else
   3715                {
   3716                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3717                }
   3718              }
   3719              
   3720              /* Clear STOP Flag */
   3721              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3722            	
   3723              /* Clear Configuration Register 2 */
   3724              I2C_RESET_CR2(hi2c);
   3725              
   3726              /* Disable DMA Request */
   3727              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   3728              
   3729              hi2c->XferCount = 0;
   3730              
   3731              hi2c->State = HAL_I2C_STATE_READY;
   3732              
   3733              /* Check if Errors has been detected during transfer */
   3734              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   3735              {
   3736                HAL_I2C_ErrorCallback(hi2c);
   3737              }
   3738              else
   3739              {
   3740                HAL_I2C_MemTxCpltCallback(hi2c);
   3741              }
   3742            }
   3743          }
   \   000001A4   0xB001             ADD      SP,SP,#+4
   \   000001A6   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMemTransmitCplt_16: (+1)
   \   000001A8   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMemTransmitCplt_14: (+1)
   \   000001AA   0x6821             LDR      R1,[R4, #+0]
   \   000001AC   0x2020             MOVS     R0,#+32
   \   000001AE   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   000001B0   0x61C8             STR      R0,[R1, #+28]
   \   000001B2   0x6820             LDR      R0,[R4, #+0]
   \   000001B4   0x6841             LDR      R1,[R0, #+4]
   \   000001B6   0x4011             ANDS     R1,R2,R1
   \   000001B8   0x6041             STR      R1,[R0, #+4]
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0x8560             STRH     R0,[R4, #+42]
   \   000001BE   0x2001             MOVS     R0,#+1
   \   000001C0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001C4   0x4620             MOV      R0,R4
   \   000001C6   0xE039             B.N      ??I2C_DMAMemTransmitCplt_7
   \                     ??I2C_DMAMemTransmitCplt_0: (+1)
   \   000001C8   0x.... 0x....      BL       HAL_GetTick
   \   000001CC   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_17: (+1)
   \   000001CE   0x6820             LDR      R0,[R4, #+0]
   \   000001D0   0x6980             LDR      R0,[R0, #+24]
   \   000001D2   0x0680             LSLS     R0,R0,#+26
   \   000001D4   0xD41C             BMI.N    ??I2C_DMAMemTransmitCplt_18
   \   000001D6   0x2119             MOVS     R1,#+25
   \   000001D8   0x4620             MOV      R0,R4
   \   000001DA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001DE   0xB970             CBNZ.N   R0,??I2C_DMAMemTransmitCplt_19
   \   000001E0   0x.... 0x....      BL       HAL_GetTick
   \   000001E4   0x1B40             SUBS     R0,R0,R5
   \   000001E6   0x281A             CMP      R0,#+26
   \   000001E8   0xD3F1             BCC.N    ??I2C_DMAMemTransmitCplt_17
   \   000001EA   0x6BA0             LDR      R0,[R4, #+56]
   \   000001EC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001F0   0x63A0             STR      R0,[R4, #+56]
   \   000001F2   0x2001             MOVS     R0,#+1
   \   000001F4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??I2C_DMAMemTransmitCplt_19: (+1)
   \   000001FE   0x6BA0             LDR      R0,[R4, #+56]
   \   00000200   0x2804             CMP      R0,#+4
   \   00000202   0x6BA0             LDR      R0,[R4, #+56]
   \   00000204   0xBF0C             ITE      EQ 
   \   00000206   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000020A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   \   0000020E   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMemTransmitCplt_18: (+1)
   \   00000210   0x6821             LDR      R1,[R4, #+0]
   \   00000212   0x2020             MOVS     R0,#+32
   \   00000214   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   00000216   0x61C8             STR      R0,[R1, #+28]
   \   00000218   0x6820             LDR      R0,[R4, #+0]
   \   0000021A   0x6841             LDR      R1,[R0, #+4]
   \   0000021C   0x4011             ANDS     R1,R2,R1
   \   0000021E   0x6041             STR      R1,[R0, #+4]
   \   00000220   0x6820             LDR      R0,[R4, #+0]
   \   00000222   0x6801             LDR      R1,[R0, #+0]
   \   00000224   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000228   0x6001             STR      R1,[R0, #+0]
   \   0000022A   0x2000             MOVS     R0,#+0
   \   0000022C   0x8560             STRH     R0,[R4, #+42]
   \   0000022E   0x2001             MOVS     R0,#+1
   \   00000230   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000234   0x6BA0             LDR      R0,[R4, #+56]
   \   00000236   0x2800             CMP      R0,#+0
   \   00000238   0x4620             MOV      R0,R4
   \   0000023A   0xD003             BEQ.N    ??I2C_DMAMemTransmitCplt_20
   \                     ??I2C_DMAMemTransmitCplt_7: (+1)
   \   0000023C   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000240   0xB001             ADD      SP,SP,#+4
   \   00000242   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMemTransmitCplt_20: (+1)
   \   00000244   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   00000248   0xB001             ADD      SP,SP,#+4
   \   0000024A   0xBD30             POP      {R4,R5,PC}       ;; return
   3744          
   3745          /**
   3746            * @brief  DMA I2C Memory Read process complete callback
   3747            * @param  hdma: DMA handle
   3748            * @retval None
   3749            */

   \                                 In section .text, align 2, keep-with-next
   3750          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma)   
   3751          {  
   \                     I2C_DMAMemReceiveCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3752            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3753            uint16_t DevAddress;
   3754            
   3755            /* Check if last DMA request was done with RELOAD */
   3756            /* Set NBYTES to write and reload if size > 255 */
   3757            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x80D9      BNE.W    ??I2C_DMAMemReceiveCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x80D5      BCS.W    ??I2C_DMAMemReceiveCplt_0
   3758            {
   3759              /* Wait until TCR flag is set */
   3760              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMemReceiveCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMemReceiveCplt_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   3761              {
   3762                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   3763              }
   3764              
   3765              /* Disable DMA Request */
   3766              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMAMemReceiveCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   3767              
   3768              /* Check if Errors has been detected during transfer */
   3769              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0xB390             CBZ.N    R0,??I2C_DMAMemReceiveCplt_3
   3770              {
   3771                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3772                /* Wait until STOPF flag is reset */ 
   3773                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6980             LDR      R0,[R0, #+24]
   \   0000005A   0x0680             LSLS     R0,R0,#+26
   \   0000005C   0xD41C             BMI.N    ??I2C_DMAMemReceiveCplt_5
   \   0000005E   0x2119             MOVS     R1,#+25
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000066   0xB970             CBNZ.N   R0,??I2C_DMAMemReceiveCplt_6
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1B40             SUBS     R0,R0,R5
   \   0000006E   0x281A             CMP      R0,#+26
   \   00000070   0xD3F1             BCC.N    ??I2C_DMAMemReceiveCplt_4
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   3774                {
   3775                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMemReceiveCplt_6: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000092   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3776                  {
   3777                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3778                  }
   3779                  else
   3780                  {
   3781                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000096   0x63A0             STR      R0,[R4, #+56]
   3782                  }
   3783                }
   3784                
   3785                /* Clear STOP Flag */
   3786                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemReceiveCplt_5: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x2020             MOVS     R0,#+32
   3787                
   3788                /* Clear Configuration Register 2 */
   3789                I2C_RESET_CR2(hi2c);
   \   0000009C   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   0000009E   0x61C8             STR      R0,[R1, #+28]
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6841             LDR      R1,[R0, #+4]
   \   000000A4   0x4011             ANDS     R1,R2,R1
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   3790                
   3791                hi2c->XferCount = 0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x8560             STRH     R0,[R4, #+42]
   3792                
   3793                hi2c->State = HAL_I2C_STATE_READY;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xF884 0x0035      STRB     R0,[R4, #+53]
   3794                HAL_I2C_ErrorCallback(hi2c);
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0xE0BE             B.N      ??I2C_DMAMemReceiveCplt_7
   3795              }
   3796              else
   3797              {
   3798                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMemReceiveCplt_3: (+1)
   \   000000B6   0x8D20             LDRH     R0,[R4, #+40]
   \   000000B8   0x6A61             LDR      R1,[R4, #+36]
   \   000000BA   0x1842             ADDS     R2,R0,R1
   \   000000BC   0x6262             STR      R2,[R4, #+36]
   3799                hi2c->XferCount -= hi2c->XferSize;
   \   000000BE   0x8D61             LDRH     R1,[R4, #+42]
   \   000000C0   0x1A08             SUBS     R0,R1,R0
   \   000000C2   0x8560             STRH     R0,[R4, #+42]
   3800                if(hi2c->XferCount > 255)
   \   000000C4   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C6   0x28FF             CMP      R0,#+255
   \   000000C8   0xBFCC             ITE      GT 
   \   000000CA   0x20FF             MOVGT    R0,#+255
   \   000000CC   0x8D60             LDRHLE   R0,[R4, #+42]
   3801                {
   3802                  hi2c->XferSize = 255;
   3803                }
   3804                else
   3805                {
   3806                  hi2c->XferSize = hi2c->XferCount;
   \   000000CE   0x8520             STRH     R0,[R4, #+40]
   3807                }
   3808                
   3809                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6841             LDR      R1,[R0, #+4]
   3810                
   3811                /* Enable the DMA channel */
   3812                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000D4   0x8D23             LDRH     R3,[R4, #+40]
   \   000000D6   0x058D             LSLS     R5,R1,#+22
   \   000000D8   0xF100 0x0124      ADD      R1,R0,#+36
   \   000000DC   0x6B20             LDR      R0,[R4, #+48]
   \   000000DE   0x.... 0x....      BL       HAL_DMA_Start_IT
   3813                
   3814                /* Send Slave Address */
   3815                /* Set NBYTES to write and reload if size > 255 */
   3816                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000E2   0x8D21             LDRH     R1,[R4, #+40]
   \   000000E4   0x29FF             CMP      R1,#+255
   \   000000E6   0xD10D             BNE.N    ??I2C_DMAMemReceiveCplt_8
   \   000000E8   0x8D60             LDRH     R0,[R4, #+42]
   \   000000EA   0x4281             CMP      R1,R0
   \   000000EC   0xD20A             BCS.N    ??I2C_DMAMemReceiveCplt_8
   3817                {
   3818                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x....             LDR.N    R3,??DataTable22  ;; 0xfc009800
   \   000000F2   0x6842             LDR      R2,[R0, #+4]
   \   000000F4   0x401A             ANDS     R2,R3,R2
   \   000000F6   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   000000FA   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   000000FE   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000102   0xE00A             B.N      ??I2C_DMAMemReceiveCplt_9
   3819                }
   3820                else
   3821                {
   3822                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMemReceiveCplt_8: (+1)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x....             LDR.N    R3,??DataTable22  ;; 0xfc009800
   \   00000108   0xB2C9             UXTB     R1,R1
   \   0000010A   0x6842             LDR      R2,[R0, #+4]
   \   0000010C   0x401A             ANDS     R2,R3,R2
   \   0000010E   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   00000112   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000116   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??I2C_DMAMemReceiveCplt_9: (+1)
   \   0000011A   0x6041             STR      R1,[R0, #+4]
   3823                }  
   3824                
   3825                /* Wait until RXNE flag is set */
   3826                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   0000011C   0x.... 0x....      BL       HAL_GetTick
   \   00000120   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_10: (+1)
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6980             LDR      R0,[R0, #+24]
   \   00000126   0x0740             LSLS     R0,R0,#+29
   \   00000128   0xD40E             BMI.N    ??I2C_DMAMemReceiveCplt_11
   \   0000012A   0x.... 0x....      BL       HAL_GetTick
   \   0000012E   0x1B40             SUBS     R0,R0,R5
   \   00000130   0x281A             CMP      R0,#+26
   \   00000132   0xD3F6             BCC.N    ??I2C_DMAMemReceiveCplt_10
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xF884 0x0034      STRB     R0,[R4, #+52]
   3827                {
   3828                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000140   0x6BA0             LDR      R0,[R4, #+56]
   \   00000142   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000146   0x63A0             STR      R0,[R4, #+56]
   3829                }
   3830                
   3831                /* Check if Errors has been detected during transfer */
   3832                if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??I2C_DMAMemReceiveCplt_11: (+1)
   \   00000148   0x6BA0             LDR      R0,[R4, #+56]
   \   0000014A   0xB390             CBZ.N    R0,??I2C_DMAMemReceiveCplt_12
   3833                {
   3834                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3835                  /* Wait until STOPF flag is reset */ 
   3836                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   0000014C   0x.... 0x....      BL       HAL_GetTick
   \   00000150   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_13: (+1)
   \   00000152   0x6820             LDR      R0,[R4, #+0]
   \   00000154   0x6980             LDR      R0,[R0, #+24]
   \   00000156   0x0680             LSLS     R0,R0,#+26
   \   00000158   0xD41C             BMI.N    ??I2C_DMAMemReceiveCplt_14
   \   0000015A   0x2119             MOVS     R1,#+25
   \   0000015C   0x4620             MOV      R0,R4
   \   0000015E   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000162   0xB970             CBNZ.N   R0,??I2C_DMAMemReceiveCplt_15
   \   00000164   0x.... 0x....      BL       HAL_GetTick
   \   00000168   0x1B40             SUBS     R0,R0,R5
   \   0000016A   0x281A             CMP      R0,#+26
   \   0000016C   0xD3F1             BCC.N    ??I2C_DMAMemReceiveCplt_13
   \   0000016E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000170   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000174   0x63A0             STR      R0,[R4, #+56]
   \   00000176   0x2001             MOVS     R0,#+1
   \   00000178   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0xF884 0x0034      STRB     R0,[R4, #+52]
   3837                  {
   3838                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMemReceiveCplt_15: (+1)
   \   00000182   0x6BA0             LDR      R0,[R4, #+56]
   \   00000184   0x2804             CMP      R0,#+4
   \   00000186   0x6BA0             LDR      R0,[R4, #+56]
   \   00000188   0xBF0C             ITE      EQ 
   \   0000018A   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000018E   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3839                    {
   3840                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3841                    }
   3842                    else
   3843                    {
   3844                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000192   0x63A0             STR      R0,[R4, #+56]
   3845                    }
   3846                  }
   3847                  
   3848                  /* Clear STOP Flag */
   3849                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemReceiveCplt_14: (+1)
   \   00000194   0x6821             LDR      R1,[R4, #+0]
   \   00000196   0x2020             MOVS     R0,#+32
   3850                  
   3851                  /* Clear Configuration Register 2 */
   3852                  I2C_RESET_CR2(hi2c);
   \   00000198   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   0000019A   0x61C8             STR      R0,[R1, #+28]
   \   0000019C   0x6820             LDR      R0,[R4, #+0]
   \   0000019E   0x6841             LDR      R1,[R0, #+4]
   \   000001A0   0x4011             ANDS     R1,R2,R1
   \   000001A2   0x6041             STR      R1,[R0, #+4]
   3853                  
   3854                  hi2c->XferCount = 0;
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0x8560             STRH     R0,[R4, #+42]
   3855                  
   3856                  hi2c->State = HAL_I2C_STATE_READY;
   \   000001A8   0x2001             MOVS     R0,#+1
   \   000001AA   0xF884 0x0035      STRB     R0,[R4, #+53]
   3857                  HAL_I2C_ErrorCallback(hi2c);
   \   000001AE   0x4620             MOV      R0,R4
   \   000001B0   0xE040             B.N      ??I2C_DMAMemReceiveCplt_7
   3858                }
   3859                else
   3860                {
   3861                  /* Enable DMA Request */
   3862                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??I2C_DMAMemReceiveCplt_12: (+1)
   \   000001B2   0x6820             LDR      R0,[R4, #+0]
   \   000001B4   0x6801             LDR      R1,[R0, #+0]
   \   000001B6   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001BA   0x6001             STR      R1,[R0, #+0]
   3863                }
   3864              }
   3865            }
   3866            else
   3867            {
   3868              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3869              /* Wait until STOPF flag is reset */ 
   3870              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   3871              {
   3872                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3873                {
   3874                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3875                }
   3876                else
   3877                {
   3878                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3879                }
   3880              }
   3881              
   3882              /* Clear STOP Flag */
   3883              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3884            	
   3885              /* Clear Configuration Register 2 */
   3886              I2C_RESET_CR2(hi2c);
   3887              
   3888              /* Disable DMA Request */
   3889              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   3890              
   3891              hi2c->XferCount = 0;
   3892              
   3893              hi2c->State = HAL_I2C_STATE_READY;
   3894              
   3895              /* Check if Errors has been detected during transfer */
   3896              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   3897              {
   3898                HAL_I2C_ErrorCallback(hi2c);
   3899              }
   3900              else
   3901              {
   3902                HAL_I2C_MemRxCpltCallback(hi2c);
   3903              }
   3904            }
   3905          }
   \   000001BC   0xB001             ADD      SP,SP,#+4
   \   000001BE   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMemReceiveCplt_0: (+1)
   \   000001C0   0x.... 0x....      BL       HAL_GetTick
   \   000001C4   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_16: (+1)
   \   000001C6   0x6820             LDR      R0,[R4, #+0]
   \   000001C8   0x6980             LDR      R0,[R0, #+24]
   \   000001CA   0x0680             LSLS     R0,R0,#+26
   \   000001CC   0xD41C             BMI.N    ??I2C_DMAMemReceiveCplt_17
   \   000001CE   0x2119             MOVS     R1,#+25
   \   000001D0   0x4620             MOV      R0,R4
   \   000001D2   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001D6   0xB970             CBNZ.N   R0,??I2C_DMAMemReceiveCplt_18
   \   000001D8   0x.... 0x....      BL       HAL_GetTick
   \   000001DC   0x1B40             SUBS     R0,R0,R5
   \   000001DE   0x281A             CMP      R0,#+26
   \   000001E0   0xD3F1             BCC.N    ??I2C_DMAMemReceiveCplt_16
   \   000001E2   0x6BA0             LDR      R0,[R4, #+56]
   \   000001E4   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001E8   0x63A0             STR      R0,[R4, #+56]
   \   000001EA   0x2001             MOVS     R0,#+1
   \   000001EC   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??I2C_DMAMemReceiveCplt_18: (+1)
   \   000001F6   0x6BA0             LDR      R0,[R4, #+56]
   \   000001F8   0x2804             CMP      R0,#+4
   \   000001FA   0x6BA0             LDR      R0,[R4, #+56]
   \   000001FC   0xBF0C             ITE      EQ 
   \   000001FE   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000202   0xF040 0x0020      ORRNE    R0,R0,#0x20
   \   00000206   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMemReceiveCplt_17: (+1)
   \   00000208   0x6821             LDR      R1,[R4, #+0]
   \   0000020A   0x2020             MOVS     R0,#+32
   \   0000020C   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   0000020E   0x61C8             STR      R0,[R1, #+28]
   \   00000210   0x6820             LDR      R0,[R4, #+0]
   \   00000212   0x6841             LDR      R1,[R0, #+4]
   \   00000214   0x4011             ANDS     R1,R2,R1
   \   00000216   0x6041             STR      R1,[R0, #+4]
   \   00000218   0x6820             LDR      R0,[R4, #+0]
   \   0000021A   0x6801             LDR      R1,[R0, #+0]
   \   0000021C   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000220   0x6001             STR      R1,[R0, #+0]
   \   00000222   0x2000             MOVS     R0,#+0
   \   00000224   0x8560             STRH     R0,[R4, #+42]
   \   00000226   0x2001             MOVS     R0,#+1
   \   00000228   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000022C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000022E   0x2800             CMP      R0,#+0
   \   00000230   0x4620             MOV      R0,R4
   \   00000232   0xD003             BEQ.N    ??I2C_DMAMemReceiveCplt_19
   \                     ??I2C_DMAMemReceiveCplt_7: (+1)
   \   00000234   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000238   0xB001             ADD      SP,SP,#+4
   \   0000023A   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMemReceiveCplt_19: (+1)
   \   0000023C   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   00000240   0xB001             ADD      SP,SP,#+4
   \   00000242   0xBD30             POP      {R4,R5,PC}       ;; return
   3906          
   3907          /**
   3908            * @brief  DMA I2C communication error callback. 
   3909            * @param hdma : DMA handle
   3910            * @retval None
   3911            */

   \                                 In section .text, align 2, keep-with-next
   3912          static void I2C_DMAError(DMA_HandleTypeDef *hdma)   
   3913          {
   \                     I2C_DMAError: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3914            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   3915            
   3916            /* Disable Acknowledge */
   3917            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   0000000E   0x604A             STR      R2,[R1, #+4]
   3918            
   3919            hi2c->XferCount = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8541             STRH     R1,[R0, #+42]
   3920            
   3921            hi2c->State = HAL_I2C_STATE_READY;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF880 0x1035      STRB     R1,[R0, #+53]
   3922            
   3923            hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \   0000001A   0x6B81             LDR      R1,[R0, #+56]
   \   0000001C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000020   0x6381             STR      R1,[R0, #+56]
   3924            
   3925            HAL_I2C_ErrorCallback(hi2c);
   \   00000022   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3926          }
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0xBD00             POP      {PC}             ;; return
   3927          
   3928          /**
   3929            * @brief  This function handles I2C Communication Timeout.
   3930            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3931            *                the configuration information for the specified I2C.
   3932            * @param  Flag: specifies the I2C flag to check.
   3933            * @param  Status: The new Flag status (SET or RESET).
   3934            * @param  Timeout: Timeout duration
   3935            * @retval HAL status
   3936            */
   3937          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
   3938          {  
   3939            uint32_t tickstart = HAL_GetTick();
   3940            
   3941            /* Wait until flag is set */
   3942            if(Status == RESET)
   3943            {    
   3944              while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   3945              {
   3946                /* Check for the Timeout */
   3947                if(Timeout != HAL_MAX_DELAY)
   3948                {
   3949                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   3950                  {
   3951                    hi2c->State= HAL_I2C_STATE_READY;
   3952                    /* Process Unlocked */
   3953                    __HAL_UNLOCK(hi2c);
   3954                    return HAL_TIMEOUT;
   3955                  }
   3956                }
   3957              }
   3958            }
   3959            else
   3960            {
   3961              while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
   3962              {
   3963                /* Check for the Timeout */
   3964                if(Timeout != HAL_MAX_DELAY)
   3965                {
   3966                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   3967                  {
   3968                    hi2c->State= HAL_I2C_STATE_READY;
   3969                    /* Process Unlocked */
   3970                    __HAL_UNLOCK(hi2c);
   3971                    return HAL_TIMEOUT;
   3972                  }
   3973                }
   3974              }
   3975            }
   3976            return HAL_OK;
   3977          }
   3978          
   3979          /**
   3980            * @brief  This function handles I2C Communication Timeout for specific usage of TXIS flag.
   3981            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3982            *                the configuration information for the specified I2C.
   3983            * @param  Timeout: Timeout duration
   3984            * @retval HAL status
   3985            */
   3986          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
   3987          {  
   3988            uint32_t tickstart = HAL_GetTick();
   3989            
   3990            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
   3991            {
   3992              /* Check if a NACK is detected */
   3993              if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
   3994              {
   3995                return HAL_ERROR;
   3996              }
   3997              
   3998              /* Check for the Timeout */
   3999              if(Timeout != HAL_MAX_DELAY)
   4000              {
   4001                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   4002                {
   4003                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   4004                  hi2c->State= HAL_I2C_STATE_READY;
   4005                  
   4006                  /* Process Unlocked */
   4007                  __HAL_UNLOCK(hi2c);
   4008                  
   4009                  return HAL_TIMEOUT;
   4010                }
   4011              }
   4012            }
   4013            return HAL_OK;      
   4014          }
   4015          
   4016          /**
   4017            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   4018            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   4019            *                the configuration information for the specified I2C.
   4020            * @param  Timeout: Timeout duration
   4021            * @retval HAL status
   4022            */
   4023          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   4024          {  
   4025            uint32_t tickstart = 0x00;
   4026            tickstart = HAL_GetTick();
   4027            
   4028            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   4029            {
   4030              /* Check if a NACK is detected */
   4031              if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
   4032              {
   4033                return HAL_ERROR;
   4034              }
   4035              
   4036              /* Check for the Timeout */
   4037              if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   4038              {
   4039                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   4040                hi2c->State= HAL_I2C_STATE_READY;
   4041                
   4042                /* Process Unlocked */
   4043                __HAL_UNLOCK(hi2c);
   4044                
   4045                return HAL_TIMEOUT;
   4046              }
   4047            }
   4048            return HAL_OK;
   4049          }
   4050          
   4051          /**
   4052            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   4053            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   4054            *                the configuration information for the specified I2C.
   4055            * @param  Timeout: Timeout duration
   4056            * @retval HAL status
   4057            */
   4058          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   4059          {  
   4060            uint32_t tickstart = 0x00;
   4061            tickstart = HAL_GetTick();
   4062            
   4063            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   4064            {
   4065              /* Check if a NACK is detected */
   4066              if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
   4067              {
   4068                return HAL_ERROR;
   4069              }
   4070              
   4071              /* Check if a STOPF is detected */
   4072              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   4073              {
   4074                /* Clear STOP Flag */
   4075                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   4076                
   4077                /* Clear Configuration Register 2 */
   4078                I2C_RESET_CR2(hi2c);
   4079                
   4080                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   4081                hi2c->State= HAL_I2C_STATE_READY;
   4082                
   4083                /* Process Unlocked */
   4084                __HAL_UNLOCK(hi2c);
   4085                
   4086                return HAL_ERROR;
   4087              }
   4088              
   4089              /* Check for the Timeout */
   4090              if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   4091              {
   4092                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   4093                hi2c->State= HAL_I2C_STATE_READY;
   4094                
   4095                /* Process Unlocked */
   4096                __HAL_UNLOCK(hi2c);
   4097                
   4098                return HAL_TIMEOUT;
   4099              }
   4100            }
   4101            return HAL_OK;
   4102          }
   4103          
   4104          /**
   4105            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   4106            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   4107            *                the configuration information for the specified I2C.
   4108            * @param  Timeout: Timeout duration
   4109            * @retval HAL status
   4110            */

   \                                 In section .text, align 2, keep-with-next
   4111          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   4112          {
   \                     I2C_IsAcknowledgeFailed: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   4113            uint32_t tickstart = 0x00;
   4114            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   4115            
   4116            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x06C0             LSLS     R0,R0,#+27
   \   00000012   0xD52E             BPL.N    ??I2C_IsAcknowledgeFailed_0
   4117            {
   4118              /* Wait until STOP Flag is reset */
   4119              /* AutoEnd should be initiate after AF */
   4120              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_IsAcknowledgeFailed_1: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6981             LDR      R1,[R0, #+24]
   \   00000018   0x0689             LSLS     R1,R1,#+26
   \   0000001A   0xD410             BMI.N    ??I2C_IsAcknowledgeFailed_2
   4121              {
   4122                /* Check for the Timeout */
   4123                if(Timeout != HAL_MAX_DELAY)
   \   0000001C   0xF115 0x0F01      CMN      R5,#+1
   \   00000020   0xD0F8             BEQ.N    ??I2C_IsAcknowledgeFailed_1
   4124                {
   4125                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000022   0xB125             CBZ.N    R5,??I2C_IsAcknowledgeFailed_3
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B80             SUBS     R0,R0,R6
   \   0000002A   0x4285             CMP      R5,R0
   \   0000002C   0xD2F2             BCS.N    ??I2C_IsAcknowledgeFailed_1
   4126                  {
   4127                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_IsAcknowledgeFailed_3: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   4128                    /* Process Unlocked */
   4129                    __HAL_UNLOCK(hi2c);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   4130                    return HAL_TIMEOUT;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0xBD70             POP      {R4-R6,PC}
   4131                  }
   4132                }
   4133              }
   4134              
   4135              /* Clear NACKF Flag */
   4136              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_IsAcknowledgeFailed_2: (+1)
   \   0000003E   0x2110             MOVS     R1,#+16
   4137              
   4138              /* Clear STOP Flag */
   4139              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   4140              
   4141              /* Flush TX register if not empty */
   4142              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   4143              {
   4144                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
   4145              }
   4146              
   4147              /* Clear Configuration Register 2 */
   4148              I2C_RESET_CR2(hi2c);
   \   00000040   0x....             LDR.N    R2,??DataTable22_1  ;; 0xfe00e800
   \   00000042   0x61C1             STR      R1,[R0, #+28]
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x2020             MOVS     R0,#+32
   \   00000048   0x61C8             STR      R0,[R1, #+28]
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6981             LDR      R1,[R0, #+24]
   \   0000004E   0x07C9             LSLS     R1,R1,#+31
   \   00000050   0xBF5C             ITT      PL 
   \   00000052   0x2101             MOVPL    R1,#+1
   \   00000054   0x61C1             STRPL    R1,[R0, #+28]
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6841             LDR      R1,[R0, #+4]
   \   0000005A   0x4011             ANDS     R1,R2,R1
   \   0000005C   0x6041             STR      R1,[R0, #+4]
   4149              
   4150              hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   0000005E   0x2004             MOVS     R0,#+4
   \   00000060   0x63A0             STR      R0,[R4, #+56]
   4151              hi2c->State= HAL_I2C_STATE_READY;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF884 0x0035      STRB     R0,[R4, #+53]
   4152              
   4153              /* Process Unlocked */
   4154              __HAL_UNLOCK(hi2c);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF884 0x0034      STRB     R0,[R4, #+52]
   4155              
   4156              return HAL_ERROR;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xBD70             POP      {R4-R6,PC}
   4157            }
   4158            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xBD70             POP      {R4-R6,PC}       ;; return
   4159          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0xFE00E800         DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     I2C_DMAMasterTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     I2C_DMAMasterReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     I2C_DMASlaveTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     I2C_DMASlaveReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xFE00E800         DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     I2C_DMAMemTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     I2C_DMAMemReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x02002000         DC32     0x2002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0xFE00E800         DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0xFE00E800         DC32     0xfe00e800
   4160          
   4161          /**
   4162            * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
   4163            * @param  hi2c: I2C handle.
   4164            * @param  DevAddress: specifies the slave address to be programmed.
   4165            * @param  Size: specifies the number of bytes to be programmed.
   4166            *   This parameter must be a value between 0 and 255.
   4167            * @param  Mode: new state of the I2C START condition generation.
   4168            *   This parameter can be one of the following values:
   4169            *     @arg I2C_RELOAD_MODE: Enable Reload mode .
   4170            *     @arg I2C_AUTOEND_MODE: Enable Automatic end mode.
   4171            *     @arg I2C_SOFTEND_MODE: Enable Software end mode.
   4172            * @param  Request: new state of the I2C START condition generation.
   4173            *   This parameter can be one of the following values:
   4174            *     @arg I2C_NO_STARTSTOP: Don't Generate stop and start condition.
   4175            *     @arg I2C_GENERATE_STOP: Generate stop condition (Size should be set to 0).
   4176            *     @arg I2C_GENERATE_START_READ: Generate Restart for read request.
   4177            *     @arg I2C_GENERATE_START_WRITE: Generate Restart for write request.
   4178            * @retval None
   4179            */
   4180          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
   4181          {
   4182            uint32_t tmpreg = 0;
   4183            
   4184            /* Check the parameters */
   4185            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
   4186            assert_param(IS_TRANSFER_MODE(Mode));
   4187            assert_param(IS_TRANSFER_REQUEST(Request));
   4188            
   4189            /* Get the CR2 register value */
   4190            tmpreg = hi2c->Instance->CR2;
   4191            
   4192            /* clear tmpreg specific bits */
   4193            tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
   4194            
   4195            /* update tmpreg */
   4196            tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
   4197              (uint32_t)Mode | (uint32_t)Request);
   4198            
   4199            /* update CR2 register */
   4200            hi2c->Instance->CR2 = tmpreg;  
   4201          }  
   4202          
   4203          /**
   4204            * @}
   4205            */
   4206          
   4207          /**
   4208            * @}
   4209            */
   4210          
   4211          #endif /* HAL_I2C_MODULE_ENABLED */
   4212          /**
   4213            * @}
   4214            */
   4215          
   4216          /**
   4217            * @}
   4218            */
   4219          
   4220          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_I2C_DeInit
         8   -> HAL_I2C_MspDeInit
       8   HAL_I2C_ER_IRQHandler
         8   -> HAL_I2C_ErrorCallback
       8   HAL_I2C_EV_IRQHandler
         0   -> I2C_MasterReceive_ISR
         8   -> I2C_MasterTransmit_ISR
         8   -> I2C_SlaveReceive_ISR
         8   -> I2C_SlaveTransmit_ISR
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetState
       8   HAL_I2C_Init
         8   -> HAL_I2C_MspInit
      32   HAL_I2C_IsDeviceReady
        32   -> HAL_GetTick
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
      40   HAL_I2C_Master_Receive
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
      16   HAL_I2C_Master_Receive_DMA
        16   -> HAL_DMA_Abort
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
       8   HAL_I2C_Master_Receive_IT
      40   HAL_I2C_Master_Transmit
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
      16   HAL_I2C_Master_Transmit_DMA
        16   -> HAL_DMA_Abort
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
       8   HAL_I2C_Master_Transmit_IT
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      40   HAL_I2C_Mem_Read
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
      32   HAL_I2C_Mem_Read_DMA
        32   -> HAL_DMA_Start_IT
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
      32   HAL_I2C_Mem_Read_IT
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
      40   HAL_I2C_Mem_Write
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
      32   HAL_I2C_Mem_Write_DMA
        32   -> HAL_DMA_Start_IT
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
      32   HAL_I2C_Mem_Write_IT
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      24   HAL_I2C_Slave_Receive
        24   -> HAL_GetTick
        24   -> I2C_IsAcknowledgeFailed
      16   HAL_I2C_Slave_Receive_DMA
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
       0   HAL_I2C_Slave_Receive_IT
      24   HAL_I2C_Slave_Transmit
        24   -> HAL_GetTick
        24   -> I2C_IsAcknowledgeFailed
      16   HAL_I2C_Slave_Transmit_DMA
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
       0   HAL_I2C_Slave_Transmit_IT
       8   I2C_DMAError
         8   -> HAL_I2C_ErrorCallback
      16   I2C_DMAMasterReceiveCplt
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterRxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMAMasterTransmitCplt
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterTxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMAMemReceiveCplt
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MemRxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMAMemTransmitCplt
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MemTxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMASlaveReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveRxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMASlaveTransmitCplt
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveTxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_IsAcknowledgeFailed
        16   -> HAL_GetTick
      16   I2C_MasterReceive_ISR
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterRxCpltCallback
        16   -> HAL_I2C_MemRxCpltCallback
      16   I2C_MasterTransmit_ISR
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterTxCpltCallback
        16   -> HAL_I2C_MemTxCpltCallback
       8   I2C_SlaveReceive_ISR
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_SlaveRxCpltCallback
       8   I2C_SlaveTransmit_ISR
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_SlaveTxCpltCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
      46  HAL_I2C_DeInit
     106  HAL_I2C_ER_IRQHandler
     254  HAL_I2C_EV_IRQHandler
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetState
     162  HAL_I2C_Init
     342  HAL_I2C_IsDeviceReady
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
     476  HAL_I2C_Master_Receive
     294  HAL_I2C_Master_Receive_DMA
     160  HAL_I2C_Master_Receive_IT
     466  HAL_I2C_Master_Transmit
     276  HAL_I2C_Master_Transmit_DMA
     160  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     700  HAL_I2C_Mem_Read
     456  HAL_I2C_Mem_Read_DMA
     398  HAL_I2C_Mem_Read_IT
     694  HAL_I2C_Mem_Write
     510  HAL_I2C_Mem_Write_DMA
     402  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     452  HAL_I2C_Slave_Receive
     196  HAL_I2C_Slave_Receive_DMA
      88  HAL_I2C_Slave_Receive_IT
     536  HAL_I2C_Slave_Transmit
     230  HAL_I2C_Slave_Transmit_DMA
      88  HAL_I2C_Slave_Transmit_IT
      42  I2C_DMAError
     590  I2C_DMAMasterReceiveCplt
     596  I2C_DMAMasterTransmitCplt
     580  I2C_DMAMemReceiveCplt
     588  I2C_DMAMemTransmitCplt
     182  I2C_DMASlaveReceiveCplt
     170  I2C_DMASlaveTransmitCplt
     118  I2C_IsAcknowledgeFailed
     340  I2C_MasterReceive_ISR
     352  I2C_MasterTransmit_ISR
     172  I2C_SlaveReceive_ISR
     192  I2C_SlaveTransmit_ISR

 
 11 522 bytes in section .text
 
 11 522 bytes of CODE memory

Errors: none
Warnings: none
