###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       30/Mar/2016  19:08:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_i2c.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_i2c.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.0.1
      6            * @date    25-June-2015
      7            * @brief   I2C HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral State and Errors functions
     13            *         
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19              The I2C HAL driver can be used as follows:
     20              
     21              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     22                  I2C_HandleTypeDef  hi2c; 
     23          
     24              (#)Initialize the I2C low level resources by implement the HAL_I2C_MspInit ()API:
     25                  (##) Enable the I2Cx interface clock
     26                  (##) I2C pins configuration
     27                      (+++) Enable the clock for the I2C GPIOs
     28                      (+++) Configure I2C pins as alternate function open-drain
     29                  (##) NVIC configuration if you need to use interrupt process
     30                      (+++) Configure the I2Cx interrupt priority
     31                      (+++) Enable the NVIC I2C IRQ Channel
     32                  (##) DMA Configuration if you need to use DMA process
     33                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     34                      (+++) Enable the DMAx interface clock using
     35                      (+++) Configure the DMA handle parameters
     36                      (+++) Configure the DMA Tx or Rx Stream
     37                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     38                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream
     39          
     40              (#) Configure the Communication Clock Timing, Own Address1, Master Addressing Mode, Dual Addressing mode,
     41                  Own Address2, Own Address2 Mask, General call and Nostretch mode in the hi2c Init structure.
     42          
     43              (#) Initialize the I2C registers by calling the HAL_I2C_Init(), configures also the low level Hardware 
     44                  (GPIO, CLOCK, NVIC...etc) by calling the customed HAL_I2C_MspInit(&hi2c) API.
     45          
     46              (#) To check if target device is ready for communication, use the function HAL_I2C_IsDeviceReady()
     47          
     48              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     49          
     50              *** Polling mode IO operation ***
     51              =================================
     52              [..]
     53                (+) Transmit in master mode an amount of data in blocking mode using HAL_I2C_Master_Transmit()
     54                (+) Receive in master mode an amount of data in blocking mode using HAL_I2C_Master_Receive()
     55                (+) Transmit in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Transmit()
     56                (+) Receive in slave mode an amount of data in blocking mode using HAL_I2C_Slave_Receive()
     57          
     58              *** Polling mode IO MEM operation ***
     59              =====================================
     60              [..]
     61                (+) Write an amount of data in blocking mode to a specific memory address using HAL_I2C_Mem_Write()
     62                (+) Read an amount of data in blocking mode from a specific memory address using HAL_I2C_Mem_Read()
     63          
     64          
     65              *** Interrupt mode IO operation ***
     66              ===================================
     67              [..]
     68                (+) Transmit in master mode an amount of data in non blocking mode using HAL_I2C_Master_Transmit_IT()
     69                (+) At transmission end of transfer HAL_I2C_MasterTxCpltCallback is executed and user can
     70                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback
     71                (+) Receive in master mode an amount of data in non blocking mode using HAL_I2C_Master_Receive_IT()
     72                (+) At reception end of transfer HAL_I2C_MasterRxCpltCallback is executed and user can
     73                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback
     74                (+) Transmit in slave mode an amount of data in non blocking mode using HAL_I2C_Slave_Transmit_IT()
     75                (+) At transmission end of transfer HAL_I2C_SlaveTxCpltCallback is executed and user can
     76                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback
     77                (+) Receive in slave mode an amount of data in non blocking mode using HAL_I2C_Slave_Receive_IT()
     78                (+) At reception end of transfer HAL_I2C_SlaveRxCpltCallback is executed and user can
     79                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback
     80                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     81                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
     82          
     83              *** Interrupt mode IO MEM operation ***
     84              =======================================
     85              [..]
     86                (+) Write an amount of data in no-blocking mode with Interrupt to a specific memory address using
     87                    HAL_I2C_Mem_Write_IT()
     88                (+) At MEM end of write transfer HAL_I2C_MemTxCpltCallback is executed and user can
     89                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback
     90                (+) Read an amount of data in no-blocking mode with Interrupt from a specific memory address using
     91                    HAL_I2C_Mem_Read_IT()
     92                (+) At MEM end of read transfer HAL_I2C_MemRxCpltCallback is executed and user can
     93                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback
     94                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
     95                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
     96          
     97              *** DMA mode IO operation ***
     98              ==============================
     99              [..]
    100                (+) Transmit in master mode an amount of data in non blocking mode (DMA) using
    101                    HAL_I2C_Master_Transmit_DMA()
    102                (+) At transmission end of transfer HAL_I2C_MasterTxCpltCallback is executed and user can
    103                     add his own code by customization of function pointer HAL_I2C_MasterTxCpltCallback
    104                (+) Receive in master mode an amount of data in non blocking mode (DMA) using
    105                    HAL_I2C_Master_Receive_DMA()
    106                (+) At reception end of transfer HAL_I2C_MasterRxCpltCallback is executed and user can
    107                     add his own code by customization of function pointer HAL_I2C_MasterRxCpltCallback
    108                (+) Transmit in slave mode an amount of data in non blocking mode (DMA) using
    109                    HAL_I2C_Slave_Transmit_DMA()
    110                (+) At transmission end of transfer HAL_I2C_SlaveTxCpltCallback is executed and user can
    111                     add his own code by customization of function pointer HAL_I2C_SlaveTxCpltCallback
    112                (+) Receive in slave mode an amount of data in non blocking mode (DMA) using
    113                    HAL_I2C_Slave_Receive_DMA()
    114                (+) At reception end of transfer HAL_I2C_SlaveRxCpltCallback is executed and user can
    115                     add his own code by customization of function pointer HAL_I2C_SlaveRxCpltCallback
    116                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    117                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    118          
    119              *** DMA mode IO MEM operation ***
    120              =================================
    121              [..]
    122                (+) Write an amount of data in no-blocking mode with DMA to a specific memory address using
    123                    HAL_I2C_Mem_Write_DMA()
    124                (+) At MEM end of write transfer HAL_I2C_MemTxCpltCallback is executed and user can
    125                     add his own code by customization of function pointer HAL_I2C_MemTxCpltCallback
    126                (+) Read an amount of data in no-blocking mode with DMA from a specific memory address using
    127                    HAL_I2C_Mem_Read_DMA()
    128                (+) At MEM end of read transfer HAL_I2C_MemRxCpltCallback is executed and user can
    129                     add his own code by customization of function pointer HAL_I2C_MemRxCpltCallback
    130                (+) In case of transfer Error, HAL_I2C_ErrorCallback() function is executed and user can
    131                     add his own code by customization of function pointer HAL_I2C_ErrorCallback
    132          
    133          
    134               *** I2C HAL driver macros list ***
    135               ==================================
    136               [..]
    137                 Below the list of most used macros in I2C HAL driver.
    138          
    139                (+) __HAL_I2C_ENABLE: Enable the I2C peripheral
    140                (+) __HAL_I2C_DISABLE: Disable the I2C peripheral
    141                (+) __HAL_I2C_GET_FLAG : Checks whether the specified I2C flag is set or not
    142                (+) __HAL_I2C_CLEAR_FLAG : Clear the specified I2C pending flag
    143                (+) __HAL_I2C_ENABLE_IT: Enable the specified I2C interrupt
    144                (+) __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    145          
    146               [..]
    147                 (@) You can refer to the I2C HAL driver header file for more useful macros
    148          
    149            @endverbatim
    150            ******************************************************************************
    151            * @attention
    152            *
    153            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    154            *
    155            * Redistribution and use in source and binary forms, with or without modification,
    156            * are permitted provided that the following conditions are met:
    157            *   1. Redistributions of source code must retain the above copyright notice,
    158            *      this list of conditions and the following disclaimer.
    159            *   2. Redistributions in binary form must reproduce the above copyright notice,
    160            *      this list of conditions and the following disclaimer in the documentation
    161            *      and/or other materials provided with the distribution.
    162            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    163            *      may be used to endorse or promote products derived from this software
    164            *      without specific prior written permission.
    165            *
    166            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    167            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    168            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    169            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    170            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    171            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    172            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    173            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    174            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    175            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    176            *
    177            ******************************************************************************  
    178            */ 
    179          
    180          /* Includes ------------------------------------------------------------------*/
    181          #include "stm32f7xx_hal.h"
    182          
    183          /** @addtogroup STM32F7xx_HAL_Driver
    184            * @{
    185            */
    186          
    187          /** @defgroup I2C I2C
    188            * @brief I2C HAL module driver
    189            * @{
    190            */
    191          
    192          #ifdef HAL_I2C_MODULE_ENABLED
    193          
    194          /* Private typedef -----------------------------------------------------------*/
    195          /* Private constants ---------------------------------------------------------*/
    196          /** @addtogroup I2C_Private_Constants I2C Private Constants
    197            * @{
    198            */
    199          #define TIMING_CLEAR_MASK   ((uint32_t)0xF0FFFFFF)  /*<! I2C TIMING clear register Mask */
    200          #define I2C_TIMEOUT_ADDR    ((uint32_t)10000)  /* 10 s  */
    201          #define I2C_TIMEOUT_BUSY    ((uint32_t)25)     /* 25 ms */
    202          #define I2C_TIMEOUT_DIR     ((uint32_t)25)     /* 25 ms */
    203          #define I2C_TIMEOUT_RXNE    ((uint32_t)25)     /* 25 ms */
    204          #define I2C_TIMEOUT_STOPF   ((uint32_t)25)     /* 25 ms */
    205          #define I2C_TIMEOUT_TC      ((uint32_t)25)     /* 25 ms */
    206          #define I2C_TIMEOUT_TCR     ((uint32_t)25)     /* 25 ms */
    207          #define I2C_TIMEOUT_TXIS    ((uint32_t)25)     /* 25 ms */
    208          #define I2C_TIMEOUT_FLAG    ((uint32_t)25)     /* 25 ms */
    209          /**
    210            * @}
    211            */ 
    212          
    213          /* Private macro -------------------------------------------------------------*/
    214          /* Private variables ---------------------------------------------------------*/
    215          /* Private function prototypes -----------------------------------------------*/
    216          /** @addtogroup I2C_Private_Functions I2C Private Functions
    217            * @{
    218            */
    219          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma);
    220          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma);
    221          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma);
    222          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma);
    223          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma);
    224          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma);
    225          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    226          
    227          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    228          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout);
    229          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    230          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    231          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    232          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    233          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout);
    234          
    235          static HAL_StatusTypeDef I2C_MasterTransmit_ISR(I2C_HandleTypeDef *hi2c);
    236          static HAL_StatusTypeDef I2C_MasterReceive_ISR(I2C_HandleTypeDef *hi2c);
    237          
    238          static HAL_StatusTypeDef I2C_SlaveTransmit_ISR(I2C_HandleTypeDef *hi2c);
    239          static HAL_StatusTypeDef I2C_SlaveReceive_ISR(I2C_HandleTypeDef *hi2c);
    240          
    241          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request);
    242          /**
    243            * @}
    244            */ 
    245          
    246          /* Exported functions --------------------------------------------------------*/
    247          
    248          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    249            * @{
    250            */
    251          
    252          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    253           *  @brief    Initialization and Configuration functions 
    254           *
    255          @verbatim    
    256           ===============================================================================
    257                        ##### Initialization and de-initialization functions #####
    258           ===============================================================================
    259              [..]  This subsection provides a set of functions allowing to initialize and 
    260                    de-initialize the I2Cx peripheral:
    261          
    262                (+) User must Implement HAL_I2C_MspInit() function in which he configures 
    263                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    264          
    265                (+) Call the function HAL_I2C_Init() to configure the selected device with 
    266                    the selected configuration:
    267                  (++) Clock Timing
    268                  (++) Own Address 1
    269                  (++) Addressing mode (Master, Slave)
    270                  (++) Dual Addressing mode
    271                  (++) Own Address 2
    272                  (++) Own Address 2 Mask
    273                  (++) General call mode
    274                  (++) Nostretch mode
    275          
    276                (+) Call the function HAL_I2C_DeInit() to restore the default configuration 
    277                    of the selected I2Cx peripheral.       
    278          
    279          @endverbatim
    280            * @{
    281            */
    282          
    283          /**
    284            * @brief  Initializes the I2C according to the specified parameters 
    285            *         in the I2C_InitTypeDef and create the associated handle.
    286            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    287            *                the configuration information for the specified I2C.
    288            * @retval HAL status
    289            */

   \                                 In section .text, align 2, keep-with-next
    290          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    291          { 
   \                     HAL_I2C_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    292            /* Check the I2C handle allocation */
    293            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_Init_0
    294            {
    295              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    296            }
    297            
    298            /* Check the parameters */
    299            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    300            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    301            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    302            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    303            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    304            assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
    305            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    306            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    307          
    308            if(hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0xB920             CBNZ.N   R0,??HAL_I2C_Init_1
    309            {
    310              /* Allocate lock resource and initialize it */
    311              hi2c->Lock = HAL_UNLOCKED;
   \   00000010   0xF884 0x0034      STRB     R0,[R4, #+52]
    312              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    313              HAL_I2C_MspInit(hi2c);
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       HAL_I2C_MspInit
    314            }
    315          
    316            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_1: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xF884 0x0035      STRB     R0,[R4, #+53]
    317            
    318            /* Disable the selected I2C peripheral */
    319            __HAL_I2C_DISABLE(hi2c);
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x0849             LSRS     R1,R1,#+1
   \   00000026   0x0049             LSLS     R1,R1,#+1
   \   00000028   0x6001             STR      R1,[R0, #+0]
    320            
    321            /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
    322            /* Configure I2Cx: Frequency range */
    323            hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
   \   0000002A   0x6860             LDR      R0,[R4, #+4]
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0xF020 0x6070      BIC      R0,R0,#0xF000000
   \   00000032   0x6108             STR      R0,[R1, #+16]
    324            
    325            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    326            /* Configure I2Cx: Own Address1 and ack own address1 mode */
    327            hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6881             LDR      R1,[R0, #+8]
   \   00000038   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000003C   0x6081             STR      R1,[R0, #+8]
    328            if(hi2c->Init.OwnAddress1 != 0)
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0xB140             CBZ.N    R0,??HAL_I2C_Init_2
    329            {
    330              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \   00000042   0x68E1             LDR      R1,[R4, #+12]
   \   00000044   0x2901             CMP      R1,#+1
   \   00000046   0xBF0C             ITE      EQ 
   \   00000048   0xF440 0x4000      ORREQ    R0,R0,#0x8000
   \   0000004C   0xF440 0x4004      ORRNE    R0,R0,#0x8400
    331              {
    332                hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
    333              }
    334              else /* I2C_ADDRESSINGMODE_10BIT */
    335              {
    336                hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6088             STR      R0,[R1, #+8]
    337              }
    338            }
    339            
    340            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    341            /* Configure I2Cx: Addressing Master mode */
    342            if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \                     ??HAL_I2C_Init_2: (+1)
   \   00000054   0x68E0             LDR      R0,[R4, #+12]
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD103             BNE.N    ??HAL_I2C_Init_3
    343            {
    344              hi2c->Instance->CR2 = (I2C_CR2_ADD10);
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0xF44F 0x6000      MOV      R0,#+2048
   \   00000060   0x6048             STR      R0,[R1, #+4]
    345            }
    346            /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
    347            hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
   \                     ??HAL_I2C_Init_3: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6841             LDR      R1,[R0, #+4]
   \   00000066   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000006A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000006E   0x6041             STR      R1,[R0, #+4]
    348            
    349            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    350            /* Configure I2Cx: Dual mode and Own Address2 */
    351            hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
   \   00000070   0x6920             LDR      R0,[R4, #+16]
   \   00000072   0x6961             LDR      R1,[R4, #+20]
   \   00000074   0x4308             ORRS     R0,R1,R0
   \   00000076   0x69A1             LDR      R1,[R4, #+24]
   \   00000078   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000007C   0x6821             LDR      R1,[R4, #+0]
   \   0000007E   0x60C8             STR      R0,[R1, #+12]
    352          
    353            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    354            /* Configure I2Cx: Generalcall and NoStretch mode */
    355            hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
   \   00000080   0x69E0             LDR      R0,[R4, #+28]
   \   00000082   0x6A21             LDR      R1,[R4, #+32]
   \   00000084   0x4308             ORRS     R0,R1,R0
   \   00000086   0x6821             LDR      R1,[R4, #+0]
   \   00000088   0x6008             STR      R0,[R1, #+0]
    356            
    357            /* Enable the selected I2C peripheral */
    358            __HAL_I2C_ENABLE(hi2c);
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000092   0x6001             STR      R1,[R0, #+0]
    359            
    360            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x63A0             STR      R0,[R4, #+56]
    361            hi2c->State = HAL_I2C_STATE_READY;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xF884 0x0035      STRB     R0,[R4, #+53]
    362            
    363            return HAL_OK;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xBD10             POP      {R4,PC}          ;; return
    364          }
    365          
    366          /**
    367            * @brief  DeInitializes the I2C peripheral. 
    368            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    369            *                the configuration information for the specified I2C.
    370            * @retval HAL status
    371            */

   \                                 In section .text, align 2, keep-with-next
    372          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    373          {
   \                     HAL_I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    374            /* Check the I2C handle allocation */
    375            if(hi2c == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    376            {
    377              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    378            }
    379            
    380            /* Check the parameters */
    381            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    382            
    383            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xF884 0x0035      STRB     R0,[R4, #+53]
    384            
    385            /* Disable the I2C Peripheral Clock */
    386            __HAL_I2C_DISABLE(hi2c);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    387            
    388            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    389            HAL_I2C_MspDeInit(hi2c);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_I2C_MspDeInit
    390            
    391            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x63A0             STR      R0,[R4, #+56]
    392          
    393            hi2c->State = HAL_I2C_STATE_RESET;
   \   00000024   0xF884 0x0035      STRB     R0,[R4, #+53]
    394            
    395            /* Release Lock */
    396            __HAL_UNLOCK(hi2c);
   \   00000028   0xF884 0x0034      STRB     R0,[R4, #+52]
    397          
    398            return HAL_OK;
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    399          }
    400          
    401          /**
    402            * @brief I2C MSP Init.
    403            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    404            *                the configuration information for the specified I2C.
    405            * @retval None
    406            */
    407          // __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    408          //{
    409            /* NOTE : This function Should not be modified, when the callback is needed,
    410                      the HAL_I2C_MspInit could be implemented in the user file
    411             */ 
    412          //}
    413          
    414          /**
    415            * @brief I2C MSP DeInit
    416            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    417            *                the configuration information for the specified I2C.
    418            * @retval None
    419            */

   \                                 In section .text, align 2, keep-with-next
    420           __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    421          {
    422            /* NOTE : This function Should not be modified, when the callback is needed,
    423                      the HAL_I2C_MspDeInit could be implemented in the user file
    424             */ 
    425          }
   \                     HAL_I2C_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    426          
    427          /**
    428            * @}
    429            */
    430          
    431          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
    432           *  @brief   Data transfers functions 
    433           *
    434          @verbatim   
    435           ===============================================================================
    436                                ##### IO operation functions #####
    437           ===============================================================================  
    438              [..]
    439              This subsection provides a set of functions allowing to manage the I2C data 
    440              transfers.
    441          
    442              (#) There are two modes of transfer:
    443                 (++) Blocking mode : The communication is performed in the polling mode. 
    444                      The status of all data processing is returned by the same function 
    445                      after finishing transfer.  
    446                 (++) No-Blocking mode : The communication is performed using Interrupts 
    447                      or DMA. These functions return the status of the transfer startup.
    448                      The end of the data processing will be indicated through the 
    449                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when 
    450                      using DMA mode.
    451          
    452              (#) Blocking mode functions are :
    453                  (++) HAL_I2C_Master_Transmit()
    454                  (++) HAL_I2C_Master_Receive()
    455                  (++) HAL_I2C_Slave_Transmit()
    456                  (++) HAL_I2C_Slave_Receive()
    457                  (++) HAL_I2C_Mem_Write()
    458                  (++) HAL_I2C_Mem_Read()
    459                  (++) HAL_I2C_IsDeviceReady()
    460                  
    461              (#) No-Blocking mode functions with Interrupt are :
    462                  (++) HAL_I2C_Master_Transmit_IT()
    463                  (++) HAL_I2C_Master_Receive_IT()
    464                  (++) HAL_I2C_Slave_Transmit_IT()
    465                  (++) HAL_I2C_Slave_Receive_IT()
    466                  (++) HAL_I2C_Mem_Write_IT()
    467                  (++) HAL_I2C_Mem_Read_IT()
    468          
    469              (#) No-Blocking mode functions with DMA are :
    470                  (++) HAL_I2C_Master_Transmit_DMA()
    471                  (++) HAL_I2C_Master_Receive_DMA()
    472                  (++) HAL_I2C_Slave_Transmit_DMA()
    473                  (++) HAL_I2C_Slave_Receive_DMA()
    474                  (++) HAL_I2C_Mem_Write_DMA()
    475                  (++) HAL_I2C_Mem_Read_DMA()
    476          
    477              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    478                  (++) HAL_I2C_MemTxCpltCallback()
    479                  (++) HAL_I2C_MemRxCpltCallback()
    480                  (++) HAL_I2C_MasterTxCpltCallback()
    481                  (++) HAL_I2C_MasterRxCpltCallback()
    482                  (++) HAL_I2C_SlaveTxCpltCallback()
    483                  (++) HAL_I2C_SlaveRxCpltCallback()
    484                  (++) HAL_I2C_ErrorCallback()
    485          
    486          @endverbatim
    487            * @{
    488            */
    489          
    490          /**
    491            * @brief  Transmits in master mode an amount of data in blocking mode.
    492            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    493            *                the configuration information for the specified I2C.
    494            * @param  DevAddress: Target device address
    495            * @param  pData: Pointer to data buffer
    496            * @param  Size: Amount of data to be sent
    497            * @param  Timeout: Timeout duration
    498            * @retval HAL status
    499            */

   \                                 In section .text, align 4, keep-with-next
    500          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    501          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x461E             MOV      R6,R3
    502            uint32_t sizetmp = 0;
    503          
    504            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80DA      BNE.W    ??HAL_I2C_Master_Transmit_0
    505            {    
    506              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2E00             CMPNE    R6,#+0
   \   0000001E   0xF000 0x80D5      BEQ.W    ??HAL_I2C_Master_Transmit_1
    507              {
    508                return  HAL_ERROR;                                    
    509              }
    510              
    511              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6982             LDR      R2,[R0, #+24]
   \   00000026   0x0412             LSLS     R2,R2,#+16
   \   00000028   0xF100 0x80CF      BMI.W    ??HAL_I2C_Master_Transmit_0
    512              {
    513                return HAL_BUSY;
    514              }
    515          
    516              /* Process Locked */
    517              __HAL_LOCK(hi2c);
   \   0000002C   0xF894 0x2034      LDRB     R2,[R4, #+52]
   \   00000030   0x2A01             CMP      R2,#+1
   \   00000032   0xF000 0x80CA      BEQ.W    ??HAL_I2C_Master_Transmit_0
   \   00000036   0x2201             MOVS     R2,#+1
    518              
    519              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
    520              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    521              
    522              /* Send Slave Address */
    523              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    524              /* Size > 255, need to set RELOAD bit */
    525              if(Size > 255)
   \   00000038   0x058F             LSLS     R7,R1,#+22
   \   0000003A   0xF884 0x2034      STRB     R2,[R4, #+52]
   \   0000003E   0x2212             MOVS     R2,#+18
   \   00000040   0xF884 0x2035      STRB     R2,[R4, #+53]
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x63A2             STR      R2,[R4, #+56]
   \   00000048   0x2EFF             CMP      R6,#+255
   \   0000004A   0x6841             LDR      R1,[R0, #+4]
   \   0000004C   0x.... 0x....      LDR.W    R8,??DataTable8  ;; 0xfc009800
   \   00000050   0xEA08 0x0101      AND      R1,R8,R1
   \   00000054   0xDD0A             BLE.N    ??HAL_I2C_Master_Transmit_2
    526              {
    527                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   00000056   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
    528                sizetmp = 255;
   \   0000005A   0x25FF             MOVS     R5,#+255
   \   0000005C   0xF041 0x71F0      ORR      R1,R1,#0x1E00000
   \   00000060   0xF441 0x11F9      ORR      R1,R1,#0x1F2000
   \   00000064   0x6041             STR      R1,[R0, #+4]
   \   00000066   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   0000006A   0xE016             B.N      ??HAL_I2C_Master_Transmit_3
    529              }
    530              else
    531              {
    532                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \   0000006C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000070   0xB2F2             UXTB     R2,R6
    533                sizetmp = Size;
   \   00000072   0x4635             MOV      R5,R6
   \   00000074   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000078   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000007C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000080   0x6041             STR      R1,[R0, #+4]
   \   00000082   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   00000086   0xE008             B.N      ??HAL_I2C_Master_Transmit_3
    534              }
    535                
    536              do
    537              {
    538                /* Wait until TXIS flag is set */
    539                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    540                {
    541                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    542                  {
    543                    return HAL_ERROR;
    544                  }
    545                  else
    546                  {
    547                    return HAL_TIMEOUT;
    548                  }
    549                }
    550                /* Write data to TXDR */
    551                hi2c->Instance->TXDR = (*pData++);
    552                sizetmp--;
    553                Size--;
    554          
    555                if((sizetmp == 0)&&(Size!=0))
    556                {
    557                  /* Wait until TXE flag is set */
    558                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
    559                  {
    560                    return HAL_TIMEOUT;
    561                  }
    562                  
    563                  if(Size > 255)
    564                  {
    565                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    566                    sizetmp = 255;
    567                  }
    568                  else
    569                  {
    570                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \   00000088   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   0000008C   0xB2F2             UXTB     R2,R6
    571                    sizetmp = Size;
   \   0000008E   0x4635             MOV      R5,R6
   \   00000090   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000094   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000098   0x6041             STR      R1,[R0, #+4]
    572                  }
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \   0000009A   0x.... 0x....      BL       HAL_GetTick
   \   0000009E   0x4683             MOV      R11,R0
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6981             LDR      R1,[R0, #+24]
   \   000000A4   0x0789             LSLS     R1,R1,#+30
   \   000000A6   0xD421             BMI.N    ??HAL_I2C_Master_Transmit_6
   \   000000A8   0x4649             MOV      R1,R9
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000B0   0xB9A8             CBNZ.N   R0,??HAL_I2C_Master_Transmit_7
   \   000000B2   0xF119 0x0F01      CMN      R9,#+1
   \   000000B6   0xD0F3             BEQ.N    ??HAL_I2C_Master_Transmit_5
   \   000000B8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000BC   0xD005             BEQ.N    ??HAL_I2C_Master_Transmit_8
   \   000000BE   0x.... 0x....      BL       HAL_GetTick
   \   000000C2   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000C6   0x4581             CMP      R9,R0
   \   000000C8   0xD2EA             BCS.N    ??HAL_I2C_Master_Transmit_5
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \   000000CA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000D0   0x63A0             STR      R0,[R4, #+56]
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \   000000DE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E0   0x2804             CMP      R0,#+4
   \   000000E2   0xD16E             BNE.N    ??HAL_I2C_Master_Transmit_9
    573                }
    574          
    575              }while(Size > 0);
    576              
    577              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    578              /* Wait until STOPF flag is set */
    579              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    580              {
    581                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    582                {
    583                  return HAL_ERROR;
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0xB001             ADD      SP,SP,#+4
   \   000000E8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \   000000EC   0xF81A 0x1B01      LDRB     R1,[R10], #+1
   \   000000F0   0x1E6D             SUBS     R5,R5,#+1
   \   000000F2   0xF1A6 0x0601      SUB      R6,R6,#+1
   \   000000F6   0xB2B6             UXTH     R6,R6
   \   000000F8   0x6281             STR      R1,[R0, #+40]
   \   000000FA   0xD129             BNE.N    ??HAL_I2C_Master_Transmit_10
   \   000000FC   0xB356             CBZ.N    R6,??HAL_I2C_Master_Transmit_11
   \   000000FE   0x.... 0x....      BL       HAL_GetTick
   \   00000102   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Master_Transmit_12: (+1)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6981             LDR      R1,[R0, #+24]
   \   00000108   0x0609             LSLS     R1,R1,#+24
   \   0000010A   0xD414             BMI.N    ??HAL_I2C_Master_Transmit_13
   \   0000010C   0xF119 0x0F01      CMN      R9,#+1
   \   00000110   0xD0F8             BEQ.N    ??HAL_I2C_Master_Transmit_12
   \   00000112   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000116   0xD004             BEQ.N    ??HAL_I2C_Master_Transmit_14
   \   00000118   0x.... 0x....      BL       HAL_GetTick
   \   0000011C   0x1B40             SUBS     R0,R0,R5
   \   0000011E   0x4581             CMP      R9,R0
   \   00000120   0xD2F0             BCS.N    ??HAL_I2C_Master_Transmit_12
   \                     ??HAL_I2C_Master_Transmit_14: (+1)
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF884 0x0034      STRB     R0,[R4, #+52]
    584                }
    585                else
    586                {
    587                  return HAL_TIMEOUT;
   \   0000012E   0x2003             MOVS     R0,#+3
   \   00000130   0xB001             ADD      SP,SP,#+4
   \   00000132   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Transmit_13: (+1)
   \   00000136   0x2EFF             CMP      R6,#+255
   \   00000138   0x6841             LDR      R1,[R0, #+4]
   \   0000013A   0xEA08 0x0101      AND      R1,R8,R1
   \   0000013E   0xDDA3             BLE.N    ??HAL_I2C_Master_Transmit_4
   \   00000140   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000144   0x.... 0x....      LDR.W    R2,??DataTable8_1  ;; 0x1ff0000
   \   00000148   0x25FF             MOVS     R5,#+255
   \   0000014A   0x4311             ORRS     R1,R2,R1
   \   0000014C   0x6041             STR      R1,[R0, #+4]
   \   0000014E   0xE7A4             B.N      ??HAL_I2C_Master_Transmit_3
   \                     ??HAL_I2C_Master_Transmit_10: (+1)
   \   00000150   0x2E00             CMP      R6,#+0
   \   00000152   0xD1A2             BNE.N    ??HAL_I2C_Master_Transmit_3
   \                     ??HAL_I2C_Master_Transmit_11: (+1)
   \   00000154   0x.... 0x....      BL       HAL_GetTick
   \   00000158   0x4682             MOV      R10,R0
   \                     ??HAL_I2C_Master_Transmit_15: (+1)
   \   0000015A   0x6820             LDR      R0,[R4, #+0]
   \   0000015C   0x6981             LDR      R1,[R0, #+24]
   \   0000015E   0x0689             LSLS     R1,R1,#+26
   \   00000160   0xD41E             BMI.N    ??HAL_I2C_Master_Transmit_16
   \   00000162   0x4649             MOV      R1,R9
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000016A   0xB990             CBNZ.N   R0,??HAL_I2C_Master_Transmit_17
   \   0000016C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000170   0xD005             BEQ.N    ??HAL_I2C_Master_Transmit_18
   \   00000172   0x.... 0x....      BL       HAL_GetTick
   \   00000176   0xEBA0 0x000A      SUB      R0,R0,R10
   \   0000017A   0x4581             CMP      R9,R0
   \   0000017C   0xD2ED             BCS.N    ??HAL_I2C_Master_Transmit_15
   \                     ??HAL_I2C_Master_Transmit_18: (+1)
   \   0000017E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000180   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000184   0x63A0             STR      R0,[R4, #+56]
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000018C   0x2000             MOVS     R0,#+0
   \   0000018E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Master_Transmit_17: (+1)
   \   00000192   0x6BA0             LDR      R0,[R4, #+56]
   \   00000194   0x2804             CMP      R0,#+4
   \   00000196   0xD114             BNE.N    ??HAL_I2C_Master_Transmit_9
   \   00000198   0x2001             MOVS     R0,#+1
   \   0000019A   0xB001             ADD      SP,SP,#+4
   \   0000019C   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    588                }
    589              }
    590              
    591              /* Clear STOP Flag */
    592              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Transmit_16: (+1)
   \   000001A0   0x2120             MOVS     R1,#+32
    593            	
    594              /* Clear Configuration Register 2 */
    595              I2C_RESET_CR2(hi2c);
   \   000001A2   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0xfe00e800
   \   000001A6   0x61C1             STR      R1,[R0, #+28]
   \   000001A8   0x6820             LDR      R0,[R4, #+0]
   \   000001AA   0x6841             LDR      R1,[R0, #+4]
   \   000001AC   0x4011             ANDS     R1,R2,R1
   \   000001AE   0x6041             STR      R1,[R0, #+4]
    596          
    597              hi2c->State = HAL_I2C_STATE_READY; 	  
   \   000001B0   0x2001             MOVS     R0,#+1
   \   000001B2   0xF884 0x0035      STRB     R0,[R4, #+53]
    598              
    599              /* Process Unlocked */
    600              __HAL_UNLOCK(hi2c);
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0xF884 0x0034      STRB     R0,[R4, #+52]
    601          
    602              return HAL_OK;
   \   000001BC   0xB001             ADD      SP,SP,#+4
   \   000001BE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Transmit_9: (+1)
   \   000001C2   0x2003             MOVS     R0,#+3
   \   000001C4   0xB001             ADD      SP,SP,#+4
   \   000001C6   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    603            }
    604            else
    605            {
    606              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \   000001CA   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \   000001CC   0xB001             ADD      SP,SP,#+4
   \   000001CE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    607            }
    608          }
    609          
    610          /**
    611            * @brief  Receives in master mode an amount of data in blocking mode. 
    612            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    613            *                the configuration information for the specified I2C.
    614            * @param  DevAddress: Target device address
    615            * @param  pData: Pointer to data buffer
    616            * @param  Size: Amount of data to be sent
    617            * @param  Timeout: Timeout duration
    618            * @retval HAL status
    619            */

   \                                 In section .text, align 4, keep-with-next
    620          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    621          {
   \                     HAL_I2C_Master_Receive: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x461E             MOV      R6,R3
    622            uint32_t sizetmp = 0;
    623          
    624            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80CB      BNE.W    ??HAL_I2C_Master_Receive_0
    625            {    
    626              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2E00             CMPNE    R6,#+0
   \   0000001E   0xF000 0x80C6      BEQ.W    ??HAL_I2C_Master_Receive_1
    627              {
    628                return  HAL_ERROR;                                    
    629              }
    630              
    631              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6982             LDR      R2,[R0, #+24]
   \   00000026   0x0412             LSLS     R2,R2,#+16
   \   00000028   0xF100 0x80C0      BMI.W    ??HAL_I2C_Master_Receive_0
    632              {
    633                return HAL_BUSY;
    634              }
    635          
    636              /* Process Locked */
    637              __HAL_LOCK(hi2c);
   \   0000002C   0xF894 0x2034      LDRB     R2,[R4, #+52]
   \   00000030   0x2A01             CMP      R2,#+1
   \   00000032   0xF000 0x80BB      BEQ.W    ??HAL_I2C_Master_Receive_0
   \   00000036   0x2201             MOVS     R2,#+1
    638              
    639              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
    640              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
    641              
    642              /* Send Slave Address */
    643              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
    644              /* Size > 255, need to set RELOAD bit */
    645              if(Size > 255)
   \   00000038   0x058F             LSLS     R7,R1,#+22
   \   0000003A   0xF884 0x2034      STRB     R2,[R4, #+52]
   \   0000003E   0x2222             MOVS     R2,#+34
   \   00000040   0xF884 0x2035      STRB     R2,[R4, #+53]
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x63A2             STR      R2,[R4, #+56]
   \   00000048   0x2EFF             CMP      R6,#+255
   \   0000004A   0x6841             LDR      R1,[R0, #+4]
   \   0000004C   0x.... 0x....      LDR.W    R8,??DataTable8  ;; 0xfc009800
   \   00000050   0xEA08 0x0101      AND      R1,R8,R1
   \   00000054   0xDD0A             BLE.N    ??HAL_I2C_Master_Receive_2
    646              {
    647                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000056   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
    648                sizetmp = 255;
   \   0000005A   0x25FF             MOVS     R5,#+255
   \   0000005C   0xF041 0x71FE      ORR      R1,R1,#0x1FC0000
   \   00000060   0xF441 0x3149      ORR      R1,R1,#0x32400
   \   00000064   0x6041             STR      R1,[R0, #+4]
   \   00000066   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   0000006A   0xE016             B.N      ??HAL_I2C_Master_Receive_3
    649              }
    650              else
    651              {
    652                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \   0000006C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000070   0xB2F2             UXTB     R2,R6
    653                sizetmp = Size;
   \   00000072   0x4635             MOV      R5,R6
   \   00000074   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000078   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000007C   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   00000080   0x6041             STR      R1,[R0, #+4]
   \   00000082   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   00000086   0xE008             B.N      ??HAL_I2C_Master_Receive_3
    654              }
    655              
    656              do
    657              {
    658                /* Wait until RXNE flag is set */
    659                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)      
    660                {
    661                  return HAL_TIMEOUT;
    662                }
    663               
    664                /* Write data to RXDR */
    665                (*pData++) =hi2c->Instance->RXDR;
    666                sizetmp--;
    667                Size--;
    668          
    669                if((sizetmp == 0)&&(Size!=0))
    670                {
    671                  /* Wait until TCR flag is set */
    672                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
    673                  {
    674                    return HAL_TIMEOUT;
    675                  }
    676                  
    677                  if(Size > 255)
    678                  {
    679                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
    680                    sizetmp = 255;
    681                  }
    682                  else
    683                  {
    684                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \   00000088   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   0000008C   0xB2F2             UXTB     R2,R6
    685                    sizetmp = Size;
   \   0000008E   0x4635             MOV      R5,R6
   \   00000090   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000094   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000098   0x6041             STR      R1,[R0, #+4]
    686                  }
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \   0000009A   0x.... 0x....      BL       HAL_GetTick
   \   0000009E   0x4683             MOV      R11,R0
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6981             LDR      R1,[R0, #+24]
   \   000000A4   0x0749             LSLS     R1,R1,#+29
   \   000000A6   0xD415             BMI.N    ??HAL_I2C_Master_Receive_6
   \   000000A8   0xF119 0x0F01      CMN      R9,#+1
   \   000000AC   0xD0F8             BEQ.N    ??HAL_I2C_Master_Receive_5
   \   000000AE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000B2   0xD005             BEQ.N    ??HAL_I2C_Master_Receive_7
   \   000000B4   0x.... 0x....      BL       HAL_GetTick
   \   000000B8   0xEBA0 0x000B      SUB      R0,R0,R11
   \   000000BC   0x4581             CMP      R9,R0
   \   000000BE   0xD2EF             BCS.N    ??HAL_I2C_Master_Receive_5
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF884 0x0034      STRB     R0,[R4, #+52]
    687                }
    688          
    689              }while(Size > 0);
    690              
    691              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    692              /* Wait until STOPF flag is set */
    693              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    694              {
    695                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    696                {
    697                  return HAL_ERROR;
    698                }
    699                else
    700                {
    701                  return HAL_TIMEOUT;
   \   000000CC   0x2003             MOVS     R0,#+3
   \   000000CE   0xB001             ADD      SP,SP,#+4
   \   000000D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \   000000D4   0x6A40             LDR      R0,[R0, #+36]
   \   000000D6   0x1E6D             SUBS     R5,R5,#+1
   \   000000D8   0xF1A6 0x0601      SUB      R6,R6,#+1
   \   000000DC   0xB2B6             UXTH     R6,R6
   \   000000DE   0xF80A 0x0B01      STRB     R0,[R10], #+1
   \   000000E2   0xD129             BNE.N    ??HAL_I2C_Master_Receive_8
   \   000000E4   0xB356             CBZ.N    R6,??HAL_I2C_Master_Receive_9
   \   000000E6   0x.... 0x....      BL       HAL_GetTick
   \   000000EA   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Master_Receive_10: (+1)
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6981             LDR      R1,[R0, #+24]
   \   000000F0   0x0609             LSLS     R1,R1,#+24
   \   000000F2   0xD414             BMI.N    ??HAL_I2C_Master_Receive_11
   \   000000F4   0xF119 0x0F01      CMN      R9,#+1
   \   000000F8   0xD0F8             BEQ.N    ??HAL_I2C_Master_Receive_10
   \   000000FA   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000FE   0xD004             BEQ.N    ??HAL_I2C_Master_Receive_12
   \   00000100   0x.... 0x....      BL       HAL_GetTick
   \   00000104   0x1B40             SUBS     R0,R0,R5
   \   00000106   0x4581             CMP      R9,R0
   \   00000108   0xD2F0             BCS.N    ??HAL_I2C_Master_Receive_10
   \                     ??HAL_I2C_Master_Receive_12: (+1)
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000116   0x2003             MOVS     R0,#+3
   \   00000118   0xB001             ADD      SP,SP,#+4
   \   0000011A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Receive_11: (+1)
   \   0000011E   0x2EFF             CMP      R6,#+255
   \   00000120   0x6841             LDR      R1,[R0, #+4]
   \   00000122   0xEA08 0x0101      AND      R1,R8,R1
   \   00000126   0xDDAF             BLE.N    ??HAL_I2C_Master_Receive_4
   \   00000128   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   0000012C   0x.... 0x....      LDR.W    R2,??DataTable8_1  ;; 0x1ff0000
   \   00000130   0x25FF             MOVS     R5,#+255
   \   00000132   0x4311             ORRS     R1,R2,R1
   \   00000134   0x6041             STR      R1,[R0, #+4]
   \   00000136   0xE7B0             B.N      ??HAL_I2C_Master_Receive_3
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \   00000138   0x2E00             CMP      R6,#+0
   \   0000013A   0xD1AE             BNE.N    ??HAL_I2C_Master_Receive_3
   \                     ??HAL_I2C_Master_Receive_9: (+1)
   \   0000013C   0x.... 0x....      BL       HAL_GetTick
   \   00000140   0x4682             MOV      R10,R0
   \                     ??HAL_I2C_Master_Receive_13: (+1)
   \   00000142   0x6820             LDR      R0,[R4, #+0]
   \   00000144   0x6981             LDR      R1,[R0, #+24]
   \   00000146   0x0689             LSLS     R1,R1,#+26
   \   00000148   0xD41B             BMI.N    ??HAL_I2C_Master_Receive_14
   \   0000014A   0x2119             MOVS     R1,#+25
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000152   0xB978             CBNZ.N   R0,??HAL_I2C_Master_Receive_15
   \   00000154   0x.... 0x....      BL       HAL_GetTick
   \   00000158   0xEBA0 0x000A      SUB      R0,R0,R10
   \   0000015C   0x281A             CMP      R0,#+26
   \   0000015E   0xD3F0             BCC.N    ??HAL_I2C_Master_Receive_13
   \   00000160   0x6BA0             LDR      R0,[R4, #+56]
   \   00000162   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000166   0x63A0             STR      R0,[R4, #+56]
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Master_Receive_15: (+1)
   \   00000174   0x6BA0             LDR      R0,[R4, #+56]
   \   00000176   0x2804             CMP      R0,#+4
   \   00000178   0xD114             BNE.N    ??HAL_I2C_Master_Receive_16
   \   0000017A   0x2001             MOVS     R0,#+1
   \   0000017C   0xB001             ADD      SP,SP,#+4
   \   0000017E   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    702                }
    703              }
    704              
    705              /* Clear STOP Flag */
    706              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Master_Receive_14: (+1)
   \   00000182   0x2120             MOVS     R1,#+32
    707            	
    708              /* Clear Configuration Register 2 */
    709              I2C_RESET_CR2(hi2c);
   \   00000184   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0xfe00e800
   \   00000188   0x61C1             STR      R1,[R0, #+28]
   \   0000018A   0x6820             LDR      R0,[R4, #+0]
   \   0000018C   0x6841             LDR      R1,[R0, #+4]
   \   0000018E   0x4011             ANDS     R1,R2,R1
   \   00000190   0x6041             STR      R1,[R0, #+4]
    710              
    711              hi2c->State = HAL_I2C_STATE_READY; 	  
   \   00000192   0x2001             MOVS     R0,#+1
   \   00000194   0xF884 0x0035      STRB     R0,[R4, #+53]
    712              
    713              /* Process Unlocked */
    714              __HAL_UNLOCK(hi2c);
   \   00000198   0x2000             MOVS     R0,#+0
   \   0000019A   0xF884 0x0034      STRB     R0,[R4, #+52]
    715              
    716              return HAL_OK;
   \   0000019E   0xB001             ADD      SP,SP,#+4
   \   000001A0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Master_Receive_16: (+1)
   \   000001A4   0x2003             MOVS     R0,#+3
   \   000001A6   0xB001             ADD      SP,SP,#+4
   \   000001A8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
    717            }
    718            else
    719            {
    720              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \   000001AC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \   000001AE   0xB001             ADD      SP,SP,#+4
   \   000001B0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    721            }
    722          }
    723          
    724          /**
    725            * @brief  Transmits in slave mode an amount of data in blocking mode. 
    726            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    727            *                the configuration information for the specified I2C.
    728            * @param  pData: Pointer to data buffer
    729            * @param  Size: Amount of data to be sent
    730            * @param  Timeout: Timeout duration
    731            * @retval HAL status
    732            */

   \                                 In section .text, align 4, keep-with-next
    733          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    734          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
    735            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80FE      BNE.W    ??HAL_I2C_Slave_Transmit_0
    736            {    
    737              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2E00             CMPNE    R6,#+0
   \   0000001E   0xF000 0x80F9      BEQ.W    ??HAL_I2C_Slave_Transmit_1
    738              {
    739                return  HAL_ERROR;                                    
    740              }
    741              
    742              /* Process Locked */
    743              __HAL_LOCK(hi2c);
   \   00000022   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xF000 0x80F3      BEQ.W    ??HAL_I2C_Slave_Transmit_0
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
    744              
    745              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   \   00000032   0x2042             MOVS     R0,#+66
   \   00000034   0xF884 0x0035      STRB     R0,[R4, #+53]
    746              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x63A0             STR      R0,[R4, #+56]
    747              
    748              /* Enable Address Acknowledge */
    749              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6841             LDR      R1,[R0, #+4]
   \   00000040   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000044   0x6041             STR      R1,[R0, #+4]
    750          
    751              /* Wait until ADDR flag is set */
    752              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
   \   00000046   0x.... 0x....      BL       HAL_GetTick
   \   0000004A   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6981             LDR      R1,[R0, #+24]
   \   00000050   0x0709             LSLS     R1,R1,#+28
   \   00000052   0xD416             BMI.N    ??HAL_I2C_Slave_Transmit_3
   \   00000054   0xF117 0x0F01      CMN      R7,#+1
   \   00000058   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Transmit_2
   \   0000005A   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Transmit_4
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0x1B40             SUBS     R0,R0,R5
   \   00000062   0x4287             CMP      R7,R0
   \   00000064   0xD2F2             BCS.N    ??HAL_I2C_Slave_Transmit_2
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0034      STRB     R0,[R4, #+52]
    753              {
    754                /* Disable Address Acknowledge */
    755                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x6841             LDR      R1,[R0, #+4]
   \   00000076   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000007A   0x6041             STR      R1,[R0, #+4]
    756                return HAL_TIMEOUT;
    757              }
    758              
    759              /* Clear ADDR flag */
    760              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
    761          
    762              /* If 10bit addressing mode is selected */
    763              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
    764              {
    765                /* Wait until ADDR flag is set */
    766                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
    767                {
    768                  /* Disable Address Acknowledge */
    769                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    770                  return HAL_TIMEOUT;
    771                }
    772              
    773                /* Clear ADDR flag */
    774                __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
    775              }
    776          
    777              /* Wait until DIR flag is set Transmitter mode */
    778              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, Timeout) != HAL_OK)      
    779              {
    780                /* Disable Address Acknowledge */
    781                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    782                return HAL_TIMEOUT;
    783              }
    784          
    785              do
    786              {
    787                /* Wait until TXIS flag is set */
    788                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
    789                {
    790                  /* Disable Address Acknowledge */
    791                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
    792          
    793                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    794                  {
    795                    return HAL_ERROR;
    796                  }
    797                  else
    798                  {
    799                    return HAL_TIMEOUT;
    800                  }
    801                }
    802                
    803                /* Read data from TXDR */
    804                hi2c->Instance->TXDR = (*pData++);
    805                Size--;
    806              }while(Size > 0);
    807              
    808              /* Wait until STOP flag is set */
    809              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    810              {
    811                /* Disable Address Acknowledge */
    812                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    813          
    814                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    815                {
    816          	/* Normal use case for Transmitter mode */
    817          	/* A NACK is generated to confirm the end of transfer */
    818          	hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    819                }
    820                else
    821                {
    822                  return HAL_TIMEOUT;
   \   0000007C   0x2003             MOVS     R0,#+3
   \   0000007E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \   00000082   0x2108             MOVS     R1,#+8
   \   00000084   0x61C1             STR      R1,[R0, #+28]
   \   00000086   0x68E0             LDR      R0,[R4, #+12]
   \   00000088   0x2802             CMP      R0,#+2
   \   0000008A   0xD11F             BNE.N    ??HAL_I2C_Slave_Transmit_5
   \   0000008C   0x.... 0x....      BL       HAL_GetTick
   \   00000090   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6981             LDR      R1,[R0, #+24]
   \   00000096   0x0709             LSLS     R1,R1,#+28
   \   00000098   0xD416             BMI.N    ??HAL_I2C_Slave_Transmit_7
   \   0000009A   0xF117 0x0F01      CMN      R7,#+1
   \   0000009E   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Transmit_6
   \   000000A0   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Transmit_8
   \   000000A2   0x.... 0x....      BL       HAL_GetTick
   \   000000A6   0x1B40             SUBS     R0,R0,R5
   \   000000A8   0x4287             CMP      R7,R0
   \   000000AA   0xD2F2             BCS.N    ??HAL_I2C_Slave_Transmit_6
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x6841             LDR      R1,[R0, #+4]
   \   000000BC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000C0   0x6041             STR      R1,[R0, #+4]
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \   000000C8   0x2108             MOVS     R1,#+8
   \   000000CA   0x61C1             STR      R1,[R0, #+28]
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \   000000CC   0x.... 0x....      BL       HAL_GetTick
   \   000000D0   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6980             LDR      R0,[R0, #+24]
   \   000000D6   0x03C0             LSLS     R0,R0,#+15
   \   000000D8   0xD416             BMI.N    ??HAL_I2C_Slave_Transmit_10
   \   000000DA   0xF117 0x0F01      CMN      R7,#+1
   \   000000DE   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Transmit_9
   \   000000E0   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Transmit_11
   \   000000E2   0x.... 0x....      BL       HAL_GetTick
   \   000000E6   0x1B40             SUBS     R0,R0,R5
   \   000000E8   0x4287             CMP      R7,R0
   \   000000EA   0xD2F2             BCS.N    ??HAL_I2C_Slave_Transmit_9
   \                     ??HAL_I2C_Slave_Transmit_11: (+1)
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6841             LDR      R1,[R0, #+4]
   \   000000FC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000100   0x6041             STR      R1,[R0, #+4]
   \   00000102   0x2003             MOVS     R0,#+3
   \   00000104   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Transmit_10: (+1)
   \   00000108   0x.... 0x....      BL       HAL_GetTick
   \   0000010C   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_12: (+1)
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x6981             LDR      R1,[R0, #+24]
   \   00000112   0x0789             LSLS     R1,R1,#+30
   \   00000114   0xD422             BMI.N    ??HAL_I2C_Slave_Transmit_13
   \   00000116   0x4639             MOV      R1,R7
   \   00000118   0x4620             MOV      R0,R4
   \   0000011A   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000011E   0xB990             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_14
   \   00000120   0xF117 0x0F01      CMN      R7,#+1
   \   00000124   0xD0F3             BEQ.N    ??HAL_I2C_Slave_Transmit_12
   \   00000126   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Transmit_15
   \   00000128   0x.... 0x....      BL       HAL_GetTick
   \   0000012C   0x1B40             SUBS     R0,R0,R5
   \   0000012E   0x4287             CMP      R7,R0
   \   00000130   0xD2ED             BCS.N    ??HAL_I2C_Slave_Transmit_12
   \                     ??HAL_I2C_Slave_Transmit_15: (+1)
   \   00000132   0x6BA0             LDR      R0,[R4, #+56]
   \   00000134   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000138   0x63A0             STR      R0,[R4, #+56]
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Slave_Transmit_14: (+1)
   \   00000146   0x6820             LDR      R0,[R4, #+0]
   \   00000148   0x6841             LDR      R1,[R0, #+4]
   \   0000014A   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000014E   0x6041             STR      R1,[R0, #+4]
   \   00000150   0x6BA0             LDR      R0,[R4, #+56]
   \   00000152   0x2804             CMP      R0,#+4
   \   00000154   0xD14E             BNE.N    ??HAL_I2C_Slave_Transmit_16
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Transmit_13: (+1)
   \   0000015C   0x1E76             SUBS     R6,R6,#+1
   \   0000015E   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \   00000162   0xB2B6             UXTH     R6,R6
   \   00000164   0x2E00             CMP      R6,#+0
   \   00000166   0x6281             STR      R1,[R0, #+40]
   \   00000168   0xD1CE             BNE.N    ??HAL_I2C_Slave_Transmit_10
   \   0000016A   0x.... 0x....      BL       HAL_GetTick
   \   0000016E   0x4680             MOV      R8,R0
   \                     ??HAL_I2C_Slave_Transmit_17: (+1)
   \   00000170   0x6820             LDR      R0,[R4, #+0]
   \   00000172   0x6980             LDR      R0,[R0, #+24]
   \   00000174   0x0680             LSLS     R0,R0,#+26
   \   00000176   0xD41E             BMI.N    ??HAL_I2C_Slave_Transmit_18
   \   00000178   0x2119             MOVS     R1,#+25
   \   0000017A   0x4620             MOV      R0,R4
   \   0000017C   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000180   0xB978             CBNZ.N   R0,??HAL_I2C_Slave_Transmit_19
   \   00000182   0x.... 0x....      BL       HAL_GetTick
   \   00000186   0xEBA0 0x0008      SUB      R0,R0,R8
   \   0000018A   0x281A             CMP      R0,#+26
   \   0000018C   0xD3F0             BCC.N    ??HAL_I2C_Slave_Transmit_17
   \   0000018E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000190   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000194   0x63A0             STR      R0,[R4, #+56]
   \   00000196   0x2001             MOVS     R0,#+1
   \   00000198   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Slave_Transmit_19: (+1)
   \   000001A2   0x6820             LDR      R0,[R4, #+0]
   \   000001A4   0x6841             LDR      R1,[R0, #+4]
   \   000001A6   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001AA   0x6041             STR      R1,[R0, #+4]
   \   000001AC   0x6BA0             LDR      R0,[R4, #+56]
   \   000001AE   0x2804             CMP      R0,#+4
   \   000001B0   0xD120             BNE.N    ??HAL_I2C_Slave_Transmit_16
   \   000001B2   0x2000             MOVS     R0,#+0
   \   000001B4   0x63A0             STR      R0,[R4, #+56]
    823                }
    824              }
    825              
    826              /* Clear STOP flag */
    827              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Slave_Transmit_18: (+1)
   \   000001B6   0x6821             LDR      R1,[R4, #+0]
   \   000001B8   0x2020             MOVS     R0,#+32
   \   000001BA   0x61C8             STR      R0,[R1, #+28]
    828              
    829              /* Wait until BUSY flag is reset */ 
    830              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
   \   000001BC   0x.... 0x....      BL       HAL_GetTick
   \   000001C0   0x4680             MOV      R8,R0
   \                     ??HAL_I2C_Slave_Transmit_20: (+1)
   \   000001C2   0x6820             LDR      R0,[R4, #+0]
   \   000001C4   0x6981             LDR      R1,[R0, #+24]
   \   000001C6   0x0409             LSLS     R1,R1,#+16
   \   000001C8   0xD517             BPL.N    ??HAL_I2C_Slave_Transmit_21
   \   000001CA   0xF117 0x0F01      CMN      R7,#+1
   \   000001CE   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Transmit_20
   \   000001D0   0xB12F             CBZ.N    R7,??HAL_I2C_Slave_Transmit_22
   \   000001D2   0x.... 0x....      BL       HAL_GetTick
   \   000001D6   0xEBA0 0x0008      SUB      R0,R0,R8
   \   000001DA   0x4287             CMP      R7,R0
   \   000001DC   0xD2F1             BCS.N    ??HAL_I2C_Slave_Transmit_20
   \                     ??HAL_I2C_Slave_Transmit_22: (+1)
   \   000001DE   0x2001             MOVS     R0,#+1
   \   000001E0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xF884 0x0034      STRB     R0,[R4, #+52]
    831              {
    832                /* Disable Address Acknowledge */
    833                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   000001EA   0x6820             LDR      R0,[R4, #+0]
   \   000001EC   0x6841             LDR      R1,[R0, #+4]
   \   000001EE   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001F2   0x6041             STR      R1,[R0, #+4]
    834                return HAL_TIMEOUT;
    835              }
   \                     ??HAL_I2C_Slave_Transmit_16: (+1)
   \   000001F4   0x2003             MOVS     R0,#+3
   \   000001F6   0xE8BD 0x81F0      POP      {R4-R8,PC}
    836              
    837              /* Disable Address Acknowledge */
    838              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Slave_Transmit_21: (+1)
   \   000001FA   0x6841             LDR      R1,[R0, #+4]
   \   000001FC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000200   0x6041             STR      R1,[R0, #+4]
    839          
    840              hi2c->State = HAL_I2C_STATE_READY;
   \   00000202   0x2001             MOVS     R0,#+1
   \   00000204   0xF884 0x0035      STRB     R0,[R4, #+53]
    841              
    842              /* Process Unlocked */
    843              __HAL_UNLOCK(hi2c);
   \   00000208   0x2000             MOVS     R0,#+0
   \   0000020A   0xF884 0x0034      STRB     R0,[R4, #+52]
    844              
    845              return HAL_OK;
   \   0000020E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    846            }
    847            else
    848            {
    849              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \   00000212   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \   00000214   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    850            }
    851          }
    852          
    853          /**
    854            * @brief  Receive in slave mode an amount of data in blocking mode 
    855            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    856            *                the configuration information for the specified I2C.
    857            * @param  pData: Pointer to data buffer
    858            * @param  Size: Amount of data to be sent
    859            * @param  Timeout: Timeout duration
    860            * @retval HAL status
    861            */

   \                                 In section .text, align 4, keep-with-next
    862          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    863          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
    864            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80C6      BNE.W    ??HAL_I2C_Slave_Receive_0
    865            {  
    866              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xBF18             IT       NE 
   \   0000001A   0xF1B8 0x0F00      CMPNE    R8,#+0
   \   0000001E   0xF000 0x80C1      BEQ.W    ??HAL_I2C_Slave_Receive_1
    867              {
    868                return  HAL_ERROR;                                    
    869              }
    870              
    871              /* Process Locked */
    872              __HAL_LOCK(hi2c);
   \   00000022   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xF000 0x80BB      BEQ.W    ??HAL_I2C_Slave_Receive_0
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
    873              
    874              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   \   00000032   0x2042             MOVS     R0,#+66
   \   00000034   0xF884 0x0035      STRB     R0,[R4, #+53]
    875              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x63A0             STR      R0,[R4, #+56]
    876              
    877              /* Enable Address Acknowledge */
    878              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6841             LDR      R1,[R0, #+4]
   \   00000040   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000044   0x6041             STR      R1,[R0, #+4]
    879          
    880              /* Wait until ADDR flag is set */
    881              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout) != HAL_OK)      
   \   00000046   0x.... 0x....      BL       HAL_GetTick
   \   0000004A   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6981             LDR      R1,[R0, #+24]
   \   00000050   0x0709             LSLS     R1,R1,#+28
   \   00000052   0xD40B             BMI.N    ??HAL_I2C_Slave_Receive_3
   \   00000054   0xF117 0x0F01      CMN      R7,#+1
   \   00000058   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Receive_2
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xF000 0x8087      BEQ.W    ??HAL_I2C_Slave_Receive_4
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0x1B80             SUBS     R0,R0,R6
   \   00000066   0x4287             CMP      R7,R0
   \   00000068   0xD2F0             BCS.N    ??HAL_I2C_Slave_Receive_2
   \   0000006A   0xE080             B.N      ??HAL_I2C_Slave_Receive_4
    882              {
    883                /* Disable Address Acknowledge */
    884                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    885                return HAL_TIMEOUT;
    886              }
    887          
    888              /* Clear ADDR flag */
    889              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \   0000006C   0x2108             MOVS     R1,#+8
   \   0000006E   0x61C1             STR      R1,[R0, #+28]
    890              
    891              /* Wait until DIR flag is reset Receiver mode */
    892              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, Timeout) != HAL_OK)      
   \   00000070   0x.... 0x....      BL       HAL_GetTick
   \   00000074   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6980             LDR      R0,[R0, #+24]
   \   0000007A   0x03C0             LSLS     R0,R0,#+15
   \   0000007C   0xD50A             BPL.N    ??HAL_I2C_Slave_Receive_6
   \   0000007E   0xF117 0x0F01      CMN      R7,#+1
   \   00000082   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Receive_5
   \   00000084   0x2F00             CMP      R7,#+0
   \   00000086   0xD072             BEQ.N    ??HAL_I2C_Slave_Receive_4
   \   00000088   0x.... 0x....      BL       HAL_GetTick
   \   0000008C   0x1B80             SUBS     R0,R0,R6
   \   0000008E   0x4287             CMP      R7,R0
   \   00000090   0xD2F1             BCS.N    ??HAL_I2C_Slave_Receive_5
   \   00000092   0xE06C             B.N      ??HAL_I2C_Slave_Receive_4
    893              {
    894                /* Disable Address Acknowledge */
    895                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    896                return HAL_TIMEOUT;
    897              }
    898          
    899              while(Size > 0)
    900              {
    901                /* Wait until RXNE flag is set */
    902                if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout) != HAL_OK)      
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \   00000094   0x.... 0x....      BL       HAL_GetTick
   \   00000098   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6981             LDR      R1,[R0, #+24]
   \   0000009E   0x0749             LSLS     R1,R1,#+29
   \   000000A0   0xD427             BMI.N    ??HAL_I2C_Slave_Receive_8
   \   000000A2   0x6981             LDR      R1,[R0, #+24]
   \   000000A4   0x0689             LSLS     R1,R1,#+26
   \   000000A6   0xD51A             BPL.N    ??HAL_I2C_Slave_Receive_9
   \   000000A8   0x2120             MOVS     R1,#+32
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable8_2  ;; 0xfe00e800
   \   000000AE   0x61C1             STR      R1,[R0, #+28]
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
   \   000000B2   0x6841             LDR      R1,[R0, #+4]
   \   000000B4   0x4011             ANDS     R1,R2,R1
   \   000000B6   0x6041             STR      R1,[R0, #+4]
   \   000000B8   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Slave_Receive_10: (+1)
   \   000000BA   0x63A0             STR      R0,[R4, #+56]
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF884 0x0034      STRB     R0,[R4, #+52]
    903                {
    904                  /* Disable Address Acknowledge */
    905                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x6841             LDR      R1,[R0, #+4]
   \   000000CC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000D0   0x6041             STR      R1,[R0, #+4]
    906                  if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
   \   000000D2   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D4   0x2820             CMP      R0,#+32
   \   000000D6   0xD135             BNE.N    ??HAL_I2C_Slave_Receive_11
    907                  {
    908                    return HAL_TIMEOUT;
    909                  }
    910                  else
    911                  {
    912                    return HAL_ERROR;
    913                  }
    914                }
    915                
    916                /* Read data from RXDR */
    917                (*pData++) = hi2c->Instance->RXDR;
    918                Size--;
    919              }
    920              
    921              /* Wait until STOP flag is set */
    922              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
    923              {
    924                /* Disable Address Acknowledge */
    925                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    926          
    927                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    928                {
    929                  return HAL_ERROR;
    930                }
    931                else
    932                {
    933                  return HAL_TIMEOUT;
    934                }
    935              }
    936          
    937              /* Clear STOP flag */
    938              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
    939              
    940              /* Wait until BUSY flag is reset */ 
    941              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, Timeout) != HAL_OK)      
    942              {
    943                /* Disable Address Acknowledge */
    944                hi2c->Instance->CR2 |= I2C_CR2_NACK;
    945                return HAL_TIMEOUT;
   \   000000D8   0x2003             MOVS     R0,#+3
   \   000000DA   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \   000000DE   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Receive_12
   \   000000E0   0x.... 0x....      BL       HAL_GetTick
   \   000000E4   0x1B80             SUBS     R0,R0,R6
   \   000000E6   0x4287             CMP      R7,R0
   \   000000E8   0xD2D7             BCS.N    ??HAL_I2C_Slave_Receive_7
   \                     ??HAL_I2C_Slave_Receive_12: (+1)
   \   000000EA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000EC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000F0   0xE7E3             B.N      ??HAL_I2C_Slave_Receive_10
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \   000000F2   0x6A40             LDR      R0,[R0, #+36]
   \   000000F4   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000000F8   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   000000FC   0xD1CA             BNE.N    ??HAL_I2C_Slave_Receive_6
   \   000000FE   0x.... 0x....      BL       HAL_GetTick
   \   00000102   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Receive_13: (+1)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6981             LDR      R1,[R0, #+24]
   \   00000108   0x0689             LSLS     R1,R1,#+26
   \   0000010A   0xD41E             BMI.N    ??HAL_I2C_Slave_Receive_14
   \   0000010C   0x2119             MOVS     R1,#+25
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000114   0xB970             CBNZ.N   R0,??HAL_I2C_Slave_Receive_15
   \   00000116   0x.... 0x....      BL       HAL_GetTick
   \   0000011A   0x1B40             SUBS     R0,R0,R5
   \   0000011C   0x281A             CMP      R0,#+26
   \   0000011E   0xD3F1             BCC.N    ??HAL_I2C_Slave_Receive_13
   \   00000120   0x6BA0             LDR      R0,[R4, #+56]
   \   00000122   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000126   0x63A0             STR      R0,[R4, #+56]
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Slave_Receive_15: (+1)
   \   00000134   0x6820             LDR      R0,[R4, #+0]
   \   00000136   0x6841             LDR      R1,[R0, #+4]
   \   00000138   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000013C   0x6041             STR      R1,[R0, #+4]
   \   0000013E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000140   0x2804             CMP      R0,#+4
   \   00000142   0xD11F             BNE.N    ??HAL_I2C_Slave_Receive_16
   \                     ??HAL_I2C_Slave_Receive_11: (+1)
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_I2C_Slave_Receive_14: (+1)
   \   0000014A   0x2120             MOVS     R1,#+32
   \   0000014C   0x61C1             STR      R1,[R0, #+28]
   \   0000014E   0x.... 0x....      BL       HAL_GetTick
   \   00000152   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Receive_17: (+1)
   \   00000154   0x6820             LDR      R0,[R4, #+0]
   \   00000156   0x6981             LDR      R1,[R0, #+24]
   \   00000158   0x0409             LSLS     R1,R1,#+16
   \   0000015A   0xD516             BPL.N    ??HAL_I2C_Slave_Receive_18
   \   0000015C   0xF117 0x0F01      CMN      R7,#+1
   \   00000160   0xD0F8             BEQ.N    ??HAL_I2C_Slave_Receive_17
   \   00000162   0xB127             CBZ.N    R7,??HAL_I2C_Slave_Receive_4
   \   00000164   0x.... 0x....      BL       HAL_GetTick
   \   00000168   0x1B40             SUBS     R0,R0,R5
   \   0000016A   0x4287             CMP      R7,R0
   \   0000016C   0xD2F2             BCS.N    ??HAL_I2C_Slave_Receive_17
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000017A   0x6820             LDR      R0,[R4, #+0]
   \   0000017C   0x6841             LDR      R1,[R0, #+4]
   \   0000017E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000182   0x6041             STR      R1,[R0, #+4]
   \                     ??HAL_I2C_Slave_Receive_16: (+1)
   \   00000184   0x2003             MOVS     R0,#+3
   \   00000186   0xE8BD 0x81F0      POP      {R4-R8,PC}
    946              }
    947          
    948              
    949              /* Disable Address Acknowledge */
    950              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Slave_Receive_18: (+1)
   \   0000018A   0x6841             LDR      R1,[R0, #+4]
   \   0000018C   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000190   0x6041             STR      R1,[R0, #+4]
    951              
    952              hi2c->State = HAL_I2C_STATE_READY;
   \   00000192   0x2001             MOVS     R0,#+1
   \   00000194   0xF884 0x0035      STRB     R0,[R4, #+53]
    953          
    954              /* Process Unlocked */
    955              __HAL_UNLOCK(hi2c);
   \   00000198   0x2000             MOVS     R0,#+0
   \   0000019A   0xF884 0x0034      STRB     R0,[R4, #+52]
    956              
    957              return HAL_OK;
   \   0000019E   0xE8BD 0x81F0      POP      {R4-R8,PC}
    958            }
    959            else
    960            {
    961              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \   000001A2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \   000001A4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    962            } 
    963          }
    964          
    965          /**
    966            * @brief  Transmit in master mode an amount of data in no-blocking mode with Interrupt
    967            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
    968            *                the configuration information for the specified I2C.
    969            * @param  DevAddress: Target device address
    970            * @param  pData: Pointer to data buffer
    971            * @param  Size: Amount of data to be sent
    972            * @retval HAL status
    973            */

   \                                 In section .text, align 2, keep-with-next
    974          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
    975          {   
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    976            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000002   0xF890 0x4035      LDRB     R4,[R0, #+53]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD147             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
    977            {
    978              if((pData == NULL) || (Size == 0)) 
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xBF14             ITE      NE 
   \   0000000E   0x2B00             CMPNE    R3,#+0
   \   00000010   0x2001             MOVEQ    R0,#+1
    979              {
    980                return  HAL_ERROR;                                    
   \   00000012   0xD043             BEQ.N    ??HAL_I2C_Master_Transmit_IT_1
    981              }
    982              
    983              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000014   0x6804             LDR      R4,[R0, #+0]
   \   00000016   0x69A5             LDR      R5,[R4, #+24]
   \   00000018   0x042D             LSLS     R5,R5,#+16
   \   0000001A   0xD43E             BMI.N    ??HAL_I2C_Master_Transmit_IT_0
    984              {
    985                return HAL_BUSY;
    986              }
    987          
    988              /* Process Locked */
    989              __HAL_LOCK(hi2c);
   \   0000001C   0xF890 0x5034      LDRB     R5,[R0, #+52]
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD03A             BEQ.N    ??HAL_I2C_Master_Transmit_IT_0
   \   00000024   0x2501             MOVS     R5,#+1
   \   00000026   0xF880 0x5034      STRB     R5,[R0, #+52]
    990              
    991              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
   \   0000002A   0x2512             MOVS     R5,#+18
   \   0000002C   0xF880 0x5035      STRB     R5,[R0, #+53]
    992              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000030   0x2500             MOVS     R5,#+0
   \   00000032   0x6385             STR      R5,[R0, #+56]
    993              
    994              hi2c->pBuffPtr = pData;
    995              hi2c->XferCount = Size;
    996              if(Size > 255)
   \   00000034   0x2BFF             CMP      R3,#+255
   \   00000036   0x6242             STR      R2,[R0, #+36]
   \   00000038   0x8543             STRH     R3,[R0, #+42]
   \   0000003A   0xBFC6             ITTE     GT 
   \   0000003C   0x22FF             MOVGT    R2,#+255
   \   0000003E   0x8502             STRHGT   R2,[R0, #+40]
   \   00000040   0x8503             STRHLE   R3,[R0, #+40]
    997              {
    998                hi2c->XferSize = 255;
    999              }
   1000              else
   1001              {
   1002                hi2c->XferSize = Size;
   1003              }
   1004              
   1005              /* Send Slave Address */
   1006              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1007              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000042   0x8D02             LDRH     R2,[R0, #+40]
   \   00000044   0x2AFF             CMP      R2,#+255
   \   00000046   0xD10E             BNE.N    ??HAL_I2C_Master_Transmit_IT_2
   \   00000048   0x8D43             LDRH     R3,[R0, #+42]
   \   0000004A   0x429A             CMP      R2,R3
   \   0000004C   0xD20B             BCS.N    ??HAL_I2C_Master_Transmit_IT_2
   1008              {
   1009                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   0000004E   0x6863             LDR      R3,[R4, #+4]
   \   00000050   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0xfc009800
   \   00000054   0x0589             LSLS     R1,R1,#+22
   \   00000056   0x402B             ANDS     R3,R5,R3
   \   00000058   0xEA53 0x5191      ORRS     R1,R3,R1, LSR #+22
   \   0000005C   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000060   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000064   0xE00B             B.N      ??HAL_I2C_Master_Transmit_IT_3
   1010              }
   1011              else
   1012              {
   1013                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_IT_2: (+1)
   \   00000066   0x6863             LDR      R3,[R4, #+4]
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0xfc009800
   \   0000006C   0x0589             LSLS     R1,R1,#+22
   \   0000006E   0xB2D2             UXTB     R2,R2
   \   00000070   0x402B             ANDS     R3,R5,R3
   \   00000072   0xEA53 0x5191      ORRS     R1,R3,R1, LSR #+22
   \   00000076   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000007A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Master_Transmit_IT_3: (+1)
   \   0000007E   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000082   0x6061             STR      R1,[R4, #+4]
   1014              }
   1015              
   1016              /* Process Unlocked */
   1017              __HAL_UNLOCK(hi2c); 
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0xF880 0x1034      STRB     R1,[R0, #+52]
   1018          
   1019              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1020                        to avoid the risk of I2C interrupt handle execution before current
   1021                        process unlock */
   1022          
   1023          
   1024              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1025              /* possible to enable all of these */
   1026              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1027              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x01F2      ORR      R1,R1,#0xF2
   \   00000092   0x6001             STR      R1,[R0, #+0]
   1028                  
   1029              return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBC30             POP      {R4,R5}
   \   00000098   0x4770             BX       LR
   1030            }
   1031            else
   1032            {
   1033              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \   0000009A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_IT_1: (+1)
   \   0000009C   0xBC30             POP      {R4,R5}
   \   0000009E   0x4770             BX       LR               ;; return
   1034            } 
   1035          }
   1036          
   1037          /**
   1038            * @brief  Receive in master mode an amount of data in no-blocking mode with Interrupt
   1039            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1040            *                the configuration information for the specified I2C.
   1041            * @param  DevAddress: Target device address
   1042            * @param  pData: Pointer to data buffer
   1043            * @param  Size: Amount of data to be sent
   1044            * @retval HAL status
   1045            */

   \                                 In section .text, align 2, keep-with-next
   1046          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1047          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1048            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000002   0xF890 0x4035      LDRB     R4,[R0, #+53]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD147             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1049            {
   1050              if((pData == NULL) || (Size == 0)) 
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xBF14             ITE      NE 
   \   0000000E   0x2B00             CMPNE    R3,#+0
   \   00000010   0x2001             MOVEQ    R0,#+1
   1051              {
   1052                return  HAL_ERROR;                                    
   \   00000012   0xD043             BEQ.N    ??HAL_I2C_Master_Receive_IT_1
   1053              }
   1054              
   1055              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000014   0x6804             LDR      R4,[R0, #+0]
   \   00000016   0x69A5             LDR      R5,[R4, #+24]
   \   00000018   0x042D             LSLS     R5,R5,#+16
   \   0000001A   0xD43E             BMI.N    ??HAL_I2C_Master_Receive_IT_0
   1056              {
   1057                return HAL_BUSY;
   1058              }
   1059          
   1060              /* Process Locked */
   1061              __HAL_LOCK(hi2c);
   \   0000001C   0xF890 0x5034      LDRB     R5,[R0, #+52]
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD03A             BEQ.N    ??HAL_I2C_Master_Receive_IT_0
   \   00000024   0x2501             MOVS     R5,#+1
   \   00000026   0xF880 0x5034      STRB     R5,[R0, #+52]
   1062              
   1063              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
   \   0000002A   0x2522             MOVS     R5,#+34
   \   0000002C   0xF880 0x5035      STRB     R5,[R0, #+53]
   1064              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000030   0x2500             MOVS     R5,#+0
   \   00000032   0x6385             STR      R5,[R0, #+56]
   1065              
   1066              hi2c->pBuffPtr = pData;
   1067              hi2c->XferCount = Size;
   1068              if(Size > 255)
   \   00000034   0x2BFF             CMP      R3,#+255
   \   00000036   0x6242             STR      R2,[R0, #+36]
   \   00000038   0x8543             STRH     R3,[R0, #+42]
   \   0000003A   0xBFC6             ITTE     GT 
   \   0000003C   0x22FF             MOVGT    R2,#+255
   \   0000003E   0x8502             STRHGT   R2,[R0, #+40]
   \   00000040   0x8503             STRHLE   R3,[R0, #+40]
   1069              {
   1070                hi2c->XferSize = 255;
   1071              }
   1072              else
   1073              {
   1074                hi2c->XferSize = Size;
   1075              }
   1076              
   1077              /* Send Slave Address */
   1078              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1079              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000042   0x8D02             LDRH     R2,[R0, #+40]
   \   00000044   0x2AFF             CMP      R2,#+255
   \   00000046   0xD10E             BNE.N    ??HAL_I2C_Master_Receive_IT_2
   \   00000048   0x8D43             LDRH     R3,[R0, #+42]
   \   0000004A   0x429A             CMP      R2,R3
   \   0000004C   0xD20B             BCS.N    ??HAL_I2C_Master_Receive_IT_2
   1080              {
   1081                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   0000004E   0x6863             LDR      R3,[R4, #+4]
   \   00000050   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0xfc009800
   \   00000054   0x0589             LSLS     R1,R1,#+22
   \   00000056   0x402B             ANDS     R3,R5,R3
   \   00000058   0xEA53 0x5191      ORRS     R1,R3,R1, LSR #+22
   \   0000005C   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000060   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000064   0xE00B             B.N      ??HAL_I2C_Master_Receive_IT_3
   1082              }
   1083              else
   1084              {
   1085                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_IT_2: (+1)
   \   00000066   0x6863             LDR      R3,[R4, #+4]
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0xfc009800
   \   0000006C   0x0589             LSLS     R1,R1,#+22
   \   0000006E   0xB2D2             UXTB     R2,R2
   \   00000070   0x402B             ANDS     R3,R5,R3
   \   00000072   0xEA53 0x5191      ORRS     R1,R3,R1, LSR #+22
   \   00000076   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000007A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Master_Receive_IT_3: (+1)
   \   0000007E   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   00000082   0x6061             STR      R1,[R4, #+4]
   1086              }
   1087              
   1088              /* Process Unlocked */
   1089              __HAL_UNLOCK(hi2c); 
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0xF880 0x1034      STRB     R1,[R0, #+52]
   1090          
   1091              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1092                        to avoid the risk of I2C interrupt handle execution before current
   1093                        process unlock */
   1094              
   1095              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1096              /* possible to enable all of these */
   1097              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1098              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI );
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x01F4      ORR      R1,R1,#0xF4
   \   00000092   0x6001             STR      R1,[R0, #+0]
   1099              
   1100              return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBC30             POP      {R4,R5}
   \   00000098   0x4770             BX       LR
   1101            }
   1102            else
   1103            {
   1104              return HAL_BUSY; 
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \   0000009A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_IT_1: (+1)
   \   0000009C   0xBC30             POP      {R4,R5}
   \   0000009E   0x4770             BX       LR               ;; return
   1105            } 
   1106          }
   1107          
   1108          /**
   1109            * @brief  Transmit in slave mode an amount of data in no-blocking mode with Interrupt 
   1110            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1111            *                the configuration information for the specified I2C.
   1112            * @param  pData: Pointer to data buffer
   1113            * @param  Size: Amount of data to be sent
   1114            * @retval HAL status
   1115            */

   \                                 In section .text, align 2, keep-with-next
   1116          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1117          {
   1118            if(hi2c->State == HAL_I2C_STATE_READY)
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \   00000000   0xF890 0x3035      LDRB     R3,[R0, #+53]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD125             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1119            {
   1120              if((pData == NULL) || (Size == 0)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_1
   1121              {
   1122                return  HAL_ERROR;                                    
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   1123              }
   1124              
   1125              /* Process Locked */
   1126              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_IT_1: (+1)
   \   00000014   0xF890 0x3034      LDRB     R3,[R0, #+52]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD01B             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF880 0x3034      STRB     R3,[R0, #+52]
   1127              
   1128              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
   \   00000022   0x2332             MOVS     R3,#+50
   \   00000024   0xF880 0x3035      STRB     R3,[R0, #+53]
   1129              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x6383             STR      R3,[R0, #+56]
   1130              
   1131              /* Enable Address Acknowledge */
   1132              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   0000002C   0x6803             LDR      R3,[R0, #+0]
   \   0000002E   0xF8D3 0xC004      LDR      R12,[R3, #+4]
   \   00000032   0xF42C 0x4C00      BIC      R12,R12,#0x8000
   \   00000036   0xF8C3 0xC004      STR      R12,[R3, #+4]
   1133          
   1134              hi2c->pBuffPtr = pData;
   \   0000003A   0x6241             STR      R1,[R0, #+36]
   1135              hi2c->XferSize = Size;
   1136              hi2c->XferCount = Size;
   1137              
   1138              /* Process Unlocked */
   1139              __HAL_UNLOCK(hi2c); 
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x8502             STRH     R2,[R0, #+40]
   \   00000040   0x8542             STRH     R2,[R0, #+42]
   \   00000042   0xF880 0x1034      STRB     R1,[R0, #+52]
   1140          
   1141              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1142                        to avoid the risk of I2C interrupt handle execution before current
   1143                        process unlock */
   1144              
   1145              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1146              /* possible to enable all of these */
   1147              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1148              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_TXI );
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x01FA      ORR      R1,R1,#0xFA
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1149              
   1150              return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR
   1151            }
   1152            else
   1153            {
   1154              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x4770             BX       LR               ;; return
   1155            } 
   1156          }
   1157          
   1158          /**
   1159            * @brief  Receive in slave mode an amount of data in no-blocking mode with Interrupt 
   1160            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1161            *                the configuration information for the specified I2C.
   1162            * @param  pData: Pointer to data buffer
   1163            * @param  Size: Amount of data to be sent
   1164            * @retval HAL status
   1165            */

   \                                 In section .text, align 2, keep-with-next
   1166          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1167          {
   1168            if(hi2c->State == HAL_I2C_STATE_READY)
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \   00000000   0xF890 0x3035      LDRB     R3,[R0, #+53]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xD125             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1169            {
   1170              if((pData == NULL) || (Size == 0)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_1
   1171              {
   1172                return  HAL_ERROR;                                    
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   1173              }
   1174              
   1175              /* Process Locked */
   1176              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_IT_1: (+1)
   \   00000014   0xF890 0x3034      LDRB     R3,[R0, #+52]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD01B             BEQ.N    ??HAL_I2C_Slave_Receive_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF880 0x3034      STRB     R3,[R0, #+52]
   1177              
   1178              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   \   00000022   0x2342             MOVS     R3,#+66
   \   00000024   0xF880 0x3035      STRB     R3,[R0, #+53]
   1179              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0x6383             STR      R3,[R0, #+56]
   1180              
   1181              /* Enable Address Acknowledge */
   1182              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   0000002C   0x6803             LDR      R3,[R0, #+0]
   \   0000002E   0xF8D3 0xC004      LDR      R12,[R3, #+4]
   \   00000032   0xF42C 0x4C00      BIC      R12,R12,#0x8000
   \   00000036   0xF8C3 0xC004      STR      R12,[R3, #+4]
   1183          
   1184              hi2c->pBuffPtr = pData;
   \   0000003A   0x6241             STR      R1,[R0, #+36]
   1185              hi2c->XferSize = Size;
   1186              hi2c->XferCount = Size;
   1187              
   1188              /* Process Unlocked */
   1189              __HAL_UNLOCK(hi2c); 
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x8502             STRH     R2,[R0, #+40]
   \   00000040   0x8542             STRH     R2,[R0, #+42]
   \   00000042   0xF880 0x1034      STRB     R1,[R0, #+52]
   1190          
   1191              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1192                        to avoid the risk of I2C interrupt handle execution before current
   1193                        process unlock */
   1194              
   1195              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1196              /* possible to enable all of these */
   1197              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1198              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI);
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x01FC      ORR      R1,R1,#0xFC
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1199              
   1200              return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x4770             BX       LR
   1201            }
   1202            else
   1203            {
   1204              return HAL_BUSY; 
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x4770             BX       LR               ;; return
   1205            }
   1206          }
   1207          
   1208          /**
   1209            * @brief  Transmit in master mode an amount of data in no-blocking mode with DMA
   1210            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1211            *                the configuration information for the specified I2C.
   1212            * @param  DevAddress: Target device address
   1213            * @param  pData: Pointer to data buffer
   1214            * @param  Size: Amount of data to be sent
   1215            * @retval HAL status
   1216            */

   \                                 In section .text, align 2, keep-with-next
   1217          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1218          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
   1219            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD17A             BNE.N    ??HAL_I2C_Master_Transmit_DMA_0
   1220            {
   1221              if((pData == NULL) || (Size == 0)) 
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2B00             CMPNE    R3,#+0
   \   00000018   0xD077             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_1
   1222              {
   1223                return  HAL_ERROR;                                    
   1224              }     
   1225          
   1226              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0x0400             LSLS     R0,R0,#+16
   \   00000020   0xD472             BMI.N    ??HAL_I2C_Master_Transmit_DMA_0
   1227              {
   1228                return HAL_BUSY;
   1229              }
   1230          
   1231              /* Process Locked */
   1232              __HAL_LOCK(hi2c);
   \   00000022   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD06E             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_0
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF884 0x0034      STRB     R0,[R4, #+52]
   1233              
   1234              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_TX;
   \   00000030   0x2012             MOVS     R0,#+18
   \   00000032   0xF884 0x0035      STRB     R0,[R4, #+53]
   1235              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x63A0             STR      R0,[R4, #+56]
   1236              
   1237              hi2c->pBuffPtr = pData;
   1238              hi2c->XferCount = Size;
   1239              if(Size > 255)
   \   0000003A   0x2BFF             CMP      R3,#+255
   \   0000003C   0x6261             STR      R1,[R4, #+36]
   \   0000003E   0x8563             STRH     R3,[R4, #+42]
   \   00000040   0xBFC6             ITTE     GT 
   \   00000042   0x20FF             MOVGT    R0,#+255
   \   00000044   0x8520             STRHGT   R0,[R4, #+40]
   \   00000046   0x8523             STRHLE   R3,[R4, #+40]
   1240              {
   1241                hi2c->XferSize = 255;
   1242              }
   1243              else
   1244              {
   1245                hi2c->XferSize = Size;
   1246              }
   1247              
   1248              /* Set the I2C DMA transfer complete callback */
   1249              hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
   \   00000048   0x6AE2             LDR      R2,[R4, #+44]
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000004E   0x63D0             STR      R0,[R2, #+60]
   1250              
   1251              /* Set the DMA error callback */
   1252              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \   00000050   0x6AE2             LDR      R2,[R4, #+44]
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000056   0x6490             STR      R0,[R2, #+72]
   1253              
   1254              /* Enable the DMA channel */
   1255              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x8D23             LDRH     R3,[R4, #+40]
   \   0000005C   0xF100 0x0228      ADD      R2,R0,#+40
   \   00000060   0x6AE0             LDR      R0,[R4, #+44]
   \   00000062   0x.... 0x....      BL       HAL_DMA_Start_IT
   1256              
   1257              /* Send Slave Address */
   1258              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1259              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000066   0x8D21             LDRH     R1,[R4, #+40]
   \   00000068   0x29FF             CMP      R1,#+255
   \   0000006A   0xD10E             BNE.N    ??HAL_I2C_Master_Transmit_DMA_2
   \   0000006C   0x8D60             LDRH     R0,[R4, #+42]
   \   0000006E   0x4281             CMP      R1,R0
   \   00000070   0xD20B             BCS.N    ??HAL_I2C_Master_Transmit_DMA_2
   1260              {
   1261                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x....             LDR.N    R3,??DataTable8  ;; 0xfc009800
   \   00000076   0x6842             LDR      R2,[R0, #+4]
   \   00000078   0x401A             ANDS     R2,R3,R2
   \   0000007A   0x05AB             LSLS     R3,R5,#+22
   \   0000007C   0xEA52 0x5293      ORRS     R2,R2,R3, LSR #+22
   \   00000080   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000084   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000088   0xE00B             B.N      ??HAL_I2C_Master_Transmit_DMA_3
   1262              }
   1263              else
   1264              {
   1265                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x....             LDR.N    R3,??DataTable8  ;; 0xfc009800
   \   0000008E   0xB2C9             UXTB     R1,R1
   \   00000090   0x6842             LDR      R2,[R0, #+4]
   \   00000092   0x401A             ANDS     R2,R3,R2
   \   00000094   0x05AB             LSLS     R3,R5,#+22
   \   00000096   0xEA52 0x5293      ORRS     R2,R2,R3, LSR #+22
   \   0000009A   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000009E   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \   000000A2   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   1266              }  
   1267          
   1268              /* Wait until TXIS flag is set */
   1269              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   000000A8   0x.... 0x....      BL       HAL_GetTick
   \   000000AC   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6981             LDR      R1,[R0, #+24]
   \   000000B2   0x0789             LSLS     R1,R1,#+30
   \   000000B4   0xD41F             BMI.N    ??HAL_I2C_Master_Transmit_DMA_5
   \   000000B6   0x2119             MOVS     R1,#+25
   \   000000B8   0x4620             MOV      R0,R4
   \   000000BA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000BE   0xB970             CBNZ.N   R0,??HAL_I2C_Master_Transmit_DMA_6
   \   000000C0   0x.... 0x....      BL       HAL_GetTick
   \   000000C4   0x1B40             SUBS     R0,R0,R5
   \   000000C6   0x281A             CMP      R0,#+26
   \   000000C8   0xD3F1             BCC.N    ??HAL_I2C_Master_Transmit_DMA_4
   \   000000CA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000D0   0x63A0             STR      R0,[R4, #+56]
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x0034      STRB     R0,[R4, #+52]
   1270              {
   1271                /* Disable Address Acknowledge */
   1272                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \                     ??HAL_I2C_Master_Transmit_DMA_6: (+1)
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6841             LDR      R1,[R0, #+4]
   \   000000E2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000E6   0x6041             STR      R1,[R0, #+4]
   1273          
   1274                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \   000000E8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000EA   0x2804             CMP      R0,#+4
   \   000000EC   0xBF14             ITE      NE 
   \   000000EE   0x2003             MOVNE    R0,#+3
   \   000000F0   0x2001             MOVEQ    R0,#+1
   1275                {
   1276                  return HAL_ERROR;
   1277                }
   1278                else
   1279                {
   1280                  return HAL_TIMEOUT;
   \   000000F2   0xB001             ADD      SP,SP,#+4
   \   000000F4   0xBD30             POP      {R4,R5,PC}
   1281                }
   1282              }
   1283          
   1284              
   1285              /* Enable DMA Request */
   1286              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;   
   \                     ??HAL_I2C_Master_Transmit_DMA_5: (+1)
   \   000000F6   0x6801             LDR      R1,[R0, #+0]
   \   000000F8   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000FC   0x6001             STR      R1,[R0, #+0]
   1287              
   1288              /* Process Unlocked */
   1289              __HAL_UNLOCK(hi2c);
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xF884 0x0034      STRB     R0,[R4, #+52]
   1290              
   1291              return HAL_OK;
   \   00000104   0xB001             ADD      SP,SP,#+4
   \   00000106   0xBD30             POP      {R4,R5,PC}
   1292            }
   1293            else
   1294            {
   1295              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \   00000108   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \   0000010A   0xB001             ADD      SP,SP,#+4
   \   0000010C   0xBD30             POP      {R4,R5,PC}       ;; return
   1296            }
   1297          }
   1298          
   1299          /**
   1300            * @brief  Receive in master mode an amount of data in no-blocking mode with DMA 
   1301            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1302            *                the configuration information for the specified I2C.
   1303            * @param  DevAddress: Target device address
   1304            * @param  pData: Pointer to data buffer
   1305            * @param  Size: Amount of data to be sent
   1306            * @retval HAL status
   1307            */

   \                                 In section .text, align 2, keep-with-next
   1308          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1309          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   1310            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000008   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD168             BNE.N    ??HAL_I2C_Master_Receive_DMA_0
   1311            {
   1312              if((pData == NULL) || (Size == 0)) 
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xBF18             IT       NE 
   \   00000014   0x2B00             CMPNE    R3,#+0
   \   00000016   0xD065             BEQ.N    ??HAL_I2C_Master_Receive_DMA_1
   1313              {
   1314                return  HAL_ERROR;                                    
   1315              }  
   1316          
   1317              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6980             LDR      R0,[R0, #+24]
   \   0000001C   0x0400             LSLS     R0,R0,#+16
   \   0000001E   0xD460             BMI.N    ??HAL_I2C_Master_Receive_DMA_0
   1318              {
   1319                return HAL_BUSY;
   1320              }
   1321          
   1322              /* Process Locked */
   1323              __HAL_LOCK(hi2c);
   \   00000020   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD05C             BEQ.N    ??HAL_I2C_Master_Receive_DMA_0
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0034      STRB     R0,[R4, #+52]
   1324              
   1325              hi2c->State = HAL_I2C_STATE_MASTER_BUSY_RX;
   \   0000002E   0x2022             MOVS     R0,#+34
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   1326              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x63A0             STR      R0,[R4, #+56]
   1327              
   1328              hi2c->pBuffPtr = pData;
   1329              hi2c->XferCount = Size;
   1330              if(Size > 255)
   \   00000038   0x2BFF             CMP      R3,#+255
   \   0000003A   0x6262             STR      R2,[R4, #+36]
   \   0000003C   0x8563             STRH     R3,[R4, #+42]
   \   0000003E   0xBFC6             ITTE     GT 
   \   00000040   0x20FF             MOVGT    R0,#+255
   \   00000042   0x8520             STRHGT   R0,[R4, #+40]
   \   00000044   0x8523             STRHLE   R3,[R4, #+40]
   1331              {
   1332                hi2c->XferSize = 255;
   1333              }
   1334              else
   1335              {
   1336                hi2c->XferSize = Size;
   1337              }
   1338              
   1339              /* Set the I2C DMA transfer complete callback */
   1340              hi2c->hdmarx->XferCpltCallback = I2C_DMAMasterReceiveCplt;
   \   00000046   0x6B21             LDR      R1,[R4, #+48]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000004C   0x63C8             STR      R0,[R1, #+60]
   1341              
   1342              /* Set the DMA error callback */
   1343              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \   0000004E   0x6B21             LDR      R1,[R4, #+48]
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000054   0x6488             STR      R0,[R1, #+72]
   1344              
   1345              /* Enable the DMA channel */
   1346              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x8D23             LDRH     R3,[R4, #+40]
   \   0000005A   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000005E   0x6B20             LDR      R0,[R4, #+48]
   \   00000060   0x.... 0x....      BL       HAL_DMA_Start_IT
   1347              
   1348              /* Send Slave Address */
   1349              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1350              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000064   0x8D21             LDRH     R1,[R4, #+40]
   \   00000066   0x29FF             CMP      R1,#+255
   \   00000068   0xD10E             BNE.N    ??HAL_I2C_Master_Receive_DMA_2
   \   0000006A   0x8D60             LDRH     R0,[R4, #+42]
   \   0000006C   0x4281             CMP      R1,R0
   \   0000006E   0xD20B             BCS.N    ??HAL_I2C_Master_Receive_DMA_2
   1351              {
   1352                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x....             LDR.N    R3,??DataTable8  ;; 0xfc009800
   \   00000074   0x6842             LDR      R2,[R0, #+4]
   \   00000076   0x401A             ANDS     R2,R3,R2
   \   00000078   0x05AB             LSLS     R3,R5,#+22
   \   0000007A   0xEA52 0x5293      ORRS     R2,R2,R3, LSR #+22
   \   0000007E   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000082   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000086   0xE00B             B.N      ??HAL_I2C_Master_Receive_DMA_3
   1353              }
   1354              else
   1355              {
   1356                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x....             LDR.N    R3,??DataTable8  ;; 0xfc009800
   \   0000008C   0xB2C9             UXTB     R1,R1
   \   0000008E   0x6842             LDR      R2,[R0, #+4]
   \   00000090   0x401A             ANDS     R2,R3,R2
   \   00000092   0x05AB             LSLS     R3,R5,#+22
   \   00000094   0xEA52 0x5293      ORRS     R2,R2,R3, LSR #+22
   \   00000098   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000009C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \   000000A0   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   000000A4   0x6041             STR      R1,[R0, #+4]
   1357              }
   1358          
   1359              /* Wait until RXNE flag is set */
   1360              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   000000A6   0x.... 0x....      BL       HAL_GetTick
   \   000000AA   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \   000000AC   0x6820             LDR      R0,[R4, #+0]
   \   000000AE   0x6981             LDR      R1,[R0, #+24]
   \   000000B0   0x0749             LSLS     R1,R1,#+29
   \   000000B2   0xD40D             BMI.N    ??HAL_I2C_Master_Receive_DMA_5
   \   000000B4   0x.... 0x....      BL       HAL_GetTick
   \   000000B8   0x1B40             SUBS     R0,R0,R5
   \   000000BA   0x281A             CMP      R0,#+26
   \   000000BC   0xD3F6             BCC.N    ??HAL_I2C_Master_Receive_DMA_4
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xF884 0x0034      STRB     R0,[R4, #+52]
   1361              {
   1362                return HAL_TIMEOUT;
   \   000000CA   0x2003             MOVS     R0,#+3
   \   000000CC   0xB001             ADD      SP,SP,#+4
   \   000000CE   0xBD30             POP      {R4,R5,PC}
   1363              }
   1364          
   1365              
   1366              /* Enable DMA Request */
   1367              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;   
   \                     ??HAL_I2C_Master_Receive_DMA_5: (+1)
   \   000000D0   0x6801             LDR      R1,[R0, #+0]
   \   000000D2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000D6   0x6001             STR      R1,[R0, #+0]
   1368              
   1369              /* Process Unlocked */
   1370              __HAL_UNLOCK(hi2c);
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x0034      STRB     R0,[R4, #+52]
   1371              
   1372              return HAL_OK;
   \   000000DE   0xB001             ADD      SP,SP,#+4
   \   000000E0   0xBD30             POP      {R4,R5,PC}
   1373            }
   1374            else
   1375            {
   1376              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \   000000E4   0xB001             ADD      SP,SP,#+4
   \   000000E6   0xBD30             POP      {R4,R5,PC}       ;; return
   1377            }
   1378          }
   1379          
   1380          /**
   1381            * @brief  Transmit in slave mode an amount of data in no-blocking mode with DMA 
   1382            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1383            *                the configuration information for the specified I2C.
   1384            * @param  pData: Pointer to data buffer
   1385            * @param  Size: Amount of data to be sent
   1386            * @retval HAL status
   1387            */

   \                                 In section .text, align 2, keep-with-next
   1388          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1389          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1390            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD16A             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   1391            {
   1392              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD067             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_1
   1393              {
   1394                return  HAL_ERROR;                                    
   1395              }   
   1396              /* Process Locked */
   1397              __HAL_LOCK(hi2c); 
   \   00000014   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD062             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_0
   \   0000001C   0x2001             MOVS     R0,#+1
   1398              
   1399              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_TX;
   1400              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1401              
   1402              hi2c->pBuffPtr = pData;
   1403              hi2c->XferCount = Size;
   1404              hi2c->XferSize = Size;
   1405              
   1406              /* Set the I2C DMA transfer complete callback */
   1407              hi2c->hdmatx->XferCpltCallback = I2C_DMASlaveTransmitCplt;
   1408              
   1409              /* Set the DMA error callback */
   1410              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   1411              
   1412              /* Enable the DMA channel */
   1413              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   0000001E   0xF242 0x7511      MOVW     R5,#+10001
   \   00000022   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000026   0x2032             MOVS     R0,#+50
   \   00000028   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000034   0x6261             STR      R1,[R4, #+36]
   \   00000036   0x8562             STRH     R2,[R4, #+42]
   \   00000038   0x8522             STRH     R2,[R4, #+40]
   \   0000003A   0x6AE2             LDR      R2,[R4, #+44]
   \   0000003C   0x63D0             STR      R0,[R2, #+60]
   \   0000003E   0x6AE2             LDR      R2,[R4, #+44]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000044   0x6490             STR      R0,[R2, #+72]
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x8D23             LDRH     R3,[R4, #+40]
   \   0000004A   0xF100 0x0228      ADD      R2,R0,#+40
   \   0000004E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000050   0x.... 0x....      BL       HAL_DMA_Start_IT
   1414              
   1415              /* Enable Address Acknowledge */
   1416              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6841             LDR      R1,[R0, #+4]
   \   00000058   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000005C   0x6041             STR      R1,[R0, #+4]
   1417          
   1418              /* Wait until ADDR flag is set */
   1419              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   0000005E   0x.... 0x....      BL       HAL_GetTick
   \   00000062   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6981             LDR      R1,[R0, #+24]
   \   00000068   0x0709             LSLS     R1,R1,#+28
   \   0000006A   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_3
   \   0000006C   0x.... 0x....      BL       HAL_GetTick
   \   00000070   0x1B80             SUBS     R0,R0,R6
   \   00000072   0x42A8             CMP      R0,R5
   \   00000074   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_2
   \   00000076   0xE01F             B.N      ??HAL_I2C_Slave_Transmit_DMA_4
   1420              {
   1421                /* Disable Address Acknowledge */
   1422                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1423                return HAL_TIMEOUT;
   1424              }
   1425          
   1426              /* Clear ADDR flag */
   1427              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \   00000078   0x2108             MOVS     R1,#+8
   \   0000007A   0x61C1             STR      R1,[R0, #+28]
   1428              
   1429              /* If 10bits addressing mode is selected */
   1430              if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \   0000007C   0x68E0             LDR      R0,[R4, #+12]
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD10E             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_5
   1431              {
   1432                /* Wait until ADDR flag is set */
   1433                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   00000082   0x.... 0x....      BL       HAL_GetTick
   \   00000086   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_6: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6981             LDR      R1,[R0, #+24]
   \   0000008C   0x0709             LSLS     R1,R1,#+28
   \   0000008E   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_7
   \   00000090   0x.... 0x....      BL       HAL_GetTick
   \   00000094   0x1B80             SUBS     R0,R0,R6
   \   00000096   0x42A8             CMP      R0,R5
   \   00000098   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_6
   \   0000009A   0xE00D             B.N      ??HAL_I2C_Slave_Transmit_DMA_4
   1434                {
   1435                  /* Disable Address Acknowledge */
   1436                  hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1437                  return HAL_TIMEOUT;
   1438                }
   1439          
   1440                /* Clear ADDR flag */
   1441                __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Transmit_DMA_7: (+1)
   \   0000009C   0x2108             MOVS     R1,#+8
   \   0000009E   0x61C1             STR      R1,[R0, #+28]
   1442              }
   1443              
   1444              /* Wait until DIR flag is set Transmitter mode */
   1445              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, RESET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \                     ??HAL_I2C_Slave_Transmit_DMA_5: (+1)
   \   000000A0   0x.... 0x....      BL       HAL_GetTick
   \   000000A4   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Transmit_DMA_8: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6981             LDR      R1,[R0, #+24]
   \   000000AA   0x03C9             LSLS     R1,R1,#+15
   \   000000AC   0xD411             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_9
   \   000000AE   0x.... 0x....      BL       HAL_GetTick
   \   000000B2   0x1B40             SUBS     R0,R0,R5
   \   000000B4   0x281A             CMP      R0,#+26
   \   000000B6   0xD3F6             BCC.N    ??HAL_I2C_Slave_Transmit_DMA_8
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF884 0x0034      STRB     R0,[R4, #+52]
   1446              {
   1447                /* Disable Address Acknowledge */
   1448                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6841             LDR      R1,[R0, #+4]
   \   000000C8   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000CC   0x6041             STR      R1,[R0, #+4]
   1449                return HAL_TIMEOUT;
   \   000000CE   0x2003             MOVS     R0,#+3
   \   000000D0   0xBD70             POP      {R4-R6,PC}
   1450              }
   1451                
   1452              /* Enable DMA Request */
   1453              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN; 
   \                     ??HAL_I2C_Slave_Transmit_DMA_9: (+1)
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000D8   0x6001             STR      R1,[R0, #+0]
   1454              
   1455              /* Process Unlocked */
   1456              __HAL_UNLOCK(hi2c);
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xF884 0x0034      STRB     R0,[R4, #+52]
   1457              
   1458              return HAL_OK;
   \   000000E0   0xBD70             POP      {R4-R6,PC}
   1459            }
   1460            else
   1461            {
   1462              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \   000000E4   0xBD70             POP      {R4-R6,PC}       ;; return
   1463            }
   1464          }
   1465          
   1466          /**
   1467            * @brief  Receive in slave mode an amount of data in no-blocking mode with DMA 
   1468            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1469            *                the configuration information for the specified I2C.
   1470            * @param  pData: Pointer to data buffer
   1471            * @param  Size: Amount of data to be sent
   1472            * @retval HAL status
   1473            */

   \                                 In section .text, align 2, keep-with-next
   1474          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1475          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1476            if(hi2c->State == HAL_I2C_STATE_READY)
   \   00000004   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD159             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   1477            {
   1478              if((pData == NULL) || (Size == 0)) 
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD056             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_1
   1479              {
   1480                return  HAL_ERROR;                                    
   1481              }   
   1482              /* Process Locked */
   1483              __HAL_LOCK(hi2c);
   \   00000014   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD051             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_0
   \   0000001C   0x2001             MOVS     R0,#+1
   1484              
   1485              hi2c->State = HAL_I2C_STATE_SLAVE_BUSY_RX;
   1486              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   1487              
   1488              hi2c->pBuffPtr = pData;
   1489              hi2c->XferSize = Size;
   1490              hi2c->XferCount = Size;
   1491              
   1492              /* Set the I2C DMA transfer complete callback */
   1493              hi2c->hdmarx->XferCpltCallback = I2C_DMASlaveReceiveCplt;
   1494              
   1495              /* Set the DMA error callback */
   1496              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   1497              
   1498              /* Enable the DMA channel */
   1499              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, Size);
   \   0000001E   0xF242 0x7611      MOVW     R6,#+10001
   \   00000022   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000026   0x2042             MOVS     R0,#+66
   \   00000028   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000034   0x6261             STR      R1,[R4, #+36]
   \   00000036   0x8522             STRH     R2,[R4, #+40]
   \   00000038   0x8562             STRH     R2,[R4, #+42]
   \   0000003A   0x6B23             LDR      R3,[R4, #+48]
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
   \   0000003E   0x6B23             LDR      R3,[R4, #+48]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000044   0x6498             STR      R0,[R3, #+72]
   \   00000046   0x4613             MOV      R3,R2
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x460A             MOV      R2,R1
   \   0000004C   0xF100 0x0124      ADD      R1,R0,#+36
   \   00000050   0x6B20             LDR      R0,[R4, #+48]
   \   00000052   0x.... 0x....      BL       HAL_DMA_Start_IT
   1500              
   1501              /* Enable Address Acknowledge */
   1502              hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6841             LDR      R1,[R0, #+4]
   \   0000005A   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000005E   0x6041             STR      R1,[R0, #+4]
   1503          
   1504              /* Wait until ADDR flag is set */
   1505              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, I2C_TIMEOUT_ADDR) != HAL_OK)      
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6981             LDR      R1,[R0, #+24]
   \   0000006A   0x0709             LSLS     R1,R1,#+28
   \   0000006C   0xD405             BMI.N    ??HAL_I2C_Slave_Receive_DMA_3
   \   0000006E   0x.... 0x....      BL       HAL_GetTick
   \   00000072   0x1B40             SUBS     R0,R0,R5
   \   00000074   0x42B0             CMP      R0,R6
   \   00000076   0xD3F6             BCC.N    ??HAL_I2C_Slave_Receive_DMA_2
   \   00000078   0xE00D             B.N      ??HAL_I2C_Slave_Receive_DMA_4
   1506              {
   1507                /* Disable Address Acknowledge */
   1508                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   1509                return HAL_TIMEOUT;
   1510              }
   1511          
   1512              /* Clear ADDR flag */
   1513              __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_ADDR);
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \   0000007A   0x2108             MOVS     R1,#+8
   \   0000007C   0x61C1             STR      R1,[R0, #+28]
   1514              
   1515              /* Wait until DIR flag is set Receiver mode */
   1516              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_DIR, SET, I2C_TIMEOUT_DIR) != HAL_OK)      
   \   0000007E   0x.... 0x....      BL       HAL_GetTick
   \   00000082   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Slave_Receive_DMA_5: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6981             LDR      R1,[R0, #+24]
   \   00000088   0x03C9             LSLS     R1,R1,#+15
   \   0000008A   0xD511             BPL.N    ??HAL_I2C_Slave_Receive_DMA_6
   \   0000008C   0x.... 0x....      BL       HAL_GetTick
   \   00000090   0x1B40             SUBS     R0,R0,R5
   \   00000092   0x281A             CMP      R0,#+26
   \   00000094   0xD3F6             BCC.N    ??HAL_I2C_Slave_Receive_DMA_5
   \                     ??HAL_I2C_Slave_Receive_DMA_4: (+1)
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x0034      STRB     R0,[R4, #+52]
   1517              {
   1518                /* Disable Address Acknowledge */
   1519                hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000AA   0x6041             STR      R1,[R0, #+4]
   1520                return HAL_TIMEOUT;
   \   000000AC   0x2003             MOVS     R0,#+3
   \   000000AE   0xBD70             POP      {R4-R6,PC}
   1521              }
   1522           
   1523              /* Enable DMA Request */
   1524              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;  
   \                     ??HAL_I2C_Slave_Receive_DMA_6: (+1)
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000B6   0x6001             STR      R1,[R0, #+0]
   1525              
   1526              /* Process Unlocked */
   1527              __HAL_UNLOCK(hi2c);
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF884 0x0034      STRB     R0,[R4, #+52]
   1528              
   1529              return HAL_OK;
   \   000000BE   0xBD70             POP      {R4-R6,PC}
   1530            }
   1531            else
   1532            {
   1533              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \   000000C0   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \   000000C2   0xBD70             POP      {R4-R6,PC}       ;; return
   1534            }
   1535          }
   1536          /**
   1537            * @brief  Write an amount of data in blocking mode to a specific memory address
   1538            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1539            *                the configuration information for the specified I2C.
   1540            * @param  DevAddress: Target device address
   1541            * @param  MemAddress: Internal memory address
   1542            * @param  MemAddSize: Size of internal memory address
   1543            * @param  pData: Pointer to data buffer
   1544            * @param  Size: Amount of data to be sent
   1545            * @param  Timeout: Timeout duration
   1546            * @retval HAL status
   1547            */

   \                                 In section .text, align 4, keep-with-next
   1548          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1549          {
   \                     HAL_I2C_Mem_Write: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4699             MOV      R9,R3
   1550            uint32_t Sizetmp = 0;
   1551          
   1552            /* Check the parameters */
   1553            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1554            
   1555            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x814C      BNE.W    ??HAL_I2C_Mem_Write_0
   \   00000016   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1556            { 
   1557              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x9C0B             LDRNE    R4,[SP, #+44]
   \   00000022   0x2C00             CMPNE    R4,#+0
   \   00000024   0xF000 0x8144      BEQ.W    ??HAL_I2C_Mem_Write_1
   1558              {
   1559                return  HAL_ERROR;                                    
   1560              }
   1561          
   1562              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x6982             LDR      R2,[R0, #+24]
   \   0000002C   0x0412             LSLS     R2,R2,#+16
   \   0000002E   0xF100 0x813E      BMI.W    ??HAL_I2C_Mem_Write_0
   1563              {
   1564                return HAL_BUSY;
   1565              }
   1566          
   1567              /* Process Locked */
   1568              __HAL_LOCK(hi2c);
   \   00000032   0xF895 0x2034      LDRB     R2,[R5, #+52]
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xF000 0x8139      BEQ.W    ??HAL_I2C_Mem_Write_0
   \   0000003C   0x2201             MOVS     R2,#+1
   1569              
   1570              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   1571              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1572              
   1573              /* Send Slave Address and Memory Address */
   1574              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   0000003E   0x058F             LSLS     R7,R1,#+22
   \   00000040   0xF885 0x2034      STRB     R2,[R5, #+52]
   \   00000044   0x2252             MOVS     R2,#+82
   \   00000046   0xF885 0x2035      STRB     R2,[R5, #+53]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x63AA             STR      R2,[R5, #+56]
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0x.... 0x....      LDR.W    R10,??DataTable15  ;; 0xfc009800
   \   00000054   0xFA5F 0xF289      UXTB     R2,R9
   \   00000058   0xEA0A 0x0101      AND      R1,R10,R1
   \   0000005C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000060   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000064   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000068   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000006C   0x6041             STR      R1,[R0, #+4]
   \   0000006E   0x.... 0x....      BL       HAL_GetTick
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \   00000078   0x6829             LDR      R1,[R5, #+0]
   \   0000007A   0x6988             LDR      R0,[R1, #+24]
   \   0000007C   0x0780             LSLS     R0,R0,#+30
   \   0000007E   0xD425             BMI.N    ??HAL_I2C_Mem_Write_3
   \   00000080   0x4659             MOV      R1,R11
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000088   0xB9A8             CBNZ.N   R0,??HAL_I2C_Mem_Write_4
   \   0000008A   0xF11B 0x0F01      CMN      R11,#+1
   \   0000008E   0xD0F3             BEQ.N    ??HAL_I2C_Mem_Write_2
   \   00000090   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000094   0xD005             BEQ.N    ??HAL_I2C_Mem_Write_5
   \   00000096   0x.... 0x....      BL       HAL_GetTick
   \   0000009A   0x9900             LDR      R1,[SP, #+0]
   \   0000009C   0x1A40             SUBS     R0,R0,R1
   \   0000009E   0x4583             CMP      R11,R0
   \   000000A0   0xD2EA             BCS.N    ??HAL_I2C_Mem_Write_2
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \   000000A2   0x6BA8             LDR      R0,[R5, #+56]
   \   000000A4   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000A8   0x63A8             STR      R0,[R5, #+56]
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \   000000B6   0x6BA8             LDR      R0,[R5, #+56]
   1575              {
   1576                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \   000000B8   0x6BA8             LDR      R0,[R5, #+56]
   \   000000BA   0x2804             CMP      R0,#+4
   \   000000BC   0xD158             BNE.N    ??HAL_I2C_Mem_Write_7
   1577                {
   1578                  /* Process Unlocked */
   1579                  __HAL_UNLOCK(hi2c);
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xF885 0x0034      STRB     R0,[R5, #+52]
   1580                  return HAL_ERROR;
   1581                }
   1582                else
   1583                {
   1584                  /* Process Unlocked */
   1585                  __HAL_UNLOCK(hi2c);
   1586                  return HAL_TIMEOUT;
   1587                }
   1588              }
   1589          
   1590              /* Set NBYTES to write and reload if size > 255 */
   1591              /* Size > 255, need to set RELOAD bit */
   1592              if(Size > 255)
   1593              {
   1594                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   1595                Sizetmp = 255;
   1596              }
   1597              else
   1598              {
   1599                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   1600                Sizetmp = Size;
   1601              }
   1602              
   1603              do
   1604              {
   1605                /* Wait until TXIS flag is set */
   1606                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   1607                {
   1608                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1609                  {
   1610                    return HAL_ERROR;
   1611                  }
   1612                  else
   1613                  {
   1614                    return HAL_TIMEOUT;
   1615                  }
   1616                }
   1617               
   1618                /* Write data to DR */
   1619                hi2c->Instance->TXDR = (*pData++);
   1620                Sizetmp--;
   1621                Size--;
   1622          
   1623                if((Sizetmp == 0)&&(Size!=0))
   1624                {
   1625                  /* Wait until TCR flag is set */
   1626                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   1627                  {
   1628                    return HAL_TIMEOUT;
   1629                  }
   1630          
   1631                  
   1632                  if(Size > 255)
   1633                  {
   1634                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   1635                    Sizetmp = 255;
   1636                  }
   1637                  else
   1638                  {
   1639                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   1640                    Sizetmp = Size;
   1641                  }
   1642                }
   1643                
   1644              }while(Size > 0);
   1645              
   1646              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1647              /* Wait until STOPF flag is reset */ 
   1648              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   1649              {
   1650                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1651                {
   1652                  return HAL_ERROR;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0xB001             ADD      SP,SP,#+4
   \   000000C8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \   000000CC   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000D0   0xD025             BEQ.N    ??HAL_I2C_Mem_Write_8
   \   000000D2   0x0A30             LSRS     R0,R6,#+8
   \   000000D4   0x6288             STR      R0,[R1, #+40]
   \   000000D6   0x.... 0x....      BL       HAL_GetTick
   \   000000DA   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Write_9: (+1)
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0x6980             LDR      R0,[R0, #+24]
   \   000000E0   0x0780             LSLS     R0,R0,#+30
   \   000000E2   0xD41C             BMI.N    ??HAL_I2C_Mem_Write_8
   \   000000E4   0x4659             MOV      R1,R11
   \   000000E6   0x4628             MOV      R0,R5
   \   000000E8   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD1E2             BNE.N    ??HAL_I2C_Mem_Write_4
   \   000000F0   0xF11B 0x0F01      CMN      R11,#+1
   \   000000F4   0xD0F2             BEQ.N    ??HAL_I2C_Mem_Write_9
   \   000000F6   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000FA   0xD005             BEQ.N    ??HAL_I2C_Mem_Write_10
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000104   0x4583             CMP      R11,R0
   \   00000106   0xD2E9             BCS.N    ??HAL_I2C_Mem_Write_9
   \                     ??HAL_I2C_Mem_Write_10: (+1)
   \   00000108   0x6BA8             LDR      R0,[R5, #+56]
   \   0000010A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010E   0x63A8             STR      R0,[R5, #+56]
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   0000011C   0xE7CB             B.N      ??HAL_I2C_Mem_Write_4
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \   0000011E   0x6828             LDR      R0,[R5, #+0]
   \   00000120   0xB2F6             UXTB     R6,R6
   \   00000122   0x6286             STR      R6,[R0, #+40]
   \   00000124   0x.... 0x....      BL       HAL_GetTick
   \   00000128   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Write_11: (+1)
   \   0000012A   0x6828             LDR      R0,[R5, #+0]
   \   0000012C   0x6981             LDR      R1,[R0, #+24]
   \   0000012E   0x0609             LSLS     R1,R1,#+24
   \   00000130   0xD411             BMI.N    ??HAL_I2C_Mem_Write_12
   \   00000132   0xF11B 0x0F01      CMN      R11,#+1
   \   00000136   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Write_11
   \   00000138   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000013C   0xD004             BEQ.N    ??HAL_I2C_Mem_Write_13
   \   0000013E   0x.... 0x....      BL       HAL_GetTick
   \   00000142   0x1B80             SUBS     R0,R0,R6
   \   00000144   0x4583             CMP      R11,R0
   \   00000146   0xD2F0             BCS.N    ??HAL_I2C_Mem_Write_11
   \                     ??HAL_I2C_Mem_Write_13: (+1)
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000154   0xE7B0             B.N      ??HAL_I2C_Mem_Write_6
   \                     ??HAL_I2C_Mem_Write_12: (+1)
   \   00000156   0x2CFF             CMP      R4,#+255
   \   00000158   0x6841             LDR      R1,[R0, #+4]
   \   0000015A   0xEA0A 0x0101      AND      R1,R10,R1
   \   0000015E   0xDD0E             BLE.N    ??HAL_I2C_Mem_Write_14
   \   00000160   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \                     ??HAL_I2C_Mem_Write_15: (+1)
   \   00000164   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0x1ff0000
   \   00000168   0x26FF             MOVS     R6,#+255
   \   0000016A   0x4311             ORRS     R1,R2,R1
   \   0000016C   0x6041             STR      R1,[R0, #+4]
   \   0000016E   0xE00F             B.N      ??HAL_I2C_Mem_Write_16
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xF885 0x0034      STRB     R0,[R5, #+52]
   1653                }
   1654                else
   1655                {
   1656                  return HAL_TIMEOUT;
   \   00000176   0x2003             MOVS     R0,#+3
   \   00000178   0xB001             ADD      SP,SP,#+4
   \   0000017A   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_14: (+1)
   \   0000017E   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000182   0xB2E2             UXTB     R2,R4
   \   00000184   0x4626             MOV      R6,R4
   \   00000186   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000018A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000018E   0x6041             STR      R1,[R0, #+4]
   \                     ??HAL_I2C_Mem_Write_16: (+1)
   \   00000190   0x.... 0x....      BL       HAL_GetTick
   \   00000194   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Write_17: (+1)
   \   00000196   0x6828             LDR      R0,[R5, #+0]
   \   00000198   0x6981             LDR      R1,[R0, #+24]
   \   0000019A   0x0789             LSLS     R1,R1,#+30
   \   0000019C   0xD421             BMI.N    ??HAL_I2C_Mem_Write_18
   \   0000019E   0x4659             MOV      R1,R11
   \   000001A0   0x4628             MOV      R0,R5
   \   000001A2   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001A6   0xB9A8             CBNZ.N   R0,??HAL_I2C_Mem_Write_19
   \   000001A8   0xF11B 0x0F01      CMN      R11,#+1
   \   000001AC   0xD0F3             BEQ.N    ??HAL_I2C_Mem_Write_17
   \   000001AE   0xF1BB 0x0F00      CMP      R11,#+0
   \   000001B2   0xD005             BEQ.N    ??HAL_I2C_Mem_Write_20
   \   000001B4   0x.... 0x....      BL       HAL_GetTick
   \   000001B8   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000001BC   0x4583             CMP      R11,R0
   \   000001BE   0xD2EA             BCS.N    ??HAL_I2C_Mem_Write_17
   \                     ??HAL_I2C_Mem_Write_20: (+1)
   \   000001C0   0x6BA8             LDR      R0,[R5, #+56]
   \   000001C2   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001C6   0x63A8             STR      R0,[R5, #+56]
   \   000001C8   0x2001             MOVS     R0,#+1
   \   000001CA   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Write_19: (+1)
   \   000001D4   0x6BA8             LDR      R0,[R5, #+56]
   \   000001D6   0x2804             CMP      R0,#+4
   \   000001D8   0xD165             BNE.N    ??HAL_I2C_Mem_Write_21
   \   000001DA   0x2001             MOVS     R0,#+1
   \   000001DC   0xB001             ADD      SP,SP,#+4
   \   000001DE   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_18: (+1)
   \   000001E2   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \   000001E6   0x1E76             SUBS     R6,R6,#+1
   \   000001E8   0xF1A4 0x0401      SUB      R4,R4,#+1
   \   000001EC   0xB2A4             UXTH     R4,R4
   \   000001EE   0x6281             STR      R1,[R0, #+40]
   \   000001F0   0xD124             BNE.N    ??HAL_I2C_Mem_Write_22
   \   000001F2   0xB32C             CBZ.N    R4,??HAL_I2C_Mem_Write_23
   \   000001F4   0x.... 0x....      BL       HAL_GetTick
   \   000001F8   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Write_24: (+1)
   \   000001FA   0x6828             LDR      R0,[R5, #+0]
   \   000001FC   0x6981             LDR      R1,[R0, #+24]
   \   000001FE   0x0609             LSLS     R1,R1,#+24
   \   00000200   0xD414             BMI.N    ??HAL_I2C_Mem_Write_25
   \   00000202   0xF11B 0x0F01      CMN      R11,#+1
   \   00000206   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Write_24
   \   00000208   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000020C   0xD004             BEQ.N    ??HAL_I2C_Mem_Write_26
   \   0000020E   0x.... 0x....      BL       HAL_GetTick
   \   00000212   0x1B80             SUBS     R0,R0,R6
   \   00000214   0x4583             CMP      R11,R0
   \   00000216   0xD2F0             BCS.N    ??HAL_I2C_Mem_Write_24
   \                     ??HAL_I2C_Mem_Write_26: (+1)
   \   00000218   0x2001             MOVS     R0,#+1
   \   0000021A   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000224   0x2003             MOVS     R0,#+3
   \   00000226   0xB001             ADD      SP,SP,#+4
   \   00000228   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_25: (+1)
   \   0000022C   0x2CFF             CMP      R4,#+255
   \   0000022E   0x6841             LDR      R1,[R0, #+4]
   \   00000230   0xEA0A 0x0101      AND      R1,R10,R1
   \   00000234   0xDDA3             BLE.N    ??HAL_I2C_Mem_Write_14
   \   00000236   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   0000023A   0xE793             B.N      ??HAL_I2C_Mem_Write_15
   \                     ??HAL_I2C_Mem_Write_22: (+1)
   \   0000023C   0x2C00             CMP      R4,#+0
   \   0000023E   0xD1A7             BNE.N    ??HAL_I2C_Mem_Write_16
   \                     ??HAL_I2C_Mem_Write_23: (+1)
   \   00000240   0x.... 0x....      BL       HAL_GetTick
   \   00000244   0x4604             MOV      R4,R0
   \                     ??HAL_I2C_Mem_Write_27: (+1)
   \   00000246   0x6828             LDR      R0,[R5, #+0]
   \   00000248   0x6981             LDR      R1,[R0, #+24]
   \   0000024A   0x0689             LSLS     R1,R1,#+26
   \   0000024C   0xD41A             BMI.N    ??HAL_I2C_Mem_Write_28
   \   0000024E   0x2119             MOVS     R1,#+25
   \   00000250   0x4628             MOV      R0,R5
   \   00000252   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000256   0xB970             CBNZ.N   R0,??HAL_I2C_Mem_Write_29
   \   00000258   0x.... 0x....      BL       HAL_GetTick
   \   0000025C   0x1B00             SUBS     R0,R0,R4
   \   0000025E   0x281A             CMP      R0,#+26
   \   00000260   0xD3F1             BCC.N    ??HAL_I2C_Mem_Write_27
   \   00000262   0x6BA8             LDR      R0,[R5, #+56]
   \   00000264   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000268   0x63A8             STR      R0,[R5, #+56]
   \   0000026A   0x2001             MOVS     R0,#+1
   \   0000026C   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000270   0x2000             MOVS     R0,#+0
   \   00000272   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Write_29: (+1)
   \   00000276   0x6BA8             LDR      R0,[R5, #+56]
   \   00000278   0x2804             CMP      R0,#+4
   \   0000027A   0xD114             BNE.N    ??HAL_I2C_Mem_Write_21
   \   0000027C   0x2001             MOVS     R0,#+1
   \   0000027E   0xB001             ADD      SP,SP,#+4
   \   00000280   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1657                }
   1658              }
   1659              
   1660              /* Clear STOP Flag */
   1661              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Write_28: (+1)
   \   00000284   0x2120             MOVS     R1,#+32
   1662            	
   1663              /* Clear Configuration Register 2 */
   1664              I2C_RESET_CR2(hi2c);
   \   00000286   0x.... 0x....      LDR.W    R2,??DataTable15_2  ;; 0xfe00e800
   \   0000028A   0x61C1             STR      R1,[R0, #+28]
   \   0000028C   0x6828             LDR      R0,[R5, #+0]
   \   0000028E   0x6841             LDR      R1,[R0, #+4]
   \   00000290   0x4011             ANDS     R1,R2,R1
   \   00000292   0x6041             STR      R1,[R0, #+4]
   1665          
   1666              hi2c->State = HAL_I2C_STATE_READY; 	  
   \   00000294   0x2001             MOVS     R0,#+1
   \   00000296   0xF885 0x0035      STRB     R0,[R5, #+53]
   1667              
   1668              /* Process Unlocked */
   1669              __HAL_UNLOCK(hi2c);
   \   0000029A   0x2000             MOVS     R0,#+0
   \   0000029C   0xF885 0x0034      STRB     R0,[R5, #+52]
   1670              
   1671              return HAL_OK;
   \   000002A0   0xB001             ADD      SP,SP,#+4
   \   000002A2   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Write_21: (+1)
   \   000002A6   0x2003             MOVS     R0,#+3
   \   000002A8   0xB001             ADD      SP,SP,#+4
   \   000002AA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1672            }
   1673            else
   1674            {
   1675              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \   000002AE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \   000002B0   0xB001             ADD      SP,SP,#+4
   \   000002B2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1676            }
   1677          }
   1678          
   1679          /**
   1680            * @brief  Read an amount of data in blocking mode from a specific memory address
   1681            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1682            *                the configuration information for the specified I2C.
   1683            * @param  DevAddress: Target device address
   1684            * @param  MemAddress: Internal memory address
   1685            * @param  MemAddSize: Size of internal memory address
   1686            * @param  pData: Pointer to data buffer
   1687            * @param  Size: Amount of data to be sent
   1688            * @param  Timeout: Timeout duration
   1689            * @retval HAL status
   1690            */

   \                                 In section .text, align 4, keep-with-next
   1691          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1692          {
   \                     HAL_I2C_Mem_Read: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4699             MOV      R9,R3
   1693            uint32_t Sizetmp = 0;
   1694          
   1695            /* Check the parameters */
   1696            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1697            
   1698            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x814F      BNE.W    ??HAL_I2C_Mem_Read_0
   \   00000016   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1699            {    
   1700              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x9C0B             LDRNE    R4,[SP, #+44]
   \   00000022   0x2C00             CMPNE    R4,#+0
   \   00000024   0xF000 0x8147      BEQ.W    ??HAL_I2C_Mem_Read_1
   1701              {
   1702                return  HAL_ERROR;                                    
   1703              }
   1704          
   1705              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x6982             LDR      R2,[R0, #+24]
   \   0000002C   0x0412             LSLS     R2,R2,#+16
   \   0000002E   0xF100 0x8141      BMI.W    ??HAL_I2C_Mem_Read_0
   1706              {
   1707                return HAL_BUSY;
   1708              }
   1709          
   1710              /* Process Locked */
   1711              __HAL_LOCK(hi2c);
   \   00000032   0xF895 0x2034      LDRB     R2,[R5, #+52]
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xF000 0x813C      BEQ.W    ??HAL_I2C_Mem_Read_0
   \   0000003C   0x2201             MOVS     R2,#+1
   1712              
   1713              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   1714              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1715              
   1716              /* Send Slave Address and Memory Address */
   1717              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout) != HAL_OK)
   \   0000003E   0x058F             LSLS     R7,R1,#+22
   \   00000040   0xF885 0x2034      STRB     R2,[R5, #+52]
   \   00000044   0x2262             MOVS     R2,#+98
   \   00000046   0xF885 0x2035      STRB     R2,[R5, #+53]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x63AA             STR      R2,[R5, #+56]
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0x.... 0x....      LDR.W    R10,??DataTable15  ;; 0xfc009800
   \   00000054   0xFA5F 0xF289      UXTB     R2,R9
   \   00000058   0xEA0A 0x0101      AND      R1,R10,R1
   \   0000005C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000060   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000064   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000068   0x6041             STR      R1,[R0, #+4]
   \   0000006A   0x.... 0x....      BL       HAL_GetTick
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0xF8DD 0xB030      LDR      R11,[SP, #+48]
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \   00000074   0x6829             LDR      R1,[R5, #+0]
   \   00000076   0x6988             LDR      R0,[R1, #+24]
   \   00000078   0x0780             LSLS     R0,R0,#+30
   \   0000007A   0xD425             BMI.N    ??HAL_I2C_Mem_Read_3
   \   0000007C   0x4659             MOV      R1,R11
   \   0000007E   0x4628             MOV      R0,R5
   \   00000080   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000084   0xB9A8             CBNZ.N   R0,??HAL_I2C_Mem_Read_4
   \   00000086   0xF11B 0x0F01      CMN      R11,#+1
   \   0000008A   0xD0F3             BEQ.N    ??HAL_I2C_Mem_Read_2
   \   0000008C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000090   0xD005             BEQ.N    ??HAL_I2C_Mem_Read_5
   \   00000092   0x.... 0x....      BL       HAL_GetTick
   \   00000096   0x9900             LDR      R1,[SP, #+0]
   \   00000098   0x1A40             SUBS     R0,R0,R1
   \   0000009A   0x4583             CMP      R11,R0
   \   0000009C   0xD2EA             BCS.N    ??HAL_I2C_Mem_Read_2
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \   0000009E   0x6BA8             LDR      R0,[R5, #+56]
   \   000000A0   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000A4   0x63A8             STR      R0,[R5, #+56]
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \   000000B2   0x6BA8             LDR      R0,[R5, #+56]
   1718              {
   1719                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \   000000B4   0x6BA8             LDR      R0,[R5, #+56]
   \   000000B6   0x2804             CMP      R0,#+4
   \   000000B8   0xD159             BNE.N    ??HAL_I2C_Mem_Read_7
   1720                {
   1721                  /* Process Unlocked */
   1722                  __HAL_UNLOCK(hi2c);
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF885 0x0034      STRB     R0,[R5, #+52]
   1723                  return HAL_ERROR;
   1724                }
   1725                else
   1726                {
   1727                  /* Process Unlocked */
   1728                  __HAL_UNLOCK(hi2c);
   1729                  return HAL_TIMEOUT;
   1730                }
   1731              }
   1732          
   1733              /* Send Slave Address */
   1734              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1735              /* Size > 255, need to set RELOAD bit */
   1736              if(Size > 255)
   1737              {
   1738                I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   1739                Sizetmp = 255;
   1740              }
   1741              else
   1742              {
   1743                I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   1744                Sizetmp = Size;
   1745              }
   1746              
   1747              do
   1748              {  
   1749                /* Wait until RXNE flag is set */
   1750                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout) != HAL_OK)      
   1751                {
   1752                  return HAL_TIMEOUT;
   1753                }
   1754                    
   1755                /* Read data from RXDR */
   1756                (*pData++) = hi2c->Instance->RXDR;
   1757          
   1758                /* Decrement the Size counter */
   1759                Sizetmp--;
   1760                Size--;   
   1761          
   1762                if((Sizetmp == 0)&&(Size!=0))
   1763                {
   1764                  /* Wait until TCR flag is set */
   1765                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   1766                  {
   1767                    return HAL_TIMEOUT;
   1768                  }
   1769                  
   1770                  if(Size > 255)
   1771                  {
   1772                    I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   1773                    Sizetmp = 255;
   1774                  }
   1775                  else
   1776                  {
   1777                    I2C_TransferConfig(hi2c,DevAddress,Size, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   1778                    Sizetmp = Size;
   1779                  }
   1780                }
   1781          
   1782              }while(Size > 0);
   1783          
   1784              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   1785              /* Wait until STOPF flag is reset */ 
   1786              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   1787              {
   1788                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   1789                {
   1790                  return HAL_ERROR;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xB001             ADD      SP,SP,#+4
   \   000000C4   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \   000000C8   0xF1B9 0x0F01      CMP      R9,#+1
   \   000000CC   0xD025             BEQ.N    ??HAL_I2C_Mem_Read_8
   \   000000CE   0x0A30             LSRS     R0,R6,#+8
   \   000000D0   0x6288             STR      R0,[R1, #+40]
   \   000000D2   0x.... 0x....      BL       HAL_GetTick
   \   000000D6   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x6980             LDR      R0,[R0, #+24]
   \   000000DC   0x0780             LSLS     R0,R0,#+30
   \   000000DE   0xD41C             BMI.N    ??HAL_I2C_Mem_Read_8
   \   000000E0   0x4659             MOV      R1,R11
   \   000000E2   0x4628             MOV      R0,R5
   \   000000E4   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD1E2             BNE.N    ??HAL_I2C_Mem_Read_4
   \   000000EC   0xF11B 0x0F01      CMN      R11,#+1
   \   000000F0   0xD0F2             BEQ.N    ??HAL_I2C_Mem_Read_9
   \   000000F2   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000F6   0xD005             BEQ.N    ??HAL_I2C_Mem_Read_10
   \   000000F8   0x.... 0x....      BL       HAL_GetTick
   \   000000FC   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000100   0x4583             CMP      R11,R0
   \   00000102   0xD2E9             BCS.N    ??HAL_I2C_Mem_Read_9
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \   00000104   0x6BA8             LDR      R0,[R5, #+56]
   \   00000106   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010A   0x63A8             STR      R0,[R5, #+56]
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000118   0xE7CB             B.N      ??HAL_I2C_Mem_Read_4
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \   0000011A   0x6828             LDR      R0,[R5, #+0]
   \   0000011C   0xB2F6             UXTB     R6,R6
   \   0000011E   0x6286             STR      R6,[R0, #+40]
   \   00000120   0x.... 0x....      BL       HAL_GetTick
   \   00000124   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \   00000126   0x6828             LDR      R0,[R5, #+0]
   \   00000128   0x6981             LDR      R1,[R0, #+24]
   \   0000012A   0x0649             LSLS     R1,R1,#+25
   \   0000012C   0xD411             BMI.N    ??HAL_I2C_Mem_Read_12
   \   0000012E   0xF11B 0x0F01      CMN      R11,#+1
   \   00000132   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Read_11
   \   00000134   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000138   0xD004             BEQ.N    ??HAL_I2C_Mem_Read_13
   \   0000013A   0x.... 0x....      BL       HAL_GetTick
   \   0000013E   0x1B80             SUBS     R0,R0,R6
   \   00000140   0x4583             CMP      R11,R0
   \   00000142   0xD2F0             BCS.N    ??HAL_I2C_Mem_Read_11
   \                     ??HAL_I2C_Mem_Read_13: (+1)
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000150   0xE7B0             B.N      ??HAL_I2C_Mem_Read_6
   \                     ??HAL_I2C_Mem_Read_12: (+1)
   \   00000152   0x2CFF             CMP      R4,#+255
   \   00000154   0x6841             LDR      R1,[R0, #+4]
   \   00000156   0xEA0A 0x0101      AND      R1,R10,R1
   \   0000015A   0xDD0F             BLE.N    ??HAL_I2C_Mem_Read_14
   \   0000015C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000160   0x26FF             MOVS     R6,#+255
   \   00000162   0xF041 0x71FE      ORR      R1,R1,#0x1FC0000
   \   00000166   0xF441 0x3149      ORR      R1,R1,#0x32400
   \   0000016A   0x6041             STR      R1,[R0, #+4]
   \   0000016C   0xE01A             B.N      ??HAL_I2C_Mem_Read_15
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF885 0x0034      STRB     R0,[R5, #+52]
   1791                }
   1792                else
   1793                {
   1794                  return HAL_TIMEOUT;
   \   00000174   0x2003             MOVS     R0,#+3
   \   00000176   0xB001             ADD      SP,SP,#+4
   \   00000178   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_14: (+1)
   \   0000017C   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000180   0xB2E2             UXTB     R2,R4
   \   00000182   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000186   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000018A   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   0000018E   0xE006             B.N      ??HAL_I2C_Mem_Read_16
   \                     ??HAL_I2C_Mem_Read_17: (+1)
   \   00000190   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000194   0xB2E2             UXTB     R2,R4
   \   00000196   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000019A   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Read_16: (+1)
   \   0000019E   0x6041             STR      R1,[R0, #+4]
   \   000001A0   0xEA4F 0x0604      MOV.W    R6,R4
   \                     ??HAL_I2C_Mem_Read_15: (+1)
   \   000001A4   0x.... 0x....      BL       HAL_GetTick
   \   000001A8   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Read_18: (+1)
   \   000001AA   0x6828             LDR      R0,[R5, #+0]
   \   000001AC   0x6981             LDR      R1,[R0, #+24]
   \   000001AE   0x0749             LSLS     R1,R1,#+29
   \   000001B0   0xD415             BMI.N    ??HAL_I2C_Mem_Read_19
   \   000001B2   0xF11B 0x0F01      CMN      R11,#+1
   \   000001B6   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Read_18
   \   000001B8   0xF1BB 0x0F00      CMP      R11,#+0
   \   000001BC   0xD005             BEQ.N    ??HAL_I2C_Mem_Read_20
   \   000001BE   0x.... 0x....      BL       HAL_GetTick
   \   000001C2   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000001C6   0x4583             CMP      R11,R0
   \   000001C8   0xD2EF             BCS.N    ??HAL_I2C_Mem_Read_18
   \                     ??HAL_I2C_Mem_Read_20: (+1)
   \   000001CA   0x2001             MOVS     R0,#+1
   \   000001CC   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   000001D0   0x2000             MOVS     R0,#+0
   \   000001D2   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   000001D6   0x2003             MOVS     R0,#+3
   \   000001D8   0xB001             ADD      SP,SP,#+4
   \   000001DA   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_19: (+1)
   \   000001DE   0x6A40             LDR      R0,[R0, #+36]
   \   000001E0   0x1E76             SUBS     R6,R6,#+1
   \   000001E2   0xF1A4 0x0401      SUB      R4,R4,#+1
   \   000001E6   0xB2A4             UXTH     R4,R4
   \   000001E8   0xF808 0x0B01      STRB     R0,[R8], #+1
   \   000001EC   0xD129             BNE.N    ??HAL_I2C_Mem_Read_21
   \   000001EE   0xB354             CBZ.N    R4,??HAL_I2C_Mem_Read_22
   \   000001F0   0x.... 0x....      BL       HAL_GetTick
   \   000001F4   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Read_23: (+1)
   \   000001F6   0x6828             LDR      R0,[R5, #+0]
   \   000001F8   0x6981             LDR      R1,[R0, #+24]
   \   000001FA   0x0609             LSLS     R1,R1,#+24
   \   000001FC   0xD414             BMI.N    ??HAL_I2C_Mem_Read_24
   \   000001FE   0xF11B 0x0F01      CMN      R11,#+1
   \   00000202   0xD0F8             BEQ.N    ??HAL_I2C_Mem_Read_23
   \   00000204   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000208   0xD004             BEQ.N    ??HAL_I2C_Mem_Read_25
   \   0000020A   0x.... 0x....      BL       HAL_GetTick
   \   0000020E   0x1B80             SUBS     R0,R0,R6
   \   00000210   0x4583             CMP      R11,R0
   \   00000212   0xD2F0             BCS.N    ??HAL_I2C_Mem_Read_23
   \                     ??HAL_I2C_Mem_Read_25: (+1)
   \   00000214   0x2001             MOVS     R0,#+1
   \   00000216   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   0000021A   0x2000             MOVS     R0,#+0
   \   0000021C   0xF885 0x0034      STRB     R0,[R5, #+52]
   \   00000220   0x2003             MOVS     R0,#+3
   \   00000222   0xB001             ADD      SP,SP,#+4
   \   00000224   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_24: (+1)
   \   00000228   0x2CFF             CMP      R4,#+255
   \   0000022A   0x6841             LDR      R1,[R0, #+4]
   \   0000022C   0xEA0A 0x0101      AND      R1,R10,R1
   \   00000230   0xDDAE             BLE.N    ??HAL_I2C_Mem_Read_17
   \   00000232   0xEA51 0x5197      ORRS     R1,R1,R7, LSR #+22
   \   00000236   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0x1ff0000
   \   0000023A   0x26FF             MOVS     R6,#+255
   \   0000023C   0x4311             ORRS     R1,R2,R1
   \   0000023E   0x6041             STR      R1,[R0, #+4]
   \   00000240   0xE7B0             B.N      ??HAL_I2C_Mem_Read_15
   \                     ??HAL_I2C_Mem_Read_21: (+1)
   \   00000242   0x2C00             CMP      R4,#+0
   \   00000244   0xD1AE             BNE.N    ??HAL_I2C_Mem_Read_15
   \                     ??HAL_I2C_Mem_Read_22: (+1)
   \   00000246   0x.... 0x....      BL       HAL_GetTick
   \   0000024A   0x4604             MOV      R4,R0
   \                     ??HAL_I2C_Mem_Read_26: (+1)
   \   0000024C   0x6828             LDR      R0,[R5, #+0]
   \   0000024E   0x6981             LDR      R1,[R0, #+24]
   \   00000250   0x0689             LSLS     R1,R1,#+26
   \   00000252   0xD41A             BMI.N    ??HAL_I2C_Mem_Read_27
   \   00000254   0x2119             MOVS     R1,#+25
   \   00000256   0x4628             MOV      R0,R5
   \   00000258   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000025C   0xB970             CBNZ.N   R0,??HAL_I2C_Mem_Read_28
   \   0000025E   0x.... 0x....      BL       HAL_GetTick
   \   00000262   0x1B00             SUBS     R0,R0,R4
   \   00000264   0x281A             CMP      R0,#+26
   \   00000266   0xD3F1             BCC.N    ??HAL_I2C_Mem_Read_26
   \   00000268   0x6BA8             LDR      R0,[R5, #+56]
   \   0000026A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000026E   0x63A8             STR      R0,[R5, #+56]
   \   00000270   0x2001             MOVS     R0,#+1
   \   00000272   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xF885 0x0034      STRB     R0,[R5, #+52]
   \                     ??HAL_I2C_Mem_Read_28: (+1)
   \   0000027C   0x6BA8             LDR      R0,[R5, #+56]
   \   0000027E   0x2804             CMP      R0,#+4
   \   00000280   0xD114             BNE.N    ??HAL_I2C_Mem_Read_29
   \   00000282   0x2001             MOVS     R0,#+1
   \   00000284   0xB001             ADD      SP,SP,#+4
   \   00000286   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1795                }
   1796              }
   1797          
   1798              /* Clear STOP Flag */
   1799              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_Mem_Read_27: (+1)
   \   0000028A   0x2120             MOVS     R1,#+32
   1800            	
   1801              /* Clear Configuration Register 2 */
   1802              I2C_RESET_CR2(hi2c);
   \   0000028C   0x.... 0x....      LDR.W    R2,??DataTable15_2  ;; 0xfe00e800
   \   00000290   0x61C1             STR      R1,[R0, #+28]
   \   00000292   0x6828             LDR      R0,[R5, #+0]
   \   00000294   0x6841             LDR      R1,[R0, #+4]
   \   00000296   0x4011             ANDS     R1,R2,R1
   \   00000298   0x6041             STR      R1,[R0, #+4]
   1803              
   1804              hi2c->State = HAL_I2C_STATE_READY;
   \   0000029A   0x2001             MOVS     R0,#+1
   \   0000029C   0xF885 0x0035      STRB     R0,[R5, #+53]
   1805              
   1806              /* Process Unlocked */
   1807              __HAL_UNLOCK(hi2c);
   \   000002A0   0x2000             MOVS     R0,#+0
   \   000002A2   0xF885 0x0034      STRB     R0,[R5, #+52]
   1808              
   1809              return HAL_OK;
   \   000002A6   0xB001             ADD      SP,SP,#+4
   \   000002A8   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   \                     ??HAL_I2C_Mem_Read_29: (+1)
   \   000002AC   0x2003             MOVS     R0,#+3
   \   000002AE   0xB001             ADD      SP,SP,#+4
   \   000002B0   0xE8BD 0x8FF0      POP      {R4-R11,PC}
   1810            }
   1811            else
   1812            {
   1813              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \   000002B4   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \   000002B6   0xB001             ADD      SP,SP,#+4
   \   000002B8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1814            }
   1815          }
   1816          /**
   1817            * @brief  Write an amount of data in no-blocking mode with Interrupt to a specific memory address
   1818            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1819            *                the configuration information for the specified I2C.
   1820            * @param  DevAddress: Target device address
   1821            * @param  MemAddress: Internal memory address
   1822            * @param  MemAddSize: Size of internal memory address
   1823            * @param  pData: Pointer to data buffer
   1824            * @param  Size: Amount of data to be sent
   1825            * @retval HAL status
   1826            */

   \                                 In section .text, align 2, keep-with-next
   1827          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   1828          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
   1829            /* Check the parameters */
   1830            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1831            
   1832            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80BA      BNE.W    ??HAL_I2C_Mem_Write_IT_0
   \   00000016   0x9B08             LDR      R3,[SP, #+32]
   1833            {
   1834              if((pData == NULL) || (Size == 0)) 
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x9809             LDRNE    R0,[SP, #+36]
   \   0000001E   0x2800             CMPNE    R0,#+0
   \   00000020   0xD04A             BEQ.N    ??HAL_I2C_Mem_Write_IT_1
   1835              {
   1836                return  HAL_ERROR;                                    
   1837              }
   1838              
   1839              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000022   0x6822             LDR      R2,[R4, #+0]
   \   00000024   0x6997             LDR      R7,[R2, #+24]
   \   00000026   0x043F             LSLS     R7,R7,#+16
   \   00000028   0xF100 0x80AF      BMI.W    ??HAL_I2C_Mem_Write_IT_0
   1840              {
   1841                return HAL_BUSY;
   1842              }
   1843          
   1844              /* Process Locked */
   1845              __HAL_LOCK(hi2c);
   \   0000002C   0xF894 0x7034      LDRB     R7,[R4, #+52]
   \   00000030   0x2F01             CMP      R7,#+1
   \   00000032   0xF000 0x80AA      BEQ.W    ??HAL_I2C_Mem_Write_IT_0
   \   00000036   0x2701             MOVS     R7,#+1
   1846              
   1847              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   1848              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   1849              
   1850              hi2c->pBuffPtr = pData;
   1851              hi2c->XferCount = Size;
   1852              if(Size > 255)
   1853              {
   1854                hi2c->XferSize = 255;
   1855              }
   1856              else
   1857              {
   1858                hi2c->XferSize = Size;
   1859              }
   1860              
   1861              /* Send Slave Address and Memory Address */
   1862              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000038   0x.... 0x....      LDR.W    R8,??DataTable15  ;; 0xfc009800
   \   0000003C   0xF884 0x7034      STRB     R7,[R4, #+52]
   \   00000040   0x2752             MOVS     R7,#+82
   \   00000042   0xF884 0x7035      STRB     R7,[R4, #+53]
   \   00000046   0x2700             MOVS     R7,#+0
   \   00000048   0x63A7             STR      R7,[R4, #+56]
   \   0000004A   0x28FF             CMP      R0,#+255
   \   0000004C   0x6263             STR      R3,[R4, #+36]
   \   0000004E   0x8560             STRH     R0,[R4, #+42]
   \   00000050   0xBFC8             IT       GT 
   \   00000052   0x20FF             MOVGT    R0,#+255
   \   00000054   0x8520             STRH     R0,[R4, #+40]
   \   00000056   0x058F             LSLS     R7,R1,#+22
   \   00000058   0x6850             LDR      R0,[R2, #+4]
   \   0000005A   0xB2F1             UXTB     R1,R6
   \   0000005C   0xEA08 0x0000      AND      R0,R8,R0
   \   00000060   0xEA50 0x5097      ORRS     R0,R0,R7, LSR #+22
   \   00000064   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000068   0xF040 0x7080      ORR      R0,R0,#0x1000000
   \   0000006C   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000070   0x6050             STR      R0,[R2, #+4]
   \   00000072   0x.... 0x....      BL       HAL_GetTick
   \   00000076   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \   00000078   0x6821             LDR      R1,[R4, #+0]
   \   0000007A   0x6988             LDR      R0,[R1, #+24]
   \   0000007C   0x0780             LSLS     R0,R0,#+30
   \   0000007E   0xD41F             BMI.N    ??HAL_I2C_Mem_Write_IT_3
   \   00000080   0x2119             MOVS     R1,#+25
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000088   0xB978             CBNZ.N   R0,??HAL_I2C_Mem_Write_IT_4
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0xEBA0 0x0009      SUB      R0,R0,R9
   \   00000092   0x281A             CMP      R0,#+26
   \   00000094   0xD3F0             BCC.N    ??HAL_I2C_Mem_Write_IT_2
   \   00000096   0x6BA0             LDR      R0,[R4, #+56]
   \   00000098   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000009C   0x63A0             STR      R0,[R4, #+56]
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \   000000AA   0x6BA0             LDR      R0,[R4, #+56]
   1863              {
   1864                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Write_IT_5: (+1)
   \   000000AC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000AE   0x2804             CMP      R0,#+4
   \   000000B0   0xD14D             BNE.N    ??HAL_I2C_Mem_Write_IT_6
   1865                {
   1866                  /* Process Unlocked */
   1867                  __HAL_UNLOCK(hi2c);
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF884 0x0034      STRB     R0,[R4, #+52]
   1868                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xB001             ADD      SP,SP,#+4
   \   000000BC   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1869                }
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \   000000C0   0x2E01             CMP      R6,#+1
   \   000000C2   0xD01E             BEQ.N    ??HAL_I2C_Mem_Write_IT_7
   \   000000C4   0x0A28             LSRS     R0,R5,#+8
   \   000000C6   0x6288             STR      R0,[R1, #+40]
   \   000000C8   0x.... 0x....      BL       HAL_GetTick
   \   000000CC   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Write_IT_8: (+1)
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0x6980             LDR      R0,[R0, #+24]
   \   000000D2   0x0780             LSLS     R0,R0,#+30
   \   000000D4   0xD415             BMI.N    ??HAL_I2C_Mem_Write_IT_7
   \   000000D6   0x2119             MOVS     R1,#+25
   \   000000D8   0x4620             MOV      R0,R4
   \   000000DA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD1E3             BNE.N    ??HAL_I2C_Mem_Write_IT_4
   \   000000E2   0x.... 0x....      BL       HAL_GetTick
   \   000000E6   0x1B80             SUBS     R0,R0,R6
   \   000000E8   0x281A             CMP      R0,#+26
   \   000000EA   0xD3F0             BCC.N    ??HAL_I2C_Mem_Write_IT_8
   \   000000EC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000EE   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000F2   0x63A0             STR      R0,[R4, #+56]
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000100   0xE7D3             B.N      ??HAL_I2C_Mem_Write_IT_4
   \                     ??HAL_I2C_Mem_Write_IT_7: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0xB2ED             UXTB     R5,R5
   \   00000106   0x6285             STR      R5,[R0, #+40]
   \   00000108   0x.... 0x....      BL       HAL_GetTick
   \   0000010C   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Write_IT_9: (+1)
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x6981             LDR      R1,[R0, #+24]
   \   00000112   0x0609             LSLS     R1,R1,#+24
   \   00000114   0xD40B             BMI.N    ??HAL_I2C_Mem_Write_IT_10
   \   00000116   0x.... 0x....      BL       HAL_GetTick
   \   0000011A   0x1B40             SUBS     R0,R0,R5
   \   0000011C   0x281A             CMP      R0,#+26
   \   0000011E   0xD3F6             BCC.N    ??HAL_I2C_Mem_Write_IT_9
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000012C   0xE7BE             B.N      ??HAL_I2C_Mem_Write_IT_5
   1870                else
   1871                {
   1872                  /* Process Unlocked */
   1873                  __HAL_UNLOCK(hi2c);
   1874                  return HAL_TIMEOUT;
   1875                }
   1876              }
   1877          
   1878              /* Set NBYTES to write and reload if size > 255 */
   1879              /* Size > 255, need to set RELOAD bit */
   1880              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Write_IT_10: (+1)
   \   0000012E   0x8D21             LDRH     R1,[R4, #+40]
   \   00000130   0x29FF             CMP      R1,#+255
   \   00000132   0xD113             BNE.N    ??HAL_I2C_Mem_Write_IT_11
   \   00000134   0x8D62             LDRH     R2,[R4, #+42]
   \   00000136   0x4291             CMP      R1,R2
   \   00000138   0xD210             BCS.N    ??HAL_I2C_Mem_Write_IT_11
   1881              {
   1882                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   0000013A   0x6842             LDR      R2,[R0, #+4]
   \   0000013C   0xEA08 0x0202      AND      R2,R8,R2
   \   00000140   0xEA52 0x5297      ORRS     R2,R2,R7, LSR #+22
   \   00000144   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000148   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   0000014C   0xE010             B.N      ??HAL_I2C_Mem_Write_IT_12
   1883              }
   \                     ??HAL_I2C_Mem_Write_IT_6: (+1)
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000154   0x2003             MOVS     R0,#+3
   \   00000156   0xB001             ADD      SP,SP,#+4
   \   00000158   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1884              else
   1885              {
   1886                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??HAL_I2C_Mem_Write_IT_11: (+1)
   \   0000015C   0x6842             LDR      R2,[R0, #+4]
   \   0000015E   0xB2C9             UXTB     R1,R1
   \   00000160   0xEA08 0x0202      AND      R2,R8,R2
   \   00000164   0xEA52 0x5297      ORRS     R2,R2,R7, LSR #+22
   \   00000168   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000016C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Write_IT_12: (+1)
   \   00000170   0x6041             STR      R1,[R0, #+4]
   1887              }  
   1888          
   1889              /* Process Unlocked */
   1890              __HAL_UNLOCK(hi2c); 
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0xF884 0x0034      STRB     R0,[R4, #+52]
   1891          
   1892              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1893                        to avoid the risk of I2C interrupt handle execution before current
   1894                        process unlock */
   1895              
   1896              /* Enable ERR, TC, STOP, NACK, TXI interrupt */
   1897              /* possible to enable all of these */
   1898              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1899              __HAL_I2C_ENABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \   00000178   0x6820             LDR      R0,[R4, #+0]
   \   0000017A   0x6801             LDR      R1,[R0, #+0]
   \   0000017C   0xF041 0x01F2      ORR      R1,R1,#0xF2
   \   00000180   0x6001             STR      R1,[R0, #+0]
   1900              
   1901              return HAL_OK;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0xB001             ADD      SP,SP,#+4
   \   00000186   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1902            }
   1903            else
   1904            {
   1905              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \   0000018A   0x2002             MOVS     R0,#+2
   \   0000018C   0xB001             ADD      SP,SP,#+4
   \   0000018E   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1906            }
   1907          }
   1908          
   1909          /**
   1910            * @brief  Read an amount of data in no-blocking mode with Interrupt from a specific memory address
   1911            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   1912            *                the configuration information for the specified I2C.
   1913            * @param  DevAddress: Target device address
   1914            * @param  MemAddress: Internal memory address
   1915            * @param  MemAddSize: Size of internal memory address
   1916            * @param  pData: Pointer to data buffer
   1917            * @param  Size: Amount of data to be sent
   1918            * @retval HAL status
   1919            */

   \                                 In section .text, align 2, keep-with-next
   1920          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   1921          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461E             MOV      R6,R3
   1922            /* Check the parameters */
   1923            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   1924            
   1925            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x80B8      BNE.W    ??HAL_I2C_Mem_Read_IT_0
   \   00000016   0x9B08             LDR      R3,[SP, #+32]
   1926            {
   1927              if((pData == NULL) || (Size == 0)) 
   \   00000018   0x2B00             CMP      R3,#+0
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x9809             LDRNE    R0,[SP, #+36]
   \   0000001E   0x2800             CMPNE    R0,#+0
   \   00000020   0xD046             BEQ.N    ??HAL_I2C_Mem_Read_IT_1
   1928              {
   1929                return  HAL_ERROR;                                    
   1930              }
   1931              
   1932              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000022   0x6822             LDR      R2,[R4, #+0]
   \   00000024   0x6997             LDR      R7,[R2, #+24]
   \   00000026   0x043F             LSLS     R7,R7,#+16
   \   00000028   0xF100 0x80AD      BMI.W    ??HAL_I2C_Mem_Read_IT_0
   1933              {
   1934                return HAL_BUSY;
   1935              }
   1936          
   1937              /* Process Locked */
   1938              __HAL_LOCK(hi2c);
   \   0000002C   0xF894 0x7034      LDRB     R7,[R4, #+52]
   \   00000030   0x2F01             CMP      R7,#+1
   \   00000032   0xF000 0x80A8      BEQ.W    ??HAL_I2C_Mem_Read_IT_0
   \   00000036   0x2701             MOVS     R7,#+1
   1939              
   1940              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   1941              
   1942              hi2c->pBuffPtr = pData;
   1943              hi2c->XferCount = Size;
   1944              if(Size > 255)
   1945              {
   1946                hi2c->XferSize = 255;
   1947              }
   1948              else
   1949              {
   1950                hi2c->XferSize = Size;
   1951              }
   1952              
   1953              /* Send Slave Address and Memory Address */
   1954              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000038   0x.... 0x....      LDR.W    R8,??DataTable15  ;; 0xfc009800
   \   0000003C   0xF884 0x7034      STRB     R7,[R4, #+52]
   \   00000040   0x2762             MOVS     R7,#+98
   \   00000042   0xF884 0x7035      STRB     R7,[R4, #+53]
   \   00000046   0x28FF             CMP      R0,#+255
   \   00000048   0x6263             STR      R3,[R4, #+36]
   \   0000004A   0x8560             STRH     R0,[R4, #+42]
   \   0000004C   0xBFC8             IT       GT 
   \   0000004E   0x20FF             MOVGT    R0,#+255
   \   00000050   0x8520             STRH     R0,[R4, #+40]
   \   00000052   0x058F             LSLS     R7,R1,#+22
   \   00000054   0x6850             LDR      R0,[R2, #+4]
   \   00000056   0xB2F1             UXTB     R1,R6
   \   00000058   0xEA08 0x0000      AND      R0,R8,R0
   \   0000005C   0xEA50 0x5097      ORRS     R0,R0,R7, LSR #+22
   \   00000060   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000064   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000068   0x6050             STR      R0,[R2, #+4]
   \   0000006A   0x.... 0x....      BL       HAL_GetTick
   \   0000006E   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \   00000070   0x6821             LDR      R1,[R4, #+0]
   \   00000072   0x6988             LDR      R0,[R1, #+24]
   \   00000074   0x0780             LSLS     R0,R0,#+30
   \   00000076   0xD41F             BMI.N    ??HAL_I2C_Mem_Read_IT_3
   \   00000078   0x2119             MOVS     R1,#+25
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000080   0xB978             CBNZ.N   R0,??HAL_I2C_Mem_Read_IT_4
   \   00000082   0x.... 0x....      BL       HAL_GetTick
   \   00000086   0xEBA0 0x0009      SUB      R0,R0,R9
   \   0000008A   0x281A             CMP      R0,#+26
   \   0000008C   0xD3F0             BCC.N    ??HAL_I2C_Mem_Read_IT_2
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000094   0x63A0             STR      R0,[R4, #+56]
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \   000000A2   0x6BA0             LDR      R0,[R4, #+56]
   1955              {
   1956                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Read_IT_5: (+1)
   \   000000A4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000A6   0x2804             CMP      R0,#+4
   \   000000A8   0xD14D             BNE.N    ??HAL_I2C_Mem_Read_IT_6
   1957                {
   1958                  /* Process Unlocked */
   1959                  __HAL_UNLOCK(hi2c);
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x0034      STRB     R0,[R4, #+52]
   1960                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xB001             ADD      SP,SP,#+4
   \   000000B4   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1961                }
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \   000000B8   0x2E01             CMP      R6,#+1
   \   000000BA   0xD01E             BEQ.N    ??HAL_I2C_Mem_Read_IT_7
   \   000000BC   0x0A28             LSRS     R0,R5,#+8
   \   000000BE   0x6288             STR      R0,[R1, #+40]
   \   000000C0   0x.... 0x....      BL       HAL_GetTick
   \   000000C4   0x4606             MOV      R6,R0
   \                     ??HAL_I2C_Mem_Read_IT_8: (+1)
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0x6980             LDR      R0,[R0, #+24]
   \   000000CA   0x0780             LSLS     R0,R0,#+30
   \   000000CC   0xD415             BMI.N    ??HAL_I2C_Mem_Read_IT_7
   \   000000CE   0x2119             MOVS     R1,#+25
   \   000000D0   0x4620             MOV      R0,R4
   \   000000D2   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD1E3             BNE.N    ??HAL_I2C_Mem_Read_IT_4
   \   000000DA   0x.... 0x....      BL       HAL_GetTick
   \   000000DE   0x1B80             SUBS     R0,R0,R6
   \   000000E0   0x281A             CMP      R0,#+26
   \   000000E2   0xD3F0             BCC.N    ??HAL_I2C_Mem_Read_IT_8
   \   000000E4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000E6   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000EA   0x63A0             STR      R0,[R4, #+56]
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000F8   0xE7D3             B.N      ??HAL_I2C_Mem_Read_IT_4
   \                     ??HAL_I2C_Mem_Read_IT_7: (+1)
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0xB2ED             UXTB     R5,R5
   \   000000FE   0x6285             STR      R5,[R0, #+40]
   \   00000100   0x.... 0x....      BL       HAL_GetTick
   \   00000104   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Read_IT_9: (+1)
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x6981             LDR      R1,[R0, #+24]
   \   0000010A   0x0649             LSLS     R1,R1,#+25
   \   0000010C   0xD40B             BMI.N    ??HAL_I2C_Mem_Read_IT_10
   \   0000010E   0x.... 0x....      BL       HAL_GetTick
   \   00000112   0x1B40             SUBS     R0,R0,R5
   \   00000114   0x281A             CMP      R0,#+26
   \   00000116   0xD3F6             BCC.N    ??HAL_I2C_Mem_Read_IT_9
   \   00000118   0x2001             MOVS     R0,#+1
   \   0000011A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000124   0xE7BE             B.N      ??HAL_I2C_Mem_Read_IT_5
   1962                else
   1963                {
   1964                  /* Process Unlocked */
   1965                  __HAL_UNLOCK(hi2c);
   1966                  return HAL_TIMEOUT;
   1967                }
   1968              }
   1969                
   1970              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   1971              /* Size > 255, need to set RELOAD bit */
   1972              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Read_IT_10: (+1)
   \   00000126   0x8D21             LDRH     R1,[R4, #+40]
   \   00000128   0x29FF             CMP      R1,#+255
   \   0000012A   0xD113             BNE.N    ??HAL_I2C_Mem_Read_IT_11
   \   0000012C   0x8D62             LDRH     R2,[R4, #+42]
   \   0000012E   0x4291             CMP      R1,R2
   \   00000130   0xD210             BCS.N    ??HAL_I2C_Mem_Read_IT_11
   1973              {
   1974                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000132   0x6842             LDR      R2,[R0, #+4]
   \   00000134   0xEA08 0x0202      AND      R2,R8,R2
   \   00000138   0xEA52 0x5297      ORRS     R2,R2,R7, LSR #+22
   \   0000013C   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000140   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000144   0xE010             B.N      ??HAL_I2C_Mem_Read_IT_12
   1975              }
   \                     ??HAL_I2C_Mem_Read_IT_6: (+1)
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000014C   0x2003             MOVS     R0,#+3
   \   0000014E   0xB001             ADD      SP,SP,#+4
   \   00000150   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1976              else
   1977              {
   1978                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_IT_11: (+1)
   \   00000154   0x6842             LDR      R2,[R0, #+4]
   \   00000156   0xB2C9             UXTB     R1,R1
   \   00000158   0xEA08 0x0202      AND      R2,R8,R2
   \   0000015C   0xEA52 0x5297      ORRS     R2,R2,R7, LSR #+22
   \   00000160   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000164   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Read_IT_12: (+1)
   \   00000168   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   0000016C   0x6041             STR      R1,[R0, #+4]
   1979              }
   1980          
   1981              /* Process Unlocked */
   1982              __HAL_UNLOCK(hi2c); 
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF884 0x0034      STRB     R0,[R4, #+52]
   1983          
   1984              /* Note : The I2C interrupts must be enabled after unlocking current process 
   1985                        to avoid the risk of I2C interrupt handle execution before current
   1986                        process unlock */
   1987              
   1988              /* Enable ERR, TC, STOP, NACK, RXI interrupt */
   1989              /* possible to enable all of these */
   1990              /* I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
   1991              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
   \   00000174   0x6820             LDR      R0,[R4, #+0]
   \   00000176   0x6801             LDR      R1,[R0, #+0]
   \   00000178   0xF041 0x01F4      ORR      R1,R1,#0xF4
   \   0000017C   0x6001             STR      R1,[R0, #+0]
   1992              
   1993              return HAL_OK;
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0xB001             ADD      SP,SP,#+4
   \   00000182   0xE8BD 0x83F0      POP      {R4-R9,PC}
   1994            }
   1995            else
   1996            {
   1997              return HAL_BUSY; 
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \   00000186   0x2002             MOVS     R0,#+2
   \   00000188   0xB001             ADD      SP,SP,#+4
   \   0000018A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1998            }   
   1999          }
   2000          /**
   2001            * @brief  Write an amount of data in no-blocking mode with DMA to a specific memory address
   2002            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2003            *                the configuration information for the specified I2C.
   2004            * @param  DevAddress: Target device address
   2005            * @param  MemAddress: Internal memory address
   2006            * @param  MemAddSize: Size of internal memory address
   2007            * @param  pData: Pointer to data buffer
   2008            * @param  Size: Amount of data to be sent
   2009            * @retval HAL status
   2010            */

   \                                 In section .text, align 2, keep-with-next
   2011          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2012          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4615             MOV      R5,R2
   2013            /* Check the parameters */
   2014            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2015            
   2016            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x4698             MOV      R8,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x80EF      BNE.W    ??HAL_I2C_Mem_Write_DMA_0
   \   00000018   0x9908             LDR      R1,[SP, #+32]
   2017            {
   2018              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x9809             LDRNE    R0,[SP, #+36]
   \   00000020   0x2800             CMPNE    R0,#+0
   \   00000022   0xF000 0x80D6      BEQ.W    ??HAL_I2C_Mem_Write_DMA_1
   2019              {
   2020                return  HAL_ERROR;                                    
   2021              }
   2022              
   2023              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000026   0x6822             LDR      R2,[R4, #+0]
   \   00000028   0x6992             LDR      R2,[R2, #+24]
   \   0000002A   0x0412             LSLS     R2,R2,#+16
   \   0000002C   0xF100 0x80E3      BMI.W    ??HAL_I2C_Mem_Write_DMA_0
   2024              {
   2025                return HAL_BUSY;
   2026              }
   2027          
   2028              /* Process Locked */
   2029              __HAL_LOCK(hi2c);
   \   00000030   0xF894 0x2034      LDRB     R2,[R4, #+52]
   \   00000034   0x2A01             CMP      R2,#+1
   \   00000036   0xF000 0x80DE      BEQ.W    ??HAL_I2C_Mem_Write_DMA_0
   \   0000003A   0x2201             MOVS     R2,#+1
   2030              
   2031              hi2c->State = HAL_I2C_STATE_MEM_BUSY_TX;
   2032              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   2033              
   2034              hi2c->pBuffPtr = pData;
   2035              hi2c->XferCount = Size;
   2036              if(Size > 255)
   2037              {
   2038                hi2c->XferSize = 255;
   2039              }
   2040              else
   2041              {
   2042                hi2c->XferSize = Size;
   2043              }
   2044              
   2045              /* Set the I2C DMA transfer complete callback */
   2046              hi2c->hdmatx->XferCpltCallback = I2C_DMAMemTransmitCplt;
   2047              
   2048              /* Set the DMA error callback */
   2049              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   2050              
   2051              /* Enable the DMA channel */
   2052              HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   0000003C   0x.... 0x....      LDR.W    R7,??DataTable15  ;; 0xfc009800
   \   00000040   0xF884 0x2034      STRB     R2,[R4, #+52]
   \   00000044   0x2252             MOVS     R2,#+82
   \   00000046   0xF884 0x2035      STRB     R2,[R4, #+53]
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x63A2             STR      R2,[R4, #+56]
   \   0000004E   0x28FF             CMP      R0,#+255
   \   00000050   0x6261             STR      R1,[R4, #+36]
   \   00000052   0x8560             STRH     R0,[R4, #+42]
   \   00000054   0xBFC8             IT       GT 
   \   00000056   0x20FF             MOVGT    R0,#+255
   \   00000058   0x8520             STRH     R0,[R4, #+40]
   \   0000005A   0x6AE2             LDR      R2,[R4, #+44]
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000060   0x05B6             LSLS     R6,R6,#+22
   \   00000062   0x63D0             STR      R0,[R2, #+60]
   \   00000064   0x6AE2             LDR      R2,[R4, #+44]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000006A   0x6490             STR      R0,[R2, #+72]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x8D23             LDRH     R3,[R4, #+40]
   \   00000070   0xF100 0x0228      ADD      R2,R0,#+40
   \   00000074   0x6AE0             LDR      R0,[R4, #+44]
   \   00000076   0x.... 0x....      BL       HAL_DMA_Start_IT
   2053              
   2054              /* Send Slave Address and Memory Address */
   2055              if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0xFA5F 0xF288      UXTB     R2,R8
   \   00000080   0x6841             LDR      R1,[R0, #+4]
   \   00000082   0x4039             ANDS     R1,R7,R1
   \   00000084   0xEA51 0x5196      ORRS     R1,R1,R6, LSR #+22
   \   00000088   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000008C   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000090   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000094   0x6041             STR      R1,[R0, #+4]
   \   00000096   0x.... 0x....      BL       HAL_GetTick
   \   0000009A   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6988             LDR      R0,[R1, #+24]
   \   000000A0   0x0780             LSLS     R0,R0,#+30
   \   000000A2   0xD41F             BMI.N    ??HAL_I2C_Mem_Write_DMA_3
   \   000000A4   0x2119             MOVS     R1,#+25
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000AC   0xB978             CBNZ.N   R0,??HAL_I2C_Mem_Write_DMA_4
   \   000000AE   0x.... 0x....      BL       HAL_GetTick
   \   000000B2   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000B6   0x281A             CMP      R0,#+26
   \   000000B8   0xD3F0             BCC.N    ??HAL_I2C_Mem_Write_DMA_2
   \   000000BA   0x6BA0             LDR      R0,[R4, #+56]
   \   000000BC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000C0   0x63A0             STR      R0,[R4, #+56]
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \   000000CE   0x6BA0             LDR      R0,[R4, #+56]
   2056              {
   2057                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \   000000D0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D2   0x2804             CMP      R0,#+4
   \   000000D4   0xD14E             BNE.N    ??HAL_I2C_Mem_Write_DMA_6
   2058                {
   2059                  /* Process Unlocked */
   2060                  __HAL_UNLOCK(hi2c);
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xF884 0x0034      STRB     R0,[R4, #+52]
   2061                  return HAL_ERROR;
   2062                }
   2063                else
   2064                {
   2065                  /* Process Unlocked */
   2066                  __HAL_UNLOCK(hi2c);
   2067                  return HAL_TIMEOUT;
   2068                }
   2069              }
   2070              
   2071              /* Send Slave Address */
   2072              /* Set NBYTES to write and reload if size > 255 */
   2073              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   2074              {
   2075                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   2076              }
   2077              else
   2078              {
   2079                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   2080              }
   2081              
   2082              /* Wait until TXIS flag is set */
   2083              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   2084              {
   2085                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   2086                {
   2087                  return HAL_ERROR;
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xB001             ADD      SP,SP,#+4
   \   000000E0   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \   000000E4   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000E8   0xD01F             BEQ.N    ??HAL_I2C_Mem_Write_DMA_7
   \   000000EA   0x0A28             LSRS     R0,R5,#+8
   \   000000EC   0x6288             STR      R0,[R1, #+40]
   \   000000EE   0x.... 0x....      BL       HAL_GetTick
   \   000000F2   0x4680             MOV      R8,R0
   \                     ??HAL_I2C_Mem_Write_DMA_8: (+1)
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0x6980             LDR      R0,[R0, #+24]
   \   000000F8   0x0780             LSLS     R0,R0,#+30
   \   000000FA   0xD416             BMI.N    ??HAL_I2C_Mem_Write_DMA_7
   \   000000FC   0x2119             MOVS     R1,#+25
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD1E2             BNE.N    ??HAL_I2C_Mem_Write_DMA_4
   \   00000108   0x.... 0x....      BL       HAL_GetTick
   \   0000010C   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000110   0x281A             CMP      R0,#+26
   \   00000112   0xD3EF             BCC.N    ??HAL_I2C_Mem_Write_DMA_8
   \   00000114   0x6BA0             LDR      R0,[R4, #+56]
   \   00000116   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000011A   0x63A0             STR      R0,[R4, #+56]
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000128   0xE7D1             B.N      ??HAL_I2C_Mem_Write_DMA_4
   \                     ??HAL_I2C_Mem_Write_DMA_7: (+1)
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0xB2ED             UXTB     R5,R5
   \   0000012E   0x6285             STR      R5,[R0, #+40]
   \   00000130   0x.... 0x....      BL       HAL_GetTick
   \   00000134   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Write_DMA_9: (+1)
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x6981             LDR      R1,[R0, #+24]
   \   0000013A   0x0609             LSLS     R1,R1,#+24
   \   0000013C   0xD40B             BMI.N    ??HAL_I2C_Mem_Write_DMA_10
   \   0000013E   0x.... 0x....      BL       HAL_GetTick
   \   00000142   0x1B40             SUBS     R0,R0,R5
   \   00000144   0x281A             CMP      R0,#+26
   \   00000146   0xD3F6             BCC.N    ??HAL_I2C_Mem_Write_DMA_9
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000154   0xE7BC             B.N      ??HAL_I2C_Mem_Write_DMA_5
   \                     ??HAL_I2C_Mem_Write_DMA_10: (+1)
   \   00000156   0x8D21             LDRH     R1,[R4, #+40]
   \   00000158   0x29FF             CMP      R1,#+255
   \   0000015A   0xD112             BNE.N    ??HAL_I2C_Mem_Write_DMA_11
   \   0000015C   0x8D62             LDRH     R2,[R4, #+42]
   \   0000015E   0x4291             CMP      R1,R2
   \   00000160   0xD20F             BCS.N    ??HAL_I2C_Mem_Write_DMA_11
   \   00000162   0x6842             LDR      R2,[R0, #+4]
   \   00000164   0x403A             ANDS     R2,R7,R2
   \   00000166   0xEA52 0x5296      ORRS     R2,R2,R6, LSR #+22
   \   0000016A   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000016E   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000172   0xE00F             B.N      ??HAL_I2C_Mem_Write_DMA_12
   \                     ??HAL_I2C_Mem_Write_DMA_6: (+1)
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0xF884 0x0034      STRB     R0,[R4, #+52]
   2088                }
   2089                else
   2090                {
   2091                  return HAL_TIMEOUT;
   \   0000017A   0x2003             MOVS     R0,#+3
   \   0000017C   0xB001             ADD      SP,SP,#+4
   \   0000017E   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??HAL_I2C_Mem_Write_DMA_11: (+1)
   \   00000182   0x6842             LDR      R2,[R0, #+4]
   \   00000184   0xB2C9             UXTB     R1,R1
   \   00000186   0x403A             ANDS     R2,R7,R2
   \   00000188   0xEA52 0x5296      ORRS     R2,R2,R6, LSR #+22
   \   0000018C   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000190   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Write_DMA_12: (+1)
   \   00000194   0x6041             STR      R1,[R0, #+4]
   \   00000196   0x.... 0x....      BL       HAL_GetTick
   \   0000019A   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Write_DMA_13: (+1)
   \   0000019C   0x6820             LDR      R0,[R4, #+0]
   \   0000019E   0x6981             LDR      R1,[R0, #+24]
   \   000001A0   0x0789             LSLS     R1,R1,#+30
   \   000001A2   0xD41A             BMI.N    ??HAL_I2C_Mem_Write_DMA_14
   \   000001A4   0x2119             MOVS     R1,#+25
   \   000001A6   0x4620             MOV      R0,R4
   \   000001A8   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001AC   0xB970             CBNZ.N   R0,??HAL_I2C_Mem_Write_DMA_15
   \   000001AE   0x.... 0x....      BL       HAL_GetTick
   \   000001B2   0x1B40             SUBS     R0,R0,R5
   \   000001B4   0x281A             CMP      R0,#+26
   \   000001B6   0xD3F1             BCC.N    ??HAL_I2C_Mem_Write_DMA_13
   \   000001B8   0x6BA0             LDR      R0,[R4, #+56]
   \   000001BA   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001BE   0x63A0             STR      R0,[R4, #+56]
   \   000001C0   0x2001             MOVS     R0,#+1
   \   000001C2   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Write_DMA_15: (+1)
   \   000001CC   0x6BA0             LDR      R0,[R4, #+56]
   \   000001CE   0x2804             CMP      R0,#+4
   \   000001D0   0xD10D             BNE.N    ??HAL_I2C_Mem_Write_DMA_16
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \   000001D2   0x2001             MOVS     R0,#+1
   \   000001D4   0xB001             ADD      SP,SP,#+4
   \   000001D6   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2092                }
   2093              }
   2094          
   2095              /* Enable DMA Request */
   2096              hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;  
   \                     ??HAL_I2C_Mem_Write_DMA_14: (+1)
   \   000001DA   0x6801             LDR      R1,[R0, #+0]
   \   000001DC   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000001E0   0x6001             STR      R1,[R0, #+0]
   2097              
   2098              /* Process Unlocked */
   2099              __HAL_UNLOCK(hi2c);
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0xF884 0x0034      STRB     R0,[R4, #+52]
   2100              
   2101              return HAL_OK;
   \   000001E8   0xB001             ADD      SP,SP,#+4
   \   000001EA   0xE8BD 0x83F0      POP      {R4-R9,PC}
   \                     ??HAL_I2C_Mem_Write_DMA_16: (+1)
   \   000001EE   0x2003             MOVS     R0,#+3
   \   000001F0   0xB001             ADD      SP,SP,#+4
   \   000001F2   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2102            }
   2103            else
   2104            {
   2105              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \   000001F6   0x2002             MOVS     R0,#+2
   \   000001F8   0xB001             ADD      SP,SP,#+4
   \   000001FA   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2106            }
   2107          }
   2108          
   2109          /**
   2110            * @brief  Reads an amount of data in no-blocking mode with DMA from a specific memory address.
   2111            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2112            *                the configuration information for the specified I2C.
   2113            * @param  DevAddress: Target device address
   2114            * @param  MemAddress: Internal memory address
   2115            * @param  MemAddSize: Size of internal memory address
   2116            * @param  pData: Pointer to data buffer
   2117            * @param  Size: Amount of data to be read
   2118            * @retval HAL status
   2119            */

   \                                 In section .text, align 2, keep-with-next
   2120          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2121          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4615             MOV      R5,R2
   2122            /* Check the parameters */
   2123            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2124            
   2125            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x4698             MOV      R8,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xF040 0x80D4      BNE.W    ??HAL_I2C_Mem_Read_DMA_0
   \   00000018   0x9A08             LDR      R2,[SP, #+32]
   2126            {
   2127              if((pData == NULL) || (Size == 0)) 
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x9809             LDRNE    R0,[SP, #+36]
   \   00000020   0x2800             CMPNE    R0,#+0
   \   00000022   0xD055             BEQ.N    ??HAL_I2C_Mem_Read_DMA_1
   2128              {
   2129                return  HAL_ERROR;                                    
   2130              }
   2131          
   2132              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6989             LDR      R1,[R1, #+24]
   \   00000028   0x0409             LSLS     R1,R1,#+16
   \   0000002A   0xF100 0x80C9      BMI.W    ??HAL_I2C_Mem_Read_DMA_0
   2133              {
   2134                return HAL_BUSY;
   2135              }
   2136          
   2137              /* Process Locked */
   2138              __HAL_LOCK(hi2c);
   \   0000002E   0xF894 0x1034      LDRB     R1,[R4, #+52]
   \   00000032   0x2901             CMP      R1,#+1
   \   00000034   0xF000 0x80C4      BEQ.W    ??HAL_I2C_Mem_Read_DMA_0
   \   00000038   0x2101             MOVS     R1,#+1
   2139              
   2140              hi2c->State = HAL_I2C_STATE_MEM_BUSY_RX;
   2141              
   2142              hi2c->pBuffPtr = pData;
   2143              hi2c->XferCount = Size;
   2144              if(Size > 255)
   2145              {
   2146                hi2c->XferSize = 255;
   2147              }
   2148              else
   2149              {
   2150                hi2c->XferSize = Size;
   2151              }
   2152          
   2153              /* Set the I2C DMA transfer complete callback */
   2154              hi2c->hdmarx->XferCpltCallback = I2C_DMAMemReceiveCplt;
   2155              
   2156              /* Set the DMA error callback */
   2157              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   2158              
   2159              /* Enable the DMA channel */
   2160              HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)pData, hi2c->XferSize);
   \   0000003A   0x....             LDR.N    R7,??DataTable15  ;; 0xfc009800
   \   0000003C   0xF884 0x1034      STRB     R1,[R4, #+52]
   \   00000040   0x2162             MOVS     R1,#+98
   \   00000042   0xF884 0x1035      STRB     R1,[R4, #+53]
   \   00000046   0x28FF             CMP      R0,#+255
   \   00000048   0x6262             STR      R2,[R4, #+36]
   \   0000004A   0x8560             STRH     R0,[R4, #+42]
   \   0000004C   0xBFC8             IT       GT 
   \   0000004E   0x20FF             MOVGT    R0,#+255
   \   00000050   0x8520             STRH     R0,[R4, #+40]
   \   00000052   0x6B21             LDR      R1,[R4, #+48]
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000058   0x05B6             LSLS     R6,R6,#+22
   \   0000005A   0x63C8             STR      R0,[R1, #+60]
   \   0000005C   0x6B21             LDR      R1,[R4, #+48]
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000062   0x6488             STR      R0,[R1, #+72]
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x8D23             LDRH     R3,[R4, #+40]
   \   00000068   0xF100 0x0124      ADD      R1,R0,#+36
   \   0000006C   0x6B20             LDR      R0,[R4, #+48]
   \   0000006E   0x.... 0x....      BL       HAL_DMA_Start_IT
   2161              
   2162              /* Send Slave Address and Memory Address */
   2163              if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG) != HAL_OK)
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xFA5F 0xF288      UXTB     R2,R8
   \   00000078   0x6841             LDR      R1,[R0, #+4]
   \   0000007A   0x4039             ANDS     R1,R7,R1
   \   0000007C   0xEA51 0x5196      ORRS     R1,R1,R6, LSR #+22
   \   00000080   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000084   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000088   0x6041             STR      R1,[R0, #+4]
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0x4681             MOV      R9,R0
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \   00000090   0x6821             LDR      R1,[R4, #+0]
   \   00000092   0x6988             LDR      R0,[R1, #+24]
   \   00000094   0x0780             LSLS     R0,R0,#+30
   \   00000096   0xD41F             BMI.N    ??HAL_I2C_Mem_Read_DMA_3
   \   00000098   0x2119             MOVS     R1,#+25
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000A0   0xB978             CBNZ.N   R0,??HAL_I2C_Mem_Read_DMA_4
   \   000000A2   0x.... 0x....      BL       HAL_GetTick
   \   000000A6   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000AA   0x281A             CMP      R0,#+26
   \   000000AC   0xD3F0             BCC.N    ??HAL_I2C_Mem_Read_DMA_2
   \   000000AE   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B0   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000B4   0x63A0             STR      R0,[R4, #+56]
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \   000000C2   0x6BA0             LDR      R0,[R4, #+56]
   2164              {
   2165                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \   000000C4   0x6BA0             LDR      R0,[R4, #+56]
   \   000000C6   0x2804             CMP      R0,#+4
   \   000000C8   0xD169             BNE.N    ??HAL_I2C_Mem_Read_DMA_6
   2166                {
   2167                  /* Process Unlocked */
   2168                  __HAL_UNLOCK(hi2c);
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF884 0x0034      STRB     R0,[R4, #+52]
   2169                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xB001             ADD      SP,SP,#+4
   \   000000D4   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2170                }
   2171                else
   2172                {
   2173                  /* Process Unlocked */
   2174                  __HAL_UNLOCK(hi2c);
   2175                  return HAL_TIMEOUT;
   2176                }
   2177              }
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \   000000D8   0xF1B8 0x0F01      CMP      R8,#+1
   \   000000DC   0xD01F             BEQ.N    ??HAL_I2C_Mem_Read_DMA_7
   \   000000DE   0x0A28             LSRS     R0,R5,#+8
   \   000000E0   0x6288             STR      R0,[R1, #+40]
   \   000000E2   0x.... 0x....      BL       HAL_GetTick
   \   000000E6   0x4680             MOV      R8,R0
   \                     ??HAL_I2C_Mem_Read_DMA_8: (+1)
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6980             LDR      R0,[R0, #+24]
   \   000000EC   0x0780             LSLS     R0,R0,#+30
   \   000000EE   0xD416             BMI.N    ??HAL_I2C_Mem_Read_DMA_7
   \   000000F0   0x2119             MOVS     R1,#+25
   \   000000F2   0x4620             MOV      R0,R4
   \   000000F4   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD1E2             BNE.N    ??HAL_I2C_Mem_Read_DMA_4
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0xEBA0 0x0008      SUB      R0,R0,R8
   \   00000104   0x281A             CMP      R0,#+26
   \   00000106   0xD3EF             BCC.N    ??HAL_I2C_Mem_Read_DMA_8
   \   00000108   0x6BA0             LDR      R0,[R4, #+56]
   \   0000010A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000010E   0x63A0             STR      R0,[R4, #+56]
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000011C   0xE7D1             B.N      ??HAL_I2C_Mem_Read_DMA_4
   \                     ??HAL_I2C_Mem_Read_DMA_7: (+1)
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0xB2ED             UXTB     R5,R5
   \   00000122   0x6285             STR      R5,[R0, #+40]
   \   00000124   0x.... 0x....      BL       HAL_GetTick
   \   00000128   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Read_DMA_9: (+1)
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x6981             LDR      R1,[R0, #+24]
   \   0000012E   0x0649             LSLS     R1,R1,#+25
   \   00000130   0xD40B             BMI.N    ??HAL_I2C_Mem_Read_DMA_10
   \   00000132   0x.... 0x....      BL       HAL_GetTick
   \   00000136   0x1B40             SUBS     R0,R0,R5
   \   00000138   0x281A             CMP      R0,#+26
   \   0000013A   0xD3F6             BCC.N    ??HAL_I2C_Mem_Read_DMA_9
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000148   0xE7BC             B.N      ??HAL_I2C_Mem_Read_DMA_5
   2178              
   2179              /* Set NBYTES to write and reload if size > 255 and generate RESTART */
   2180              if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \                     ??HAL_I2C_Mem_Read_DMA_10: (+1)
   \   0000014A   0x8D21             LDRH     R1,[R4, #+40]
   \   0000014C   0x29FF             CMP      R1,#+255
   \   0000014E   0xD10B             BNE.N    ??HAL_I2C_Mem_Read_DMA_11
   \   00000150   0x8D62             LDRH     R2,[R4, #+42]
   \   00000152   0x4291             CMP      R1,R2
   \   00000154   0xD208             BCS.N    ??HAL_I2C_Mem_Read_DMA_11
   2181              {
   2182                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
   \   00000156   0x6842             LDR      R2,[R0, #+4]
   \   00000158   0x403A             ANDS     R2,R7,R2
   \   0000015A   0xEA52 0x5296      ORRS     R2,R2,R6, LSR #+22
   \   0000015E   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000162   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000166   0xE008             B.N      ??HAL_I2C_Mem_Read_DMA_12
   2183              }
   2184              else
   2185              {
   2186                I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
   \                     ??HAL_I2C_Mem_Read_DMA_11: (+1)
   \   00000168   0x6842             LDR      R2,[R0, #+4]
   \   0000016A   0xB2C9             UXTB     R1,R1
   \   0000016C   0x403A             ANDS     R2,R7,R2
   \   0000016E   0xEA52 0x5296      ORRS     R2,R2,R6, LSR #+22
   \   00000172   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000176   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??HAL_I2C_Mem_Read_DMA_12: (+1)
   \   0000017A   0xF441 0x5110      ORR      R1,R1,#0x2400
   \   0000017E   0x6041             STR      R1,[R0, #+4]
   2187              }
   2188          
   2189              /* Wait until RXNE flag is set */
   2190              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   00000180   0x.... 0x....      BL       HAL_GetTick
   \   00000184   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_Mem_Read_DMA_13: (+1)
   \   00000186   0x6820             LDR      R0,[R4, #+0]
   \   00000188   0x6981             LDR      R1,[R0, #+24]
   \   0000018A   0x0749             LSLS     R1,R1,#+29
   \   0000018C   0xD40E             BMI.N    ??HAL_I2C_Mem_Read_DMA_14
   \   0000018E   0x.... 0x....      BL       HAL_GetTick
   \   00000192   0x1B40             SUBS     R0,R0,R5
   \   00000194   0x281A             CMP      R0,#+26
   \   00000196   0xD3F6             BCC.N    ??HAL_I2C_Mem_Read_DMA_13
   \   00000198   0x2001             MOVS     R0,#+1
   \   0000019A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0xF884 0x0034      STRB     R0,[R4, #+52]
   2191              {
   2192                return HAL_TIMEOUT;
   \   000001A4   0x2003             MOVS     R0,#+3
   \   000001A6   0xB001             ADD      SP,SP,#+4
   \   000001A8   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2193              }
   2194              
   2195              /* Enable DMA Request */
   2196              hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;  
   \                     ??HAL_I2C_Mem_Read_DMA_14: (+1)
   \   000001AC   0x6801             LDR      R1,[R0, #+0]
   \   000001AE   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001B2   0x6001             STR      R1,[R0, #+0]
   2197              
   2198              /* Process Unlocked */
   2199              __HAL_UNLOCK(hi2c);
   \   000001B4   0x2000             MOVS     R0,#+0
   \   000001B6   0xF884 0x0034      STRB     R0,[R4, #+52]
   2200              
   2201              return HAL_OK;
   \   000001BA   0xB001             ADD      SP,SP,#+4
   \   000001BC   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2202            }
   2203            else
   2204            {
   2205              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \   000001C0   0x2002             MOVS     R0,#+2
   \   000001C2   0xB001             ADD      SP,SP,#+4
   \   000001C4   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2206            }
   2207          }
   2208          
   2209          /**
   2210            * @brief  Checks if target device is ready for communication. 
   2211            * @note   This function is used with Memory devices
   2212            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2213            *                the configuration information for the specified I2C.
   2214            * @param  DevAddress: Target device address
   2215            * @param  Trials: Number of trials
   2216            * @param  Timeout: Timeout duration
   2217            * @retval HAL status
   2218            */

   \                                 In section .text, align 2, keep-with-next
   2219          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   2220          {  
   \                     HAL_I2C_IsDeviceReady: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB081             SUB      SP,SP,#+4
   2221            uint32_t tickstart = 0;
   2222            
   2223            __IO uint32_t I2C_Trials = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4615             MOV      R5,R2
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   2224           
   2225            if(hi2c->State == HAL_I2C_STATE_READY)
   \   0000000E   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000012   0x461E             MOV      R6,R3
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xF040 0x809A      BNE.W    ??HAL_I2C_IsDeviceReady_0
   2226            {
   2227              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0x0400             LSLS     R0,R0,#+16
   \   00000020   0xF100 0x8095      BMI.W    ??HAL_I2C_IsDeviceReady_0
   2228              {
   2229                return HAL_BUSY;
   2230              }
   2231          
   2232              /* Process Locked */
   2233              __HAL_LOCK(hi2c);
   \   00000024   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xF000 0x8090      BEQ.W    ??HAL_I2C_IsDeviceReady_0
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0034      STRB     R0,[R4, #+52]
   2234              
   2235              hi2c->State = HAL_I2C_STATE_BUSY;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xF884 0x0035      STRB     R0,[R4, #+53]
   2236              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63A0             STR      R0,[R4, #+56]
   \   0000003E   0x0588             LSLS     R0,R1,#+22
   \   00000040   0x0D80             LSRS     R0,R0,#+22
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable19_1  ;; 0x2002000
   \   00000046   0xF440 0x5920      ORR      R9,R0,#0x2800
   \   0000004A   0xEA41 0x0800      ORR      R8,R1,R0
   2237              
   2238              do
   2239              {
   2240                /* Generate Start */
   2241                hi2c->Instance->CR2 = I2C_GENERATE_START(hi2c->Init.AddressingMode,DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \   0000004E   0x68E0             LDR      R0,[R4, #+12]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xBF0C             ITE      EQ 
   \   00000054   0x4640             MOVEQ    R0,R8
   \   00000056   0x4648             MOVNE    R0,R9
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6048             STR      R0,[R1, #+4]
   2242                
   2243                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   2244                /* Wait until STOPF flag is set or a NACK flag is set*/
   2245                tickstart = HAL_GetTick();
   \   0000005C   0x.... 0x....      BL       HAL_GetTick
   \   00000060   0x4607             MOV      R7,R0
   2246                while((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET) && (hi2c->State != HAL_I2C_STATE_TIMEOUT))
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6981             LDR      R1,[R0, #+24]
   \   00000066   0x0689             LSLS     R1,R1,#+26
   \   00000068   0xD411             BMI.N    ??HAL_I2C_IsDeviceReady_3
   \   0000006A   0x6981             LDR      R1,[R0, #+24]
   \   0000006C   0x06C9             LSLS     R1,R1,#+27
   \   0000006E   0xD40E             BMI.N    ??HAL_I2C_IsDeviceReady_3
   \   00000070   0xF894 0x1035      LDRB     R1,[R4, #+53]
   \   00000074   0x2903             CMP      R1,#+3
   \   00000076   0xD00A             BEQ.N    ??HAL_I2C_IsDeviceReady_3
   2247                {
   2248                	if(Timeout != HAL_MAX_DELAY)
   \   00000078   0xF116 0x0F01      CMN      R6,#+1
   \   0000007C   0xD0F1             BEQ.N    ??HAL_I2C_IsDeviceReady_2
   2249                	{
   2250                    if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000007E   0x2E00             CMP      R6,#+0
   \   00000080   0xD05B             BEQ.N    ??HAL_I2C_IsDeviceReady_4
   \   00000082   0x.... 0x....      BL       HAL_GetTick
   \   00000086   0x1BC0             SUBS     R0,R0,R7
   \   00000088   0x4286             CMP      R6,R0
   \   0000008A   0xD2EA             BCS.N    ??HAL_I2C_IsDeviceReady_2
   \   0000008C   0xE055             B.N      ??HAL_I2C_IsDeviceReady_4
   2251                    {
   2252                      /* Device is ready */
   2253                      hi2c->State = HAL_I2C_STATE_READY;
   2254                      /* Process Unlocked */
   2255                      __HAL_UNLOCK(hi2c);         
   2256                      return HAL_TIMEOUT;
   2257                    }
   2258                  } 
   2259                }
   2260                
   2261                /* Check if the NACKF flag has not been set */
   2262                if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == RESET)
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \   0000008E   0x6980             LDR      R0,[R0, #+24]
   \   00000090   0x06C0             LSLS     R0,R0,#+27
   \   00000092   0xD41C             BMI.N    ??HAL_I2C_IsDeviceReady_5
   2263                {
   2264                  /* Wait until STOPF flag is reset */ 
   2265                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \   00000094   0x.... 0x....      BL       HAL_GetTick
   \   00000098   0x4605             MOV      R5,R0
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6981             LDR      R1,[R0, #+24]
   \   0000009E   0x0689             LSLS     R1,R1,#+26
   \   000000A0   0xD40A             BMI.N    ??HAL_I2C_IsDeviceReady_7
   \   000000A2   0xF116 0x0F01      CMN      R6,#+1
   \   000000A6   0xD0F8             BEQ.N    ??HAL_I2C_IsDeviceReady_6
   \   000000A8   0x2E00             CMP      R6,#+0
   \   000000AA   0xD046             BEQ.N    ??HAL_I2C_IsDeviceReady_4
   \   000000AC   0x.... 0x....      BL       HAL_GetTick
   \   000000B0   0x1B40             SUBS     R0,R0,R5
   \   000000B2   0x4286             CMP      R6,R0
   \   000000B4   0xD2F1             BCS.N    ??HAL_I2C_IsDeviceReady_6
   \   000000B6   0xE040             B.N      ??HAL_I2C_IsDeviceReady_4
   2266                  {
   2267                    return HAL_TIMEOUT;
   2268                  }
   2269                  
   2270                  /* Clear STOP Flag */
   2271                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \   000000B8   0x2120             MOVS     R1,#+32
   \   000000BA   0x61C1             STR      R1,[R0, #+28]
   2272          
   2273                  /* Device is ready */
   2274                  hi2c->State = HAL_I2C_STATE_READY;
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0xF884 0x0035      STRB     R0,[R4, #+53]
   2275                  
   2276                  /* Process Unlocked */
   2277                  __HAL_UNLOCK(hi2c);
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xF884 0x0034      STRB     R0,[R4, #+52]
   2278                  
   2279                  return HAL_OK;
   \   000000C8   0xB001             ADD      SP,SP,#+4
   \   000000CA   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2280                }
   2281                else
   2282                {
   2283                  /* Wait until STOPF flag is reset */ 
   2284                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \   000000CE   0x.... 0x....      BL       HAL_GetTick
   \   000000D2   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6981             LDR      R1,[R0, #+24]
   \   000000D8   0x0689             LSLS     R1,R1,#+26
   \   000000DA   0xD409             BMI.N    ??HAL_I2C_IsDeviceReady_9
   \   000000DC   0xF116 0x0F01      CMN      R6,#+1
   \   000000E0   0xD0F8             BEQ.N    ??HAL_I2C_IsDeviceReady_8
   \   000000E2   0xB356             CBZ.N    R6,??HAL_I2C_IsDeviceReady_4
   \   000000E4   0x.... 0x....      BL       HAL_GetTick
   \   000000E8   0x1BC0             SUBS     R0,R0,R7
   \   000000EA   0x4286             CMP      R6,R0
   \   000000EC   0xD2F2             BCS.N    ??HAL_I2C_IsDeviceReady_8
   \   000000EE   0xE024             B.N      ??HAL_I2C_IsDeviceReady_4
   2285                  {
   2286                    return HAL_TIMEOUT;
   2287                  }
   2288          
   2289                  /* Clear NACK Flag */
   2290                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_IsDeviceReady_9: (+1)
   \   000000F0   0x2110             MOVS     R1,#+16
   \   000000F2   0x61C1             STR      R1,[R0, #+28]
   2291          
   2292                  /* Clear STOP Flag, auto generated with autoend*/
   2293                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \   000000F4   0x6821             LDR      R1,[R4, #+0]
   \   000000F6   0x2020             MOVS     R0,#+32
   \   000000F8   0x61C8             STR      R0,[R1, #+28]
   2294                }
   2295                
   2296                /* Check if the maximum allowed number of trials has been reached */
   2297                if (I2C_Trials++ == Trials)
   \   000000FA   0x9800             LDR      R0,[SP, #+0]
   \   000000FC   0x1C41             ADDS     R1,R0,#+1
   \   000000FE   0x42A8             CMP      R0,R5
   \   00000100   0x9100             STR      R1,[SP, #+0]
   \   00000102   0xD117             BNE.N    ??HAL_I2C_IsDeviceReady_10
   2298                {
   2299                  /* Generate Stop */
   2300                  hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x6841             LDR      R1,[R0, #+4]
   \   00000108   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000010C   0x6041             STR      R1,[R0, #+4]
   2301                  
   2302                  /* Wait until STOPF flag is reset */ 
   2303                  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_STOPF, RESET, Timeout) != HAL_OK)
   \   0000010E   0x.... 0x....      BL       HAL_GetTick
   \   00000112   0x4607             MOV      R7,R0
   \                     ??HAL_I2C_IsDeviceReady_11: (+1)
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x6981             LDR      R1,[R0, #+24]
   \   00000118   0x0689             LSLS     R1,R1,#+26
   \   0000011A   0xD409             BMI.N    ??HAL_I2C_IsDeviceReady_12
   \   0000011C   0xF116 0x0F01      CMN      R6,#+1
   \   00000120   0xD0F8             BEQ.N    ??HAL_I2C_IsDeviceReady_11
   \   00000122   0xB156             CBZ.N    R6,??HAL_I2C_IsDeviceReady_4
   \   00000124   0x.... 0x....      BL       HAL_GetTick
   \   00000128   0x1BC0             SUBS     R0,R0,R7
   \   0000012A   0x4286             CMP      R6,R0
   \   0000012C   0xD2F2             BCS.N    ??HAL_I2C_IsDeviceReady_11
   \   0000012E   0xE004             B.N      ??HAL_I2C_IsDeviceReady_4
   2304                  {
   2305                    return HAL_TIMEOUT;
   2306                  }
   2307                  
   2308                  /* Clear STOP Flag */
   2309                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??HAL_I2C_IsDeviceReady_12: (+1)
   \   00000130   0x2120             MOVS     R1,#+32
   \   00000132   0x61C1             STR      R1,[R0, #+28]
   2310                }      
   2311              }while(I2C_Trials < Trials);
   \                     ??HAL_I2C_IsDeviceReady_10: (+1)
   \   00000134   0x9800             LDR      R0,[SP, #+0]
   \   00000136   0x42A8             CMP      R0,R5
   \   00000138   0xD389             BCC.N    ??HAL_I2C_IsDeviceReady_1
   2312          
   2313              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xF884 0x0035      STRB     R0,[R4, #+53]
   2314          
   2315              /* Process Unlocked */
   2316              __HAL_UNLOCK(hi2c);
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xF884 0x0034      STRB     R0,[R4, #+52]
   2317                  
   2318              return HAL_TIMEOUT;
   \   00000146   0x2003             MOVS     R0,#+3
   \   00000148   0xB001             ADD      SP,SP,#+4
   \   0000014A   0xE8BD 0x83F0      POP      {R4-R9,PC}
   2319            }
   2320            else
   2321            {
   2322              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \   0000014E   0x2002             MOVS     R0,#+2
   \   00000150   0xB001             ADD      SP,SP,#+4
   \   00000152   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2323            }
   2324          }
   2325          /**
   2326            * @}
   2327            */
   2328          
   2329          /** @defgroup IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
   2330           * @{
   2331           */   
   2332          
   2333          /**
   2334            * @brief  This function handles I2C event interrupt request.
   2335            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2336            *                the configuration information for the specified I2C.
   2337            * @retval None
   2338            */

   \                                 In section .text, align 2, keep-with-next
   2339          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   2340          {
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2341            /* I2C in mode Transmitter ---------------------------------------------------*/
   2342            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI | I2C_IT_ADDRI)) == SET))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6981             LDR      R1,[R0, #+24]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD40E             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   0000000C   0x6981             LDR      R1,[R0, #+24]
   \   0000000E   0x0609             LSLS     R1,R1,#+24
   \   00000010   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000012   0x6981             LDR      R1,[R0, #+24]
   \   00000014   0x0649             LSLS     R1,R1,#+25
   \   00000016   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x0689             LSLS     R1,R1,#+26
   \   0000001C   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   0000001E   0x6981             LDR      R1,[R0, #+24]
   \   00000020   0x06C9             LSLS     R1,R1,#+27
   \   00000022   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_0
   \   00000024   0x6981             LDR      R1,[R0, #+24]
   \   00000026   0x0709             LSLS     R1,R1,#+28
   \   00000028   0xD50A             BPL.N    ??HAL_I2C_EV_IRQHandler_1
   \                     ??HAL_I2C_EV_IRQHandler_0: (+1)
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF000 0x007A      AND      R0,R0,#0x7A
   \   00000030   0x287A             CMP      R0,#+122
   \   00000032   0xBF01             ITTTT    EQ 
   2343            {     
   2344              /* Slave mode selected */
   2345              if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_TX)
   \   00000034   0xF894 0x0035      LDRBEQ   R0,[R4, #+53]
   \   00000038   0x2832             CMPEQ    R0,#+50
   2346              {
   2347                I2C_SlaveTransmit_ISR(hi2c);
   \   0000003A   0x4620             MOVEQ    R0,R4
   \   0000003C   0x.... 0x....      BLEQ     I2C_SlaveTransmit_ISR
   2348              }
   2349            }
   2350              
   2351            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_1: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x6981             LDR      R1,[R0, #+24]
   \   00000044   0x0789             LSLS     R1,R1,#+30
   \   00000046   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   00000048   0x6981             LDR      R1,[R0, #+24]
   \   0000004A   0x0609             LSLS     R1,R1,#+24
   \   0000004C   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   0000004E   0x6981             LDR      R1,[R0, #+24]
   \   00000050   0x0649             LSLS     R1,R1,#+25
   \   00000052   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   00000054   0x6981             LDR      R1,[R0, #+24]
   \   00000056   0x0689             LSLS     R1,R1,#+26
   \   00000058   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \   0000005A   0x6981             LDR      R1,[R0, #+24]
   \   0000005C   0x06C9             LSLS     R1,R1,#+27
   \   0000005E   0xD50E             BPL.N    ??HAL_I2C_EV_IRQHandler_3
   \                     ??HAL_I2C_EV_IRQHandler_2: (+1)
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF000 0x0072      AND      R0,R0,#0x72
   \   00000066   0x2872             CMP      R0,#+114
   \   00000068   0xD109             BNE.N    ??HAL_I2C_EV_IRQHandler_3
   2352            {     
   2353              /* Master mode selected */
   2354              if ((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX))
   \   0000006A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000006E   0x2812             CMP      R0,#+18
   \   00000070   0xBF19             ITTEE    NE 
   \   00000072   0xF894 0x0035      LDRBNE   R0,[R4, #+53]
   \   00000076   0x2852             CMPNE    R0,#+82
   2355              {
   2356                I2C_MasterTransmit_ISR(hi2c);
   \   00000078   0x4620             MOVEQ    R0,R4
   \   0000007A   0x.... 0x....      BLEQ     I2C_MasterTransmit_ISR
   2357              }
   2358            }
   2359          
   2360            /* I2C in mode Receiver ----------------------------------------------------*/
   2361            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI | I2C_IT_ADDRI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_3: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6981             LDR      R1,[R0, #+24]
   \   00000082   0x0749             LSLS     R1,R1,#+29
   \   00000084   0xD40E             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000086   0x6981             LDR      R1,[R0, #+24]
   \   00000088   0x0609             LSLS     R1,R1,#+24
   \   0000008A   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000008C   0x6981             LDR      R1,[R0, #+24]
   \   0000008E   0x0649             LSLS     R1,R1,#+25
   \   00000090   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000092   0x6981             LDR      R1,[R0, #+24]
   \   00000094   0x0689             LSLS     R1,R1,#+26
   \   00000096   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   00000098   0x6981             LDR      R1,[R0, #+24]
   \   0000009A   0x06C9             LSLS     R1,R1,#+27
   \   0000009C   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_4
   \   0000009E   0x6981             LDR      R1,[R0, #+24]
   \   000000A0   0x0709             LSLS     R1,R1,#+28
   \   000000A2   0xD50A             BPL.N    ??HAL_I2C_EV_IRQHandler_5
   \                     ??HAL_I2C_EV_IRQHandler_4: (+1)
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF000 0x007C      AND      R0,R0,#0x7C
   \   000000AA   0x287C             CMP      R0,#+124
   \   000000AC   0xBF01             ITTTT    EQ 
   2362            {
   2363              /* Slave mode selected */
   2364              if (hi2c->State == HAL_I2C_STATE_SLAVE_BUSY_RX)
   \   000000AE   0xF894 0x0035      LDRBEQ   R0,[R4, #+53]
   \   000000B2   0x2842             CMPEQ    R0,#+66
   2365              {
   2366                I2C_SlaveReceive_ISR(hi2c);
   \   000000B4   0x4620             MOVEQ    R0,R4
   \   000000B6   0x.... 0x....      BLEQ     I2C_SlaveReceive_ISR
   2367              }
   2368            } 
   2369            if (((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET) || (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)) && (__HAL_I2C_GET_IT_SOURCE(hi2c, (I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI)) == SET))
   \                     ??HAL_I2C_EV_IRQHandler_5: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x6981             LDR      R1,[R0, #+24]
   \   000000BE   0x0749             LSLS     R1,R1,#+29
   \   000000C0   0xD40B             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000C2   0x6981             LDR      R1,[R0, #+24]
   \   000000C4   0x0609             LSLS     R1,R1,#+24
   \   000000C6   0xD408             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000C8   0x6981             LDR      R1,[R0, #+24]
   \   000000CA   0x0649             LSLS     R1,R1,#+25
   \   000000CC   0xD405             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000CE   0x6981             LDR      R1,[R0, #+24]
   \   000000D0   0x0689             LSLS     R1,R1,#+26
   \   000000D2   0xD402             BMI.N    ??HAL_I2C_EV_IRQHandler_6
   \   000000D4   0x6981             LDR      R1,[R0, #+24]
   \   000000D6   0x06C9             LSLS     R1,R1,#+27
   \   000000D8   0xD510             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   \                     ??HAL_I2C_EV_IRQHandler_6: (+1)
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0xF000 0x0074      AND      R0,R0,#0x74
   \   000000E0   0x2874             CMP      R0,#+116
   \   000000E2   0xD10B             BNE.N    ??HAL_I2C_EV_IRQHandler_7
   2370            {
   2371              /* Master mode selected */
   2372              if ((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_RX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX))
   \   000000E4   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   000000E8   0x2822             CMP      R0,#+34
   \   000000EA   0xBF1C             ITT      NE 
   \   000000EC   0xF894 0x0035      LDRBNE   R0,[R4, #+53]
   \   000000F0   0x2862             CMPNE    R0,#+98
   \   000000F2   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_7
   2373              {
   2374                I2C_MasterReceive_ISR(hi2c);
   \   000000F4   0x4620             MOV      R0,R4
   \   000000F6   0xE8BD 0x4010      POP      {R4,LR}
   \   000000FA   0x....             B.N      I2C_MasterReceive_ISR
   2375              }
   2376            } 
   2377          }
   \                     ??HAL_I2C_EV_IRQHandler_7: (+1)
   \   000000FC   0xBD10             POP      {R4,PC}          ;; return
   2378          
   2379          /**
   2380            * @brief  This function handles I2C error interrupt request.
   2381            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2382            *                the configuration information for the specified I2C.
   2383            * @retval None
   2384            */

   \                                 In section .text, align 2, keep-with-next
   2385          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   2386          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2387            /* I2C Bus error interrupt occurred ------------------------------------*/
   2388            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BERR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x698A             LDR      R2,[R1, #+24]
   \   00000008   0x05D2             LSLS     R2,R2,#+23
   \   0000000A   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0x0612             LSLS     R2,R2,#+24
   \   00000010   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   2389            { 
   2390              hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
   \   00000012   0x6B82             LDR      R2,[R0, #+56]
   \   00000014   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000018   0x6382             STR      R2,[R0, #+56]
   2391             
   2392              /* Clear BERR flag */
   2393              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \   0000001A   0xF44F 0x7280      MOV      R2,#+256
   \   0000001E   0x61CA             STR      R2,[R1, #+28]
   2394            }
   2395            
   2396            /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
   2397            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_OVR) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x698A             LDR      R2,[R1, #+24]
   \   00000024   0x0552             LSLS     R2,R2,#+21
   \   00000026   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x0612             LSLS     R2,R2,#+24
   \   0000002C   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   2398            { 
   2399              hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
   \   0000002E   0x6B82             LDR      R2,[R0, #+56]
   \   00000030   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000034   0x6382             STR      R2,[R0, #+56]
   2400          
   2401              /* Clear OVR flag */
   2402              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \   00000036   0xF44F 0x6280      MOV      R2,#+1024
   \   0000003A   0x61CA             STR      R2,[R1, #+28]
   2403            }
   2404          
   2405            /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
   2406            if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ARLO) == SET) && (__HAL_I2C_GET_IT_SOURCE(hi2c, I2C_IT_ERRI) == SET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x698A             LDR      R2,[R1, #+24]
   \   00000040   0x0592             LSLS     R2,R2,#+22
   \   00000042   0xD509             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   \   00000044   0x680A             LDR      R2,[R1, #+0]
   \   00000046   0x0612             LSLS     R2,R2,#+24
   \   00000048   0xD506             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   2407            { 
   2408              hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
   \   0000004A   0x6B82             LDR      R2,[R0, #+56]
   \   0000004C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000050   0x6382             STR      R2,[R0, #+56]
   2409          
   2410              /* Clear ARLO flag */
   2411              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \   00000052   0xF44F 0x7200      MOV      R2,#+512
   \   00000056   0x61CA             STR      R2,[R1, #+28]
   2412            }
   2413          
   2414            /* Call the Error Callback in case of Error detected */
   2415            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \   00000058   0x6B81             LDR      R1,[R0, #+56]
   \   0000005A   0xB121             CBZ.N    R1,??HAL_I2C_ER_IRQHandler_3
   2416            {
   2417              hi2c->State = HAL_I2C_STATE_READY;
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0xF880 0x1035      STRB     R1,[R0, #+53]
   2418              
   2419              HAL_I2C_ErrorCallback(hi2c);
   \   00000062   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2420            }
   2421          }
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0xBD00             POP      {PC}             ;; return
   2422          
   2423          /**
   2424            * @brief  Master Tx Transfer completed callbacks.
   2425            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2426            *                the configuration information for the specified I2C.
   2427            * @retval None
   2428            */

   \                                 In section .text, align 2, keep-with-next
   2429           __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2430          {
   2431            /* NOTE : This function Should not be modified, when the callback is needed,
   2432                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2433             */ 
   2434          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2435          
   2436          /**
   2437            * @brief  Master Rx Transfer completed callbacks.
   2438            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2439            *                the configuration information for the specified I2C.
   2440            * @retval None
   2441            */

   \                                 In section .text, align 2, keep-with-next
   2442          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2443          {
   2444            /* NOTE : This function Should not be modified, when the callback is needed,
   2445                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2446             */
   2447          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2448          
   2449          /** @brief  Slave Tx Transfer completed callbacks.
   2450            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2451            *                the configuration information for the specified I2C.
   2452            * @retval None
   2453            */

   \                                 In section .text, align 2, keep-with-next
   2454           __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2455          {
   2456            /* NOTE : This function Should not be modified, when the callback is needed,
   2457                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2458             */ 
   2459          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2460          
   2461          /**
   2462            * @brief  Slave Rx Transfer completed callbacks.
   2463            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2464            *                the configuration information for the specified I2C.
   2465            * @retval None
   2466            */

   \                                 In section .text, align 2, keep-with-next
   2467          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2468          {
   2469            /* NOTE : This function Should not be modified, when the callback is needed,
   2470                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2471             */
   2472          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2473          
   2474          /**
   2475            * @brief  Memory Tx Transfer completed callbacks.
   2476            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2477            *                the configuration information for the specified I2C.
   2478            * @retval None
   2479            */

   \                                 In section .text, align 2, keep-with-next
   2480           __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   2481          {
   2482            /* NOTE : This function Should not be modified, when the callback is needed,
   2483                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2484             */ 
   2485          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2486          
   2487          /**
   2488            * @brief  Memory Rx Transfer completed callbacks.
   2489            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2490            *                the configuration information for the specified I2C.
   2491            * @retval None
   2492            */

   \                                 In section .text, align 2, keep-with-next
   2493          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   2494          {
   2495            /* NOTE : This function Should not be modified, when the callback is needed,
   2496                      the HAL_I2C_TxCpltCallback could be implemented in the user file
   2497             */
   2498          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2499          
   2500          /**
   2501            * @brief  I2C error callbacks.
   2502            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2503            *                the configuration information for the specified I2C.
   2504            * @retval None
   2505            */

   \                                 In section .text, align 2, keep-with-next
   2506           __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   2507          {
   2508            /* NOTE : This function Should not be modified, when the callback is needed,
   2509                      the HAL_I2C_ErrorCallback could be implemented in the user file
   2510             */ 
   2511          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2512          
   2513          /**
   2514            * @}
   2515            */
   2516          
   2517          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State and Errors functions
   2518           *  @brief   Peripheral State and Errors functions
   2519           *
   2520          @verbatim   
   2521           ===============================================================================
   2522                      ##### Peripheral State and Errors functions #####
   2523           ===============================================================================  
   2524              [..]
   2525              This subsection permit to get in run-time the status of the peripheral 
   2526              and the data flow.
   2527          
   2528          @endverbatim
   2529            * @{
   2530            */
   2531          
   2532          /**
   2533            * @brief  Returns the I2C state.
   2534            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2535            *                the configuration information for the specified I2C.
   2536            * @retval HAL state
   2537            */

   \                                 In section .text, align 2, keep-with-next
   2538          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   2539          {
   2540            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   2541          }
   2542          
   2543          /**
   2544            * @brief  Return the I2C error code
   2545            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2546            *              the configuration information for the specified I2C.
   2547          * @retval I2C Error Code
   2548          */

   \                                 In section .text, align 2, keep-with-next
   2549          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   2550          {
   2551            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \   00000000   0x6B80             LDR      R0,[R0, #+56]
   \   00000002   0x4770             BX       LR               ;; return
   2552          }
   2553          
   2554          /**
   2555            * @}
   2556            */  
   2557          
   2558          /**
   2559            * @}
   2560            */
   2561          
   2562          /** @addtogroup I2C_Private_Functions
   2563            * @{
   2564            */
   2565          
   2566          /**
   2567            * @brief  Handle Interrupt Flags Master Transmit Mode
   2568            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2569            *                the configuration information for the specified I2C.
   2570            * @retval HAL status
   2571            */

   \                                 In section .text, align 2, keep-with-next
   2572          static HAL_StatusTypeDef I2C_MasterTransmit_ISR(I2C_HandleTypeDef *hi2c) 
   2573          {
   \                     I2C_MasterTransmit_ISR: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   2574            uint16_t DevAddress;
   2575            
   2576            /* Process Locked */
   2577            __HAL_LOCK(hi2c); 
   \   00000006   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xF000 0x8085      BEQ.W    ??I2C_MasterTransmit_ISR_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   2578            
   2579            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6981             LDR      R1,[R0, #+24]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD50B             BPL.N    ??I2C_MasterTransmit_ISR_1
   2580            {
   2581              /* Write data to TXDR */
   2582              hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
   \   00000022   0x6A61             LDR      R1,[R4, #+36]
   \   00000024   0x1C4A             ADDS     R2,R1,#+1
   \   00000026   0x6262             STR      R2,[R4, #+36]
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x6281             STR      R1,[R0, #+40]
   2583              hi2c->XferSize--;
   \   0000002C   0x8D20             LDRH     R0,[R4, #+40]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x8520             STRH     R0,[R4, #+40]
   2584              hi2c->XferCount--;	
   \   00000032   0x8D60             LDRH     R0,[R4, #+42]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x8560             STRH     R0,[R4, #+42]
   \   00000038   0xE06E             B.N      ??I2C_MasterTransmit_ISR_2
   2585            }
   2586            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
   \                     ??I2C_MasterTransmit_ISR_1: (+1)
   \   0000003A   0x6981             LDR      R1,[R0, #+24]
   \   0000003C   0x0609             LSLS     R1,R1,#+24
   \   0000003E   0xD52A             BPL.N    ??I2C_MasterTransmit_ISR_3
   2587            {
   2588              if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
   \   00000040   0x8D21             LDRH     R1,[R4, #+40]
   \   00000042   0xBB09             CBNZ.N   R1,??I2C_MasterTransmit_ISR_4
   \   00000044   0x8D61             LDRH     R1,[R4, #+42]
   \   00000046   0xB1F9             CBZ.N    R1,??I2C_MasterTransmit_ISR_4
   2589              {
   2590                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   00000048   0x6841             LDR      R1,[R0, #+4]
   2591                
   2592                if(hi2c->XferCount > 255)
   \   0000004A   0x8D63             LDRH     R3,[R4, #+42]
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable20  ;; 0xfc009800
   \   00000050   0x0589             LSLS     R1,R1,#+22
   \   00000052   0x2BFF             CMP      R3,#+255
   \   00000054   0xDD0A             BLE.N    ??I2C_MasterTransmit_ISR_5
   2593                {    
   2594                  I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   00000056   0x6843             LDR      R3,[R0, #+4]
   \   00000058   0x401A             ANDS     R2,R2,R3
   \   0000005A   0xEA52 0x5191      ORRS     R1,R2,R1, LSR #+22
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0x1ff0000
   \   00000062   0x4311             ORRS     R1,R2,R1
   \   00000064   0x6041             STR      R1,[R0, #+4]
   2595                  hi2c->XferSize = 255;
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0x8520             STRH     R0,[R4, #+40]
   \   0000006A   0xE055             B.N      ??I2C_MasterTransmit_ISR_2
   2596                }
   2597                else
   2598                {
   2599                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_MasterTransmit_ISR_5: (+1)
   \   0000006C   0x8D63             LDRH     R3,[R4, #+42]
   \   0000006E   0x6845             LDR      R5,[R0, #+4]
   \   00000070   0x402A             ANDS     R2,R2,R5
   \   00000072   0xEA52 0x5191      ORRS     R1,R2,R1, LSR #+22
   \   00000076   0xB2DB             UXTB     R3,R3
   \   00000078   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \   0000007C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000080   0x6041             STR      R1,[R0, #+4]
   2600                  hi2c->XferSize = hi2c->XferCount;
   \   00000082   0x8D60             LDRH     R0,[R4, #+42]
   \   00000084   0x8520             STRH     R0,[R4, #+40]
   \   00000086   0xE047             B.N      ??I2C_MasterTransmit_ISR_2
   2601                }
   2602              }
   2603              else
   2604              {
   2605                /* Process Unlocked */
   2606                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_4: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x0034      STRB     R0,[R4, #+52]
   2607                
   2608                /* Wrong size Status regarding TCR flag event */
   2609                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000094   0xE03C             B.N      ??I2C_MasterTransmit_ISR_6
   2610                HAL_I2C_ErrorCallback(hi2c);
   2611              }
   2612            }
   2613            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET)
   \                     ??I2C_MasterTransmit_ISR_3: (+1)
   \   00000096   0x6981             LDR      R1,[R0, #+24]
   \   00000098   0x0649             LSLS     R1,R1,#+25
   \   0000009A   0xD50D             BPL.N    ??I2C_MasterTransmit_ISR_7
   2614            {
   2615              if(hi2c->XferCount == 0)
   \   0000009C   0x8D61             LDRH     R1,[R4, #+42]
   \   0000009E   0xB921             CBNZ.N   R1,??I2C_MasterTransmit_ISR_8
   2616              {
   2617                /* Generate Stop */
   2618                hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   000000A0   0x6841             LDR      R1,[R0, #+4]
   \   000000A2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   \   000000A8   0xE036             B.N      ??I2C_MasterTransmit_ISR_2
   2619              }
   2620              else
   2621              {
   2622                /* Process Unlocked */
   2623                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_8: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x0034      STRB     R0,[R4, #+52]
   2624                
   2625                /* Wrong size Status regarding TCR flag event */
   2626                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   000000B0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B2   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000B6   0xE02B             B.N      ??I2C_MasterTransmit_ISR_6
   2627                HAL_I2C_ErrorCallback(hi2c);
   2628              }
   2629            }
   2630            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \                     ??I2C_MasterTransmit_ISR_7: (+1)
   \   000000B8   0x6981             LDR      R1,[R0, #+24]
   \   000000BA   0x0689             LSLS     R1,R1,#+26
   \   000000BC   0xD51D             BPL.N    ??I2C_MasterTransmit_ISR_9
   2631            {
   2632              /* Disable ERR, TC, STOP, NACK, TXI interrupt */
   2633              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_TXI );
   \   000000BE   0x6801             LDR      R1,[R0, #+0]
   2634          
   2635              /* Clear STOP Flag */
   2636              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2637          
   2638              /* Clear Configuration Register 2 */
   2639              I2C_RESET_CR2(hi2c);
   \   000000C0   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000C4   0xF021 0x01F2      BIC      R1,R1,#0xF2
   \   000000C8   0x6001             STR      R1,[R0, #+0]
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x2020             MOVS     R0,#+32
   \   000000CE   0x61C8             STR      R0,[R1, #+28]
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6841             LDR      R1,[R0, #+4]
   \   000000D4   0x4011             ANDS     R1,R2,R1
   \   000000D6   0x6041             STR      R1,[R0, #+4]
   2640          
   2641              hi2c->State = HAL_I2C_STATE_READY;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xF884 0x0035      STRB     R0,[R4, #+53]
   2642          
   2643              /* Process Unlocked */
   2644              __HAL_UNLOCK(hi2c);
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF884 0x0034      STRB     R0,[R4, #+52]
   2645          
   2646              if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
   \   000000E4   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   000000E8   0x2852             CMP      R0,#+82
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0xD102             BNE.N    ??I2C_MasterTransmit_ISR_10
   2647              {
   2648                HAL_I2C_MemTxCpltCallback(hi2c);
   \   000000EE   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   000000F2   0xE011             B.N      ??I2C_MasterTransmit_ISR_2
   2649              }
   2650              else
   2651              {
   2652                HAL_I2C_MasterTxCpltCallback(hi2c);
   \                     ??I2C_MasterTransmit_ISR_10: (+1)
   \   000000F4   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \   000000F8   0xE00E             B.N      ??I2C_MasterTransmit_ISR_2
   2653              }
   2654            }
   2655            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     ??I2C_MasterTransmit_ISR_9: (+1)
   \   000000FA   0x6981             LDR      R1,[R0, #+24]
   \   000000FC   0x06C9             LSLS     R1,R1,#+27
   \   000000FE   0xD50B             BPL.N    ??I2C_MasterTransmit_ISR_2
   2656            {
   2657              /* Clear NACK Flag */
   2658              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000100   0x2110             MOVS     R1,#+16
   \   00000102   0x61C1             STR      R1,[R0, #+28]
   2659          
   2660              /* Process Unlocked */
   2661              __HAL_UNLOCK(hi2c);
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF884 0x0034      STRB     R0,[R4, #+52]
   2662              
   2663              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   0000010A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000010C   0xF040 0x0004      ORR      R0,R0,#0x4
   \                     ??I2C_MasterTransmit_ISR_6: (+1)
   \   00000110   0x63A0             STR      R0,[R4, #+56]
   2664              HAL_I2C_ErrorCallback(hi2c);
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2665            }
   2666            
   2667            /* Process Unlocked */
   2668            __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterTransmit_ISR_2: (+1)
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xF884 0x0034      STRB     R0,[R4, #+52]
   2669            
   2670            return HAL_OK;    
   \                     ??I2C_MasterTransmit_ISR_0: (+1)
   \   0000011E   0xB001             ADD      SP,SP,#+4
   \   00000120   0xBD30             POP      {R4,R5,PC}       ;; return
   2671          }  
   2672          
   2673          /**
   2674            * @brief  Handle Interrupt Flags Master Receive Mode
   2675            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2676            *                the configuration information for the specified I2C.
   2677            * @retval HAL status
   2678            */

   \                                 In section .text, align 2, keep-with-next
   2679          static HAL_StatusTypeDef I2C_MasterReceive_ISR(I2C_HandleTypeDef *hi2c) 
   2680          {
   \                     I2C_MasterReceive_ISR: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   2681            uint16_t DevAddress;
   2682          
   2683            /* Process Locked */
   2684            __HAL_LOCK(hi2c);
   \   00000006   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xF000 0x8085      BEQ.W    ??I2C_MasterReceive_ISR_0
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0034      STRB     R0,[R4, #+52]
   2685            
   2686            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0x6981             LDR      R1,[R0, #+24]
   \   0000001E   0x0749             LSLS     R1,R1,#+29
   \   00000020   0xD50B             BPL.N    ??I2C_MasterReceive_ISR_1
   2687            {  
   2688              /* Read data from RXDR */
   2689              (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
   \   00000022   0x6A61             LDR      R1,[R4, #+36]
   \   00000024   0x1C4A             ADDS     R2,R1,#+1
   \   00000026   0x6262             STR      R2,[R4, #+36]
   \   00000028   0x6A40             LDR      R0,[R0, #+36]
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
   2690              hi2c->XferSize--;
   \   0000002C   0x8D20             LDRH     R0,[R4, #+40]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x8520             STRH     R0,[R4, #+40]
   2691              hi2c->XferCount--;
   \   00000032   0x8D60             LDRH     R0,[R4, #+42]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x8560             STRH     R0,[R4, #+42]
   \   00000038   0xE06E             B.N      ??I2C_MasterReceive_ISR_2
   2692            }
   2693            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TCR) == SET)
   \                     ??I2C_MasterReceive_ISR_1: (+1)
   \   0000003A   0x6981             LDR      R1,[R0, #+24]
   \   0000003C   0x0609             LSLS     R1,R1,#+24
   \   0000003E   0xD52A             BPL.N    ??I2C_MasterReceive_ISR_3
   2694            {
   2695              if((hi2c->XferSize == 0)&&(hi2c->XferCount!=0))
   \   00000040   0x8D21             LDRH     R1,[R4, #+40]
   \   00000042   0xBB09             CBNZ.N   R1,??I2C_MasterReceive_ISR_4
   \   00000044   0x8D61             LDRH     R1,[R4, #+42]
   \   00000046   0xB1F9             CBZ.N    R1,??I2C_MasterReceive_ISR_4
   2696              {                  
   2697                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   00000048   0x6841             LDR      R1,[R0, #+4]
   2698                
   2699                if(hi2c->XferCount > 255)
   \   0000004A   0x8D63             LDRH     R3,[R4, #+42]
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable20  ;; 0xfc009800
   \   00000050   0x0589             LSLS     R1,R1,#+22
   \   00000052   0x2BFF             CMP      R3,#+255
   \   00000054   0xDD0A             BLE.N    ??I2C_MasterReceive_ISR_5
   2700                {
   2701                  I2C_TransferConfig(hi2c,DevAddress,255, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   00000056   0x6843             LDR      R3,[R0, #+4]
   \   00000058   0x401A             ANDS     R2,R2,R3
   \   0000005A   0xEA52 0x5191      ORRS     R1,R2,R1, LSR #+22
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable20_1  ;; 0x1ff0000
   \   00000062   0x4311             ORRS     R1,R2,R1
   \   00000064   0x6041             STR      R1,[R0, #+4]
   2702                  hi2c->XferSize = 255;
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0x8520             STRH     R0,[R4, #+40]
   \   0000006A   0xE055             B.N      ??I2C_MasterReceive_ISR_2
   2703                }      
   2704                else
   2705                {    
   2706                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferCount, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_MasterReceive_ISR_5: (+1)
   \   0000006C   0x8D63             LDRH     R3,[R4, #+42]
   \   0000006E   0x6845             LDR      R5,[R0, #+4]
   \   00000070   0x402A             ANDS     R2,R2,R5
   \   00000072   0xEA52 0x5191      ORRS     R1,R2,R1, LSR #+22
   \   00000076   0xB2DB             UXTB     R3,R3
   \   00000078   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \   0000007C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   00000080   0x6041             STR      R1,[R0, #+4]
   2707                  hi2c->XferSize = hi2c->XferCount;
   \   00000082   0x8D60             LDRH     R0,[R4, #+42]
   \   00000084   0x8520             STRH     R0,[R4, #+40]
   \   00000086   0xE047             B.N      ??I2C_MasterReceive_ISR_2
   2708                } 
   2709              } 
   2710              else
   2711              {
   2712                /* Process Unlocked */
   2713                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterReceive_ISR_4: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x0034      STRB     R0,[R4, #+52]
   2714                
   2715                /* Wrong size Status regarding TCR flag event */
   2716                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000094   0xE03C             B.N      ??I2C_MasterReceive_ISR_6
   2717                HAL_I2C_ErrorCallback(hi2c);
   2718              }
   2719            }
   2720            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TC) == SET)
   \                     ??I2C_MasterReceive_ISR_3: (+1)
   \   00000096   0x6981             LDR      R1,[R0, #+24]
   \   00000098   0x0649             LSLS     R1,R1,#+25
   \   0000009A   0xD50D             BPL.N    ??I2C_MasterReceive_ISR_7
   2721            {
   2722              if(hi2c->XferCount == 0)
   \   0000009C   0x8D61             LDRH     R1,[R4, #+42]
   \   0000009E   0xB921             CBNZ.N   R1,??I2C_MasterReceive_ISR_8
   2723              {
   2724                /* Generate Stop */
   2725                hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   000000A0   0x6841             LDR      R1,[R0, #+4]
   \   000000A2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   \   000000A8   0xE036             B.N      ??I2C_MasterReceive_ISR_2
   2726              }
   2727              else
   2728              {
   2729                /* Process Unlocked */
   2730                __HAL_UNLOCK(hi2c);
   \                     ??I2C_MasterReceive_ISR_8: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x0034      STRB     R0,[R4, #+52]
   2731                
   2732                /* Wrong size Status regarding TCR flag event */
   2733                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \   000000B0   0x6BA0             LDR      R0,[R4, #+56]
   \   000000B2   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000B6   0xE02B             B.N      ??I2C_MasterReceive_ISR_6
   2734                HAL_I2C_ErrorCallback(hi2c);
   2735              }
   2736            }
   2737            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \                     ??I2C_MasterReceive_ISR_7: (+1)
   \   000000B8   0x6981             LDR      R1,[R0, #+24]
   \   000000BA   0x0689             LSLS     R1,R1,#+26
   \   000000BC   0xD51D             BPL.N    ??I2C_MasterReceive_ISR_9
   2738            {
   2739              /* Disable ERR, TC, STOP, NACK, TXI interrupt */
   2740              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_RXI );
   \   000000BE   0x6801             LDR      R1,[R0, #+0]
   2741                
   2742              /* Clear STOP Flag */
   2743              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2744                
   2745              /* Clear Configuration Register 2 */
   2746              I2C_RESET_CR2(hi2c);
   \   000000C0   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000C4   0xF021 0x01F4      BIC      R1,R1,#0xF4
   \   000000C8   0x6001             STR      R1,[R0, #+0]
   \   000000CA   0x6821             LDR      R1,[R4, #+0]
   \   000000CC   0x2020             MOVS     R0,#+32
   \   000000CE   0x61C8             STR      R0,[R1, #+28]
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6841             LDR      R1,[R0, #+4]
   \   000000D4   0x4011             ANDS     R1,R2,R1
   \   000000D6   0x6041             STR      R1,[R0, #+4]
   2747              
   2748              hi2c->State = HAL_I2C_STATE_READY;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xF884 0x0035      STRB     R0,[R4, #+53]
   2749          
   2750              /* Process Unlocked */
   2751              __HAL_UNLOCK(hi2c);
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF884 0x0034      STRB     R0,[R4, #+52]
   2752              
   2753              if(hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX)
   \   000000E4   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   000000E8   0x2862             CMP      R0,#+98
   \   000000EA   0x4620             MOV      R0,R4
   \   000000EC   0xD102             BNE.N    ??I2C_MasterReceive_ISR_10
   2754              {
   2755                HAL_I2C_MemRxCpltCallback(hi2c);
   \   000000EE   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   000000F2   0xE011             B.N      ??I2C_MasterReceive_ISR_2
   2756              }
   2757              else
   2758              {
   2759                HAL_I2C_MasterRxCpltCallback(hi2c);
   \                     ??I2C_MasterReceive_ISR_10: (+1)
   \   000000F4   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \   000000F8   0xE00E             B.N      ??I2C_MasterReceive_ISR_2
   2760              }
   2761            }
   2762            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \                     ??I2C_MasterReceive_ISR_9: (+1)
   \   000000FA   0x6981             LDR      R1,[R0, #+24]
   \   000000FC   0x06C9             LSLS     R1,R1,#+27
   \   000000FE   0xD50B             BPL.N    ??I2C_MasterReceive_ISR_2
   2763            {
   2764              /* Clear NACK Flag */
   2765              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000100   0x2110             MOVS     R1,#+16
   \   00000102   0x61C1             STR      R1,[R0, #+28]
   2766          
   2767              /* Process Unlocked */
   2768              __HAL_UNLOCK(hi2c);
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0xF884 0x0034      STRB     R0,[R4, #+52]
   2769              
   2770              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   0000010A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000010C   0xF040 0x0004      ORR      R0,R0,#0x4
   \                     ??I2C_MasterReceive_ISR_6: (+1)
   \   00000110   0x63A0             STR      R0,[R4, #+56]
   2771              HAL_I2C_ErrorCallback(hi2c);
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2772            }
   2773              
   2774            /* Process Unlocked */
   2775            __HAL_UNLOCK(hi2c); 
   \                     ??I2C_MasterReceive_ISR_2: (+1)
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xF884 0x0034      STRB     R0,[R4, #+52]
   2776            
   2777            return HAL_OK; 
   \                     ??I2C_MasterReceive_ISR_0: (+1)
   \   0000011E   0xB001             ADD      SP,SP,#+4
   \   00000120   0xBD30             POP      {R4,R5,PC}       ;; return
   2778          
   2779          }  
   2780          
   2781          /**
   2782            * @brief  Handle Interrupt Flags Slave Transmit Mode
   2783            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2784            *                the configuration information for the specified I2C.
   2785            * @retval HAL status
   2786            */

   \                                 In section .text, align 2, keep-with-next
   2787          static HAL_StatusTypeDef I2C_SlaveTransmit_ISR(I2C_HandleTypeDef *hi2c) 
   2788          {
   \                     I2C_SlaveTransmit_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2789            /* Process locked */
   2790            __HAL_LOCK(hi2c);
   \   00000004   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??I2C_SlaveTransmit_ISR_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0034      STRB     R0,[R4, #+52]
   2791            
   2792            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x06C9             LSLS     R1,R1,#+27
   \   0000001C   0xD51A             BPL.N    ??I2C_SlaveTransmit_ISR_1
   2793            {
   2794              /* Check that I2C transfer finished */
   2795              /* if yes, normal usecase, a NACK is sent by the MASTER when Transfer is finished */
   2796              /* Mean XferCount == 0*/
   2797              /* So clear Flag NACKF only */
   2798              if(hi2c->XferCount == 0)
   \   0000001E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000020   0xB941             CBNZ.N   R1,??I2C_SlaveTransmit_ISR_2
   2799              {
   2800                /* Clear NACK Flag */
   2801                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   00000022   0x2110             MOVS     R1,#+16
   \   00000024   0x61C1             STR      R1,[R0, #+28]
   2802          
   2803                /* Process Unlocked */
   2804                __HAL_UNLOCK(hi2c);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF884 0x0034      STRB     R0,[R4, #+52]
   2805              }
   2806              else
   2807              {
   2808                /* if no, error usecase, a Non-Acknowledge of last Data is generated by the MASTER*/
   2809                /* Clear NACK Flag */
   2810                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   2811          
   2812                /* Set ErrorCode corresponding to a Non-Acknowledge */
   2813                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   2814          
   2815                /* Process Unlocked */
   2816                __HAL_UNLOCK(hi2c);
   2817              
   2818                /* Call the Error callback to prevent upper layer */
   2819                HAL_I2C_ErrorCallback(hi2c);
   2820              }
   2821            }
   2822            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   2823            {
   2824              /* Clear ADDR flag */
   2825              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   2826            }
   2827            /* Check first if STOPF is set          */
   2828            /* to prevent a Write Data in TX buffer */
   2829            /* which is stuck in TXDR until next    */
   2830            /* communication with Master            */
   2831            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   2832            {
   2833              /* Disable ERRI, TCI, STOPI, NACKI, ADDRI, RXI, TXI interrupt */
   2834              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI );
   2835              
   2836              /* Disable Address Acknowledge */
   2837              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   2838          
   2839              /* Clear STOP Flag */
   2840              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2841          
   2842              hi2c->State = HAL_I2C_STATE_READY;
   2843              
   2844              /* Process Unlocked */
   2845              __HAL_UNLOCK(hi2c);
   2846          
   2847              HAL_I2C_SlaveTxCpltCallback(hi2c);
   2848            }
   2849            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == SET)
   2850            {
   2851              /* Write data to TXDR only if XferCount not reach "0" */
   2852              /* A TXIS flag can be set, during STOP treatment      */
   2853              if(hi2c->XferCount > 0)
   2854              {
   2855                /* Write data to TXDR */
   2856                hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
   2857                hi2c->XferCount--;
   2858              }
   2859            }
   2860          
   2861            /* Process Unlocked */
   2862            __HAL_UNLOCK(hi2c);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF884 0x0034      STRB     R0,[R4, #+52]
   2863            
   2864            return HAL_OK;
   \   00000032   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_2: (+1)
   \   00000034   0x2110             MOVS     R1,#+16
   \   00000036   0x61C1             STR      R1,[R0, #+28]
   \   00000038   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003A   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000003E   0x63A0             STR      R0,[R4, #+56]
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000052   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_1: (+1)
   \   00000054   0x6981             LDR      R1,[R0, #+24]
   \   00000056   0x0709             LSLS     R1,R1,#+28
   \   00000058   0xD505             BPL.N    ??I2C_SlaveTransmit_ISR_3
   \   0000005A   0x2108             MOVS     R1,#+8
   \   0000005C   0x61C1             STR      R1,[R0, #+28]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000064   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_3: (+1)
   \   00000066   0x6981             LDR      R1,[R0, #+24]
   \   00000068   0x0689             LSLS     R1,R1,#+26
   \   0000006A   0xD518             BPL.N    ??I2C_SlaveTransmit_ISR_4
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF021 0x01FE      BIC      R1,R1,#0xFE
   \   00000072   0x6001             STR      R1,[R0, #+0]
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6841             LDR      R1,[R0, #+4]
   \   00000078   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000007C   0x6041             STR      R1,[R0, #+4]
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x2020             MOVS     R0,#+32
   \   00000082   0x61C8             STR      R0,[R1, #+28]
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000009C   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveTransmit_ISR_4: (+1)
   \   0000009E   0x6981             LDR      R1,[R0, #+24]
   \   000000A0   0x0789             LSLS     R1,R1,#+30
   \   000000A2   0xD509             BPL.N    ??I2C_SlaveTransmit_ISR_5
   \   000000A4   0x8D61             LDRH     R1,[R4, #+42]
   \   000000A6   0xB139             CBZ.N    R1,??I2C_SlaveTransmit_ISR_5
   \   000000A8   0x6A61             LDR      R1,[R4, #+36]
   \   000000AA   0x1C4A             ADDS     R2,R1,#+1
   \   000000AC   0x6262             STR      R2,[R4, #+36]
   \   000000AE   0x7809             LDRB     R1,[R1, #+0]
   \   000000B0   0x6281             STR      R1,[R0, #+40]
   \   000000B2   0x8D60             LDRH     R0,[R4, #+42]
   \   000000B4   0x1E40             SUBS     R0,R0,#+1
   \   000000B6   0x8560             STRH     R0,[R4, #+42]
   \                     ??I2C_SlaveTransmit_ISR_5: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000BE   0xBD10             POP      {R4,PC}          ;; return
   2865          }  
   2866          
   2867          /**
   2868            * @brief  Handle Interrupt Flags Slave Receive Mode
   2869            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2870            *                the configuration information for the specified I2C.
   2871            * @retval HAL status
   2872            */

   \                                 In section .text, align 2, keep-with-next
   2873          static HAL_StatusTypeDef I2C_SlaveReceive_ISR(I2C_HandleTypeDef *hi2c) 
   2874          {
   \                     I2C_SlaveReceive_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2875            /* Process Locked */
   2876            __HAL_LOCK(hi2c);
   \   00000004   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??I2C_SlaveReceive_ISR_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0034      STRB     R0,[R4, #+52]
   2877            
   2878            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) != RESET)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x06C9             LSLS     R1,R1,#+27
   \   0000001C   0xD50F             BPL.N    ??I2C_SlaveReceive_ISR_1
   2879            {
   2880              /* Clear NACK Flag */
   2881              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \   0000001E   0x2110             MOVS     R1,#+16
   \   00000020   0x61C1             STR      R1,[R0, #+28]
   2882          
   2883              /* Process Unlocked */
   2884              __HAL_UNLOCK(hi2c);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xF884 0x0034      STRB     R0,[R4, #+52]
   2885              
   2886              hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   2887              HAL_I2C_ErrorCallback(hi2c);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   2888            }
   2889            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   2890            {
   2891              /* Clear ADDR flag */
   2892              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   2893            }
   2894            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   2895            {
   2896              /* Read data from RXDR */
   2897              (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
   2898              hi2c->XferSize--;
   2899              hi2c->XferCount--;
   2900            }
   2901            else if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   2902            {
   2903              /* Disable ERRI, TCI, STOPI, NACKI, ADDRI, RXI, TXI interrupt */
   2904              __HAL_I2C_DISABLE_IT(hi2c,I2C_IT_ERRI | I2C_IT_TCI| I2C_IT_STOPI| I2C_IT_NACKI | I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_RXI );
   2905              
   2906              /* Disable Address Acknowledge */
   2907              hi2c->Instance->CR2 |= I2C_CR2_NACK;
   2908          
   2909              /* Clear STOP Flag */
   2910              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   2911          
   2912              hi2c->State = HAL_I2C_STATE_READY;
   2913              
   2914              /* Process Unlocked */
   2915              __HAL_UNLOCK(hi2c);
   2916          
   2917              HAL_I2C_SlaveRxCpltCallback(hi2c);
   2918            }
   2919          
   2920            /* Process Unlocked */
   2921            __HAL_UNLOCK(hi2c);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF884 0x0034      STRB     R0,[R4, #+52]
   2922            
   2923            return HAL_OK;     
   \   0000003C   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_1: (+1)
   \   0000003E   0x6981             LDR      R1,[R0, #+24]
   \   00000040   0x0709             LSLS     R1,R1,#+28
   \   00000042   0xD505             BPL.N    ??I2C_SlaveReceive_ISR_2
   \   00000044   0x2108             MOVS     R1,#+8
   \   00000046   0x61C1             STR      R1,[R0, #+28]
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000004E   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_2: (+1)
   \   00000050   0x6981             LDR      R1,[R0, #+24]
   \   00000052   0x0749             LSLS     R1,R1,#+29
   \   00000054   0xD50E             BPL.N    ??I2C_SlaveReceive_ISR_3
   \   00000056   0x6A61             LDR      R1,[R4, #+36]
   \   00000058   0x1C4A             ADDS     R2,R1,#+1
   \   0000005A   0x6262             STR      R2,[R4, #+36]
   \   0000005C   0x6A40             LDR      R0,[R0, #+36]
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   \   00000060   0x8D20             LDRH     R0,[R4, #+40]
   \   00000062   0x1E40             SUBS     R0,R0,#+1
   \   00000064   0x8520             STRH     R0,[R4, #+40]
   \   00000066   0x8D60             LDRH     R0,[R4, #+42]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x8560             STRH     R0,[R4, #+42]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   00000072   0xBD10             POP      {R4,PC}
   \                     ??I2C_SlaveReceive_ISR_3: (+1)
   \   00000074   0x6981             LDR      R1,[R0, #+24]
   \   00000076   0x0689             LSLS     R1,R1,#+26
   \   00000078   0xD514             BPL.N    ??I2C_SlaveReceive_ISR_4
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0xF021 0x01FC      BIC      R1,R1,#0xFC
   \   00000080   0x6001             STR      R1,[R0, #+0]
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x6841             LDR      R1,[R0, #+4]
   \   00000086   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000008A   0x6041             STR      R1,[R0, #+4]
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x2020             MOVS     R0,#+32
   \   00000090   0x61C8             STR      R0,[R1, #+28]
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   0000009E   0x4620             MOV      R0,R4
   \   000000A0   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   \                     ??I2C_SlaveReceive_ISR_4: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000AA   0xBD10             POP      {R4,PC}          ;; return
   2924          }  
   2925          
   2926          /**
   2927            * @brief  Master sends target device address followed by internal memory address for write request.
   2928            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2929            *                the configuration information for the specified I2C.
   2930            * @param  DevAddress: Target device address
   2931            * @param  MemAddress: Internal memory address
   2932            * @param  MemAddSize: Size of internal memory address
   2933            * @param  Timeout: Timeout duration
   2934            * @retval HAL status
   2935            */
   2936          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)   
   2937          {
   2938            I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
   2939          
   2940            /* Wait until TXIS flag is set */
   2941            if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   2942            {
   2943              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   2944              {
   2945                return HAL_ERROR;
   2946              }
   2947              else
   2948              {
   2949                return HAL_TIMEOUT;
   2950              }
   2951            }
   2952          
   2953            /* If Memory address size is 8Bit */
   2954            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   2955            {
   2956              /* Send Memory Address */
   2957              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);    
   2958            }      
   2959            /* If Memory address size is 16Bit */
   2960            else
   2961            {
   2962              /* Send MSB of Memory Address */
   2963              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress); 
   2964              
   2965              /* Wait until TXIS flag is set */
   2966              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   2967              {
   2968                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   2969                {
   2970                  return HAL_ERROR;
   2971                }
   2972                else
   2973                {
   2974                  return HAL_TIMEOUT;
   2975                }
   2976              }
   2977              
   2978              /* Send LSB of Memory Address */
   2979              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);  
   2980            }
   2981            
   2982            /* Wait until TCR flag is set */
   2983            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout) != HAL_OK)      
   2984            {
   2985              return HAL_TIMEOUT;
   2986            }
   2987          
   2988          return HAL_OK;
   2989          }
   2990          
   2991          /**
   2992            * @brief  Master sends target device address followed by internal memory address for read request.
   2993            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   2994            *                the configuration information for the specified I2C.
   2995            * @param  DevAddress: Target device address
   2996            * @param  MemAddress: Internal memory address
   2997            * @param  MemAddSize: Size of internal memory address
   2998            * @param  Timeout: Timeout duration
   2999            * @retval HAL status
   3000            */
   3001          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout)
   3002          {
   3003            I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
   3004            
   3005            /* Wait until TXIS flag is set */
   3006            if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   3007            {
   3008              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3009              {
   3010                return HAL_ERROR;
   3011              }
   3012              else
   3013              {
   3014                return HAL_TIMEOUT;
   3015              }
   3016            }
   3017            
   3018            /* If Memory address size is 8Bit */
   3019            if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
   3020            {
   3021              /* Send Memory Address */
   3022              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);    
   3023            }      
   3024            /* If Memory address size is 16Bit */
   3025            else
   3026            {
   3027              /* Send MSB of Memory Address */
   3028              hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress); 
   3029              
   3030              /* Wait until TXIS flag is set */
   3031              if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout) != HAL_OK)
   3032              {
   3033                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3034                {
   3035                  return HAL_ERROR;
   3036                }
   3037                else
   3038                {
   3039                  return HAL_TIMEOUT;
   3040                }
   3041              }
   3042              
   3043              /* Send LSB of Memory Address */
   3044              hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);  
   3045            }
   3046            
   3047            /* Wait until TC flag is set */
   3048            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout) != HAL_OK)      
   3049            {
   3050              return HAL_TIMEOUT;
   3051            }
   3052            
   3053            return HAL_OK;
   3054          }
   3055          
   3056          /**
   3057            * @brief  DMA I2C master transmit process complete callback.
   3058            * @param  hdma: DMA handle
   3059            * @retval None
   3060            */

   \                                 In section .text, align 2, keep-with-next
   3061          static void I2C_DMAMasterTransmitCplt(DMA_HandleTypeDef *hdma) 
   3062          {
   \                     I2C_DMAMasterTransmitCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3063            uint16_t DevAddress;
   3064            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3065            
   3066            /* Check if last DMA request was done with RELOAD */
   3067            /* Set NBYTES to write and reload if size > 255 */
   3068            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x80E0      BNE.W    ??I2C_DMAMasterTransmitCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x80DC      BCS.W    ??I2C_DMAMasterTransmitCplt_0
   3069            {
   3070              /* Wait until TCR flag is set */
   3071              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMasterTransmitCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMasterTransmitCplt_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   3072              {
   3073                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   3074              }
   3075          
   3076              /* Disable DMA Request */
   3077              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMAMasterTransmitCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   3078              
   3079              /* Check if Errors has been detected during transfer */
   3080              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0xB398             CBZ.N    R0,??I2C_DMAMasterTransmitCplt_3
   3081              {
   3082                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3083                /* Wait until STOPF flag is reset */ 
   3084                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6980             LDR      R0,[R0, #+24]
   \   0000005A   0x0680             LSLS     R0,R0,#+26
   \   0000005C   0xD41C             BMI.N    ??I2C_DMAMasterTransmitCplt_5
   \   0000005E   0x2119             MOVS     R1,#+25
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000066   0xB970             CBNZ.N   R0,??I2C_DMAMasterTransmitCplt_6
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1B40             SUBS     R0,R0,R5
   \   0000006E   0x281A             CMP      R0,#+26
   \   00000070   0xD3F1             BCC.N    ??I2C_DMAMasterTransmitCplt_4
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   3085                {
   3086                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMasterTransmitCplt_6: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000092   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3087                  {
   3088                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3089                  }
   3090                  else
   3091                  {
   3092                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000096   0x63A0             STR      R0,[R4, #+56]
   3093                  }
   3094                }
   3095              
   3096                /* Clear STOP Flag */
   3097                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterTransmitCplt_5: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x2020             MOVS     R0,#+32
   3098                    
   3099                /* Clear Configuration Register 2 */
   3100                I2C_RESET_CR2(hi2c);
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000A0   0x61C8             STR      R0,[R1, #+28]
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0x4011             ANDS     R1,R2,R1
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   3101          
   3102                hi2c->XferCount = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x8560             STRH     R0,[R4, #+42]
   3103              
   3104                hi2c->State = HAL_I2C_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0035      STRB     R0,[R4, #+53]
   3105                HAL_I2C_ErrorCallback(hi2c);
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xE0C5             B.N      ??I2C_DMAMasterTransmitCplt_7
   3106              }
   3107              else
   3108              {
   3109                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMasterTransmitCplt_3: (+1)
   \   000000B8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000BA   0x6A61             LDR      R1,[R4, #+36]
   \   000000BC   0x1841             ADDS     R1,R0,R1
   \   000000BE   0x6261             STR      R1,[R4, #+36]
   3110                hi2c->XferCount -= hi2c->XferSize;
   \   000000C0   0x8D62             LDRH     R2,[R4, #+42]
   \   000000C2   0x1A10             SUBS     R0,R2,R0
   \   000000C4   0x8560             STRH     R0,[R4, #+42]
   3111                if(hi2c->XferCount > 255)
   \   000000C6   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C8   0x28FF             CMP      R0,#+255
   \   000000CA   0xBFCC             ITE      GT 
   \   000000CC   0x20FF             MOVGT    R0,#+255
   \   000000CE   0x8D60             LDRHLE   R0,[R4, #+42]
   3112                {
   3113                  hi2c->XferSize = 255;
   3114                }
   3115                else
   3116                {
   3117                  hi2c->XferSize = hi2c->XferCount;
   \   000000D0   0x8520             STRH     R0,[R4, #+40]
   3118                }
   3119          
   3120                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6842             LDR      R2,[R0, #+4]
   3121                        
   3122                /* Enable the DMA channel */
   3123                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   000000D6   0x8D23             LDRH     R3,[R4, #+40]
   \   000000D8   0x0595             LSLS     R5,R2,#+22
   \   000000DA   0xF100 0x0228      ADD      R2,R0,#+40
   \   000000DE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3124                
   3125                /* Send Slave Address */
   3126                /* Set NBYTES to write and reload if size > 255 */
   3127                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000E4   0x8D21             LDRH     R1,[R4, #+40]
   \   000000E6   0x29FF             CMP      R1,#+255
   \   000000E8   0xD10E             BNE.N    ??I2C_DMAMasterTransmitCplt_8
   \   000000EA   0x8D60             LDRH     R0,[R4, #+42]
   \   000000EC   0x4281             CMP      R1,R0
   \   000000EE   0xD20B             BCS.N    ??I2C_DMAMasterTransmitCplt_8
   3128                {
   3129                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0xfc009800
   \   000000F6   0x6842             LDR      R2,[R0, #+4]
   \   000000F8   0x401A             ANDS     R2,R3,R2
   \   000000FA   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   000000FE   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000102   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000106   0xE00B             B.N      ??I2C_DMAMasterTransmitCplt_9
   3130                }
   3131                else
   3132                {
   3133                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMasterTransmitCplt_8: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0xfc009800
   \   0000010E   0xB2C9             UXTB     R1,R1
   \   00000110   0x6842             LDR      R2,[R0, #+4]
   \   00000112   0x401A             ANDS     R2,R3,R2
   \   00000114   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   00000118   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000011C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??I2C_DMAMasterTransmitCplt_9: (+1)
   \   00000120   0x6041             STR      R1,[R0, #+4]
   3134                }  
   3135          
   3136                /* Wait until TXIS flag is set */
   3137                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   00000122   0x.... 0x....      BL       HAL_GetTick
   \   00000126   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_10: (+1)
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0x6981             LDR      R1,[R0, #+24]
   \   0000012C   0x0789             LSLS     R1,R1,#+30
   \   0000012E   0xD437             BMI.N    ??I2C_DMAMasterTransmitCplt_11
   \   00000130   0x2119             MOVS     R1,#+25
   \   00000132   0x4620             MOV      R0,R4
   \   00000134   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000138   0xB970             CBNZ.N   R0,??I2C_DMAMasterTransmitCplt_12
   \   0000013A   0x.... 0x....      BL       HAL_GetTick
   \   0000013E   0x1B40             SUBS     R0,R0,R5
   \   00000140   0x281A             CMP      R0,#+26
   \   00000142   0xD3F1             BCC.N    ??I2C_DMAMasterTransmitCplt_10
   \   00000144   0x6BA0             LDR      R0,[R4, #+56]
   \   00000146   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000014A   0x63A0             STR      R0,[R4, #+56]
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xF884 0x0034      STRB     R0,[R4, #+52]
   3138                {
   3139                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3140                  /* Wait until STOPF flag is reset */ 
   3141                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??I2C_DMAMasterTransmitCplt_12: (+1)
   \   00000158   0x.... 0x....      BL       HAL_GetTick
   \   0000015C   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_13: (+1)
   \   0000015E   0x6820             LDR      R0,[R4, #+0]
   \   00000160   0x6980             LDR      R0,[R0, #+24]
   \   00000162   0x0680             LSLS     R0,R0,#+26
   \   00000164   0xD423             BMI.N    ??I2C_DMAMasterTransmitCplt_14
   \   00000166   0x2119             MOVS     R1,#+25
   \   00000168   0x4620             MOV      R0,R4
   \   0000016A   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000016E   0xB970             CBNZ.N   R0,??I2C_DMAMasterTransmitCplt_15
   \   00000170   0x.... 0x....      BL       HAL_GetTick
   \   00000174   0x1B40             SUBS     R0,R0,R5
   \   00000176   0x281A             CMP      R0,#+26
   \   00000178   0xD3F1             BCC.N    ??I2C_DMAMasterTransmitCplt_13
   \   0000017A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000017C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000180   0x63A0             STR      R0,[R4, #+56]
   \   00000182   0x2001             MOVS     R0,#+1
   \   00000184   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0xF884 0x0034      STRB     R0,[R4, #+52]
   3142                  {
   3143                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMasterTransmitCplt_15: (+1)
   \   0000018E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000190   0x2804             CMP      R0,#+4
   \   00000192   0x6BA0             LDR      R0,[R4, #+56]
   \   00000194   0xBF0C             ITE      EQ 
   \   00000196   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000019A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3144                    {
   3145                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3146                    }
   3147                    else
   3148                    {
   3149                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000019E   0xE005             B.N      ??I2C_DMAMasterTransmitCplt_16
   3150                    }
   3151                  }
   3152                
   3153                  /* Clear STOP Flag */
   3154                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3155                      
   3156                  /* Clear Configuration Register 2 */
   3157                  I2C_RESET_CR2(hi2c);
   3158          
   3159                  hi2c->XferCount = 0;
   3160                
   3161                  hi2c->State = HAL_I2C_STATE_READY;
   3162                  HAL_I2C_ErrorCallback(hi2c);
   3163                }
   3164                else
   3165                {
   3166                  /* Enable DMA Request */
   3167                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??I2C_DMAMasterTransmitCplt_11: (+1)
   \   000001A0   0x6801             LDR      R1,[R0, #+0]
   \   000001A2   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000001A6   0x6001             STR      R1,[R0, #+0]
   3168                }
   3169              }
   3170            }
   3171            else
   3172            {
   3173              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3174              /* Wait until STOPF flag is reset */ 
   3175              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   3176              {
   3177                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3178                {
   3179                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3180                }
   3181                else
   3182                {
   3183                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3184                }
   3185              }
   3186            
   3187              /* Clear STOP Flag */
   3188              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3189            	
   3190              /* Clear Configuration Register 2 */
   3191              I2C_RESET_CR2(hi2c);
   3192          
   3193              /* Disable DMA Request */
   3194              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   3195            
   3196              hi2c->XferCount = 0;
   3197            
   3198              hi2c->State = HAL_I2C_STATE_READY;
   3199          
   3200             /* Check if Errors has been detected during transfer */
   3201              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   3202              {
   3203                HAL_I2C_ErrorCallback(hi2c);
   3204              }
   3205              else
   3206              {
   3207                HAL_I2C_MasterTxCpltCallback(hi2c);
   3208              }
   3209            }
   3210          }
   \   000001A8   0xB001             ADD      SP,SP,#+4
   \   000001AA   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMasterTransmitCplt_16: (+1)
   \   000001AC   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMasterTransmitCplt_14: (+1)
   \   000001AE   0x6821             LDR      R1,[R4, #+0]
   \   000001B0   0x2020             MOVS     R0,#+32
   \   000001B2   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000001B6   0x61C8             STR      R0,[R1, #+28]
   \   000001B8   0x6820             LDR      R0,[R4, #+0]
   \   000001BA   0x6841             LDR      R1,[R0, #+4]
   \   000001BC   0x4011             ANDS     R1,R2,R1
   \   000001BE   0x6041             STR      R1,[R0, #+4]
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0x8560             STRH     R0,[R4, #+42]
   \   000001C4   0x2001             MOVS     R0,#+1
   \   000001C6   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001CA   0x4620             MOV      R0,R4
   \   000001CC   0xE03A             B.N      ??I2C_DMAMasterTransmitCplt_7
   \                     ??I2C_DMAMasterTransmitCplt_0: (+1)
   \   000001CE   0x.... 0x....      BL       HAL_GetTick
   \   000001D2   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterTransmitCplt_17: (+1)
   \   000001D4   0x6820             LDR      R0,[R4, #+0]
   \   000001D6   0x6980             LDR      R0,[R0, #+24]
   \   000001D8   0x0680             LSLS     R0,R0,#+26
   \   000001DA   0xD41C             BMI.N    ??I2C_DMAMasterTransmitCplt_18
   \   000001DC   0x2119             MOVS     R1,#+25
   \   000001DE   0x4620             MOV      R0,R4
   \   000001E0   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001E4   0xB970             CBNZ.N   R0,??I2C_DMAMasterTransmitCplt_19
   \   000001E6   0x.... 0x....      BL       HAL_GetTick
   \   000001EA   0x1B40             SUBS     R0,R0,R5
   \   000001EC   0x281A             CMP      R0,#+26
   \   000001EE   0xD3F1             BCC.N    ??I2C_DMAMasterTransmitCplt_17
   \   000001F0   0x6BA0             LDR      R0,[R4, #+56]
   \   000001F2   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001F6   0x63A0             STR      R0,[R4, #+56]
   \   000001F8   0x2001             MOVS     R0,#+1
   \   000001FA   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??I2C_DMAMasterTransmitCplt_19: (+1)
   \   00000204   0x6BA0             LDR      R0,[R4, #+56]
   \   00000206   0x2804             CMP      R0,#+4
   \   00000208   0x6BA0             LDR      R0,[R4, #+56]
   \   0000020A   0xBF0C             ITE      EQ 
   \   0000020C   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000210   0xF040 0x0020      ORRNE    R0,R0,#0x20
   \   00000214   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMasterTransmitCplt_18: (+1)
   \   00000216   0x6821             LDR      R1,[R4, #+0]
   \   00000218   0x2020             MOVS     R0,#+32
   \   0000021A   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   0000021E   0x61C8             STR      R0,[R1, #+28]
   \   00000220   0x6820             LDR      R0,[R4, #+0]
   \   00000222   0x6841             LDR      R1,[R0, #+4]
   \   00000224   0x4011             ANDS     R1,R2,R1
   \   00000226   0x6041             STR      R1,[R0, #+4]
   \   00000228   0x6820             LDR      R0,[R4, #+0]
   \   0000022A   0x6801             LDR      R1,[R0, #+0]
   \   0000022C   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000230   0x6001             STR      R1,[R0, #+0]
   \   00000232   0x2000             MOVS     R0,#+0
   \   00000234   0x8560             STRH     R0,[R4, #+42]
   \   00000236   0x2001             MOVS     R0,#+1
   \   00000238   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000023C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000023E   0x2800             CMP      R0,#+0
   \   00000240   0x4620             MOV      R0,R4
   \   00000242   0xD003             BEQ.N    ??I2C_DMAMasterTransmitCplt_20
   \                     ??I2C_DMAMasterTransmitCplt_7: (+1)
   \   00000244   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000248   0xB001             ADD      SP,SP,#+4
   \   0000024A   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMasterTransmitCplt_20: (+1)
   \   0000024C   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \   00000250   0xB001             ADD      SP,SP,#+4
   \   00000252   0xBD30             POP      {R4,R5,PC}       ;; return
   3211          
   3212          /**
   3213            * @brief  DMA I2C slave transmit process complete callback. 
   3214            * @param  hdma: DMA handle
   3215            * @retval None
   3216            */

   \                                 In section .text, align 2, keep-with-next
   3217          static void I2C_DMASlaveTransmitCplt(DMA_HandleTypeDef *hdma) 
   3218          {
   \                     I2C_DMASlaveTransmitCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3219            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3220            
   3221            /* Wait until STOP flag is set */
   3222            if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveTransmitCplt_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD41B             BMI.N    ??I2C_DMASlaveTransmitCplt_1
   \   00000014   0x2119             MOVS     R1,#+25
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001C   0xB970             CBNZ.N   R0,??I2C_DMASlaveTransmitCplt_2
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x1B40             SUBS     R0,R0,R5
   \   00000024   0x281A             CMP      R0,#+26
   \   00000026   0xD3F1             BCC.N    ??I2C_DMASlaveTransmitCplt_0
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF884 0x0034      STRB     R0,[R4, #+52]
   3223            {
   3224              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMASlaveTransmitCplt_2: (+1)
   \   0000003C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003E   0x2804             CMP      R0,#+4
   \   00000040   0xBF0E             ITEE     EQ 
   \   00000042   0x2000             MOVEQ    R0,#+0
   \   00000044   0x6BA0             LDRNE    R0,[R4, #+56]
   \   00000046   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3225              {
   3226                /* Normal Use case, a AF is generated by master */
   3227                /* to inform slave the end of transfer */
   3228                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3229              }
   3230              else
   3231              {
   3232                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000004A   0x63A0             STR      R0,[R4, #+56]
   3233              }
   3234            }
   3235            
   3236            /* Clear STOP flag */
   3237            __HAL_I2C_CLEAR_FLAG(hi2c,I2C_FLAG_STOPF);
   \                     ??I2C_DMASlaveTransmitCplt_1: (+1)
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0x61C8             STR      R0,[R1, #+28]
   3238            
   3239            /* Wait until BUSY flag is reset */ 
   3240            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \   00000052   0x.... 0x....      BL       HAL_GetTick
   \   00000056   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveTransmitCplt_3: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6980             LDR      R0,[R0, #+24]
   \   0000005C   0x0400             LSLS     R0,R0,#+16
   \   0000005E   0xD50E             BPL.N    ??I2C_DMASlaveTransmitCplt_4
   \   00000060   0x.... 0x....      BL       HAL_GetTick
   \   00000064   0x1B40             SUBS     R0,R0,R5
   \   00000066   0x281A             CMP      R0,#+26
   \   00000068   0xD3F6             BCC.N    ??I2C_DMASlaveTransmitCplt_3
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF884 0x0034      STRB     R0,[R4, #+52]
   3241            {
   3242              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000076   0x6BA0             LDR      R0,[R4, #+56]
   \   00000078   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000007C   0x63A0             STR      R0,[R4, #+56]
   3243            }
   3244            
   3245            /* Disable DMA Request */
   3246            hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMASlaveTransmitCplt_4: (+1)
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6801             LDR      R1,[R0, #+0]
   \   00000082   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000086   0x6001             STR      R1,[R0, #+0]
   3247            
   3248            hi2c->XferCount = 0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x8560             STRH     R0,[R4, #+42]
   3249            
   3250            hi2c->State = HAL_I2C_STATE_READY;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0xF884 0x0035      STRB     R0,[R4, #+53]
   3251          
   3252            /* Check if Errors has been detected during transfer */
   3253            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   00000092   0x6BA0             LDR      R0,[R4, #+56]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0x4620             MOV      R0,R4
   \   00000098   0xD003             BEQ.N    ??I2C_DMASlaveTransmitCplt_5
   3254            {
   3255              HAL_I2C_ErrorCallback(hi2c);
   \   0000009A   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3256            }
   3257            else
   3258            {
   3259              HAL_I2C_SlaveTxCpltCallback(hi2c);
   3260            }
   3261          }
   \   0000009E   0xB001             ADD      SP,SP,#+4
   \   000000A0   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMASlaveTransmitCplt_5: (+1)
   \   000000A2   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   \   000000A6   0xB001             ADD      SP,SP,#+4
   \   000000A8   0xBD30             POP      {R4,R5,PC}       ;; return
   3262          
   3263          /**
   3264            * @brief DMA I2C master receive process complete callback 
   3265            * @param  hdma: DMA handle
   3266            * @retval None
   3267            */

   \                                 In section .text, align 2, keep-with-next
   3268          static void I2C_DMAMasterReceiveCplt(DMA_HandleTypeDef *hdma) 
   3269          {
   \                     I2C_DMAMasterReceiveCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3270            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3271            uint16_t DevAddress;
   3272            
   3273            /* Check if last DMA request was done with RELOAD */
   3274            /* Set NBYTES to write and reload if size > 255 */
   3275            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x80DD      BNE.W    ??I2C_DMAMasterReceiveCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x80D9      BCS.W    ??I2C_DMAMasterReceiveCplt_0
   3276            {
   3277              /* Wait until TCR flag is set */
   3278              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMasterReceiveCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMasterReceiveCplt_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   3279              {
   3280                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   3281              }
   3282          
   3283              /* Disable DMA Request */
   3284              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMAMasterReceiveCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   3285          
   3286              /* Check if Errors has been detected during transfer */
   3287              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0xB398             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_3
   3288              {
   3289                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3290                /* Wait until STOPF flag is reset */ 
   3291                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6980             LDR      R0,[R0, #+24]
   \   0000005A   0x0680             LSLS     R0,R0,#+26
   \   0000005C   0xD41C             BMI.N    ??I2C_DMAMasterReceiveCplt_5
   \   0000005E   0x2119             MOVS     R1,#+25
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000066   0xB970             CBNZ.N   R0,??I2C_DMAMasterReceiveCplt_6
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1B40             SUBS     R0,R0,R5
   \   0000006E   0x281A             CMP      R0,#+26
   \   00000070   0xD3F1             BCC.N    ??I2C_DMAMasterReceiveCplt_4
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   3292                {
   3293                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMasterReceiveCplt_6: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000092   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3294                  {
   3295                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3296                  }
   3297                  else
   3298                  {
   3299                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000096   0x63A0             STR      R0,[R4, #+56]
   3300                  }
   3301                }
   3302              
   3303                /* Clear STOP Flag */
   3304                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterReceiveCplt_5: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x2020             MOVS     R0,#+32
   3305                    
   3306                /* Clear Configuration Register 2 */
   3307                I2C_RESET_CR2(hi2c);
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000A0   0x61C8             STR      R0,[R1, #+28]
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0x4011             ANDS     R1,R2,R1
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   3308              
   3309                hi2c->XferCount = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x8560             STRH     R0,[R4, #+42]
   3310              
   3311                hi2c->State = HAL_I2C_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0035      STRB     R0,[R4, #+53]
   3312                HAL_I2C_ErrorCallback(hi2c);
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xE0C2             B.N      ??I2C_DMAMasterReceiveCplt_7
   3313              }
   3314              else
   3315              {
   3316                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMasterReceiveCplt_3: (+1)
   \   000000B8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000BA   0x6A61             LDR      R1,[R4, #+36]
   \   000000BC   0x1842             ADDS     R2,R0,R1
   \   000000BE   0x6262             STR      R2,[R4, #+36]
   3317                hi2c->XferCount -= hi2c->XferSize;
   \   000000C0   0x8D61             LDRH     R1,[R4, #+42]
   \   000000C2   0x1A08             SUBS     R0,R1,R0
   \   000000C4   0x8560             STRH     R0,[R4, #+42]
   3318                if(hi2c->XferCount > 255)
   \   000000C6   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C8   0x28FF             CMP      R0,#+255
   \   000000CA   0xBFCC             ITE      GT 
   \   000000CC   0x20FF             MOVGT    R0,#+255
   \   000000CE   0x8D60             LDRHLE   R0,[R4, #+42]
   3319                {
   3320                  hi2c->XferSize = 255;
   3321                }
   3322                else
   3323                {
   3324                  hi2c->XferSize = hi2c->XferCount;
   \   000000D0   0x8520             STRH     R0,[R4, #+40]
   3325                }
   3326          
   3327                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6841             LDR      R1,[R0, #+4]
   3328                        
   3329                /* Enable the DMA channel */
   3330                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000D6   0x8D23             LDRH     R3,[R4, #+40]
   \   000000D8   0x058D             LSLS     R5,R1,#+22
   \   000000DA   0xF100 0x0124      ADD      R1,R0,#+36
   \   000000DE   0x6B20             LDR      R0,[R4, #+48]
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3331                
   3332                /* Send Slave Address */
   3333                /* Set NBYTES to write and reload if size > 255 */
   3334                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000E4   0x8D21             LDRH     R1,[R4, #+40]
   \   000000E6   0x29FF             CMP      R1,#+255
   \   000000E8   0xD10E             BNE.N    ??I2C_DMAMasterReceiveCplt_8
   \   000000EA   0x8D60             LDRH     R0,[R4, #+42]
   \   000000EC   0x4281             CMP      R1,R0
   \   000000EE   0xD20B             BCS.N    ??I2C_DMAMasterReceiveCplt_8
   3335                {
   3336                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0xfc009800
   \   000000F6   0x6842             LDR      R2,[R0, #+4]
   \   000000F8   0x401A             ANDS     R2,R3,R2
   \   000000FA   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   000000FE   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000102   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000106   0xE00B             B.N      ??I2C_DMAMasterReceiveCplt_9
   3337                }
   3338                else
   3339                {
   3340                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMasterReceiveCplt_8: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R3,??DataTable20  ;; 0xfc009800
   \   0000010E   0xB2C9             UXTB     R1,R1
   \   00000110   0x6842             LDR      R2,[R0, #+4]
   \   00000112   0x401A             ANDS     R2,R3,R2
   \   00000114   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   00000118   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   0000011C   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??I2C_DMAMasterReceiveCplt_9: (+1)
   \   00000120   0x6041             STR      R1,[R0, #+4]
   3341                }  
   3342          
   3343                /* Wait until RXNE flag is set */
   3344                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   00000122   0x.... 0x....      BL       HAL_GetTick
   \   00000126   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_10: (+1)
   \   00000128   0x6820             LDR      R0,[R4, #+0]
   \   0000012A   0x6980             LDR      R0,[R0, #+24]
   \   0000012C   0x0740             LSLS     R0,R0,#+29
   \   0000012E   0xD40E             BMI.N    ??I2C_DMAMasterReceiveCplt_11
   \   00000130   0x.... 0x....      BL       HAL_GetTick
   \   00000134   0x1B40             SUBS     R0,R0,R5
   \   00000136   0x281A             CMP      R0,#+26
   \   00000138   0xD3F6             BCC.N    ??I2C_DMAMasterReceiveCplt_10
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xF884 0x0034      STRB     R0,[R4, #+52]
   3345                {
   3346                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000146   0x6BA0             LDR      R0,[R4, #+56]
   \   00000148   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000014C   0x63A0             STR      R0,[R4, #+56]
   3347                }
   3348                
   3349                /* Check if Errors has been detected during transfer */
   3350                if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??I2C_DMAMasterReceiveCplt_11: (+1)
   \   0000014E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000150   0xB398             CBZ.N    R0,??I2C_DMAMasterReceiveCplt_12
   3351                {
   3352                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3353                  /* Wait until STOPF flag is reset */ 
   3354                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000152   0x.... 0x....      BL       HAL_GetTick
   \   00000156   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_13: (+1)
   \   00000158   0x6820             LDR      R0,[R4, #+0]
   \   0000015A   0x6980             LDR      R0,[R0, #+24]
   \   0000015C   0x0680             LSLS     R0,R0,#+26
   \   0000015E   0xD41C             BMI.N    ??I2C_DMAMasterReceiveCplt_14
   \   00000160   0x2119             MOVS     R1,#+25
   \   00000162   0x4620             MOV      R0,R4
   \   00000164   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000168   0xB970             CBNZ.N   R0,??I2C_DMAMasterReceiveCplt_15
   \   0000016A   0x.... 0x....      BL       HAL_GetTick
   \   0000016E   0x1B40             SUBS     R0,R0,R5
   \   00000170   0x281A             CMP      R0,#+26
   \   00000172   0xD3F1             BCC.N    ??I2C_DMAMasterReceiveCplt_13
   \   00000174   0x6BA0             LDR      R0,[R4, #+56]
   \   00000176   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000017A   0x63A0             STR      R0,[R4, #+56]
   \   0000017C   0x2001             MOVS     R0,#+1
   \   0000017E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0xF884 0x0034      STRB     R0,[R4, #+52]
   3355                  {
   3356                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMasterReceiveCplt_15: (+1)
   \   00000188   0x6BA0             LDR      R0,[R4, #+56]
   \   0000018A   0x2804             CMP      R0,#+4
   \   0000018C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000018E   0xBF0C             ITE      EQ 
   \   00000190   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000194   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3357                    {
   3358                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3359                    }
   3360                    else
   3361                    {
   3362                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000198   0x63A0             STR      R0,[R4, #+56]
   3363                    }
   3364                  }
   3365                
   3366                  /* Clear STOP Flag */
   3367                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMasterReceiveCplt_14: (+1)
   \   0000019A   0x6821             LDR      R1,[R4, #+0]
   \   0000019C   0x2020             MOVS     R0,#+32
   3368                      
   3369                  /* Clear Configuration Register 2 */
   3370                  I2C_RESET_CR2(hi2c);
   \   0000019E   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000001A2   0x61C8             STR      R0,[R1, #+28]
   \   000001A4   0x6820             LDR      R0,[R4, #+0]
   \   000001A6   0x6841             LDR      R1,[R0, #+4]
   \   000001A8   0x4011             ANDS     R1,R2,R1
   \   000001AA   0x6041             STR      R1,[R0, #+4]
   3371                
   3372                  hi2c->XferCount = 0;
   \   000001AC   0x2000             MOVS     R0,#+0
   \   000001AE   0x8560             STRH     R0,[R4, #+42]
   3373                
   3374                  hi2c->State = HAL_I2C_STATE_READY;
   \   000001B0   0x2001             MOVS     R0,#+1
   \   000001B2   0xF884 0x0035      STRB     R0,[R4, #+53]
   3375                
   3376                  HAL_I2C_ErrorCallback(hi2c);
   \   000001B6   0x4620             MOV      R0,R4
   \   000001B8   0xE041             B.N      ??I2C_DMAMasterReceiveCplt_7
   3377                }
   3378                else
   3379                {
   3380                  /* Enable DMA Request */
   3381                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??I2C_DMAMasterReceiveCplt_12: (+1)
   \   000001BA   0x6820             LDR      R0,[R4, #+0]
   \   000001BC   0x6801             LDR      R1,[R0, #+0]
   \   000001BE   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001C2   0x6001             STR      R1,[R0, #+0]
   3382                }
   3383              }
   3384            }
   3385            else
   3386            {
   3387              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3388              /* Wait until STOPF flag is reset */ 
   3389              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   3390              {
   3391                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3392                {
   3393                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3394                }
   3395                else
   3396                {
   3397                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3398                }
   3399              }
   3400            
   3401              /* Clear STOP Flag */
   3402              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3403            	
   3404              /* Clear Configuration Register 2 */
   3405              I2C_RESET_CR2(hi2c);
   3406            
   3407              /* Disable DMA Request */
   3408              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   3409            
   3410              hi2c->XferCount = 0;
   3411            
   3412              hi2c->State = HAL_I2C_STATE_READY;
   3413          
   3414              /* Check if Errors has been detected during transfer */
   3415              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   3416              {
   3417                HAL_I2C_ErrorCallback(hi2c);
   3418              }
   3419              else
   3420              {
   3421                HAL_I2C_MasterRxCpltCallback(hi2c);
   3422              }
   3423            }
   3424          }
   \   000001C4   0xB001             ADD      SP,SP,#+4
   \   000001C6   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMasterReceiveCplt_0: (+1)
   \   000001C8   0x.... 0x....      BL       HAL_GetTick
   \   000001CC   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMasterReceiveCplt_16: (+1)
   \   000001CE   0x6820             LDR      R0,[R4, #+0]
   \   000001D0   0x6980             LDR      R0,[R0, #+24]
   \   000001D2   0x0680             LSLS     R0,R0,#+26
   \   000001D4   0xD41C             BMI.N    ??I2C_DMAMasterReceiveCplt_17
   \   000001D6   0x2119             MOVS     R1,#+25
   \   000001D8   0x4620             MOV      R0,R4
   \   000001DA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001DE   0xB970             CBNZ.N   R0,??I2C_DMAMasterReceiveCplt_18
   \   000001E0   0x.... 0x....      BL       HAL_GetTick
   \   000001E4   0x1B40             SUBS     R0,R0,R5
   \   000001E6   0x281A             CMP      R0,#+26
   \   000001E8   0xD3F1             BCC.N    ??I2C_DMAMasterReceiveCplt_16
   \   000001EA   0x6BA0             LDR      R0,[R4, #+56]
   \   000001EC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001F0   0x63A0             STR      R0,[R4, #+56]
   \   000001F2   0x2001             MOVS     R0,#+1
   \   000001F4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??I2C_DMAMasterReceiveCplt_18: (+1)
   \   000001FE   0x6BA0             LDR      R0,[R4, #+56]
   \   00000200   0x2804             CMP      R0,#+4
   \   00000202   0x6BA0             LDR      R0,[R4, #+56]
   \   00000204   0xBF0C             ITE      EQ 
   \   00000206   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000020A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   \   0000020E   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMasterReceiveCplt_17: (+1)
   \   00000210   0x6821             LDR      R1,[R4, #+0]
   \   00000212   0x2020             MOVS     R0,#+32
   \   00000214   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   00000218   0x61C8             STR      R0,[R1, #+28]
   \   0000021A   0x6820             LDR      R0,[R4, #+0]
   \   0000021C   0x6841             LDR      R1,[R0, #+4]
   \   0000021E   0x4011             ANDS     R1,R2,R1
   \   00000220   0x6041             STR      R1,[R0, #+4]
   \   00000222   0x6820             LDR      R0,[R4, #+0]
   \   00000224   0x6801             LDR      R1,[R0, #+0]
   \   00000226   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000022A   0x6001             STR      R1,[R0, #+0]
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0x8560             STRH     R0,[R4, #+42]
   \   00000230   0x2001             MOVS     R0,#+1
   \   00000232   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000236   0x6BA0             LDR      R0,[R4, #+56]
   \   00000238   0x2800             CMP      R0,#+0
   \   0000023A   0x4620             MOV      R0,R4
   \   0000023C   0xD003             BEQ.N    ??I2C_DMAMasterReceiveCplt_19
   \                     ??I2C_DMAMasterReceiveCplt_7: (+1)
   \   0000023E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000242   0xB001             ADD      SP,SP,#+4
   \   00000244   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMasterReceiveCplt_19: (+1)
   \   00000246   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \   0000024A   0xB001             ADD      SP,SP,#+4
   \   0000024C   0xBD30             POP      {R4,R5,PC}       ;; return
   3425          
   3426          /**
   3427            * @brief  DMA I2C slave receive process complete callback.
   3428            * @param  hdma: DMA handle
   3429            * @retval None
   3430            */

   \                                 In section .text, align 2, keep-with-next
   3431          static void I2C_DMASlaveReceiveCplt(DMA_HandleTypeDef *hdma) 
   3432          {  
   \                     I2C_DMASlaveReceiveCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3433            I2C_HandleTypeDef* hi2c = (I2C_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3434            
   3435            /* Wait until STOPF flag is reset */ 
   3436            if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveReceiveCplt_0: (+1)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6980             LDR      R0,[R0, #+24]
   \   00000010   0x0680             LSLS     R0,R0,#+26
   \   00000012   0xD41C             BMI.N    ??I2C_DMASlaveReceiveCplt_1
   \   00000014   0x2119             MOVS     R1,#+25
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000001C   0xB970             CBNZ.N   R0,??I2C_DMASlaveReceiveCplt_2
   \   0000001E   0x.... 0x....      BL       HAL_GetTick
   \   00000022   0x1B40             SUBS     R0,R0,R5
   \   00000024   0x281A             CMP      R0,#+26
   \   00000026   0xD3F1             BCC.N    ??I2C_DMASlaveReceiveCplt_0
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000002E   0x63A0             STR      R0,[R4, #+56]
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF884 0x0034      STRB     R0,[R4, #+52]
   3437            {
   3438              if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMASlaveReceiveCplt_2: (+1)
   \   0000003C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003E   0x2804             CMP      R0,#+4
   \   00000040   0x6BA0             LDR      R0,[R4, #+56]
   \   00000042   0xBF0C             ITE      EQ 
   \   00000044   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000048   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3439              {
   3440                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3441              }
   3442              else
   3443              {
   3444                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000004C   0x63A0             STR      R0,[R4, #+56]
   3445              }
   3446            }
   3447            
   3448            /* Clear STOPF flag */
   3449            __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMASlaveReceiveCplt_1: (+1)
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x2020             MOVS     R0,#+32
   \   00000052   0x61C8             STR      R0,[R1, #+28]
   3450            
   3451            /* Wait until BUSY flag is reset */ 
   3452            if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY) != HAL_OK)      
   \   00000054   0x.... 0x....      BL       HAL_GetTick
   \   00000058   0x4605             MOV      R5,R0
   \                     ??I2C_DMASlaveReceiveCplt_3: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6980             LDR      R0,[R0, #+24]
   \   0000005E   0x0400             LSLS     R0,R0,#+16
   \   00000060   0xD50E             BPL.N    ??I2C_DMASlaveReceiveCplt_4
   \   00000062   0x.... 0x....      BL       HAL_GetTick
   \   00000066   0x1B40             SUBS     R0,R0,R5
   \   00000068   0x281A             CMP      R0,#+26
   \   0000006A   0xD3F6             BCC.N    ??I2C_DMASlaveReceiveCplt_3
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF884 0x0034      STRB     R0,[R4, #+52]
   3453            {
   3454              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000078   0x6BA0             LDR      R0,[R4, #+56]
   \   0000007A   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000007E   0x63A0             STR      R0,[R4, #+56]
   3455            }
   3456            
   3457            /* Disable DMA Request */
   3458            hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMASlaveReceiveCplt_4: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000088   0x6001             STR      R1,[R0, #+0]
   3459            
   3460            /* Disable Address Acknowledge */
   3461            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6841             LDR      R1,[R0, #+4]
   \   0000008E   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000092   0x6041             STR      R1,[R0, #+4]
   3462          
   3463            hi2c->XferCount = 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x8560             STRH     R0,[R4, #+42]
   3464            
   3465            hi2c->State = HAL_I2C_STATE_READY;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xF884 0x0035      STRB     R0,[R4, #+53]
   3466          
   3467            /* Check if Errors has been detected during transfer */
   3468            if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000009E   0x6BA0             LDR      R0,[R4, #+56]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0xD003             BEQ.N    ??I2C_DMASlaveReceiveCplt_5
   3469            {
   3470              HAL_I2C_ErrorCallback(hi2c);
   \   000000A6   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3471            }
   3472            else
   3473            {
   3474              HAL_I2C_SlaveRxCpltCallback(hi2c);
   3475            }
   3476          }
   \   000000AA   0xB001             ADD      SP,SP,#+4
   \   000000AC   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMASlaveReceiveCplt_5: (+1)
   \   000000AE   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   \   000000B2   0xB001             ADD      SP,SP,#+4
   \   000000B4   0xBD30             POP      {R4,R5,PC}       ;; return
   3477          
   3478          /**
   3479            * @brief DMA I2C Memory Write process complete callback 
   3480            * @param hdma : DMA handle
   3481            * @retval None
   3482            */

   \                                 In section .text, align 2, keep-with-next
   3483          static void I2C_DMAMemTransmitCplt(DMA_HandleTypeDef *hdma)   
   3484          {
   \                     I2C_DMAMemTransmitCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3485            uint16_t DevAddress;
   3486            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3487            
   3488            /* Check if last DMA request was done with RELOAD */
   3489            /* Set NBYTES to write and reload if size > 255 */
   3490            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x80DD      BNE.W    ??I2C_DMAMemTransmitCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x80D9      BCS.W    ??I2C_DMAMemTransmitCplt_0
   3491            {
   3492              /* Wait until TCR flag is set */
   3493              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMemTransmitCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMemTransmitCplt_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   3494              {
   3495                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   3496              }
   3497          
   3498              /* Disable DMA Request */
   3499              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   \                     ??I2C_DMAMemTransmitCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   3500              
   3501              /* Check if Errors has been detected during transfer */
   3502              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0xB398             CBZ.N    R0,??I2C_DMAMemTransmitCplt_3
   3503              {
   3504                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3505                /* Wait until STOPF flag is reset */ 
   3506                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6980             LDR      R0,[R0, #+24]
   \   0000005A   0x0680             LSLS     R0,R0,#+26
   \   0000005C   0xD41C             BMI.N    ??I2C_DMAMemTransmitCplt_5
   \   0000005E   0x2119             MOVS     R1,#+25
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000066   0xB970             CBNZ.N   R0,??I2C_DMAMemTransmitCplt_6
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1B40             SUBS     R0,R0,R5
   \   0000006E   0x281A             CMP      R0,#+26
   \   00000070   0xD3F1             BCC.N    ??I2C_DMAMemTransmitCplt_4
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   3507                {
   3508                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMemTransmitCplt_6: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000092   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3509                  {
   3510                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3511                  }
   3512                  else
   3513                  {
   3514                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000096   0x63A0             STR      R0,[R4, #+56]
   3515                  }
   3516                }
   3517              
   3518                /* Clear STOP Flag */
   3519                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemTransmitCplt_5: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x2020             MOVS     R0,#+32
   3520                    
   3521                /* Clear Configuration Register 2 */
   3522                I2C_RESET_CR2(hi2c);
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0xfe00e800
   \   000000A0   0x61C8             STR      R0,[R1, #+28]
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0x4011             ANDS     R1,R2,R1
   \   000000A8   0x6041             STR      R1,[R0, #+4]
   3523          
   3524                hi2c->XferCount = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x8560             STRH     R0,[R4, #+42]
   3525              
   3526                hi2c->State = HAL_I2C_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0035      STRB     R0,[R4, #+53]
   3527                HAL_I2C_ErrorCallback(hi2c);
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xE0C1             B.N      ??I2C_DMAMemTransmitCplt_7
   3528              }
   3529              else
   3530              {
   3531                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMemTransmitCplt_3: (+1)
   \   000000B8   0x8D20             LDRH     R0,[R4, #+40]
   \   000000BA   0x6A61             LDR      R1,[R4, #+36]
   \   000000BC   0x1841             ADDS     R1,R0,R1
   \   000000BE   0x6261             STR      R1,[R4, #+36]
   3532                hi2c->XferCount -= hi2c->XferSize;
   \   000000C0   0x8D62             LDRH     R2,[R4, #+42]
   \   000000C2   0x1A10             SUBS     R0,R2,R0
   \   000000C4   0x8560             STRH     R0,[R4, #+42]
   3533                if(hi2c->XferCount > 255)
   \   000000C6   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C8   0x28FF             CMP      R0,#+255
   \   000000CA   0xBFCC             ITE      GT 
   \   000000CC   0x20FF             MOVGT    R0,#+255
   \   000000CE   0x8D60             LDRHLE   R0,[R4, #+42]
   3534                {
   3535                  hi2c->XferSize = 255;
   3536                }
   3537                else
   3538                {
   3539                  hi2c->XferSize = hi2c->XferCount;
   \   000000D0   0x8520             STRH     R0,[R4, #+40]
   3540                }
   3541          
   3542                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x6842             LDR      R2,[R0, #+4]
   3543                        
   3544                /* Enable the DMA channel */
   3545                HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
   \   000000D6   0x8D23             LDRH     R3,[R4, #+40]
   \   000000D8   0x0595             LSLS     R5,R2,#+22
   \   000000DA   0xF100 0x0228      ADD      R2,R0,#+40
   \   000000DE   0x6AE0             LDR      R0,[R4, #+44]
   \   000000E0   0x.... 0x....      BL       HAL_DMA_Start_IT
   3546                
   3547                /* Send Slave Address */
   3548                /* Set NBYTES to write and reload if size > 255 */
   3549                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000E4   0x8D21             LDRH     R1,[R4, #+40]
   \   000000E6   0x29FF             CMP      R1,#+255
   \   000000E8   0xD10D             BNE.N    ??I2C_DMAMemTransmitCplt_8
   \   000000EA   0x8D60             LDRH     R0,[R4, #+42]
   \   000000EC   0x4281             CMP      R1,R0
   \   000000EE   0xD20A             BCS.N    ??I2C_DMAMemTransmitCplt_8
   3550                {
   3551                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x....             LDR.N    R3,??DataTable20  ;; 0xfc009800
   \   000000F4   0x6842             LDR      R2,[R0, #+4]
   \   000000F6   0x401A             ANDS     R2,R3,R2
   \   000000F8   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   000000FC   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000100   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000104   0xE00A             B.N      ??I2C_DMAMemTransmitCplt_9
   3552                }
   3553                else
   3554                {
   3555                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMemTransmitCplt_8: (+1)
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x....             LDR.N    R3,??DataTable20  ;; 0xfc009800
   \   0000010A   0xB2C9             UXTB     R1,R1
   \   0000010C   0x6842             LDR      R2,[R0, #+4]
   \   0000010E   0x401A             ANDS     R2,R3,R2
   \   00000110   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   00000114   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000118   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??I2C_DMAMemTransmitCplt_9: (+1)
   \   0000011C   0x6041             STR      R1,[R0, #+4]
   3556                }  
   3557          
   3558                /* Wait until TXIS flag is set */
   3559                if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, I2C_TIMEOUT_TXIS) != HAL_OK)
   \   0000011E   0x.... 0x....      BL       HAL_GetTick
   \   00000122   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_10: (+1)
   \   00000124   0x6820             LDR      R0,[R4, #+0]
   \   00000126   0x6981             LDR      R1,[R0, #+24]
   \   00000128   0x0789             LSLS     R1,R1,#+30
   \   0000012A   0xD437             BMI.N    ??I2C_DMAMemTransmitCplt_11
   \   0000012C   0x2119             MOVS     R1,#+25
   \   0000012E   0x4620             MOV      R0,R4
   \   00000130   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000134   0xB970             CBNZ.N   R0,??I2C_DMAMemTransmitCplt_12
   \   00000136   0x.... 0x....      BL       HAL_GetTick
   \   0000013A   0x1B40             SUBS     R0,R0,R5
   \   0000013C   0x281A             CMP      R0,#+26
   \   0000013E   0xD3F1             BCC.N    ??I2C_DMAMemTransmitCplt_10
   \   00000140   0x6BA0             LDR      R0,[R4, #+56]
   \   00000142   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000146   0x63A0             STR      R0,[R4, #+56]
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x0034      STRB     R0,[R4, #+52]
   3560                {
   3561                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3562                  /* Wait until STOPF flag is reset */ 
   3563                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \                     ??I2C_DMAMemTransmitCplt_12: (+1)
   \   00000154   0x.... 0x....      BL       HAL_GetTick
   \   00000158   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_13: (+1)
   \   0000015A   0x6820             LDR      R0,[R4, #+0]
   \   0000015C   0x6980             LDR      R0,[R0, #+24]
   \   0000015E   0x0680             LSLS     R0,R0,#+26
   \   00000160   0xD423             BMI.N    ??I2C_DMAMemTransmitCplt_14
   \   00000162   0x2119             MOVS     R1,#+25
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   0000016A   0xB970             CBNZ.N   R0,??I2C_DMAMemTransmitCplt_15
   \   0000016C   0x.... 0x....      BL       HAL_GetTick
   \   00000170   0x1B40             SUBS     R0,R0,R5
   \   00000172   0x281A             CMP      R0,#+26
   \   00000174   0xD3F1             BCC.N    ??I2C_DMAMemTransmitCplt_13
   \   00000176   0x6BA0             LDR      R0,[R4, #+56]
   \   00000178   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000017C   0x63A0             STR      R0,[R4, #+56]
   \   0000017E   0x2001             MOVS     R0,#+1
   \   00000180   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0xF884 0x0034      STRB     R0,[R4, #+52]
   3564                  {
   3565                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMemTransmitCplt_15: (+1)
   \   0000018A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000018C   0x2804             CMP      R0,#+4
   \   0000018E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000190   0xBF0C             ITE      EQ 
   \   00000192   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000196   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3566                    {
   3567                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3568                    }
   3569                    else
   3570                    {
   3571                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000019A   0xE005             B.N      ??I2C_DMAMemTransmitCplt_16
   3572                    }
   3573                  }
   3574                
   3575                  /* Clear STOP Flag */
   3576                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3577                      
   3578                  /* Clear Configuration Register 2 */
   3579                  I2C_RESET_CR2(hi2c);
   3580          
   3581                  hi2c->XferCount = 0;
   3582                
   3583                  hi2c->State = HAL_I2C_STATE_READY;
   3584                  HAL_I2C_ErrorCallback(hi2c);
   3585                }
   3586                else
   3587                {
   3588                  /* Enable DMA Request */
   3589                  hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
   \                     ??I2C_DMAMemTransmitCplt_11: (+1)
   \   0000019C   0x6801             LDR      R1,[R0, #+0]
   \   0000019E   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   000001A2   0x6001             STR      R1,[R0, #+0]
   3590                }
   3591              }
   3592            }
   3593            else
   3594            {
   3595              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3596              /* Wait until STOPF flag is reset */ 
   3597              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   3598              {
   3599                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3600                {
   3601                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3602                }
   3603                else
   3604                {
   3605                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3606                }
   3607              }
   3608            
   3609              /* Clear STOP Flag */
   3610              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3611            	
   3612              /* Clear Configuration Register 2 */
   3613              I2C_RESET_CR2(hi2c);
   3614          
   3615              /* Disable DMA Request */
   3616              hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN; 
   3617            
   3618              hi2c->XferCount = 0;
   3619            
   3620              hi2c->State = HAL_I2C_STATE_READY;
   3621          
   3622              /* Check if Errors has been detected during transfer */
   3623              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   3624              {
   3625                HAL_I2C_ErrorCallback(hi2c);
   3626              }
   3627              else
   3628              {
   3629                HAL_I2C_MemTxCpltCallback(hi2c);
   3630              }
   3631            }
   3632          }
   \   000001A4   0xB001             ADD      SP,SP,#+4
   \   000001A6   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMemTransmitCplt_16: (+1)
   \   000001A8   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMemTransmitCplt_14: (+1)
   \   000001AA   0x6821             LDR      R1,[R4, #+0]
   \   000001AC   0x2020             MOVS     R0,#+32
   \   000001AE   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   000001B0   0x61C8             STR      R0,[R1, #+28]
   \   000001B2   0x6820             LDR      R0,[R4, #+0]
   \   000001B4   0x6841             LDR      R1,[R0, #+4]
   \   000001B6   0x4011             ANDS     R1,R2,R1
   \   000001B8   0x6041             STR      R1,[R0, #+4]
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0x8560             STRH     R0,[R4, #+42]
   \   000001BE   0x2001             MOVS     R0,#+1
   \   000001C0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001C4   0x4620             MOV      R0,R4
   \   000001C6   0xE039             B.N      ??I2C_DMAMemTransmitCplt_7
   \                     ??I2C_DMAMemTransmitCplt_0: (+1)
   \   000001C8   0x.... 0x....      BL       HAL_GetTick
   \   000001CC   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemTransmitCplt_17: (+1)
   \   000001CE   0x6820             LDR      R0,[R4, #+0]
   \   000001D0   0x6980             LDR      R0,[R0, #+24]
   \   000001D2   0x0680             LSLS     R0,R0,#+26
   \   000001D4   0xD41C             BMI.N    ??I2C_DMAMemTransmitCplt_18
   \   000001D6   0x2119             MOVS     R1,#+25
   \   000001D8   0x4620             MOV      R0,R4
   \   000001DA   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001DE   0xB970             CBNZ.N   R0,??I2C_DMAMemTransmitCplt_19
   \   000001E0   0x.... 0x....      BL       HAL_GetTick
   \   000001E4   0x1B40             SUBS     R0,R0,R5
   \   000001E6   0x281A             CMP      R0,#+26
   \   000001E8   0xD3F1             BCC.N    ??I2C_DMAMemTransmitCplt_17
   \   000001EA   0x6BA0             LDR      R0,[R4, #+56]
   \   000001EC   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001F0   0x63A0             STR      R0,[R4, #+56]
   \   000001F2   0x2001             MOVS     R0,#+1
   \   000001F4   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??I2C_DMAMemTransmitCplt_19: (+1)
   \   000001FE   0x6BA0             LDR      R0,[R4, #+56]
   \   00000200   0x2804             CMP      R0,#+4
   \   00000202   0x6BA0             LDR      R0,[R4, #+56]
   \   00000204   0xBF0C             ITE      EQ 
   \   00000206   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000020A   0xF040 0x0020      ORRNE    R0,R0,#0x20
   \   0000020E   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMemTransmitCplt_18: (+1)
   \   00000210   0x6821             LDR      R1,[R4, #+0]
   \   00000212   0x2020             MOVS     R0,#+32
   \   00000214   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   00000216   0x61C8             STR      R0,[R1, #+28]
   \   00000218   0x6820             LDR      R0,[R4, #+0]
   \   0000021A   0x6841             LDR      R1,[R0, #+4]
   \   0000021C   0x4011             ANDS     R1,R2,R1
   \   0000021E   0x6041             STR      R1,[R0, #+4]
   \   00000220   0x6820             LDR      R0,[R4, #+0]
   \   00000222   0x6801             LDR      R1,[R0, #+0]
   \   00000224   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000228   0x6001             STR      R1,[R0, #+0]
   \   0000022A   0x2000             MOVS     R0,#+0
   \   0000022C   0x8560             STRH     R0,[R4, #+42]
   \   0000022E   0x2001             MOVS     R0,#+1
   \   00000230   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000234   0x6BA0             LDR      R0,[R4, #+56]
   \   00000236   0x2800             CMP      R0,#+0
   \   00000238   0x4620             MOV      R0,R4
   \   0000023A   0xD003             BEQ.N    ??I2C_DMAMemTransmitCplt_20
   \                     ??I2C_DMAMemTransmitCplt_7: (+1)
   \   0000023C   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000240   0xB001             ADD      SP,SP,#+4
   \   00000242   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMemTransmitCplt_20: (+1)
   \   00000244   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \   00000248   0xB001             ADD      SP,SP,#+4
   \   0000024A   0xBD30             POP      {R4,R5,PC}       ;; return
   3633          
   3634          /**
   3635            * @brief  DMA I2C Memory Read process complete callback
   3636            * @param  hdma: DMA handle
   3637            * @retval None
   3638            */

   \                                 In section .text, align 2, keep-with-next
   3639          static void I2C_DMAMemReceiveCplt(DMA_HandleTypeDef *hdma)   
   3640          {  
   \                     I2C_DMAMemReceiveCplt: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3641            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   \   00000004   0x6B84             LDR      R4,[R0, #+56]
   3642            uint16_t DevAddress;
   3643            
   3644            /* Check if last DMA request was done with RELOAD */
   3645            /* Set NBYTES to write and reload if size > 255 */
   3646            if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   00000006   0x8D20             LDRH     R0,[R4, #+40]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xF040 0x80D9      BNE.W    ??I2C_DMAMemReceiveCplt_0
   \   0000000E   0x8D61             LDRH     R1,[R4, #+42]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xF080 0x80D5      BCS.W    ??I2C_DMAMemReceiveCplt_0
   3647            {
   3648              /* Wait until TCR flag is set */
   3649              if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, I2C_TIMEOUT_TCR) != HAL_OK)      
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_1: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD40E             BMI.N    ??I2C_DMAMemReceiveCplt_2
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x1B40             SUBS     R0,R0,R5
   \   0000002A   0x281A             CMP      R0,#+26
   \   0000002C   0xD3F6             BCC.N    ??I2C_DMAMemReceiveCplt_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF884 0x0034      STRB     R0,[R4, #+52]
   3650              {
   3651                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   0000003A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000003C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000040   0x63A0             STR      R0,[R4, #+56]
   3652              }
   3653          
   3654              /* Disable DMA Request */
   3655              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   \                     ??I2C_DMAMemReceiveCplt_2: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   3656          
   3657              /* Check if Errors has been detected during transfer */
   3658              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \   0000004C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000004E   0xB390             CBZ.N    R0,??I2C_DMAMemReceiveCplt_3
   3659              {
   3660                /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3661                /* Wait until STOPF flag is reset */ 
   3662                if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_4: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6980             LDR      R0,[R0, #+24]
   \   0000005A   0x0680             LSLS     R0,R0,#+26
   \   0000005C   0xD41C             BMI.N    ??I2C_DMAMemReceiveCplt_5
   \   0000005E   0x2119             MOVS     R1,#+25
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000066   0xB970             CBNZ.N   R0,??I2C_DMAMemReceiveCplt_6
   \   00000068   0x.... 0x....      BL       HAL_GetTick
   \   0000006C   0x1B40             SUBS     R0,R0,R5
   \   0000006E   0x281A             CMP      R0,#+26
   \   00000070   0xD3F1             BCC.N    ??I2C_DMAMemReceiveCplt_4
   \   00000072   0x6BA0             LDR      R0,[R4, #+56]
   \   00000074   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   3663                {
   3664                  if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMemReceiveCplt_6: (+1)
   \   00000086   0x6BA0             LDR      R0,[R4, #+56]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000092   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3665                  {
   3666                    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3667                  }
   3668                  else
   3669                  {
   3670                    hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000096   0x63A0             STR      R0,[R4, #+56]
   3671                  }
   3672                }
   3673              
   3674                /* Clear STOP Flag */
   3675                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemReceiveCplt_5: (+1)
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x2020             MOVS     R0,#+32
   3676                    
   3677                /* Clear Configuration Register 2 */
   3678                I2C_RESET_CR2(hi2c);
   \   0000009C   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   0000009E   0x61C8             STR      R0,[R1, #+28]
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6841             LDR      R1,[R0, #+4]
   \   000000A4   0x4011             ANDS     R1,R2,R1
   \   000000A6   0x6041             STR      R1,[R0, #+4]
   3679              
   3680                hi2c->XferCount = 0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x8560             STRH     R0,[R4, #+42]
   3681              
   3682                hi2c->State = HAL_I2C_STATE_READY;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xF884 0x0035      STRB     R0,[R4, #+53]
   3683                HAL_I2C_ErrorCallback(hi2c);
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0xE0BE             B.N      ??I2C_DMAMemReceiveCplt_7
   3684              }
   3685              else
   3686              {
   3687                hi2c->pBuffPtr += hi2c->XferSize;
   \                     ??I2C_DMAMemReceiveCplt_3: (+1)
   \   000000B6   0x8D20             LDRH     R0,[R4, #+40]
   \   000000B8   0x6A61             LDR      R1,[R4, #+36]
   \   000000BA   0x1842             ADDS     R2,R0,R1
   \   000000BC   0x6262             STR      R2,[R4, #+36]
   3688                hi2c->XferCount -= hi2c->XferSize;
   \   000000BE   0x8D61             LDRH     R1,[R4, #+42]
   \   000000C0   0x1A08             SUBS     R0,R1,R0
   \   000000C2   0x8560             STRH     R0,[R4, #+42]
   3689                if(hi2c->XferCount > 255)
   \   000000C4   0x8D60             LDRH     R0,[R4, #+42]
   \   000000C6   0x28FF             CMP      R0,#+255
   \   000000C8   0xBFCC             ITE      GT 
   \   000000CA   0x20FF             MOVGT    R0,#+255
   \   000000CC   0x8D60             LDRHLE   R0,[R4, #+42]
   3690                {
   3691                  hi2c->XferSize = 255;
   3692                }
   3693                else
   3694                {
   3695                  hi2c->XferSize = hi2c->XferCount;
   \   000000CE   0x8520             STRH     R0,[R4, #+40]
   3696                }
   3697          
   3698                DevAddress = (hi2c->Instance->CR2 & I2C_CR2_SADD);
   \   000000D0   0x6820             LDR      R0,[R4, #+0]
   \   000000D2   0x6841             LDR      R1,[R0, #+4]
   3699                        
   3700                /* Enable the DMA channel */
   3701                HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->RXDR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \   000000D4   0x8D23             LDRH     R3,[R4, #+40]
   \   000000D6   0x058D             LSLS     R5,R1,#+22
   \   000000D8   0xF100 0x0124      ADD      R1,R0,#+36
   \   000000DC   0x6B20             LDR      R0,[R4, #+48]
   \   000000DE   0x.... 0x....      BL       HAL_DMA_Start_IT
   3702                
   3703                /* Send Slave Address */
   3704                /* Set NBYTES to write and reload if size > 255 */
   3705                if( (hi2c->XferSize == 255) && (hi2c->XferSize < hi2c->XferCount) )
   \   000000E2   0x8D21             LDRH     R1,[R4, #+40]
   \   000000E4   0x29FF             CMP      R1,#+255
   \   000000E6   0xD10D             BNE.N    ??I2C_DMAMemReceiveCplt_8
   \   000000E8   0x8D60             LDRH     R0,[R4, #+42]
   \   000000EA   0x4281             CMP      R1,R0
   \   000000EC   0xD20A             BCS.N    ??I2C_DMAMemReceiveCplt_8
   3706                {
   3707                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x....             LDR.N    R3,??DataTable22  ;; 0xfc009800
   \   000000F2   0x6842             LDR      R2,[R0, #+4]
   \   000000F4   0x401A             ANDS     R2,R3,R2
   \   000000F6   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   000000FA   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   000000FE   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000102   0xE00A             B.N      ??I2C_DMAMemReceiveCplt_9
   3708                }
   3709                else
   3710                {
   3711                  I2C_TransferConfig(hi2c,DevAddress,hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
   \                     ??I2C_DMAMemReceiveCplt_8: (+1)
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0x....             LDR.N    R3,??DataTable22  ;; 0xfc009800
   \   00000108   0xB2C9             UXTB     R1,R1
   \   0000010A   0x6842             LDR      R2,[R0, #+4]
   \   0000010C   0x401A             ANDS     R2,R3,R2
   \   0000010E   0xEA52 0x5295      ORRS     R2,R2,R5, LSR #+22
   \   00000112   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000116   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \                     ??I2C_DMAMemReceiveCplt_9: (+1)
   \   0000011A   0x6041             STR      R1,[R0, #+4]
   3712                }  
   3713          
   3714                /* Wait until RXNE flag is set */
   3715                if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, I2C_TIMEOUT_RXNE) != HAL_OK)      
   \   0000011C   0x.... 0x....      BL       HAL_GetTick
   \   00000120   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_10: (+1)
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6980             LDR      R0,[R0, #+24]
   \   00000126   0x0740             LSLS     R0,R0,#+29
   \   00000128   0xD40E             BMI.N    ??I2C_DMAMemReceiveCplt_11
   \   0000012A   0x.... 0x....      BL       HAL_GetTick
   \   0000012E   0x1B40             SUBS     R0,R0,R5
   \   00000130   0x281A             CMP      R0,#+26
   \   00000132   0xD3F6             BCC.N    ??I2C_DMAMemReceiveCplt_10
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xF884 0x0034      STRB     R0,[R4, #+52]
   3716                {
   3717                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000140   0x6BA0             LDR      R0,[R4, #+56]
   \   00000142   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000146   0x63A0             STR      R0,[R4, #+56]
   3718                }
   3719                
   3720                /* Check if Errors has been detected during transfer */
   3721                if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??I2C_DMAMemReceiveCplt_11: (+1)
   \   00000148   0x6BA0             LDR      R0,[R4, #+56]
   \   0000014A   0xB390             CBZ.N    R0,??I2C_DMAMemReceiveCplt_12
   3722                {
   3723                  /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3724                  /* Wait until STOPF flag is reset */ 
   3725                  if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   \   0000014C   0x.... 0x....      BL       HAL_GetTick
   \   00000150   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_13: (+1)
   \   00000152   0x6820             LDR      R0,[R4, #+0]
   \   00000154   0x6980             LDR      R0,[R0, #+24]
   \   00000156   0x0680             LSLS     R0,R0,#+26
   \   00000158   0xD41C             BMI.N    ??I2C_DMAMemReceiveCplt_14
   \   0000015A   0x2119             MOVS     R1,#+25
   \   0000015C   0x4620             MOV      R0,R4
   \   0000015E   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   00000162   0xB970             CBNZ.N   R0,??I2C_DMAMemReceiveCplt_15
   \   00000164   0x.... 0x....      BL       HAL_GetTick
   \   00000168   0x1B40             SUBS     R0,R0,R5
   \   0000016A   0x281A             CMP      R0,#+26
   \   0000016C   0xD3F1             BCC.N    ??I2C_DMAMemReceiveCplt_13
   \   0000016E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000170   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000174   0x63A0             STR      R0,[R4, #+56]
   \   00000176   0x2001             MOVS     R0,#+1
   \   00000178   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0xF884 0x0034      STRB     R0,[R4, #+52]
   3726                  {
   3727                    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \                     ??I2C_DMAMemReceiveCplt_15: (+1)
   \   00000182   0x6BA0             LDR      R0,[R4, #+56]
   \   00000184   0x2804             CMP      R0,#+4
   \   00000186   0x6BA0             LDR      R0,[R4, #+56]
   \   00000188   0xBF0C             ITE      EQ 
   \   0000018A   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   0000018E   0xF040 0x0020      ORRNE    R0,R0,#0x20
   3728                    {
   3729                      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3730                    }
   3731                    else
   3732                    {
   3733                      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \   00000192   0x63A0             STR      R0,[R4, #+56]
   3734                    }
   3735                  }
   3736                
   3737                  /* Clear STOP Flag */
   3738                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \                     ??I2C_DMAMemReceiveCplt_14: (+1)
   \   00000194   0x6821             LDR      R1,[R4, #+0]
   \   00000196   0x2020             MOVS     R0,#+32
   3739                      
   3740                  /* Clear Configuration Register 2 */
   3741                  I2C_RESET_CR2(hi2c);
   \   00000198   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   0000019A   0x61C8             STR      R0,[R1, #+28]
   \   0000019C   0x6820             LDR      R0,[R4, #+0]
   \   0000019E   0x6841             LDR      R1,[R0, #+4]
   \   000001A0   0x4011             ANDS     R1,R2,R1
   \   000001A2   0x6041             STR      R1,[R0, #+4]
   3742                
   3743                  hi2c->XferCount = 0;
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0x8560             STRH     R0,[R4, #+42]
   3744                
   3745                  hi2c->State = HAL_I2C_STATE_READY;
   \   000001A8   0x2001             MOVS     R0,#+1
   \   000001AA   0xF884 0x0035      STRB     R0,[R4, #+53]
   3746                  HAL_I2C_ErrorCallback(hi2c);
   \   000001AE   0x4620             MOV      R0,R4
   \   000001B0   0xE040             B.N      ??I2C_DMAMemReceiveCplt_7
   3747                }
   3748                else
   3749                {
   3750                  /* Enable DMA Request */
   3751                  hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
   \                     ??I2C_DMAMemReceiveCplt_12: (+1)
   \   000001B2   0x6820             LDR      R0,[R4, #+0]
   \   000001B4   0x6801             LDR      R1,[R0, #+0]
   \   000001B6   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000001BA   0x6001             STR      R1,[R0, #+0]
   3752                }
   3753              }
   3754            }
   3755            else
   3756            {
   3757              /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
   3758              /* Wait until STOPF flag is reset */ 
   3759              if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, I2C_TIMEOUT_STOPF) != HAL_OK)
   3760              {
   3761                if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   3762                {
   3763                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   3764                }
   3765                else
   3766                {
   3767                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3768                }
   3769              }
   3770            
   3771              /* Clear STOP Flag */
   3772              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3773            	
   3774              /* Clear Configuration Register 2 */
   3775              I2C_RESET_CR2(hi2c);
   3776            
   3777              /* Disable DMA Request */
   3778              hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN; 
   3779            
   3780              hi2c->XferCount = 0;
   3781            
   3782              hi2c->State = HAL_I2C_STATE_READY;
   3783          
   3784              /* Check if Errors has been detected during transfer */
   3785              if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   3786              {
   3787                HAL_I2C_ErrorCallback(hi2c);
   3788              }
   3789              else
   3790              {
   3791                HAL_I2C_MemRxCpltCallback(hi2c);
   3792              }
   3793            }
   3794          }
   \   000001BC   0xB001             ADD      SP,SP,#+4
   \   000001BE   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMemReceiveCplt_0: (+1)
   \   000001C0   0x.... 0x....      BL       HAL_GetTick
   \   000001C4   0x4605             MOV      R5,R0
   \                     ??I2C_DMAMemReceiveCplt_16: (+1)
   \   000001C6   0x6820             LDR      R0,[R4, #+0]
   \   000001C8   0x6980             LDR      R0,[R0, #+24]
   \   000001CA   0x0680             LSLS     R0,R0,#+26
   \   000001CC   0xD41C             BMI.N    ??I2C_DMAMemReceiveCplt_17
   \   000001CE   0x2119             MOVS     R1,#+25
   \   000001D0   0x4620             MOV      R0,R4
   \   000001D2   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \   000001D6   0xB970             CBNZ.N   R0,??I2C_DMAMemReceiveCplt_18
   \   000001D8   0x.... 0x....      BL       HAL_GetTick
   \   000001DC   0x1B40             SUBS     R0,R0,R5
   \   000001DE   0x281A             CMP      R0,#+26
   \   000001E0   0xD3F1             BCC.N    ??I2C_DMAMemReceiveCplt_16
   \   000001E2   0x6BA0             LDR      R0,[R4, #+56]
   \   000001E4   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000001E8   0x63A0             STR      R0,[R4, #+56]
   \   000001EA   0x2001             MOVS     R0,#+1
   \   000001EC   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0xF884 0x0034      STRB     R0,[R4, #+52]
   \                     ??I2C_DMAMemReceiveCplt_18: (+1)
   \   000001F6   0x6BA0             LDR      R0,[R4, #+56]
   \   000001F8   0x2804             CMP      R0,#+4
   \   000001FA   0x6BA0             LDR      R0,[R4, #+56]
   \   000001FC   0xBF0C             ITE      EQ 
   \   000001FE   0xF040 0x0004      ORREQ    R0,R0,#0x4
   \   00000202   0xF040 0x0020      ORRNE    R0,R0,#0x20
   \   00000206   0x63A0             STR      R0,[R4, #+56]
   \                     ??I2C_DMAMemReceiveCplt_17: (+1)
   \   00000208   0x6821             LDR      R1,[R4, #+0]
   \   0000020A   0x2020             MOVS     R0,#+32
   \   0000020C   0x....             LDR.N    R2,??DataTable21  ;; 0xfe00e800
   \   0000020E   0x61C8             STR      R0,[R1, #+28]
   \   00000210   0x6820             LDR      R0,[R4, #+0]
   \   00000212   0x6841             LDR      R1,[R0, #+4]
   \   00000214   0x4011             ANDS     R1,R2,R1
   \   00000216   0x6041             STR      R1,[R0, #+4]
   \   00000218   0x6820             LDR      R0,[R4, #+0]
   \   0000021A   0x6801             LDR      R1,[R0, #+0]
   \   0000021C   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000220   0x6001             STR      R1,[R0, #+0]
   \   00000222   0x2000             MOVS     R0,#+0
   \   00000224   0x8560             STRH     R0,[R4, #+42]
   \   00000226   0x2001             MOVS     R0,#+1
   \   00000228   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   0000022C   0x6BA0             LDR      R0,[R4, #+56]
   \   0000022E   0x2800             CMP      R0,#+0
   \   00000230   0x4620             MOV      R0,R4
   \   00000232   0xD003             BEQ.N    ??I2C_DMAMemReceiveCplt_19
   \                     ??I2C_DMAMemReceiveCplt_7: (+1)
   \   00000234   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \   00000238   0xB001             ADD      SP,SP,#+4
   \   0000023A   0xBD30             POP      {R4,R5,PC}
   \                     ??I2C_DMAMemReceiveCplt_19: (+1)
   \   0000023C   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \   00000240   0xB001             ADD      SP,SP,#+4
   \   00000242   0xBD30             POP      {R4,R5,PC}       ;; return
   3795          
   3796          /**
   3797            * @brief  DMA I2C communication error callback. 
   3798            * @param hdma : DMA handle
   3799            * @retval None
   3800            */

   \                                 In section .text, align 2, keep-with-next
   3801          static void I2C_DMAError(DMA_HandleTypeDef *hdma)   
   3802          {
   \                     I2C_DMAError: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   3803            I2C_HandleTypeDef* hi2c = ( I2C_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   3804            
   3805            /* Disable Acknowledge */
   3806            hi2c->Instance->CR2 |= I2C_CR2_NACK;
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   0000000E   0x604A             STR      R2,[R1, #+4]
   3807            
   3808            hi2c->XferCount = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8541             STRH     R1,[R0, #+42]
   3809            
   3810            hi2c->State = HAL_I2C_STATE_READY;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF880 0x1035      STRB     R1,[R0, #+53]
   3811            
   3812            hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \   0000001A   0x6B81             LDR      R1,[R0, #+56]
   \   0000001C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000020   0x6381             STR      R1,[R0, #+56]
   3813            
   3814            HAL_I2C_ErrorCallback(hi2c);
   \   00000022   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   3815          }
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0xBD00             POP      {PC}             ;; return
   3816          
   3817          /**
   3818            * @brief  This function handles I2C Communication Timeout.
   3819            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3820            *                the configuration information for the specified I2C.
   3821            * @param  Flag: specifies the I2C flag to check.
   3822            * @param  Status: The new Flag status (SET or RESET).
   3823            * @param  Timeout: Timeout duration
   3824            * @retval HAL status
   3825            */
   3826          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout)  
   3827          {  
   3828            uint32_t tickstart = HAL_GetTick();
   3829               
   3830            /* Wait until flag is set */
   3831            if(Status == RESET)
   3832            {    
   3833              while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   3834              {
   3835                /* Check for the Timeout */
   3836                if(Timeout != HAL_MAX_DELAY)
   3837                {
   3838                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   3839                  {
   3840                    hi2c->State= HAL_I2C_STATE_READY;
   3841                    /* Process Unlocked */
   3842                    __HAL_UNLOCK(hi2c);
   3843                    return HAL_TIMEOUT;
   3844                  }
   3845                }
   3846              }
   3847            }
   3848            else
   3849            {
   3850              while(__HAL_I2C_GET_FLAG(hi2c, Flag) != RESET)
   3851              {
   3852                /* Check for the Timeout */
   3853                if(Timeout != HAL_MAX_DELAY)
   3854                {
   3855                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   3856                  {
   3857                    hi2c->State= HAL_I2C_STATE_READY;
   3858                    /* Process Unlocked */
   3859                    __HAL_UNLOCK(hi2c);
   3860                    return HAL_TIMEOUT;
   3861                  }
   3862                }
   3863              }
   3864            }
   3865            return HAL_OK;
   3866          }
   3867          
   3868          /**
   3869            * @brief  This function handles I2C Communication Timeout for specific usage of TXIS flag.
   3870            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3871            *                the configuration information for the specified I2C.
   3872            * @param  Timeout: Timeout duration
   3873            * @retval HAL status
   3874            */
   3875          static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)  
   3876          {  
   3877            uint32_t tickstart = HAL_GetTick();
   3878            
   3879            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
   3880            {
   3881              /* Check if a NACK is detected */
   3882              if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
   3883              {
   3884                return HAL_ERROR;
   3885              }
   3886          		
   3887              /* Check for the Timeout */
   3888              if(Timeout != HAL_MAX_DELAY)
   3889              {
   3890                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   3891                {
   3892                  hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3893                  hi2c->State= HAL_I2C_STATE_READY;
   3894          
   3895                  /* Process Unlocked */
   3896                  __HAL_UNLOCK(hi2c);
   3897          
   3898                  return HAL_TIMEOUT;
   3899                }
   3900              }
   3901            }
   3902            return HAL_OK;      
   3903          }
   3904          
   3905          /**
   3906            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   3907            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3908            *                the configuration information for the specified I2C.
   3909            * @param  Timeout: Timeout duration
   3910            * @retval HAL status
   3911            */
   3912          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   3913          {  
   3914            uint32_t tickstart = 0x00;
   3915            tickstart = HAL_GetTick();
   3916            
   3917            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   3918            {
   3919              /* Check if a NACK is detected */
   3920              if(I2C_IsAcknowledgeFailed(hi2c, Timeout) != HAL_OK)
   3921              {
   3922                return HAL_ERROR;
   3923              }
   3924          		
   3925              /* Check for the Timeout */
   3926              if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   3927              {
   3928                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3929                hi2c->State= HAL_I2C_STATE_READY;
   3930          
   3931                /* Process Unlocked */
   3932                __HAL_UNLOCK(hi2c);
   3933          
   3934                return HAL_TIMEOUT;
   3935              }
   3936            }
   3937            return HAL_OK;
   3938          }
   3939          
   3940          /**
   3941            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   3942            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3943            *                the configuration information for the specified I2C.
   3944            * @param  Timeout: Timeout duration
   3945            * @retval HAL status
   3946            */
   3947          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   3948          {  
   3949            uint32_t tickstart = 0x00;
   3950            tickstart = HAL_GetTick();
   3951            
   3952            while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   3953            {
   3954              /* Check if a STOPF is detected */
   3955              if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   3956              {
   3957                /* Clear STOP Flag */
   3958                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   3959          
   3960                /* Clear Configuration Register 2 */
   3961                I2C_RESET_CR2(hi2c);
   3962          
   3963                hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   3964                hi2c->State= HAL_I2C_STATE_READY;
   3965          
   3966                /* Process Unlocked */
   3967                __HAL_UNLOCK(hi2c);
   3968          
   3969                return HAL_ERROR;
   3970              }
   3971          		
   3972              /* Check for the Timeout */
   3973              if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   3974              {
   3975                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   3976                hi2c->State= HAL_I2C_STATE_READY;
   3977          
   3978                /* Process Unlocked */
   3979                __HAL_UNLOCK(hi2c);
   3980          
   3981                return HAL_TIMEOUT;
   3982              }
   3983            }
   3984            return HAL_OK;
   3985          }
   3986          
   3987          /**
   3988            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   3989            * @param  hi2c : Pointer to a I2C_HandleTypeDef structure that contains
   3990            *                the configuration information for the specified I2C.
   3991            * @param  Timeout: Timeout duration
   3992            * @retval HAL status
   3993            */

   \                                 In section .text, align 2, keep-with-next
   3994          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout)
   3995          {
   \                     I2C_IsAcknowledgeFailed: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3996            uint32_t tickstart = 0x00;
   3997            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
   3998          
   3999            if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6981             LDR      R1,[R0, #+24]
   \   00000010   0x06C9             LSLS     R1,R1,#+27
   \   00000012   0xD53A             BPL.N    ??I2C_IsAcknowledgeFailed_0
   4000            {
   4001              /* Generate stop if necessary only in case of I2C peripheral in MASTER mode */
   4002              if((hi2c->State == HAL_I2C_STATE_MASTER_BUSY_TX) || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_TX)
   4003                 || (hi2c->State == HAL_I2C_STATE_MEM_BUSY_RX))
   \   00000014   0xF894 0x1035      LDRB     R1,[R4, #+53]
   \   00000018   0x2912             CMP      R1,#+18
   \   0000001A   0xBF1F             ITTTT    NE 
   \   0000001C   0xF894 0x1035      LDRBNE   R1,[R4, #+53]
   \   00000020   0x2952             CMPNE    R1,#+82
   \   00000022   0xF894 0x1035      LDRBNE   R1,[R4, #+53]
   \   00000026   0x2962             CMPNE    R1,#+98
   \   00000028   0xD106             BNE.N    ??I2C_IsAcknowledgeFailed_1
   4004              {
   4005                /* No need to generate the STOP condition if AUTOEND mode is enabled */
   4006                /* Generate the STOP condition only in case of SOFTEND mode is enabled */
   4007                if((hi2c->Instance->CR2 & I2C_AUTOEND_MODE) != I2C_AUTOEND_MODE)
   \   0000002A   0x6841             LDR      R1,[R0, #+4]
   \   0000002C   0x0189             LSLS     R1,R1,#+6
   \   0000002E   0xD403             BMI.N    ??I2C_IsAcknowledgeFailed_1
   4008                {
   4009                  /* Generate Stop */
   4010                  hi2c->Instance->CR2 |= I2C_CR2_STOP;
   \   00000030   0x6841             LDR      R1,[R0, #+4]
   \   00000032   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000036   0x6041             STR      R1,[R0, #+4]
   4011                }
   4012              }
   4013          		
   4014              /* Wait until STOP Flag is reset */
   4015              /* AutoEnd should be initiate after AF */
   4016              while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_IsAcknowledgeFailed_1: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6981             LDR      R1,[R0, #+24]
   \   0000003C   0x0689             LSLS     R1,R1,#+26
   \   0000003E   0xD410             BMI.N    ??I2C_IsAcknowledgeFailed_2
   4017              {
   4018                /* Check for the Timeout */
   4019                if(Timeout != HAL_MAX_DELAY)
   \   00000040   0xF115 0x0F01      CMN      R5,#+1
   \   00000044   0xD0F8             BEQ.N    ??I2C_IsAcknowledgeFailed_1
   4020                {
   4021                if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   00000046   0xB125             CBZ.N    R5,??I2C_IsAcknowledgeFailed_3
   \   00000048   0x.... 0x....      BL       HAL_GetTick
   \   0000004C   0x1B80             SUBS     R0,R0,R6
   \   0000004E   0x4285             CMP      R5,R0
   \   00000050   0xD2F2             BCS.N    ??I2C_IsAcknowledgeFailed_1
   4022                  {
   4023                    hi2c->State= HAL_I2C_STATE_READY;
   \                     ??I2C_IsAcknowledgeFailed_3: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF884 0x0035      STRB     R0,[R4, #+53]
   4024                    /* Process Unlocked */
   4025                    __HAL_UNLOCK(hi2c);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF884 0x0034      STRB     R0,[R4, #+52]
   4026                    return HAL_TIMEOUT;
   \   0000005E   0x2003             MOVS     R0,#+3
   \   00000060   0xBD70             POP      {R4-R6,PC}
   4027                  }
   4028                }
   4029              }
   4030          
   4031              /* Clear NACKF Flag */
   4032              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_IsAcknowledgeFailed_2: (+1)
   \   00000062   0x2110             MOVS     R1,#+16
   4033          
   4034              /* Clear STOP Flag */
   4035              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   4036          
   4037              /* Clear Configuration Register 2 */
   4038              I2C_RESET_CR2(hi2c);
   \   00000064   0x....             LDR.N    R2,??DataTable22_1  ;; 0xfe00e800
   \   00000066   0x61C1             STR      R1,[R0, #+28]
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x2020             MOVS     R0,#+32
   \   0000006C   0x61C8             STR      R0,[R1, #+28]
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6841             LDR      R1,[R0, #+4]
   \   00000072   0x4011             ANDS     R1,R2,R1
   \   00000074   0x6041             STR      R1,[R0, #+4]
   4039          
   4040              hi2c->ErrorCode = HAL_I2C_ERROR_AF;
   \   00000076   0x2004             MOVS     R0,#+4
   \   00000078   0x63A0             STR      R0,[R4, #+56]
   4041              hi2c->State= HAL_I2C_STATE_READY;
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0035      STRB     R0,[R4, #+53]
   4042          
   4043              /* Process Unlocked */
   4044              __HAL_UNLOCK(hi2c);
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0034      STRB     R0,[R4, #+52]
   4045          
   4046              return HAL_ERROR;
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xBD70             POP      {R4-R6,PC}
   4047            }
   4048            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
   4049          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0xFE00E800         DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     I2C_DMAMasterTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     I2C_DMAMasterReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     I2C_DMASlaveTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     I2C_DMASlaveReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xFE00E800         DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     I2C_DMAMemTransmitCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     I2C_DMAMemReceiveCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x02002000         DC32     0x2002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x01FF0000         DC32     0x1ff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0xFE00E800         DC32     0xfe00e800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xFC009800         DC32     0xfc009800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0xFE00E800         DC32     0xfe00e800
   4050          
   4051          /**
   4052            * @brief  Handles I2Cx communication when starting transfer or during transfer (TC or TCR flag are set).
   4053            * @param  hi2c: I2C handle.
   4054            * @param  DevAddress: specifies the slave address to be programmed.
   4055            * @param  Size: specifies the number of bytes to be programmed.
   4056            *   This parameter must be a value between 0 and 255.
   4057            * @param  Mode: new state of the I2C START condition generation.
   4058            *   This parameter can be one of the following values:
   4059            *     @arg I2C_RELOAD_MODE: Enable Reload mode .
   4060            *     @arg I2C_AUTOEND_MODE: Enable Automatic end mode.
   4061            *     @arg I2C_SOFTEND_MODE: Enable Software end mode.
   4062            * @param  Request: new state of the I2C START condition generation.
   4063            *   This parameter can be one of the following values:
   4064            *     @arg I2C_NO_STARTSTOP: Don't Generate stop and start condition.
   4065            *     @arg I2C_GENERATE_STOP: Generate stop condition (Size should be set to 0).
   4066            *     @arg I2C_GENERATE_START_READ: Generate Restart for read request.
   4067            *     @arg I2C_GENERATE_START_WRITE: Generate Restart for write request.
   4068            * @retval None
   4069            */
   4070          static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c,  uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
   4071          {
   4072            uint32_t tmpreg = 0;
   4073            
   4074            /* Check the parameters */
   4075            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
   4076            assert_param(IS_TRANSFER_MODE(Mode));
   4077            assert_param(IS_TRANSFER_REQUEST(Request));
   4078              
   4079            /* Get the CR2 register value */
   4080            tmpreg = hi2c->Instance->CR2;
   4081            
   4082            /* clear tmpreg specific bits */
   4083            tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
   4084            
   4085            /* update tmpreg */
   4086            tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
   4087                      (uint32_t)Mode | (uint32_t)Request);
   4088            
   4089            /* update CR2 register */
   4090            hi2c->Instance->CR2 = tmpreg;  
   4091          }  
   4092          
   4093          /**
   4094            * @}
   4095            */
   4096          
   4097          /**
   4098            * @}
   4099            */
   4100          
   4101          #endif /* HAL_I2C_MODULE_ENABLED */
   4102          /**
   4103            * @}
   4104            */
   4105          
   4106          /**
   4107            * @}
   4108            */
   4109          
   4110          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_I2C_DeInit
         8   -> HAL_I2C_MspDeInit
       8   HAL_I2C_ER_IRQHandler
         8   -> HAL_I2C_ErrorCallback
       8   HAL_I2C_EV_IRQHandler
         0   -> I2C_MasterReceive_ISR
         8   -> I2C_MasterTransmit_ISR
         8   -> I2C_SlaveReceive_ISR
         8   -> I2C_SlaveTransmit_ISR
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetState
       8   HAL_I2C_Init
         8   -> HAL_I2C_MspInit
      32   HAL_I2C_IsDeviceReady
        32   -> HAL_GetTick
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
      40   HAL_I2C_Master_Receive
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
      16   HAL_I2C_Master_Receive_DMA
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
       8   HAL_I2C_Master_Receive_IT
      40   HAL_I2C_Master_Transmit
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
      16   HAL_I2C_Master_Transmit_DMA
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
       8   HAL_I2C_Master_Transmit_IT
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      40   HAL_I2C_Mem_Read
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
      32   HAL_I2C_Mem_Read_DMA
        32   -> HAL_DMA_Start_IT
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
      32   HAL_I2C_Mem_Read_IT
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
      40   HAL_I2C_Mem_Write
        40   -> HAL_GetTick
        40   -> I2C_IsAcknowledgeFailed
      32   HAL_I2C_Mem_Write_DMA
        32   -> HAL_DMA_Start_IT
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
      32   HAL_I2C_Mem_Write_IT
        32   -> HAL_GetTick
        32   -> I2C_IsAcknowledgeFailed
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      24   HAL_I2C_Slave_Receive
        24   -> HAL_GetTick
        24   -> I2C_IsAcknowledgeFailed
      16   HAL_I2C_Slave_Receive_DMA
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
       0   HAL_I2C_Slave_Receive_IT
      24   HAL_I2C_Slave_Transmit
        24   -> HAL_GetTick
        24   -> I2C_IsAcknowledgeFailed
      16   HAL_I2C_Slave_Transmit_DMA
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
       0   HAL_I2C_Slave_Transmit_IT
       8   I2C_DMAError
         8   -> HAL_I2C_ErrorCallback
      16   I2C_DMAMasterReceiveCplt
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterRxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMAMasterTransmitCplt
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterTxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMAMemReceiveCplt
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MemRxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMAMemTransmitCplt
        16   -> HAL_DMA_Start_IT
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MemTxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMASlaveReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveRxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_DMASlaveTransmitCplt
        16   -> HAL_GetTick
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_SlaveTxCpltCallback
        16   -> I2C_IsAcknowledgeFailed
      16   I2C_IsAcknowledgeFailed
        16   -> HAL_GetTick
      16   I2C_MasterReceive_ISR
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterRxCpltCallback
        16   -> HAL_I2C_MemRxCpltCallback
      16   I2C_MasterTransmit_ISR
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterTxCpltCallback
        16   -> HAL_I2C_MemTxCpltCallback
       8   I2C_SlaveReceive_ISR
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_SlaveRxCpltCallback
       8   I2C_SlaveTransmit_ISR
         8   -> HAL_I2C_ErrorCallback
         8   -> HAL_I2C_SlaveTxCpltCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
      46  HAL_I2C_DeInit
     106  HAL_I2C_ER_IRQHandler
     254  HAL_I2C_EV_IRQHandler
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetState
     162  HAL_I2C_Init
     342  HAL_I2C_IsDeviceReady
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
     436  HAL_I2C_Master_Receive
     232  HAL_I2C_Master_Receive_DMA
     160  HAL_I2C_Master_Receive_IT
     466  HAL_I2C_Master_Transmit
     270  HAL_I2C_Master_Transmit_DMA
     160  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     700  HAL_I2C_Mem_Read
     456  HAL_I2C_Mem_Read_DMA
     398  HAL_I2C_Mem_Read_IT
     694  HAL_I2C_Mem_Write
     510  HAL_I2C_Mem_Write_DMA
     402  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     424  HAL_I2C_Slave_Receive
     196  HAL_I2C_Slave_Receive_DMA
      88  HAL_I2C_Slave_Receive_IT
     536  HAL_I2C_Slave_Transmit
     230  HAL_I2C_Slave_Transmit_DMA
      88  HAL_I2C_Slave_Transmit_IT
      42  I2C_DMAError
     590  I2C_DMAMasterReceiveCplt
     596  I2C_DMAMasterTransmitCplt
     580  I2C_DMAMemReceiveCplt
     588  I2C_DMAMemTransmitCplt
     182  I2C_DMASlaveReceiveCplt
     170  I2C_DMASlaveTransmitCplt
     142  I2C_IsAcknowledgeFailed
     290  I2C_MasterReceive_ISR
     290  I2C_MasterTransmit_ISR
     172  I2C_SlaveReceive_ISR
     192  I2C_SlaveTransmit_ISR

 
 11 296 bytes in section .text
 
 11 296 bytes of CODE memory

Errors: none
Warnings: none
