###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       27/Apr/2016  12:04:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file provides a set of firmware functions to manage LEDs, 
      8            *          push-buttons and COM ports available on STM32746G-Discovery
      9            *          board(MB1191) from STMicroelectronics.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     14            *
     15            * Redistribution and use in source and binary forms, with or without modification,
     16            * are permitted provided that the following conditions are met:
     17            *   1. Redistributions of source code must retain the above copyright notice,
     18            *      this list of conditions and the following disclaimer.
     19            *   2. Redistributions in binary form must reproduce the above copyright notice,
     20            *      this list of conditions and the following disclaimer in the documentation
     21            *      and/or other materials provided with the distribution.
     22            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     23            *      may be used to endorse or promote products derived from this software
     24            *      without specific prior written permission.
     25            *
     26            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     27            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     28            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     29            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     30            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     31            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     32            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     33            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     34            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     35            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     36            *
     37            ******************************************************************************
     38            */ 
     39          
     40          /* Includes ------------------------------------------------------------------*/
     41          #include "stm32746g_discovery.h"
     42          
     43          /** @addtogroup BSP
     44            * @{
     45            */ 
     46          
     47          /** @addtogroup STM32746G_DISCOVERY
     48            * @{
     49            */
     50          
     51          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL STM32746G_DISCOVERY_LOW_LEVEL
     52            * @{
     53            */
     54          
     55          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_TypesDefinitions STM32746G_DISCOVERY_LOW_LEVEL Private Types Definitions
     56            * @{
     57            */
     58          /**
     59            * @}
     60            */
     61          
     62          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Defines STM32746G_DISCOVERY_LOW_LEVEL Private Defines
     63            * @{
     64            */
     65          /**
     66           * @brief STM32746G DISCOVERY BSP Driver version number V1.0.0
     67             */
     68          #define __STM32746G_DISCO_BSP_VERSION_MAIN   (0x01) /*!< [31:24] main version */
     69          #define __STM32746G_DISCO_BSP_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version */
     70          #define __STM32746G_DISCO_BSP_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
     71          #define __STM32746G_DISCO_BSP_VERSION_RC     (0x00) /*!< [7:0]  release candidate */
     72          #define __STM32746G_DISCO_BSP_VERSION         ((__STM32746G_DISCO_BSP_VERSION_MAIN << 24)\
     73                                                       |(__STM32746G_DISCO_BSP_VERSION_SUB1 << 16)\
     74                                                       |(__STM32746G_DISCO_BSP_VERSION_SUB2 << 8 )\
     75                                                       |(__STM32746G_DISCO_BSP_VERSION_RC))
     76          /**
     77            * @}
     78            */
     79          
     80          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Macros STM32746G_DISCOVERY_LOW_LEVEL Private Macros
     81            * @{
     82            */
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Variables STM32746G_DISCOVERY_LOW_LEVEL Private Variables
     88            * @{
     89            */
     90          

   \                                 In section .text, align 4, keep-with-next
     91          const uint32_t GPIO_PIN[LEDn] = {LED1_PIN, LED2_PIN};
   \                     GPIO_PIN:
   \   00000000   0x00000400         DC32 1024, 2048
   \              0x00000800   
     92          

   \                                 In section .data, align 4
     93          GPIO_TypeDef* BUTTON_PORT[BUTTONn] = {WAKEUP_BUTTON_GPIO_PORT,
   \                     BUTTON_PORT:
   \   00000000   0x40022000         DC32 40022000H, 40022000H, 40022000H
   \              0x40022000   
   \              0x40022000   
     94                                                TAMPER_BUTTON_GPIO_PORT,
     95                                                KEY_BUTTON_GPIO_PORT};
     96          

   \                                 In section .text, align 4, keep-with-next
     97          const uint16_t BUTTON_PIN[BUTTONn] = {WAKEUP_BUTTON_PIN,
   \                     BUTTON_PIN:
   \   00000000   0x0800 0x0800      DC16 2048, 2048, 2048
   \              0x0800       
   \   00000006   0x00 0x00          DC8 0, 0
     98                                                TAMPER_BUTTON_PIN,
     99                                                KEY_BUTTON_PIN};
    100          

   \                                 In section .text, align 4, keep-with-next
    101          const uint16_t BUTTON_IRQn[BUTTONn] = {WAKEUP_BUTTON_EXTI_IRQn,
   \                     BUTTON_IRQn:
   \   00000000   0x0028 0x0028      DC16 40, 40, 40
   \              0x0028       
   \   00000006   0x00 0x00          DC8 0, 0
    102                                                 TAMPER_BUTTON_EXTI_IRQn,
    103                                                 KEY_BUTTON_EXTI_IRQn};
    104          

   \                                 In section .data, align 4
    105          USART_TypeDef* COM_USART[COMn] = {DISCOVERY_COM1};
   \                     COM_USART:
   \   00000000   0x40011000         DC32 40011000H
    106          
    107          GPIO_TypeDef* COM_TX_PORT[COMn] = {DISCOVERY_COM1_TX_GPIO_PORT};
   \                     COM_TX_PORT:
   \   00000004   0x40020000         DC32 40020000H
    108          
    109          GPIO_TypeDef* COM_RX_PORT[COMn] = {DISCOVERY_COM1_RX_GPIO_PORT};
   \                     COM_RX_PORT:
   \   00000008   0x40020400         DC32 40020400H
    110          

   \                                 In section .text, align 4, keep-with-next
    111          const uint16_t COM_TX_PIN[COMn] = {DISCOVERY_COM1_TX_PIN};
   \                     COM_TX_PIN:
   \   00000000   0x0200             DC16 512
    112          

   \                                 In section .text, align 4, keep-with-next
    113          const uint16_t COM_RX_PIN[COMn] = {DISCOVERY_COM1_RX_PIN};
   \                     COM_RX_PIN:
   \   00000000   0x0080             DC16 128
    114          

   \                                 In section .text, align 4, keep-with-next
    115          const uint16_t COM_TX_AF[COMn] = {DISCOVERY_COM1_TX_AF};
   \                     COM_TX_AF:
   \   00000000   0x0007             DC16 7
    116          

   \                                 In section .text, align 4, keep-with-next
    117          const uint16_t COM_RX_AF[COMn] = {DISCOVERY_COM1_RX_AF};
   \                     COM_RX_AF:
   \   00000000   0x0007             DC16 7
    118          

   \                                 In section .bss, align 4
    119          static I2C_HandleTypeDef hI2cAudioHandler = {0};
   \                     hI2cAudioHandler:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    120          static I2C_HandleTypeDef hI2cExtHandler = {0};
   \                     hI2cExtHandler:
   \   00000000                      DS8 60
    121          
    122          /**
    123            * @}
    124            */
    125          
    126          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_FunctionPrototypes STM32746G_DISCOVERY_LOW_LEVEL Private Function Prototypes
    127            * @{
    128            */
    129          static void     I2Cx_MspInit(I2C_HandleTypeDef *i2c_handler);
    130          static void     I2Cx_Init(I2C_HandleTypeDef *i2c_handler);
    131          
    132          static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef *i2c_handler, uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length);
    133          static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef *i2c_handler, uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length);
    134          static HAL_StatusTypeDef I2Cx_IsDeviceReady(I2C_HandleTypeDef *i2c_handler, uint16_t DevAddress, uint32_t Trials);
    135          static void              I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr);
    136          
    137          /* AUDIO IO functions */
    138          void            AUDIO_IO_Init(void);
    139          void            AUDIO_IO_DeInit(void);
    140          void            AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value);
    141          uint16_t        AUDIO_IO_Read(uint8_t Addr, uint16_t Reg);
    142          void            AUDIO_IO_Delay(uint32_t Delay);
    143          
    144          /* TOUCHSCREEN IO functions */
    145          void            TS_IO_Init(void);
    146          void            TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value);
    147          uint8_t         TS_IO_Read(uint8_t Addr, uint8_t Reg);
    148          void            TS_IO_Delay(uint32_t Delay);
    149          
    150          /* CAMERA IO functions */
    151          void            CAMERA_IO_Init(void);
    152          void            CAMERA_Delay(uint32_t Delay);
    153          void            CAMERA_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value);
    154          uint8_t         CAMERA_IO_Read(uint8_t Addr, uint8_t Reg);
    155          
    156          /* I2C EEPROM IO function */
    157          void                EEPROM_IO_Init(void);
    158          HAL_StatusTypeDef   EEPROM_IO_WriteData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize);
    159          HAL_StatusTypeDef   EEPROM_IO_ReadData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize);
    160          HAL_StatusTypeDef   EEPROM_IO_IsDeviceReady(uint16_t DevAddress, uint32_t Trials);
    161          /**
    162            * @}
    163            */
    164          
    165          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Exported_Functions STM32746G_DISCOVERY_LOW_LEVELSTM32746G_DISCOVERY_LOW_LEVEL Exported Functions
    166            * @{
    167            */ 
    168          
    169            /**
    170            * @brief  This method returns the STM32746G DISCOVERY BSP Driver revision
    171            * @retval version: 0xXYZR (8bits for each decimal, R for RC)
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          uint32_t BSP_GetVersion(void)
    174          {
    175            return __STM32746G_DISCO_BSP_VERSION;
   \                     BSP_GetVersion: (+1)
   \   00000000   0xF04F 0x7080      MOV      R0,#+16777216
   \   00000004   0x4770             BX       LR               ;; return
    176          }
    177          
    178          /**
    179            * @brief  Configures LED on GPIO.
    180            * @param  Led: LED to be configured. 
    181            *          This parameter can be one of the following values:
    182            *            @arg  LED1
    183            * @retval None
    184            */

   \                                 In section .text, align 2, keep-with-next
    185          void BSP_LED_Init(Led_TypeDef Led)
    186          {
   \                     BSP_LED_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    187            GPIO_InitTypeDef  gpio_init_structure;
    188            GPIO_TypeDef*     gpio_led;
    189          
    190            if (Led == LED1)
   \   00000004   0xB9E8             CBNZ.N   R0,??BSP_LED_Init_0
    191            {
    192              gpio_led = LED1_GPIO_PORT;
    193              /* Enable the GPIO_LED clock */
    194              LED1_GPIO_CLK_ENABLE();
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable31  ;; 0x40023830
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    195          
    196              /* Configure the GPIO_LED pin */
    197              gpio_init_structure.Pin = GPIO_PIN[Led];
    198              gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
    199              gpio_init_structure.Pull = GPIO_PULLUP;
    200              gpio_init_structure.Speed = GPIO_SPEED_HIGH;
    201            
    202              HAL_GPIO_Init(gpio_led, &gpio_init_structure);
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable31_1  ;; 0x40022000
   \   00000010   0x6808             LDR      R0,[R1, #+0]
   \   00000012   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000016   0x6008             STR      R0,[R1, #+0]
   \   00000018   0x6808             LDR      R0,[R1, #+0]
   \   0000001A   0xA901             ADD      R1,SP,#+4
   \   0000001C   0xF400 0x7080      AND      R0,R0,#0x100
   \   00000020   0x9000             STR      R0,[SP, #+0]
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xF44F 0x6080      MOV      R0,#+1024
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x9002             STR      R0,[SP, #+8]
   \   0000002E   0x9003             STR      R0,[SP, #+12]
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x9004             STR      R0,[SP, #+16]
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       HAL_GPIO_Init
    203              
    204              /* By default, turn off LED */
    205              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0xF44F 0x6180      MOV      R1,#+1024
   \   00000040   0xE01F             B.N      ??BSP_LED_Init_1
    206            }
    207            else if (Led == LED2)
   \                     ??BSP_LED_Init_0: (+1)
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD120             BNE.N    ??BSP_LED_Init_2
    208            {
    209              gpio_led = LED2_GPIO_PORT;
    210              /* Enable the GPIO_LED clock */
    211              LED2_GPIO_CLK_ENABLE();
   \   00000046   0x2100             MOVS     R1,#+0
    212          
    213              /* Configure the GPIO_LED pin */
    214              gpio_init_structure.Pin = GPIO_PIN[Led];
    215              gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
    216              gpio_init_structure.Pull = GPIO_PULLUP;
    217              gpio_init_structure.Speed = GPIO_SPEED_HIGH;
    218            
    219              HAL_GPIO_Init(gpio_led, &gpio_init_structure);
   \   00000048   0x.... 0x....      LDR.W    R5,??DataTable31_1  ;; 0x40022000
   \   0000004C   0x9100             STR      R1,[SP, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable31  ;; 0x40023830
   \   00000052   0x680A             LDR      R2,[R1, #+0]
   \   00000054   0xF442 0x7280      ORR      R2,R2,#0x100
   \   00000058   0x600A             STR      R2,[R1, #+0]
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0xF401 0x7180      AND      R1,R1,#0x100
   \   00000060   0x9100             STR      R1,[SP, #+0]
   \   00000062   0x9900             LDR      R1,[SP, #+0]
   \   00000064   0x.... 0x....      ADR.W    R1,GPIO_PIN
   \   00000068   0xF851 0x4020      LDR      R4,[R1, R0, LSL #+2]
   \   0000006C   0x9002             STR      R0,[SP, #+8]
   \   0000006E   0x9003             STR      R0,[SP, #+12]
   \   00000070   0x2003             MOVS     R0,#+3
   \   00000072   0x9004             STR      R0,[SP, #+16]
   \   00000074   0xA901             ADD      R1,SP,#+4
   \   00000076   0x9401             STR      R4,[SP, #+4]
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x.... 0x....      BL       HAL_GPIO_Init
    220              
    221              /* By default, turn off LED */
    222              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
   \   0000007E   0x2201             MOVS     R2,#+1
   \   00000080   0xB2A1             UXTH     R1,R4
   \                     ??BSP_LED_Init_1: (+1)
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       HAL_GPIO_WritePin
    223            }
    224          }
   \                     ??BSP_LED_Init_2: (+1)
   \   00000088   0xB007             ADD      SP,SP,#+28
   \   0000008A   0xBD30             POP      {R4,R5,PC}       ;; return
    225          
    226          /**
    227            * @brief  DeInit LEDs.
    228            * @param  Led: LED to be configured. 
    229            *          This parameter can be one of the following values:
    230            *            @arg  LED1
    231            * @note Led DeInit does not disable the GPIO clock
    232            * @retval None
    233            */

   \                                 In section .text, align 2, keep-with-next
    234          void BSP_LED_DeInit(Led_TypeDef Led)
    235          {
   \                     BSP_LED_DeInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    236            GPIO_InitTypeDef  gpio_init_structure;
    237            GPIO_TypeDef*     gpio_led;
    238          
    239            if (Led == LED1)
   \   00000006   0xD10C             BNE.N    ??BSP_LED_DeInit_0
    240            {
    241              gpio_led = LED1_GPIO_PORT;
    242              /* Turn off LED */
    243              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable31_1  ;; 0x40022000
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       HAL_GPIO_WritePin
    244              /* Configure the GPIO_LED pin */
    245              gpio_init_structure.Pin = GPIO_PIN[Led];
    246              HAL_GPIO_DeInit(gpio_led, gpio_init_structure.Pin);
   \   00000018   0xF44F 0x6180      MOV      R1,#+1024
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_DeInit
    247            }
    248            
    249            if (Led == LED2)
   \                     ??BSP_LED_DeInit_0: (+1)
   \   00000022   0x2C01             CMP      R4,#+1
   \   00000024   0xD111             BNE.N    ??BSP_LED_DeInit_1
   \   00000026   0x.... 0x....      ADR.W    R0,GPIO_PIN
   \   0000002A   0x.... 0x....      LDR.W    R5,??DataTable31_1  ;; 0x40022000
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0xF850 0x4024      LDR      R4,[R0, R4, LSL #+2]
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0xB2A1             UXTH     R1,R4
    250            {
    251              gpio_led = LED2_GPIO_PORT;
    252              /* Turn off LED */
    253              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000038   0x.... 0x....      BL       HAL_GPIO_WritePin
    254              /* Configure the GPIO_LED pin */
    255              gpio_init_structure.Pin = GPIO_PIN[Led];
    256              HAL_GPIO_DeInit(gpio_led, gpio_init_structure.Pin);
   \   0000003C   0x4621             MOV      R1,R4
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0xB001             ADD      SP,SP,#+4
   \   00000042   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000046   0x.... 0x....      B.W      HAL_GPIO_DeInit
    257            }
    258          }
   \                     ??BSP_LED_DeInit_1: (+1)
   \   0000004A   0xB001             ADD      SP,SP,#+4
   \   0000004C   0xBD30             POP      {R4,R5,PC}       ;; return
    259          
    260          /**
    261            * @brief  Turns selected LED On.
    262            * @param  Led: LED to be set on 
    263            *          This parameter can be one of the following values:
    264            *            @arg  LED1
    265            * @retval None
    266            */

   \                                 In section .text, align 2, keep-with-next
    267          void BSP_LED_On(Led_TypeDef Led)
    268          {
   \                     BSP_LED_On: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    269            GPIO_TypeDef*     gpio_led;
    270          
    271            if (Led == LED1)	/* Switch On LED connected to GPIO */
   \   00000004   0xD106             BNE.N    ??BSP_LED_On_0
    272            {
    273              gpio_led = LED1_GPIO_PORT;
    274              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xF44F 0x6180      MOV      R1,#+1024
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x40022000
   \   00000010   0x.... 0x....      BL       HAL_GPIO_WritePin
    275            }
    276            
    277            if (Led == LED2)	/* Switch On LED connected to GPIO */
   \                     ??BSP_LED_On_0: (+1)
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xD10B             BNE.N    ??BSP_LED_On_1
    278            {
    279              gpio_led = LED2_GPIO_PORT;
    280              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
   \   00000018   0x.... 0x....      ADR.W    R0,GPIO_PIN
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x40022000
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0xB289             UXTH     R1,R1
   \   0000002C   0x.... 0x....      B.W      HAL_GPIO_WritePin
    281            }
    282          }
   \                     ??BSP_LED_On_1: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    283          
    284          /**
    285            * @brief  Turns selected LED Off. 
    286            * @param  Led: LED to be set off
    287            *          This parameter can be one of the following values:
    288            *            @arg  LED1
    289            * @retval None
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          void BSP_LED_Off(Led_TypeDef Led)
    292          {
   \                     BSP_LED_Off: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    293            GPIO_TypeDef*     gpio_led;
    294          
    295            if (Led == LED1) /* Switch Off LED connected to GPIO */
   \   00000004   0xD106             BNE.N    ??BSP_LED_Off_0
    296            {
    297              gpio_led = LED1_GPIO_PORT;
    298              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xF44F 0x6180      MOV      R1,#+1024
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x40022000
   \   00000010   0x.... 0x....      BL       HAL_GPIO_WritePin
    299            }
    300            
    301            if (Led == LED2) /* Switch Off LED connected to GPIO */
   \                     ??BSP_LED_Off_0: (+1)
   \   00000014   0x2C01             CMP      R4,#+1
   \   00000016   0xD10B             BNE.N    ??BSP_LED_Off_1
    302            {
    303              gpio_led = LED2_GPIO_PORT;
    304              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000018   0x.... 0x....      ADR.W    R0,GPIO_PIN
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x40022000
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0xB289             UXTH     R1,R1
   \   0000002C   0x.... 0x....      B.W      HAL_GPIO_WritePin
    305            }
    306          }
   \                     ??BSP_LED_Off_1: (+1)
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    307          
    308          /**
    309            * @brief  Toggles the selected LED.
    310            * @param  Led: LED to be toggled
    311            *          This parameter can be one of the following values:
    312            *            @arg  LED1
    313            * @retval None
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void BSP_LED_Toggle(Led_TypeDef Led)
    316          {
   \                     BSP_LED_Toggle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    317            GPIO_TypeDef*     gpio_led;
    318          
    319            if (Led == LED1)	/* Toggle LED connected to GPIO */
   \   00000004   0xD105             BNE.N    ??BSP_LED_Toggle_0
    320            {
    321              gpio_led = LED1_GPIO_PORT;
    322              HAL_GPIO_TogglePin(gpio_led, GPIO_PIN[Led]);
   \   00000006   0xF44F 0x6180      MOV      R1,#+1024
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x40022000
   \   0000000E   0x.... 0x....      BL       HAL_GPIO_TogglePin
    323            }
    324            
    325            if (Led == LED2)	/* Toggle LED connected to GPIO */
   \                     ??BSP_LED_Toggle_0: (+1)
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD10A             BNE.N    ??BSP_LED_Toggle_1
    326            {
    327              gpio_led = LED2_GPIO_PORT;
    328              HAL_GPIO_TogglePin(gpio_led, GPIO_PIN[Led]);
   \   00000016   0x.... 0x....      ADR.W    R0,GPIO_PIN
   \   0000001A   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x40022000
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0xB289             UXTH     R1,R1
   \   00000028   0x.... 0x....      B.W      HAL_GPIO_TogglePin
    329            }
    330          }
   \                     ??BSP_LED_Toggle_1: (+1)
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    331          
    332          /**
    333            * @brief  Configures button GPIO and EXTI Line.
    334            * @param  Button: Button to be configured
    335            *          This parameter can be one of the following values:
    336            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    337            *            @arg  BUTTON_TAMPER: Tamper Push Button  
    338            *            @arg  BUTTON_KEY: Key Push Button
    339            * @param  ButtonMode: Button mode
    340            *          This parameter can be one of the following values:
    341            *            @arg  BUTTON_MODE_GPIO: Button will be used as simple IO
    342            *            @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line 
    343            *                                    with interrupt generation capability
    344            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons)
    345            *       are mapped on the same push button named "User"
    346            *       on the board serigraphy.
    347            * @retval None
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
    350          {
   \                     BSP_PB_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0xB086             SUB      SP,SP,#+24
    351            GPIO_InitTypeDef gpio_init_structure;
    352            
    353            /* Enable the BUTTON clock */
    354            BUTTONx_GPIO_CLK_ENABLE(Button);
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x40023830
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF400 0x7080      AND      R0,R0,#0x100
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
    355            
    356            if(ButtonMode == BUTTON_MODE_GPIO)
   \   00000022   0xB98E             CBNZ.N   R6,??BSP_PB_Init_0
    357            {
    358              /* Configure Button pin as input */
    359              gpio_init_structure.Pin = BUTTON_PIN[Button];
   \   00000024   0x.... 0x....      ADR.W    R0,BUTTON_PIN
   \   00000028   0x4625             MOV      R5,R4
    360              gpio_init_structure.Mode = GPIO_MODE_INPUT;
    361              gpio_init_structure.Pull = GPIO_NOPULL;
    362              gpio_init_structure.Speed = GPIO_SPEED_FAST;
    363              HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
   \   0000002A   0xA901             ADD      R1,SP,#+4
   \   0000002C   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000030   0x9001             STR      R0,[SP, #+4]
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x9002             STR      R0,[SP, #+8]
   \   00000036   0x9003             STR      R0,[SP, #+12]
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x9004             STR      R0,[SP, #+16]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable31_2
   \   00000040   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000044   0x.... 0x....      BL       HAL_GPIO_Init
    364            }
    365            
    366            if(ButtonMode == BUTTON_MODE_EXTI)
   \                     ??BSP_PB_Init_0: (+1)
   \   00000048   0x2E01             CMP      R6,#+1
   \   0000004A   0xD123             BNE.N    ??BSP_PB_Init_1
    367            {
    368              /* Configure Button pin as input with External interrupt */
    369              gpio_init_structure.Pin = BUTTON_PIN[Button];
   \   0000004C   0x.... 0x....      ADR.W    R0,BUTTON_PIN
   \   00000050   0x4625             MOV      R5,R4
    370              gpio_init_structure.Pull = GPIO_NOPULL;
    371              gpio_init_structure.Speed = GPIO_SPEED_FAST;
    372              
    373              if(Button != BUTTON_WAKEUP)
    374              {
    375                gpio_init_structure.Mode = GPIO_MODE_IT_FALLING; 
    376              }
    377              else
    378              {
    379                gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
    380              }
    381              
    382              HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
   \   00000052   0xA901             ADD      R1,SP,#+4
   \   00000054   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x9003             STR      R0,[SP, #+12]
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x2C00             CMP      R4,#+0
   \   00000062   0x9004             STR      R0,[SP, #+16]
   \   00000064   0xBF14             ITE      NE 
   \   00000066   0x.... 0x....      LDRNE.W  R0,??DataTable31_3  ;; 0x10210000
   \   0000006A   0x.... 0x....      LDREQ.W  R0,??DataTable31_4  ;; 0x10110000
   \   0000006E   0x9002             STR      R0,[SP, #+8]
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable31_2
   \   00000074   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000078   0x.... 0x....      BL       HAL_GPIO_Init
   \   0000007C   0x.... 0x....      ADR.W    R0,BUTTON_IRQn
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0x210F             MOVS     R1,#+15
   \   00000084   0xF830 0x4015      LDRH     R4,[R0, R5, LSL #+1]
   \   00000088   0xB260             SXTB     R0,R4
    383              
    384              /* Enable and set Button EXTI Interrupt to the lowest priority */
    385              HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
   \   0000008A   0x.... 0x....      BL       HAL_NVIC_SetPriority
    386              HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
   \   0000008E   0xB260             SXTB     R0,R4
   \   00000090   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    387            }
    388          }
   \                     ??BSP_PB_Init_1: (+1)
   \   00000094   0xB006             ADD      SP,SP,#+24
   \   00000096   0xBD70             POP      {R4-R6,PC}       ;; return
    389          
    390          /**
    391            * @brief  Push Button DeInit.
    392            * @param  Button: Button to be configured
    393            *          This parameter can be one of the following values:
    394            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    395            *            @arg  BUTTON_TAMPER: Tamper Push Button  
    396            *            @arg  BUTTON_KEY: Key Push Button
    397            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons) 
    398            *       are mapped on the same push button named "User"
    399            *       on the board serigraphy.
    400            * @note PB DeInit does not disable the GPIO clock
    401            * @retval None
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          void BSP_PB_DeInit(Button_TypeDef Button)
    404          {
   \                     BSP_PB_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    405              GPIO_InitTypeDef gpio_init_structure;
    406          
    407              gpio_init_structure.Pin = BUTTON_PIN[Button];
    408              HAL_NVIC_DisableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
   \   00000004   0x.... 0x....      ADR.W    R0,BUTTON_IRQn
   \   00000008   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   0000000C   0xB240             SXTB     R0,R0
   \   0000000E   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    409              HAL_GPIO_DeInit(BUTTON_PORT[Button], gpio_init_structure.Pin);
   \   00000012   0x.... 0x....      ADR.W    R0,BUTTON_PIN
   \   00000016   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable31_2
   \   0000001E   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000022   0xE8BD 0x4010      POP      {R4,LR}
   \   00000026   0x.... 0x....      B.W      HAL_GPIO_DeInit
    410          }
    411          
    412          
    413          /**
    414            * @brief  Returns the selected button state.
    415            * @param  Button: Button to be checked
    416            *          This parameter can be one of the following values:
    417            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    418            *            @arg  BUTTON_TAMPER: Tamper Push Button 
    419            *            @arg  BUTTON_KEY: Key Push Button
    420            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons) 
    421            *       are mapped on the same push button named "User"
    422            *       on the board serigraphy.
    423            * @retval The Button GPIO pin value
    424            */

   \                                 In section .text, align 2, keep-with-next
    425          uint32_t BSP_PB_GetState(Button_TypeDef Button)
    426          {
    427            return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
   \                     BSP_PB_GetState: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,BUTTON_PIN
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable31_2
   \   00000008   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   0000000C   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000010   0x.... 0x....      B.W      HAL_GPIO_ReadPin
    428          }
    429          
    430          /**
    431            * @brief  Configures COM port.
    432            * @param  COM: COM port to be configured.
    433            *          This parameter can be one of the following values:
    434            *            @arg  COM1 
    435            *            @arg  COM2 
    436            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains the
    437            *                configuration information for the specified USART peripheral.
    438            * @retval None
    439            */

   \                                 In section .text, align 2, keep-with-next
    440          void BSP_COM_Init(COM_TypeDef COM, UART_HandleTypeDef *huart)
    441          {
   \                     BSP_COM_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x460C             MOV      R4,R1
    442            GPIO_InitTypeDef gpio_init_structure;
    443          
    444            /* Enable GPIO clock */
    445            DISCOVERY_COMx_TX_GPIO_CLK_ENABLE(COM);
   \   00000008   0xD121             BNE.N    ??BSP_COM_Init_0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x40023830
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   \   00000020   0x9900             LDR      R1,[SP, #+0]
    446            DISCOVERY_COMx_RX_GPIO_CLK_ENABLE(COM);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x9100             STR      R1,[SP, #+0]
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xF001 0x0102      AND      R1,R1,#0x2
   \   00000034   0x9100             STR      R1,[SP, #+0]
   \   00000036   0x9900             LDR      R1,[SP, #+0]
    447          
    448            /* Enable USART clock */
    449            DISCOVERY_COMx_CLK_ENABLE(COM);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x9100             STR      R1,[SP, #+0]
   \   0000003C   0x6941             LDR      R1,[R0, #+20]
   \   0000003E   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000042   0x6141             STR      R1,[R0, #+20]
   \   00000044   0x6940             LDR      R0,[R0, #+20]
   \   00000046   0xF000 0x0010      AND      R0,R0,#0x10
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
    450          
    451            /* Configure USART Tx as alternate function */
    452            gpio_init_structure.Pin = COM_TX_PIN[COM];
   \                     ??BSP_COM_Init_0: (+1)
   \   0000004E   0x.... 0x....      ADR.W    R0,COM_TX_PIN
    453            gpio_init_structure.Mode = GPIO_MODE_AF_PP;
    454            gpio_init_structure.Speed = GPIO_SPEED_FAST;
    455            gpio_init_structure.Pull = GPIO_PULLUP;
    456            gpio_init_structure.Alternate = COM_TX_AF[COM];
    457            HAL_GPIO_Init(COM_TX_PORT[COM], &gpio_init_structure);
   \   00000052   0xA901             ADD      R1,SP,#+4
   \   00000054   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000058   0x9001             STR      R0,[SP, #+4]
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x9002             STR      R0,[SP, #+8]
   \   0000005E   0x9004             STR      R0,[SP, #+16]
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x9003             STR      R0,[SP, #+12]
   \   00000064   0x.... 0x....      ADR.W    R0,COM_TX_AF
   \   00000068   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   0000006C   0x9005             STR      R0,[SP, #+20]
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable31_5
   \   00000072   0xEB00 0x0685      ADD      R6,R0,R5, LSL #+2
   \   00000076   0x6870             LDR      R0,[R6, #+4]
   \   00000078   0x.... 0x....      BL       HAL_GPIO_Init
    458          
    459            /* Configure USART Rx as alternate function */
    460            gpio_init_structure.Pin = COM_RX_PIN[COM];
   \   0000007C   0x.... 0x....      ADR.W    R0,COM_RX_PIN
    461            gpio_init_structure.Mode = GPIO_MODE_AF_PP;
    462            gpio_init_structure.Alternate = COM_RX_AF[COM];
    463            HAL_GPIO_Init(COM_RX_PORT[COM], &gpio_init_structure);
   \   00000080   0xA901             ADD      R1,SP,#+4
   \   00000082   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000086   0x9001             STR      R0,[SP, #+4]
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0x9002             STR      R0,[SP, #+8]
   \   0000008C   0x.... 0x....      ADR.W    R0,COM_RX_AF
   \   00000090   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000094   0x9005             STR      R0,[SP, #+20]
   \   00000096   0x68B0             LDR      R0,[R6, #+8]
   \   00000098   0x.... 0x....      BL       HAL_GPIO_Init
    464          
    465            /* USART configuration */
    466            huart->Instance = COM_USART[COM];
   \   0000009C   0x6830             LDR      R0,[R6, #+0]
   \   0000009E   0x6020             STR      R0,[R4, #+0]
    467            HAL_UART_Init(huart);
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       HAL_UART_Init
    468          }
   \   000000A6   0xB006             ADD      SP,SP,#+24
   \   000000A8   0xBD70             POP      {R4-R6,PC}       ;; return
    469          
    470          /**
    471            * @brief  DeInit COM port.
    472            * @param  COM: COM port to be configured.
    473            *          This parameter can be one of the following values:
    474            *            @arg  COM1 
    475            *            @arg  COM2 
    476            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains the
    477            *                configuration information for the specified USART peripheral.
    478            * @retval None
    479            */

   \                                 In section .text, align 2, keep-with-next
    480          void BSP_COM_DeInit(COM_TypeDef COM, UART_HandleTypeDef *huart)
    481          {
   \                     BSP_COM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    482            /* USART configuration */
    483            huart->Instance = COM_USART[COM];
   \   00000006   0x....             LDR.N    R1,??DataTable31_5
   \   00000008   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    484            HAL_UART_DeInit(huart);
   \   0000000E   0x.... 0x....      BL       HAL_UART_DeInit
    485          
    486            /* Enable USART clock */
    487            DISCOVERY_COMx_CLK_DISABLE(COM);
   \   00000012   0xB924             CBNZ.N   R4,??BSP_COM_DeInit_0
   \   00000014   0x....             LDR.N    R0,??DataTable31_6  ;; 0x40023844
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    488          
    489            /* DeInit GPIO pins can be done in the application 
    490               (by surcharging this __weak function) */
    491          
    492            /* GPIO pins clock, DMA clock can be shut down in the application 
    493               by surcharging this __weak function */
    494          }
   \                     ??BSP_COM_DeInit_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    495          
    496          /*******************************************************************************
    497                                      BUS OPERATIONS
    498          *******************************************************************************/
    499          
    500          /******************************* I2C Routines *********************************/
    501          /**
    502            * @brief  Initializes I2C MSP.
    503            * @param  i2c_handler : I2C handler
    504            * @retval None
    505            */

   \                                 In section .text, align 2, keep-with-next
    506          static void I2Cx_MspInit(I2C_HandleTypeDef *i2c_handler)
    507          {
    508            GPIO_InitTypeDef  gpio_init_structure;
    509            
    510            if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
   \                     I2Cx_MspInit: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable31_7
   \   00000002   0x4288             CMP      R0,R1
   \   00000004   0xB570             PUSH     {R4-R6,LR}
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0x....             LDR.N    R4,??DataTable31_8  ;; 0x40023820
   \   0000000A   0xF44F 0x7580      MOV      R5,#+256
   \   0000000E   0xD140             BNE.N    ??I2Cx_MspInit_0
    511            {
    512              /* AUDIO and LCD I2C MSP init */
    513          
    514              /*** Configure the GPIOs ***/
    515              /* Enable GPIO clock */
    516              DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
   \   00000010   0x2000             MOVS     R0,#+0
    517          
    518              /* Configure I2C Tx as alternate function */
    519              gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SCL_PIN;
    520              gpio_init_structure.Mode = GPIO_MODE_AF_OD;
    521              gpio_init_structure.Pull = GPIO_NOPULL;
    522              gpio_init_structure.Speed = GPIO_SPEED_FAST;
    523              gpio_init_structure.Alternate = DISCOVERY_AUDIO_I2Cx_SCL_SDA_AF;
    524              HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   00000012   0x....             LDR.N    R6,??DataTable31_9  ;; 0x40021c00
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x6920             LDR      R0,[R4, #+16]
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000001E   0x6120             STR      R0,[R4, #+16]
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0xF000 0x0080      AND      R0,R0,#0x80
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x2080             MOVS     R0,#+128
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0x2012             MOVS     R0,#+18
   \   00000030   0x9002             STR      R0,[SP, #+8]
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x9003             STR      R0,[SP, #+12]
   \   00000036   0x2002             MOVS     R0,#+2
   \   00000038   0x9004             STR      R0,[SP, #+16]
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x9005             STR      R0,[SP, #+20]
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       HAL_GPIO_Init
    525          
    526              /* Configure I2C Rx as alternate function */
    527              gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SDA_PIN;
   \   00000044   0x9501             STR      R5,[SP, #+4]
    528              HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   00000046   0xA901             ADD      R1,SP,#+4
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       HAL_GPIO_Init
    529          
    530              /*** Configure the I2C peripheral ***/
    531              /* Enable I2C clock */
    532              DISCOVERY_AUDIO_I2Cx_CLK_ENABLE();
   \   0000004E   0x2000             MOVS     R0,#+0
    533          
    534              /* Force the I2C peripheral clock reset */
    535              DISCOVERY_AUDIO_I2Cx_FORCE_RESET();
    536          
    537              /* Release the I2C peripheral clock reset */
    538              DISCOVERY_AUDIO_I2Cx_RELEASE_RESET();
    539          
    540              /* Enable and set I2Cx Interrupt to a lower priority */
    541              HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_EV_IRQn, 0x05, 0);
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0x6A20             LDR      R0,[R4, #+32]
   \   00000056   0x2105             MOVS     R1,#+5
   \   00000058   0xF440 0x0000      ORR      R0,R0,#0x800000
   \   0000005C   0x6220             STR      R0,[R4, #+32]
   \   0000005E   0x6A20             LDR      R0,[R4, #+32]
   \   00000060   0xF400 0x0000      AND      R0,R0,#0x800000
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0xF440 0x0000      ORR      R0,R0,#0x800000
   \   0000006E   0x6020             STR      R0,[R4, #+0]
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0xF420 0x0000      BIC      R0,R0,#0x800000
   \   00000076   0x6020             STR      R0,[R4, #+0]
   \   00000078   0x2048             MOVS     R0,#+72
   \   0000007A   0x.... 0x....      BL       HAL_NVIC_SetPriority
    542              HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_EV_IRQn);
   \   0000007E   0x2048             MOVS     R0,#+72
   \   00000080   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    543          
    544              /* Enable and set I2Cx Interrupt to a lower priority */
    545              HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_ER_IRQn, 0x05, 0);
   \   00000084   0x2200             MOVS     R2,#+0
   \   00000086   0x2105             MOVS     R1,#+5
   \   00000088   0x2049             MOVS     R0,#+73
   \   0000008A   0x.... 0x....      BL       HAL_NVIC_SetPriority
    546              HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_ER_IRQn);
   \   0000008E   0x2049             MOVS     R0,#+73
   \   00000090   0xE040             B.N      ??I2Cx_MspInit_1
    547            }
    548            else
    549            {
    550              /* External, camera and Arduino connector I2C MSP init */
    551          
    552              /*** Configure the GPIOs ***/
    553              /* Enable GPIO clock */
    554              DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
   \                     ??I2Cx_MspInit_0: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
    555          
    556              /* Configure I2C Tx as alternate function */
    557              gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
    558              gpio_init_structure.Mode = GPIO_MODE_AF_OD;
    559              gpio_init_structure.Pull = GPIO_NOPULL;
    560              gpio_init_structure.Speed = GPIO_SPEED_FAST;
    561              gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
    562              HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   00000094   0xA901             ADD      R1,SP,#+4
   \   00000096   0x9000             STR      R0,[SP, #+0]
   \   00000098   0x6920             LDR      R0,[R4, #+16]
   \   0000009A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000009E   0x6120             STR      R0,[R4, #+16]
   \   000000A0   0x6920             LDR      R0,[R4, #+16]
   \   000000A2   0xF000 0x0002      AND      R0,R0,#0x2
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x9800             LDR      R0,[SP, #+0]
   \   000000AA   0x2012             MOVS     R0,#+18
   \   000000AC   0x9501             STR      R5,[SP, #+4]
   \   000000AE   0x9002             STR      R0,[SP, #+8]
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x9003             STR      R0,[SP, #+12]
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0x9004             STR      R0,[SP, #+16]
   \   000000B8   0x2004             MOVS     R0,#+4
   \   000000BA   0x9005             STR      R0,[SP, #+20]
   \   000000BC   0x....             LDR.N    R5,??DataTable31_10  ;; 0x40020400
   \   000000BE   0x4628             MOV      R0,R5
   \   000000C0   0x.... 0x....      BL       HAL_GPIO_Init
    563          
    564              /* Configure I2C Rx as alternate function */
    565              gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
   \   000000C4   0xF44F 0x7000      MOV      R0,#+512
    566              HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   000000C8   0xA901             ADD      R1,SP,#+4
   \   000000CA   0x9001             STR      R0,[SP, #+4]
   \   000000CC   0x4628             MOV      R0,R5
   \   000000CE   0x.... 0x....      BL       HAL_GPIO_Init
    567          
    568              /*** Configure the I2C peripheral ***/
    569              /* Enable I2C clock */
    570              DISCOVERY_EXT_I2Cx_CLK_ENABLE();
   \   000000D2   0x2000             MOVS     R0,#+0
    571          
    572              /* Force the I2C peripheral clock reset */
    573              DISCOVERY_EXT_I2Cx_FORCE_RESET();
    574          
    575              /* Release the I2C peripheral clock reset */
    576              DISCOVERY_EXT_I2Cx_RELEASE_RESET();
    577          
    578              /* Enable and set I2Cx Interrupt to a lower priority */
    579              HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x05, 0);
   \   000000D4   0x2200             MOVS     R2,#+0
   \   000000D6   0x9000             STR      R0,[SP, #+0]
   \   000000D8   0x6A20             LDR      R0,[R4, #+32]
   \   000000DA   0x2105             MOVS     R1,#+5
   \   000000DC   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   000000E0   0x6220             STR      R0,[R4, #+32]
   \   000000E2   0x6A20             LDR      R0,[R4, #+32]
   \   000000E4   0xF400 0x1000      AND      R0,R0,#0x200000
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0x9800             LDR      R0,[SP, #+0]
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   000000F2   0x6020             STR      R0,[R4, #+0]
   \   000000F4   0x6820             LDR      R0,[R4, #+0]
   \   000000F6   0xF420 0x1000      BIC      R0,R0,#0x200000
   \   000000FA   0x6020             STR      R0,[R4, #+0]
   \   000000FC   0x201F             MOVS     R0,#+31
   \   000000FE   0x.... 0x....      BL       HAL_NVIC_SetPriority
    580              HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_EV_IRQn);
   \   00000102   0x201F             MOVS     R0,#+31
   \   00000104   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    581          
    582              /* Enable and set I2Cx Interrupt to a lower priority */
    583              HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x05, 0);
   \   00000108   0x2200             MOVS     R2,#+0
   \   0000010A   0x2105             MOVS     R1,#+5
   \   0000010C   0x2020             MOVS     R0,#+32
   \   0000010E   0x.... 0x....      BL       HAL_NVIC_SetPriority
    584              HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
   \   00000112   0x2020             MOVS     R0,#+32
   \                     ??I2Cx_MspInit_1: (+1)
   \   00000114   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    585            }
    586          }
   \   00000118   0xB006             ADD      SP,SP,#+24
   \   0000011A   0xBD70             POP      {R4-R6,PC}       ;; return
    587          
    588          /**
    589            * @brief  Initializes I2C HAL.
    590            * @param  i2c_handler : I2C handler
    591            * @retval None
    592            */

   \                                 In section .text, align 2, keep-with-next
    593          static void I2Cx_Init(I2C_HandleTypeDef *i2c_handler)
    594          {
   \                     I2Cx_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    595            if(HAL_I2C_GetState(i2c_handler) == HAL_I2C_STATE_RESET)
   \   00000004   0x.... 0x....      BL       HAL_I2C_GetState
   \   00000008   0xB9C8             CBNZ.N   R0,??I2Cx_Init_0
    596            {
    597              if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
   \   0000000A   0x....             LDR.N    R1,??DataTable31_7
   \   0000000C   0x....             LDR.N    R0,??DataTable31_11  ;; 0x40005400
   \   0000000E   0x428C             CMP      R4,R1
   \   00000010   0xBF08             IT       EQ 
   \   00000012   0xF500 0x6000      ADDEQ    R0,R0,#+2048
    598              {
    599                /* Audio and LCD I2C configuration */
    600                i2c_handler->Instance = DISCOVERY_AUDIO_I2Cx;
    601              }
    602              else
    603              {
    604                /* External, camera and Arduino connector  I2C configuration */
    605                i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
   \   00000016   0x6020             STR      R0,[R4, #+0]
    606              }
    607              i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
   \   00000018   0x....             LDR.N    R0,??DataTable31_12  ;; 0x40912732
   \   0000001A   0x6060             STR      R0,[R4, #+4]
    608              i2c_handler->Init.OwnAddress1      = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x60A0             STR      R0,[R4, #+8]
    609              i2c_handler->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x60E0             STR      R0,[R4, #+12]
    610              i2c_handler->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6120             STR      R0,[R4, #+16]
    611              i2c_handler->Init.OwnAddress2      = 0;
   \   00000028   0x6160             STR      R0,[R4, #+20]
    612              i2c_handler->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
   \   0000002A   0x61E0             STR      R0,[R4, #+28]
    613              i2c_handler->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
   \   0000002C   0x6220             STR      R0,[R4, #+32]
    614          
    615              /* Init the I2C */
    616              I2Cx_MspInit(i2c_handler);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2Cx_MspInit
    617              HAL_I2C_Init(i2c_handler);
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003A   0x.... 0x....      B.W      HAL_I2C_Init
    618            }
    619          }
   \                     ??I2Cx_Init_0: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    620          
    621          /**
    622            * @brief  Reads multiple data.
    623            * @param  i2c_handler : I2C handler
    624            * @param  Addr: I2C address
    625            * @param  Reg: Reg address 
    626            * @param  MemAddress: Memory address 
    627            * @param  Buffer: Pointer to data buffer
    628            * @param  Length: Length of the data
    629            * @retval Number of read data
    630            */
    631          static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef *i2c_handler,
    632                                                     uint8_t Addr,
    633                                                     uint16_t Reg,
    634                                                     uint16_t MemAddress,
    635                                                     uint8_t *Buffer,
    636                                                     uint16_t Length)
    637          {
    638            HAL_StatusTypeDef status = HAL_OK;
    639          
    640            status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
    641          
    642            /* Check the communication status */
    643            if(status != HAL_OK)
    644            {
    645              /* I2C error occurred */
    646              I2Cx_Error(i2c_handler, Addr);
    647            }
    648            return status;    
    649          }
    650          
    651          /**
    652            * @brief  Writes a value in a register of the device through BUS in using DMA mode.
    653            * @param  i2c_handler : I2C handler
    654            * @param  Addr: Device address on BUS Bus.  
    655            * @param  Reg: The target register address to write
    656            * @param  MemAddress: Memory address 
    657            * @param  Buffer: The target register value to be written 
    658            * @param  Length: buffer size to be written
    659            * @retval HAL status
    660            */
    661          static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef *i2c_handler,
    662                                                      uint8_t Addr,
    663                                                      uint16_t Reg,
    664                                                      uint16_t MemAddress,
    665                                                      uint8_t *Buffer,
    666                                                      uint16_t Length)
    667          {
    668            HAL_StatusTypeDef status = HAL_OK;
    669            
    670            status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
    671            
    672            /* Check the communication status */
    673            if(status != HAL_OK)
    674            {
    675              /* Re-Initiaize the I2C Bus */
    676              I2Cx_Error(i2c_handler, Addr);
    677            }
    678            return status;
    679          }
    680          
    681          /**
    682            * @brief  Checks if target device is ready for communication. 
    683            * @note   This function is used with Memory devices
    684            * @param  i2c_handler : I2C handler
    685            * @param  DevAddress: Target device address
    686            * @param  Trials: Number of trials
    687            * @retval HAL status
    688            */
    689          static HAL_StatusTypeDef I2Cx_IsDeviceReady(I2C_HandleTypeDef *i2c_handler, uint16_t DevAddress, uint32_t Trials)
    690          { 
    691            return (HAL_I2C_IsDeviceReady(i2c_handler, DevAddress, Trials, 1000));
    692          }
    693          
    694          /**
    695            * @brief  Manages error callback by re-initializing I2C.
    696            * @param  i2c_handler : I2C handler
    697            * @param  Addr: I2C Address
    698            * @retval None
    699            */
    700          static void I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr)
    701          {
    702            /* De-initialize the I2C communication bus */
    703            HAL_I2C_DeInit(i2c_handler);
    704            
    705            /* Re-Initialize the I2C communication bus */
    706            I2Cx_Init(i2c_handler);
    707          }
    708          
    709          /*******************************************************************************
    710                                      LINK OPERATIONS
    711          *******************************************************************************/
    712          
    713          /********************************* LINK AUDIO *********************************/
    714          
    715          /**
    716            * @brief  Initializes Audio low level.
    717            * @retval None
    718            */

   \                                 In section .text, align 2, keep-with-next
    719          void AUDIO_IO_Init(void) 
    720          {
    721            I2Cx_Init(&hI2cAudioHandler);
   \                     AUDIO_IO_Init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable31_7
   \   00000002   0x....             B.N      I2Cx_Init
    722          }
    723          
    724          /**
    725            * @brief  Deinitializes Audio low level.
    726            * @retval None
    727            */

   \                                 In section .text, align 2, keep-with-next
    728          void AUDIO_IO_DeInit(void)
    729          {
    730          }
   \                     AUDIO_IO_DeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    731          
    732          /**
    733            * @brief  Writes a single data.
    734            * @param  Addr: I2C address
    735            * @param  Reg: Reg address 
    736            * @param  Value: Data to be written
    737            * @retval None
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          void AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
    740          {
    741            uint16_t tmp = Value;
    742            
    743            Value = ((uint16_t)(tmp >> 8) & 0x00FF);
    744            
    745            Value |= ((uint16_t)(tmp << 8)& 0xFF00);
   \                     AUDIO_IO_Write: (+1)
   \   00000000   0x0213             LSLS     R3,R2,#+8
   \   00000002   0xB514             PUSH     {R2,R4,LR}
   \   00000004   0xEA43 0x2212      ORR      R2,R3,R2, LSR #+8
   \   00000008   0xB083             SUB      SP,SP,#+12
    746            
    747            I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2);
   \   0000000A   0x....             LDR.N    R4,??DataTable31_7
   \   0000000C   0x2302             MOVS     R3,#+2
   \   0000000E   0xF8AD 0x200C      STRH     R2,[SP, #+12]
   \   00000012   0xF44F 0x727A      MOV      R2,#+1000
   \   00000016   0x9202             STR      R2,[SP, #+8]
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x9201             STR      R2,[SP, #+4]
   \   0000001C   0xAA03             ADD      R2,SP,#+12
   \   0000001E   0x9200             STR      R2,[SP, #+0]
   \   00000020   0x460A             MOV      R2,R1
   \   00000022   0x4601             MOV      R1,R0
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \   0000002A   0xB128             CBZ.N    R0,??AUDIO_IO_Write_0
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       HAL_I2C_DeInit
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       I2Cx_Init
    748          }
   \                     ??AUDIO_IO_Write_0: (+1)
   \   00000038   0xB004             ADD      SP,SP,#+16
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    749          
    750          /**
    751            * @brief  Reads a single data.
    752            * @param  Addr: I2C address
    753            * @param  Reg: Reg address 
    754            * @retval Data to be read
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          uint16_t AUDIO_IO_Read(uint8_t Addr, uint16_t Reg)
    757          {
   \                     AUDIO_IO_Read: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    758            uint16_t read_value = 0, tmp = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF8AD 0x200C      STRH     R2,[SP, #+12]
    759            
    760            I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2);
   \   0000000A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000000E   0x9202             STR      R2,[SP, #+8]
   \   00000010   0x2202             MOVS     R2,#+2
   \   00000012   0x9201             STR      R2,[SP, #+4]
   \   00000014   0xAA03             ADD      R2,SP,#+12
   \   00000016   0x9200             STR      R2,[SP, #+0]
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0x....             LDR.N    R4,??DataTable31_7
   \   0000001C   0x4601             MOV      R1,R0
   \   0000001E   0x2302             MOVS     R3,#+2
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \   00000026   0xB128             CBZ.N    R0,??AUDIO_IO_Read_0
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_I2C_DeInit
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2Cx_Init
    761            
    762            tmp = ((uint16_t)(read_value >> 8) & 0x00FF);
    763            
    764            tmp |= ((uint16_t)(read_value << 8)& 0xFF00);
    765            
    766            read_value = tmp;
    767            
    768            return read_value;
   \                     ??AUDIO_IO_Read_0: (+1)
   \   00000034   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   00000038   0xB004             ADD      SP,SP,#+16
   \   0000003A   0x0201             LSLS     R1,R0,#+8
   \   0000003C   0xEA41 0x2010      ORR      R0,R1,R0, LSR #+8
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
    769          }
    770          
    771          /**
    772            * @brief  AUDIO Codec delay 
    773            * @param  Delay: Delay in ms
    774            * @retval None
    775            */

   \                                 In section .text, align 2, keep-with-next
    776          void AUDIO_IO_Delay(uint32_t Delay)
    777          {
    778            HAL_Delay(Delay);
   \                     AUDIO_IO_Delay: (+1)
   \   00000000   0x.... 0x....      B.W      HAL_Delay
    779          }
    780          
    781          /********************************* LINK CAMERA ********************************/
    782          
    783          /**
    784            * @brief  Initializes Camera low level.
    785            * @retval None
    786            */

   \                                 In section .text, align 2, keep-with-next
    787          void CAMERA_IO_Init(void) 
    788          {
    789            I2Cx_Init(&hI2cExtHandler);
   \                     CAMERA_IO_Init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable31_13
   \   00000002   0x....             B.N      I2Cx_Init
    790          }
    791          
    792          /**
    793            * @brief  Camera writes single data.
    794            * @param  Addr: I2C address
    795            * @param  Reg: Register address 
    796            * @param  Value: Data to be written
    797            * @retval None
    798            */

   \                                 In section .text, align 2, keep-with-next
    799          void CAMERA_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
    800          {
   \                     CAMERA_IO_Write: (+1)
   \   00000000   0xB514             PUSH     {R2,R4,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    801            I2Cx_WriteMultiple(&hI2cExtHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
   \   00000004   0xF44F 0x727A      MOV      R2,#+1000
   \   00000008   0x9202             STR      R2,[SP, #+8]
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x9201             STR      R2,[SP, #+4]
   \   0000000E   0xAA03             ADD      R2,SP,#+12
   \   00000010   0x9200             STR      R2,[SP, #+0]
   \   00000012   0x460A             MOV      R2,R1
   \   00000014   0x....             LDR.N    R4,??DataTable31_13
   \   00000016   0x4601             MOV      R1,R0
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \   00000020   0xB128             CBZ.N    R0,??CAMERA_IO_Write_0
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       HAL_I2C_DeInit
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2Cx_Init
    802          }
   \                     ??CAMERA_IO_Write_0: (+1)
   \   0000002E   0xB004             ADD      SP,SP,#+16
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    803          
    804          /**
    805            * @brief  Camera reads single data.
    806            * @param  Addr: I2C address
    807            * @param  Reg: Register address 
    808            * @retval Read data
    809            */

   \                                 In section .text, align 2, keep-with-next
    810          uint8_t CAMERA_IO_Read(uint8_t Addr, uint8_t Reg)
    811          {
   \                     CAMERA_IO_Read: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    812            uint8_t read_value = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF88D 0x200C      STRB     R2,[SP, #+12]
    813          
    814            I2Cx_ReadMultiple(&hI2cExtHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
   \   0000000A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000000E   0x9202             STR      R2,[SP, #+8]
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x9201             STR      R2,[SP, #+4]
   \   00000014   0xAA03             ADD      R2,SP,#+12
   \   00000016   0x9200             STR      R2,[SP, #+0]
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0x....             LDR.N    R4,??DataTable31_13
   \   0000001C   0x4601             MOV      R1,R0
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \   00000026   0xB128             CBZ.N    R0,??CAMERA_IO_Read_0
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_I2C_DeInit
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2Cx_Init
    815          
    816            return read_value;
   \                     ??CAMERA_IO_Read_0: (+1)
   \   00000034   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000038   0xB004             ADD      SP,SP,#+16
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    817          }
    818          
    819          /**
    820            * @brief  Camera delay 
    821            * @param  Delay: Delay in ms
    822            * @retval None
    823            */

   \                                 In section .text, align 2, keep-with-next
    824          void CAMERA_Delay(uint32_t Delay)
    825          {
    826            HAL_Delay(Delay);
   \                     CAMERA_Delay: (+1)
   \   00000000   0x.... 0x....      B.W      HAL_Delay
    827          }
    828          
    829          /******************************** LINK I2C EEPROM *****************************/
    830          
    831          /**
    832            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    833            * @retval None
    834            */

   \                                 In section .text, align 2, keep-with-next
    835          void EEPROM_IO_Init(void)
    836          {
    837            I2Cx_Init(&hI2cExtHandler);
   \                     EEPROM_IO_Init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable31_13
   \   00000002   0x....             B.N      I2Cx_Init
    838          }
    839          
    840          /**
    841            * @brief  Write data to I2C EEPROM driver in using DMA channel.
    842            * @param  DevAddress: Target device address
    843            * @param  MemAddress: Internal memory address
    844            * @param  pBuffer: Pointer to data buffer
    845            * @param  BufferSize: Amount of data to be sent
    846            * @retval HAL status
    847            */

   \                                 In section .text, align 2, keep-with-next
    848          HAL_StatusTypeDef EEPROM_IO_WriteData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    849          {
   \                     EEPROM_IO_WriteData: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    850            return (I2Cx_WriteMultiple(&hI2cExtHandler, DevAddress, MemAddress, I2C_MEMADD_SIZE_16BIT, pBuffer, BufferSize));
   \   00000002   0xB29B             UXTH     R3,R3
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x9200             STR      R2,[SP, #+0]
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x....             LDR.N    R4,??DataTable31_13
   \   0000000C   0xF44F 0x757A      MOV      R5,#+1000
   \   00000010   0x9301             STR      R3,[SP, #+4]
   \   00000012   0xB2C1             UXTB     R1,R0
   \   00000014   0x9502             STR      R5,[SP, #+8]
   \   00000016   0x2302             MOVS     R3,#+2
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0xD005             BEQ.N    ??EEPROM_IO_WriteData_0
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       HAL_I2C_DeInit
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2Cx_Init
   \                     ??EEPROM_IO_WriteData_0: (+1)
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xB003             ADD      SP,SP,#+12
   \   00000032   0xBD30             POP      {R4,R5,PC}       ;; return
    851          }
    852          
    853          /**
    854            * @brief  Read data from I2C EEPROM driver in using DMA channel.
    855            * @param  DevAddress: Target device address
    856            * @param  MemAddress: Internal memory address
    857            * @param  pBuffer: Pointer to data buffer
    858            * @param  BufferSize: Amount of data to be read
    859            * @retval HAL status
    860            */

   \                                 In section .text, align 2, keep-with-next
    861          HAL_StatusTypeDef EEPROM_IO_ReadData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    862          {
   \                     EEPROM_IO_ReadData: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    863            return (I2Cx_ReadMultiple(&hI2cExtHandler, DevAddress, MemAddress, I2C_MEMADD_SIZE_16BIT, pBuffer, BufferSize));
   \   00000002   0xB29B             UXTH     R3,R3
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x9200             STR      R2,[SP, #+0]
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x....             LDR.N    R4,??DataTable31_13
   \   0000000C   0xF44F 0x757A      MOV      R5,#+1000
   \   00000010   0x9301             STR      R3,[SP, #+4]
   \   00000012   0xB2C1             UXTB     R1,R0
   \   00000014   0x9502             STR      R5,[SP, #+8]
   \   00000016   0x2302             MOVS     R3,#+2
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0xD005             BEQ.N    ??EEPROM_IO_ReadData_0
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       HAL_I2C_DeInit
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2Cx_Init
   \                     ??EEPROM_IO_ReadData_0: (+1)
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0xB003             ADD      SP,SP,#+12
   \   00000032   0xBD30             POP      {R4,R5,PC}       ;; return
    864          }
    865          
    866          /**
    867            * @brief  Checks if target device is ready for communication. 
    868            * @note   This function is used with Memory devices
    869            * @param  DevAddress: Target device address
    870            * @param  Trials: Number of trials
    871            * @retval HAL status
    872            */

   \                                 In section .text, align 2, keep-with-next
    873          HAL_StatusTypeDef EEPROM_IO_IsDeviceReady(uint16_t DevAddress, uint32_t Trials)
    874          { 
    875            return (I2Cx_IsDeviceReady(&hI2cExtHandler, DevAddress, Trials));
   \                     EEPROM_IO_IsDeviceReady: (+1)
   \   00000000   0x460A             MOV      R2,R1
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0xF44F 0x737A      MOV      R3,#+1000
   \   00000008   0x....             LDR.N    R0,??DataTable31_13
   \   0000000A   0x.... 0x....      B.W      HAL_I2C_IsDeviceReady
    876          }
    877          
    878          /********************************* LINK TOUCHSCREEN *********************************/
    879          
    880          /**
    881            * @brief  Initializes Touchscreen low level.
    882            * @retval None
    883            */

   \                                 In section .text, align 2, keep-with-next
    884          void TS_IO_Init(void)
    885          {
    886            I2Cx_Init(&hI2cAudioHandler);
   \                     TS_IO_Init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable31_7
   \   00000002   0x....             B.N      I2Cx_Init
    887          }
    888          
    889          /**
    890            * @brief  Writes a single data.
    891            * @param  Addr: I2C address
    892            * @param  Reg: Reg address
    893            * @param  Value: Data to be written
    894            * @retval None
    895            */

   \                                 In section .text, align 2, keep-with-next
    896          void TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
    897          {
   \                     TS_IO_Write: (+1)
   \   00000000   0xB514             PUSH     {R2,R4,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    898            I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
   \   00000004   0xF44F 0x727A      MOV      R2,#+1000
   \   00000008   0x9202             STR      R2,[SP, #+8]
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x9201             STR      R2,[SP, #+4]
   \   0000000E   0xAA03             ADD      R2,SP,#+12
   \   00000010   0x9200             STR      R2,[SP, #+0]
   \   00000012   0x460A             MOV      R2,R1
   \   00000014   0x....             LDR.N    R4,??DataTable31_7
   \   00000016   0x4601             MOV      R1,R0
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \   00000020   0xB128             CBZ.N    R0,??TS_IO_Write_0
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       HAL_I2C_DeInit
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       I2Cx_Init
    899          }
   \                     ??TS_IO_Write_0: (+1)
   \   0000002E   0xB004             ADD      SP,SP,#+16
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    900          
    901          /**
    902            * @brief  Reads a single data.
    903            * @param  Addr: I2C address
    904            * @param  Reg: Reg address
    905            * @retval Data to be read
    906            */

   \                                 In section .text, align 2, keep-with-next
    907          uint8_t TS_IO_Read(uint8_t Addr, uint8_t Reg)
    908          {
   \                     TS_IO_Read: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    909            uint8_t read_value = 0;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0xF88D 0x200C      STRB     R2,[SP, #+12]
    910          
    911            I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
   \   0000000A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000000E   0x9202             STR      R2,[SP, #+8]
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x9201             STR      R2,[SP, #+4]
   \   00000014   0xAA03             ADD      R2,SP,#+12
   \   00000016   0x9200             STR      R2,[SP, #+0]
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0x....             LDR.N    R4,??DataTable31_7
   \   0000001C   0x4601             MOV      R1,R0
   \   0000001E   0x2301             MOVS     R3,#+1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \   00000026   0xB128             CBZ.N    R0,??TS_IO_Read_0
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_I2C_DeInit
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       I2Cx_Init
    912          
    913            return read_value;
   \                     ??TS_IO_Read_0: (+1)
   \   00000034   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000038   0xB004             ADD      SP,SP,#+16
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    914          }
    915          
    916          /**
    917            * @brief  TS delay
    918            * @param  Delay: Delay in ms
    919            * @retval None
    920            */

   \                                 In section .text, align 2, keep-with-next
    921          void TS_IO_Delay(uint32_t Delay)
    922          {
    923            HAL_Delay(Delay);
   \                     TS_IO_Delay: (+1)
   \   00000000   0x.... 0x....      B.W      HAL_Delay
    924          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_2:
   \   00000000   0x........         DC32     BUTTON_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_3:
   \   00000000   0x10210000         DC32     0x10210000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_4:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_5:
   \   00000000   0x........         DC32     COM_USART

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_6:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_7:
   \   00000000   0x........         DC32     hI2cAudioHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_8:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_9:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_10:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_11:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_12:
   \   00000000   0x40912732         DC32     0x40912732

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_13:
   \   00000000   0x........         DC32     hI2cExtHandler
    925          
    926          /**
    927            * @}
    928            */
    929          
    930          /**
    931            * @}
    932            */ 
    933          
    934          /**
    935            * @}
    936            */
    937          
    938          /**
    939            * @}
    940            */    
    941              
    942          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AUDIO_IO_DeInit
       0   AUDIO_IO_Delay
         0   -> HAL_Delay
       0   AUDIO_IO_Init
         0   -> I2Cx_Init
      24   AUDIO_IO_Read
        24   -> HAL_I2C_DeInit
        24   -> HAL_I2C_Mem_Read
        24   -> I2Cx_Init
      24   AUDIO_IO_Write
        24   -> HAL_I2C_DeInit
        24   -> HAL_I2C_Mem_Write
        24   -> I2Cx_Init
       8   BSP_COM_DeInit
         8   -> HAL_UART_DeInit
      40   BSP_COM_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_UART_Init
       0   BSP_GetVersion
      16   BSP_LED_DeInit
         0   -> HAL_GPIO_DeInit
        16   -> HAL_GPIO_DeInit
        16   -> HAL_GPIO_WritePin
      40   BSP_LED_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_GPIO_WritePin
       8   BSP_LED_Off
         0   -> HAL_GPIO_WritePin
         8   -> HAL_GPIO_WritePin
       8   BSP_LED_On
         0   -> HAL_GPIO_WritePin
         8   -> HAL_GPIO_WritePin
       8   BSP_LED_Toggle
         0   -> HAL_GPIO_TogglePin
         8   -> HAL_GPIO_TogglePin
       8   BSP_PB_DeInit
         0   -> HAL_GPIO_DeInit
         8   -> HAL_NVIC_DisableIRQ
       0   BSP_PB_GetState
         0   -> HAL_GPIO_ReadPin
      40   BSP_PB_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
       0   CAMERA_Delay
         0   -> HAL_Delay
       0   CAMERA_IO_Init
         0   -> I2Cx_Init
      24   CAMERA_IO_Read
        24   -> HAL_I2C_DeInit
        24   -> HAL_I2C_Mem_Read
        24   -> I2Cx_Init
      24   CAMERA_IO_Write
        24   -> HAL_I2C_DeInit
        24   -> HAL_I2C_Mem_Write
        24   -> I2Cx_Init
       0   EEPROM_IO_Init
         0   -> I2Cx_Init
       0   EEPROM_IO_IsDeviceReady
         0   -> HAL_I2C_IsDeviceReady
      24   EEPROM_IO_ReadData
        24   -> HAL_I2C_DeInit
        24   -> HAL_I2C_Mem_Read
        24   -> I2Cx_Init
      24   EEPROM_IO_WriteData
        24   -> HAL_I2C_DeInit
        24   -> HAL_I2C_Mem_Write
        24   -> I2Cx_Init
       8   I2Cx_Init
         8   -> HAL_I2C_GetState
         0   -> HAL_I2C_Init
         8   -> I2Cx_MspInit
      40   I2Cx_MspInit
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
       0   TS_IO_Delay
         0   -> HAL_Delay
       0   TS_IO_Init
         0   -> I2Cx_Init
      24   TS_IO_Read
        24   -> HAL_I2C_DeInit
        24   -> HAL_I2C_Mem_Read
        24   -> I2Cx_Init
      24   TS_IO_Write
        24   -> HAL_I2C_DeInit
        24   -> HAL_I2C_Mem_Write
        24   -> I2Cx_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable31_10
       4  ??DataTable31_11
       4  ??DataTable31_12
       4  ??DataTable31_13
       4  ??DataTable31_2
       4  ??DataTable31_3
       4  ??DataTable31_4
       4  ??DataTable31_5
       4  ??DataTable31_6
       4  ??DataTable31_7
       4  ??DataTable31_8
       4  ??DataTable31_9
       2  AUDIO_IO_DeInit
       4  AUDIO_IO_Delay
       4  AUDIO_IO_Init
      68  AUDIO_IO_Read
      60  AUDIO_IO_Write
      32  BSP_COM_DeInit
     170  BSP_COM_Init
       6  BSP_GetVersion
      78  BSP_LED_DeInit
     140  BSP_LED_Init
      50  BSP_LED_Off
      50  BSP_LED_On
      46  BSP_LED_Toggle
      42  BSP_PB_DeInit
      20  BSP_PB_GetState
     152  BSP_PB_Init
       8  BUTTON_IRQn
       8  BUTTON_PIN
      12  BUTTON_PORT
       4  CAMERA_Delay
       4  CAMERA_IO_Init
      60  CAMERA_IO_Read
      50  CAMERA_IO_Write
       2  COM_RX_AF
       2  COM_RX_PIN
       2  COM_TX_AF
       2  COM_TX_PIN
      12  COM_USART
          COM_TX_PORT
          COM_RX_PORT
       4  EEPROM_IO_Init
      14  EEPROM_IO_IsDeviceReady
      52  EEPROM_IO_ReadData
      52  EEPROM_IO_WriteData
       8  GPIO_PIN
      64  I2Cx_Init
     284  I2Cx_MspInit
       4  TS_IO_Delay
       4  TS_IO_Init
      60  TS_IO_Read
      50  TS_IO_Write
      60  hI2cAudioHandler
      60  hI2cExtHandler

 
   120 bytes in section .bss
    24 bytes in section .data
 1 718 bytes in section .text
 
 1 718 bytes of CODE memory
   144 bytes of DATA memory

Errors: none
Warnings: none
