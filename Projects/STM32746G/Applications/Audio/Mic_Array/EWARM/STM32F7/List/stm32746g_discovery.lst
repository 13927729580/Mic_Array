###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       20/Dec/2015  03:50:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
#    Command line =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Full.h" -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -Ohz --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery.lst
#    Object file  =  
#        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery.o
#
###############################################################################

H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file provides a set of firmware functions to manage LEDs, 
      8            *          push-buttons and COM ports available on STM32746G-Discovery
      9            *          board(MB1191) from STMicroelectronics.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     14            *
     15            * Redistribution and use in source and binary forms, with or without modification,
     16            * are permitted provided that the following conditions are met:
     17            *   1. Redistributions of source code must retain the above copyright notice,
     18            *      this list of conditions and the following disclaimer.
     19            *   2. Redistributions in binary form must reproduce the above copyright notice,
     20            *      this list of conditions and the following disclaimer in the documentation
     21            *      and/or other materials provided with the distribution.
     22            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     23            *      may be used to endorse or promote products derived from this software
     24            *      without specific prior written permission.
     25            *
     26            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     27            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     28            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     29            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     30            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     31            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     32            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     33            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     34            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     35            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     36            *
     37            ******************************************************************************
     38            */ 
     39          
     40          /* Includes ------------------------------------------------------------------*/
     41          #include "stm32746g_discovery.h"
     42          
     43          /** @addtogroup BSP
     44            * @{
     45            */ 
     46          
     47          /** @addtogroup STM32746G_DISCOVERY
     48            * @{
     49            */
     50          
     51          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL STM32746G_DISCOVERY_LOW_LEVEL
     52            * @{
     53            */
     54          
     55          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_TypesDefinitions STM32746G_DISCOVERY_LOW_LEVEL Private Types Definitions
     56            * @{
     57            */
     58          /**
     59            * @}
     60            */
     61          
     62          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Defines STM32746G_DISCOVERY_LOW_LEVEL Private Defines
     63            * @{
     64            */
     65          /**
     66           * @brief STM32746G DISCOVERY BSP Driver version number V1.0.0
     67             */
     68          #define __STM32746G_DISCO_BSP_VERSION_MAIN   (0x01) /*!< [31:24] main version */
     69          #define __STM32746G_DISCO_BSP_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version */
     70          #define __STM32746G_DISCO_BSP_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
     71          #define __STM32746G_DISCO_BSP_VERSION_RC     (0x00) /*!< [7:0]  release candidate */
     72          #define __STM32746G_DISCO_BSP_VERSION         ((__STM32746G_DISCO_BSP_VERSION_MAIN << 24)\
     73                                                       |(__STM32746G_DISCO_BSP_VERSION_SUB1 << 16)\
     74                                                       |(__STM32746G_DISCO_BSP_VERSION_SUB2 << 8 )\
     75                                                       |(__STM32746G_DISCO_BSP_VERSION_RC))
     76          /**
     77            * @}
     78            */
     79          
     80          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Macros STM32746G_DISCOVERY_LOW_LEVEL Private Macros
     81            * @{
     82            */
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Variables STM32746G_DISCOVERY_LOW_LEVEL Private Variables
     88            * @{
     89            */
     90          

   \                                 In section .rodata, align 4, keep-with-next
     91          const uint32_t GPIO_PIN[LEDn] = {LED1_PIN};
   \                     GPIO_PIN:
   \   00000000   0x00000400         DC32 1024
     92          

   \                                 In section .data, align 4
     93          GPIO_TypeDef* BUTTON_PORT[BUTTONn] = {WAKEUP_BUTTON_GPIO_PORT,
   \                     BUTTON_PORT:
   \   00000000   0x40022000         DC32 40022000H, 40022000H, 40022000H
   \              0x40022000   
   \              0x40022000   
     94                                                TAMPER_BUTTON_GPIO_PORT,
     95                                                KEY_BUTTON_GPIO_PORT};
     96          

   \                                 In section .text, align 4, keep-with-next
     97          const uint16_t BUTTON_PIN[BUTTONn] = {WAKEUP_BUTTON_PIN,
   \                     BUTTON_PIN:
   \   00000000   0x0800 0x0800      DC16 2048, 2048, 2048
   \              0x0800       
   \   00000006   0x00 0x00          DC8 0, 0
     98                                                TAMPER_BUTTON_PIN,
     99                                                KEY_BUTTON_PIN};
    100          

   \                                 In section .text, align 4, keep-with-next
    101          const uint16_t BUTTON_IRQn[BUTTONn] = {WAKEUP_BUTTON_EXTI_IRQn,
   \                     BUTTON_IRQn:
   \   00000000   0x0028 0x0028      DC16 40, 40, 40
   \              0x0028       
   \   00000006   0x00 0x00          DC8 0, 0
    102                                                 TAMPER_BUTTON_EXTI_IRQn,
    103                                                 KEY_BUTTON_EXTI_IRQn};
    104          

   \                                 In section .data, align 4
    105          USART_TypeDef* COM_USART[COMn] = {DISCOVERY_COM1};
   \                     COM_USART:
   \   00000000   0x40011000         DC32 40011000H
    106          
    107          GPIO_TypeDef* COM_TX_PORT[COMn] = {DISCOVERY_COM1_TX_GPIO_PORT};
   \                     COM_TX_PORT:
   \   00000004   0x40020000         DC32 40020000H
    108          
    109          GPIO_TypeDef* COM_RX_PORT[COMn] = {DISCOVERY_COM1_RX_GPIO_PORT};
   \                     COM_RX_PORT:
   \   00000008   0x40020400         DC32 40020400H
    110          

   \                                 In section .text, align 4, keep-with-next
    111          const uint16_t COM_TX_PIN[COMn] = {DISCOVERY_COM1_TX_PIN};
   \                     COM_TX_PIN:
   \   00000000   0x0200             DC16 512
    112          

   \                                 In section .text, align 4, keep-with-next
    113          const uint16_t COM_RX_PIN[COMn] = {DISCOVERY_COM1_RX_PIN};
   \                     COM_RX_PIN:
   \   00000000   0x0080             DC16 128
    114          

   \                                 In section .text, align 4, keep-with-next
    115          const uint16_t COM_TX_AF[COMn] = {DISCOVERY_COM1_TX_AF};
   \                     COM_TX_AF:
   \   00000000   0x0007             DC16 7
    116          

   \                                 In section .text, align 4, keep-with-next
    117          const uint16_t COM_RX_AF[COMn] = {DISCOVERY_COM1_RX_AF};
   \                     COM_RX_AF:
   \   00000000   0x0007             DC16 7
    118          

   \                                 In section .bss, align 4
    119          static I2C_HandleTypeDef hI2cAudioHandler = {0};
   \                     hI2cAudioHandler:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    120          static I2C_HandleTypeDef hI2cExtHandler = {0};
   \                     hI2cExtHandler:
   \   00000000                      DS8 60
    121          
    122          /**
    123            * @}
    124            */
    125          
    126          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_FunctionPrototypes STM32746G_DISCOVERY_LOW_LEVEL Private Function Prototypes
    127            * @{
    128            */
    129          static void     I2Cx_MspInit(I2C_HandleTypeDef *i2c_handler);
    130          static void     I2Cx_Init(I2C_HandleTypeDef *i2c_handler);
    131          
    132          static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef *i2c_handler, uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length);
    133          static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef *i2c_handler, uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length);
    134          static HAL_StatusTypeDef I2Cx_IsDeviceReady(I2C_HandleTypeDef *i2c_handler, uint16_t DevAddress, uint32_t Trials);
    135          static void              I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr);
    136          
    137          /* AUDIO IO functions */
    138          void            AUDIO_IO_Init(void);
    139          void            AUDIO_IO_DeInit(void);
    140          void            AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value);
    141          uint16_t        AUDIO_IO_Read(uint8_t Addr, uint16_t Reg);
    142          void            AUDIO_IO_Delay(uint32_t Delay);
    143          
    144          /* TOUCHSCREEN IO functions */
    145          void            TS_IO_Init(void);
    146          void            TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value);
    147          uint8_t         TS_IO_Read(uint8_t Addr, uint8_t Reg);
    148          void            TS_IO_Delay(uint32_t Delay);
    149          
    150          /* CAMERA IO functions */
    151          void            CAMERA_IO_Init(void);
    152          void            CAMERA_Delay(uint32_t Delay);
    153          void            CAMERA_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value);
    154          uint8_t         CAMERA_IO_Read(uint8_t Addr, uint8_t Reg);
    155          
    156          /* I2C EEPROM IO function */
    157          void                EEPROM_IO_Init(void);
    158          HAL_StatusTypeDef   EEPROM_IO_WriteData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize);
    159          HAL_StatusTypeDef   EEPROM_IO_ReadData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize);
    160          HAL_StatusTypeDef   EEPROM_IO_IsDeviceReady(uint16_t DevAddress, uint32_t Trials);
    161          /**
    162            * @}
    163            */
    164          
    165          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Exported_Functions STM32746G_DISCOVERY_LOW_LEVELSTM32746G_DISCOVERY_LOW_LEVEL Exported Functions
    166            * @{
    167            */ 
    168          
    169            /**
    170            * @brief  This method returns the STM32746G DISCOVERY BSP Driver revision
    171            * @retval version: 0xXYZR (8bits for each decimal, R for RC)
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          uint32_t BSP_GetVersion(void)
    174          {
    175            return __STM32746G_DISCO_BSP_VERSION;
   \                     BSP_GetVersion: (+1)
   \   00000000   0xF04F 0x7080      MOV      R0,#+16777216
   \   00000004   0x4770             BX       LR               ;; return
    176          }
    177          
    178          /**
    179            * @brief  Configures LED on GPIO.
    180            * @param  Led: LED to be configured. 
    181            *          This parameter can be one of the following values:
    182            *            @arg  LED1
    183            * @retval None
    184            */

   \                                 In section .text, align 2, keep-with-next
    185          void BSP_LED_Init(Led_TypeDef Led)
    186          {
    187            GPIO_InitTypeDef  gpio_init_structure;
    188            GPIO_TypeDef*     gpio_led;
    189          
    190            if (Led == LED1)
   \                     BSP_LED_Init: (+1)
   \   00000000   0xB100             CBZ.N    R0,??BSP_LED_Init_0
   \   00000002   0x4770             BX       LR
    191            {
    192              gpio_led = LED1_GPIO_PORT;
    193              /* Enable the GPIO_LED clock */
    194              LED1_GPIO_CLK_ENABLE();
   \                     ??BSP_LED_Init_0: (+1)
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40023830
   \   0000000A   0xB086             SUB      SP,SP,#+24
    195          
    196              /* Configure the GPIO_LED pin */
    197              gpio_init_structure.Pin = GPIO_PIN[Led];
    198              gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
    199              gpio_init_structure.Pull = GPIO_PULLUP;
    200              gpio_init_structure.Speed = GPIO_SPEED_HIGH;
    201            
    202              HAL_GPIO_Init(gpio_led, &gpio_init_structure);
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable23_1  ;; 0x40022000
   \   00000010   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000014   0xA901             ADD      R1,SP,#+4
   \   00000016   0xF400 0x7080      AND      R0,R0,#0x100
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x9002             STR      R0,[SP, #+8]
   \   00000028   0x9003             STR      R0,[SP, #+12]
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x9004             STR      R0,[SP, #+16]
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       HAL_GPIO_Init
    203              
    204              /* By default, turn off LED */
    205              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000034   0x.... 0x....      BL       ?Subroutine12
    206            }
    207          }
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000038   0xB006             ADD      SP,SP,#+24
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xF44F 0x6180      MOV      R1,#+1024
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      B.W      HAL_GPIO_WritePin

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000006   0x6001             STR      R1,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x4770             BX       LR
    208          
    209          /**
    210            * @brief  DeInit LEDs.
    211            * @param  Led: LED to be configured. 
    212            *          This parameter can be one of the following values:
    213            *            @arg  LED1
    214            * @note Led DeInit does not disable the GPIO clock
    215            * @retval None
    216            */

   \                                 In section .text, align 2, keep-with-next
    217          void BSP_LED_DeInit(Led_TypeDef Led)
    218          {
   \                     BSP_LED_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    219            GPIO_InitTypeDef  gpio_init_structure;
    220            GPIO_TypeDef*     gpio_led;
    221          
    222            if (Led == LED1)
   \   00000002   0xB938             CBNZ.N   R0,??BSP_LED_DeInit_0
    223            {
    224              gpio_led = LED1_GPIO_PORT;
    225              /* Turn off LED */
    226              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable23_1  ;; 0x40022000
   \   00000008   0x.... 0x....      BL       ?Subroutine12
    227              /* Configure the GPIO_LED pin */
    228              gpio_init_structure.Pin = GPIO_PIN[Led];
    229              HAL_GPIO_DeInit(gpio_led, gpio_init_structure.Pin);
   \                     ??CrossCallReturnLabel_10: (+1)
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000012   0x....             B.N      ?Subroutine0
    230            }
    231          }
   \                     ??BSP_LED_DeInit_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0xE8BD 0x4010      POP      {R4,LR}
   \   00000004   0x.... 0x....      B.W      HAL_GPIO_DeInit
    232          
    233          /**
    234            * @brief  Turns selected LED On.
    235            * @param  Led: LED to be set on 
    236            *          This parameter can be one of the following values:
    237            *            @arg  LED1
    238            * @retval None
    239            */

   \                                 In section .text, align 2, keep-with-next
    240          void BSP_LED_On(Led_TypeDef Led)
    241          {
    242            GPIO_TypeDef*     gpio_led;
    243          
    244            if (Led == LED1)	/* Switch On LED connected to GPIO */
   \                     BSP_LED_On: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??BSP_LED_On_0
    245            {
    246              gpio_led = LED1_GPIO_PORT;
    247              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x....             B.N      ?Subroutine1
    248            }
    249          }
   \                     ??BSP_LED_On_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF44F 0x6180      MOV      R1,#+1024
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40022000
   \   00000008   0x.... 0x....      B.W      HAL_GPIO_WritePin
    250          
    251          /**
    252            * @brief  Turns selected LED Off. 
    253            * @param  Led: LED to be set off
    254            *          This parameter can be one of the following values:
    255            *            @arg  LED1
    256            * @retval None
    257            */

   \                                 In section .text, align 2, keep-with-next
    258          void BSP_LED_Off(Led_TypeDef Led)
    259          {
    260            GPIO_TypeDef*     gpio_led;
    261          
    262            if (Led == LED1) /* Switch Off LED connected to GPIO */
   \                     BSP_LED_Off: (+1)
   \   00000000   0xB908             CBNZ.N   R0,??BSP_LED_Off_0
    263            {
    264              gpio_led = LED1_GPIO_PORT;
    265              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             B.N      ?Subroutine1
    266            }
    267          }
   \                     ??BSP_LED_Off_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    268          
    269          /**
    270            * @brief  Toggles the selected LED.
    271            * @param  Led: LED to be toggled
    272            *          This parameter can be one of the following values:
    273            *            @arg  LED1
    274            * @retval None
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          void BSP_LED_Toggle(Led_TypeDef Led)
    277          {
    278            GPIO_TypeDef*     gpio_led;
    279          
    280            if (Led == LED1)	/* Toggle LED connected to GPIO */
   \                     BSP_LED_Toggle: (+1)
   \   00000000   0xB928             CBNZ.N   R0,??BSP_LED_Toggle_0
    281            {
    282              gpio_led = LED1_GPIO_PORT;
    283              HAL_GPIO_TogglePin(gpio_led, GPIO_PIN[Led]);
   \   00000002   0xF44F 0x6180      MOV      R1,#+1024
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40022000
   \   0000000A   0x.... 0x....      B.W      HAL_GPIO_TogglePin
    284            }
    285          }
   \                     ??BSP_LED_Toggle_0: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    286          
    287          /**
    288            * @brief  Configures button GPIO and EXTI Line.
    289            * @param  Button: Button to be configured
    290            *          This parameter can be one of the following values:
    291            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    292            *            @arg  BUTTON_TAMPER: Tamper Push Button  
    293            *            @arg  BUTTON_KEY: Key Push Button
    294            * @param  ButtonMode: Button mode
    295            *          This parameter can be one of the following values:
    296            *            @arg  BUTTON_MODE_GPIO: Button will be used as simple IO
    297            *            @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line 
    298            *                                    with interrupt generation capability
    299            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons)
    300            *       are mapped on the same push button named "User"
    301            *       on the board serigraphy.
    302            * @retval None
    303            */

   \                                 In section .text, align 2, keep-with-next
    304          void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
    305          {
   \                     BSP_PB_Init: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0x460D             MOV      R5,R1
    306            GPIO_InitTypeDef gpio_init_structure;
    307            
    308            /* Enable the BUTTON clock */
    309            BUTTONx_GPIO_CLK_ENABLE(Button);
   \   0000000A   0x4626             MOV      R6,R4
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40023830
   \   00000010   0x.... 0x....      BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_7: (+1)
   \   00000014   0xF400 0x7080      AND      R0,R0,#0x100
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
    310            
    311            if(ButtonMode == BUTTON_MODE_GPIO)
   \   0000001C   0x.... 0x....      LDR.W    R7,??DataTable23_2
   \   00000020   0x.... 0x....      ADR.W    R8,BUTTON_PIN
   \   00000024   0xB94D             CBNZ.N   R5,??BSP_PB_Init_0
    312            {
    313              /* Configure Button pin as input */
    314              gpio_init_structure.Pin = BUTTON_PIN[Button];
   \   00000026   0x.... 0x....      BL       ?Subroutine13
    315              gpio_init_structure.Mode = GPIO_MODE_INPUT;
    316              gpio_init_structure.Pull = GPIO_NOPULL;
    317              gpio_init_structure.Speed = GPIO_SPEED_FAST;
    318              HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
    319            }
   \                     ??CrossCallReturnLabel_12: (+1)
   \   0000002A   0x9002             STR      R0,[SP, #+8]
   \   0000002C   0x9003             STR      R0,[SP, #+12]
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x9004             STR      R0,[SP, #+16]
   \   00000032   0xF857 0x0026      LDR      R0,[R7, R6, LSL #+2]
   \   00000036   0x.... 0x....      BL       HAL_GPIO_Init
    320            
    321            if(ButtonMode == BUTTON_MODE_EXTI)
   \                     ??BSP_PB_Init_0: (+1)
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD11B             BNE.N    ??BSP_PB_Init_1
    322            {
    323              /* Configure Button pin as input with External interrupt */
    324              gpio_init_structure.Pin = BUTTON_PIN[Button];
   \   0000003E   0x.... 0x....      BL       ?Subroutine13
    325              gpio_init_structure.Pull = GPIO_NOPULL;
    326              gpio_init_structure.Speed = GPIO_SPEED_FAST;
    327              
    328              if(Button != BUTTON_WAKEUP)
    329              {
    330                gpio_init_structure.Mode = GPIO_MODE_IT_FALLING; 
    331              }
    332              else
    333              {
    334                gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
    335              }
    336              
    337              HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000042   0x9003             STR      R0,[SP, #+12]
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0x9004             STR      R0,[SP, #+16]
   \   0000004A   0xBF14             ITE      NE 
   \   0000004C   0x.... 0x....      LDRNE.W  R0,??DataTable23_3  ;; 0x10210000
   \   00000050   0x.... 0x....      LDREQ.W  R0,??DataTable23_4  ;; 0x10110000
   \   00000054   0x9002             STR      R0,[SP, #+8]
   \   00000056   0xF857 0x0026      LDR      R0,[R7, R6, LSL #+2]
   \   0000005A   0x.... 0x....      BL       HAL_GPIO_Init
   \   0000005E   0x.... 0x....      ADR.W    R0,BUTTON_IRQn
   \   00000062   0x2200             MOVS     R2,#+0
   \   00000064   0x210F             MOVS     R1,#+15
   \   00000066   0xF830 0x4016      LDRH     R4,[R0, R6, LSL #+1]
   \   0000006A   0xB260             SXTB     R0,R4
    338              
    339              /* Enable and set Button EXTI Interrupt to the lowest priority */
    340              HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
   \   0000006C   0x.... 0x....      BL       HAL_NVIC_SetPriority
    341              HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
   \   00000070   0xB260             SXTB     R0,R4
   \   00000072   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    342            }
    343          }
   \                     ??BSP_PB_Init_1: (+1)
   \   00000076   0xB006             ADD      SP,SP,#+24
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0xF838 0x0016      LDRH     R0,[R8, R6, LSL #+1]
   \   00000004   0xA901             ADD      R1,SP,#+4
   \   00000006   0x9001             STR      R0,[SP, #+4]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR
    344          
    345          /**
    346            * @brief  Push Button DeInit.
    347            * @param  Button: Button to be configured
    348            *          This parameter can be one of the following values:
    349            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    350            *            @arg  BUTTON_TAMPER: Tamper Push Button  
    351            *            @arg  BUTTON_KEY: Key Push Button
    352            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons) 
    353            *       are mapped on the same push button named "User"
    354            *       on the board serigraphy.
    355            * @note PB DeInit does not disable the GPIO clock
    356            * @retval None
    357            */

   \                                 In section .text, align 2, keep-with-next
    358          void BSP_PB_DeInit(Button_TypeDef Button)
    359          {
   \                     BSP_PB_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    360              GPIO_InitTypeDef gpio_init_structure;
    361          
    362              gpio_init_structure.Pin = BUTTON_PIN[Button];
    363              HAL_NVIC_DisableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
   \   00000004   0x.... 0x....      ADR.W    R0,BUTTON_IRQn
   \   00000008   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   0000000C   0xB240             SXTB     R0,R0
   \   0000000E   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    364              HAL_GPIO_DeInit(BUTTON_PORT[Button], gpio_init_structure.Pin);
   \   00000012   0x.... 0x....      ADR.W    R0,BUTTON_PIN
   \   00000016   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   0000001A   0x....             LDR.N    R0,??DataTable23_2
   \   0000001C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000020                      REQUIRE ?Subroutine0
   \   00000020                      ;; // Fall through to label ?Subroutine0
    365          }
    366          
    367          
    368          /**
    369            * @brief  Returns the selected button state.
    370            * @param  Button: Button to be checked
    371            *          This parameter can be one of the following values:
    372            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    373            *            @arg  BUTTON_TAMPER: Tamper Push Button 
    374            *            @arg  BUTTON_KEY: Key Push Button
    375            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons) 
    376            *       are mapped on the same push button named "User"
    377            *       on the board serigraphy.
    378            * @retval The Button GPIO pin value
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          uint32_t BSP_PB_GetState(Button_TypeDef Button)
    381          {
    382            return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
   \                     BSP_PB_GetState: (+1)
   \   00000000   0x.... 0x....      ADR.W    R1,BUTTON_PIN
   \   00000004   0x....             LDR.N    R2,??DataTable23_2
   \   00000006   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   0000000A   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   0000000E   0x.... 0x....      B.W      HAL_GPIO_ReadPin
    383          }
    384          
    385          /**
    386            * @brief  Configures COM port.
    387            * @param  COM: COM port to be configured.
    388            *          This parameter can be one of the following values:
    389            *            @arg  COM1 
    390            *            @arg  COM2 
    391            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains the
    392            *                configuration information for the specified USART peripheral.
    393            * @retval None
    394            */

   \                                 In section .text, align 2, keep-with-next
    395          void BSP_COM_Init(COM_TypeDef COM, UART_HandleTypeDef *huart)
    396          {
   \                     BSP_COM_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x460C             MOV      R4,R1
    397            GPIO_InitTypeDef gpio_init_structure;
    398          
    399            /* Enable GPIO clock */
    400            DISCOVERY_COMx_TX_GPIO_CLK_ENABLE(COM);
   \   00000008   0xD11B             BNE.N    ??BSP_COM_Init_0
   \   0000000A   0x....             LDR.N    R0,??DataTable23  ;; 0x40023830
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x9900             LDR      R1,[SP, #+0]
    401            DISCOVERY_COMx_RX_GPIO_CLK_ENABLE(COM);
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0xF001 0x0102      AND      R1,R1,#0x2
   \   0000002C   0x9100             STR      R1,[SP, #+0]
   \   0000002E   0x9900             LDR      R1,[SP, #+0]
    402          
    403            /* Enable USART clock */
    404            DISCOVERY_COMx_CLK_ENABLE(COM);
   \   00000030   0x6941             LDR      R1,[R0, #+20]
   \   00000032   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000036   0x6141             STR      R1,[R0, #+20]
   \   00000038   0x6940             LDR      R0,[R0, #+20]
   \   0000003A   0xF000 0x0010      AND      R0,R0,#0x10
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x9800             LDR      R0,[SP, #+0]
    405          
    406            /* Configure USART Tx as alternate function */
    407            gpio_init_structure.Pin = COM_TX_PIN[COM];
   \                     ??BSP_COM_Init_0: (+1)
   \   00000042   0x.... 0x....      ADR.W    R0,COM_TX_PIN
    408            gpio_init_structure.Mode = GPIO_MODE_AF_PP;
    409            gpio_init_structure.Speed = GPIO_SPEED_FAST;
    410            gpio_init_structure.Pull = GPIO_PULLUP;
    411            gpio_init_structure.Alternate = COM_TX_AF[COM];
    412            HAL_GPIO_Init(COM_TX_PORT[COM], &gpio_init_structure);
   \   00000046   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000004A   0x9004             STR      R0,[SP, #+16]
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x9003             STR      R0,[SP, #+12]
   \   00000050   0x.... 0x....      ADR.W    R0,COM_TX_AF
   \   00000054   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000058   0x9005             STR      R0,[SP, #+20]
   \   0000005A   0x....             LDR.N    R0,??DataTable23_5
   \   0000005C   0xEB00 0x0685      ADD      R6,R0,R5, LSL #+2
   \   00000060   0x6870             LDR      R0,[R6, #+4]
   \   00000062   0x.... 0x....      BL       HAL_GPIO_Init
    413          
    414            /* Configure USART Rx as alternate function */
    415            gpio_init_structure.Pin = COM_RX_PIN[COM];
   \   00000066   0x.... 0x....      ADR.W    R0,COM_RX_PIN
    416            gpio_init_structure.Mode = GPIO_MODE_AF_PP;
    417            gpio_init_structure.Alternate = COM_RX_AF[COM];
    418            HAL_GPIO_Init(COM_RX_PORT[COM], &gpio_init_structure);
   \   0000006A   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000006E   0x.... 0x....      ADR.W    R0,COM_RX_AF
   \   00000072   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000076   0x9005             STR      R0,[SP, #+20]
   \   00000078   0x68B0             LDR      R0,[R6, #+8]
   \   0000007A   0x.... 0x....      BL       HAL_GPIO_Init
    419          
    420            /* USART configuration */
    421            huart->Instance = COM_USART[COM];
   \   0000007E   0x6830             LDR      R0,[R6, #+0]
   \   00000080   0x6020             STR      R0,[R4, #+0]
    422            HAL_UART_Init(huart);
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       HAL_UART_Init
    423          }
   \   00000088   0xB006             ADD      SP,SP,#+24
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0xA901             ADD      R1,SP,#+4
   \   00000002   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000006   0x9001             STR      R0,[SP, #+4]
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x9002             STR      R0,[SP, #+8]
   \   0000000C   0x4770             BX       LR
    424          
    425          /**
    426            * @brief  DeInit COM port.
    427            * @param  COM: COM port to be configured.
    428            *          This parameter can be one of the following values:
    429            *            @arg  COM1 
    430            *            @arg  COM2 
    431            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains the
    432            *                configuration information for the specified USART peripheral.
    433            * @retval None
    434            */

   \                                 In section .text, align 2, keep-with-next
    435          void BSP_COM_DeInit(COM_TypeDef COM, UART_HandleTypeDef *huart)
    436          {
   \                     BSP_COM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    437            /* USART configuration */
    438            huart->Instance = COM_USART[COM];
   \   00000006   0x....             LDR.N    R1,??DataTable23_5
   \   00000008   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    439            HAL_UART_DeInit(huart);
   \   0000000E   0x.... 0x....      BL       HAL_UART_DeInit
    440          
    441            /* Enable USART clock */
    442            DISCOVERY_COMx_CLK_DISABLE(COM);
   \   00000012   0xB924             CBNZ.N   R4,??BSP_COM_DeInit_0
   \   00000014   0x....             LDR.N    R0,??DataTable23_6  ;; 0x40023844
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF021 0x0110      BIC      R1,R1,#0x10
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    443          
    444            /* DeInit GPIO pins can be done in the application 
    445               (by surcharging this __weak function) */
    446          
    447            /* GPIO pins clock, DMA clock can be shut down in the application 
    448               by surcharging this __weak function */
    449          }
   \                     ??BSP_COM_DeInit_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    450          
    451          /*******************************************************************************
    452                                      BUS OPERATIONS
    453          *******************************************************************************/
    454          
    455          /******************************* I2C Routines *********************************/
    456          /**
    457            * @brief  Initializes I2C MSP.
    458            * @param  i2c_handler : I2C handler
    459            * @retval None
    460            */

   \                                 In section .text, align 2, keep-with-next
    461          static void I2Cx_MspInit(I2C_HandleTypeDef *i2c_handler)
    462          {
   \                     I2Cx_MspInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    463            GPIO_InitTypeDef  gpio_init_structure;
    464            
    465            if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
   \   00000002   0x....             LDR.N    R4,??DataTable23_7  ;; 0x40023820
   \   00000004   0x....             LDR.N    R1,??DataTable23_8
   \   00000006   0xB086             SUB      SP,SP,#+24
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xF44F 0x7580      MOV      R5,#+256
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0xD136             BNE.N    ??I2Cx_MspInit_0
    466            {
    467              /* AUDIO and LCD I2C MSP init */
    468          
    469              /*** Configure the GPIOs ***/
    470              /* Enable GPIO clock */
    471              DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
   \   00000012   0xF040 0x0080      ORR      R0,R0,#0x80
    472          
    473              /* Configure I2C Tx as alternate function */
    474              gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SCL_PIN;
    475              gpio_init_structure.Mode = GPIO_MODE_AF_OD;
    476              gpio_init_structure.Pull = GPIO_NOPULL;
    477              gpio_init_structure.Speed = GPIO_SPEED_FAST;
    478              gpio_init_structure.Alternate = DISCOVERY_AUDIO_I2Cx_SCL_SDA_AF;
    479              HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   00000016   0x....             LDR.N    R6,??DataTable23_9  ;; 0x40021c00
   \   00000018   0x6120             STR      R0,[R4, #+16]
   \   0000001A   0x6920             LDR      R0,[R4, #+16]
   \   0000001C   0xA901             ADD      R1,SP,#+4
   \   0000001E   0xF000 0x0080      AND      R0,R0,#0x80
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x2080             MOVS     R0,#+128
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x2012             MOVS     R0,#+18
   \   0000002C   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0x.... 0x....      BL       HAL_GPIO_Init
    480          
    481              /* Configure I2C Rx as alternate function */
    482              gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SDA_PIN;
   \   00000036   0x9501             STR      R5,[SP, #+4]
    483              HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   00000038   0xA901             ADD      R1,SP,#+4
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       HAL_GPIO_Init
    484          
    485              /*** Configure the I2C peripheral ***/
    486              /* Enable I2C clock */
    487              DISCOVERY_AUDIO_I2Cx_CLK_ENABLE();
   \   00000040   0x6A20             LDR      R0,[R4, #+32]
    488          
    489              /* Force the I2C peripheral clock reset */
    490              DISCOVERY_AUDIO_I2Cx_FORCE_RESET();
    491          
    492              /* Release the I2C peripheral clock reset */
    493              DISCOVERY_AUDIO_I2Cx_RELEASE_RESET();
    494          
    495              /* Enable and set I2Cx Interrupt to a lower priority */
    496              HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_EV_IRQn, 0x05, 0);
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x2105             MOVS     R1,#+5
   \   00000046   0xF440 0x0000      ORR      R0,R0,#0x800000
   \   0000004A   0x6220             STR      R0,[R4, #+32]
   \   0000004C   0x6A20             LDR      R0,[R4, #+32]
   \   0000004E   0xF400 0x0000      AND      R0,R0,#0x800000
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0xF440 0x0000      ORR      R0,R0,#0x800000
   \   0000005C   0x6020             STR      R0,[R4, #+0]
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0xF420 0x0000      BIC      R0,R0,#0x800000
   \   00000064   0x6020             STR      R0,[R4, #+0]
   \   00000066   0x2048             MOVS     R0,#+72
   \   00000068   0x.... 0x....      BL       HAL_NVIC_SetPriority
    497              HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_EV_IRQn);
   \   0000006C   0x2048             MOVS     R0,#+72
   \   0000006E   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    498          
    499              /* Enable and set I2Cx Interrupt to a lower priority */
    500              HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_ER_IRQn, 0x05, 0);
   \   00000072   0x2200             MOVS     R2,#+0
   \   00000074   0x2105             MOVS     R1,#+5
   \   00000076   0x2049             MOVS     R0,#+73
   \   00000078   0x.... 0x....      BL       HAL_NVIC_SetPriority
    501              HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_ER_IRQn);
   \   0000007C   0x2049             MOVS     R0,#+73
   \   0000007E   0xE036             B.N      ??I2Cx_MspInit_1
    502            }
    503            else
    504            {
    505              /* External, camera and Arduino connector I2C MSP init */
    506          
    507              /*** Configure the GPIOs ***/
    508              /* Enable GPIO clock */
    509              DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
   \                     ??I2Cx_MspInit_0: (+1)
   \   00000080   0xF040 0x0002      ORR      R0,R0,#0x2
    510          
    511              /* Configure I2C Tx as alternate function */
    512              gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
    513              gpio_init_structure.Mode = GPIO_MODE_AF_OD;
    514              gpio_init_structure.Pull = GPIO_NOPULL;
    515              gpio_init_structure.Speed = GPIO_SPEED_FAST;
    516              gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
    517              HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   00000084   0xA901             ADD      R1,SP,#+4
   \   00000086   0x6120             STR      R0,[R4, #+16]
   \   00000088   0x6920             LDR      R0,[R4, #+16]
   \   0000008A   0xF000 0x0002      AND      R0,R0,#0x2
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0x2012             MOVS     R0,#+18
   \   00000094   0x9501             STR      R5,[SP, #+4]
   \   00000096   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000009A   0x....             LDR.N    R5,??DataTable23_10  ;; 0x40020400
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0x.... 0x....      BL       HAL_GPIO_Init
    518          
    519              /* Configure I2C Rx as alternate function */
    520              gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
   \   000000A2   0xF44F 0x7000      MOV      R0,#+512
    521              HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   000000A6   0xA901             ADD      R1,SP,#+4
   \   000000A8   0x9001             STR      R0,[SP, #+4]
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       HAL_GPIO_Init
    522          
    523              /*** Configure the I2C peripheral ***/
    524              /* Enable I2C clock */
    525              DISCOVERY_EXT_I2Cx_CLK_ENABLE();
   \   000000B0   0x6A20             LDR      R0,[R4, #+32]
    526          
    527              /* Force the I2C peripheral clock reset */
    528              DISCOVERY_EXT_I2Cx_FORCE_RESET();
    529          
    530              /* Release the I2C peripheral clock reset */
    531              DISCOVERY_EXT_I2Cx_RELEASE_RESET();
    532          
    533              /* Enable and set I2Cx Interrupt to a lower priority */
    534              HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x05, 0);
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x2105             MOVS     R1,#+5
   \   000000B6   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   000000BA   0x6220             STR      R0,[R4, #+32]
   \   000000BC   0x6A20             LDR      R0,[R4, #+32]
   \   000000BE   0xF400 0x1000      AND      R0,R0,#0x200000
   \   000000C2   0x9000             STR      R0,[SP, #+0]
   \   000000C4   0x9800             LDR      R0,[SP, #+0]
   \   000000C6   0x6820             LDR      R0,[R4, #+0]
   \   000000C8   0xF440 0x1000      ORR      R0,R0,#0x200000
   \   000000CC   0x6020             STR      R0,[R4, #+0]
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0xF420 0x1000      BIC      R0,R0,#0x200000
   \   000000D4   0x6020             STR      R0,[R4, #+0]
   \   000000D6   0x201F             MOVS     R0,#+31
   \   000000D8   0x.... 0x....      BL       HAL_NVIC_SetPriority
    535              HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_EV_IRQn);
   \   000000DC   0x201F             MOVS     R0,#+31
   \   000000DE   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    536          
    537              /* Enable and set I2Cx Interrupt to a lower priority */
    538              HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x05, 0);
   \   000000E2   0x2200             MOVS     R2,#+0
   \   000000E4   0x2105             MOVS     R1,#+5
   \   000000E6   0x2020             MOVS     R0,#+32
   \   000000E8   0x.... 0x....      BL       HAL_NVIC_SetPriority
    539              HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
   \   000000EC   0x2020             MOVS     R0,#+32
   \                     ??I2Cx_MspInit_1: (+1)
   \   000000EE   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    540            }
    541          }
   \   000000F2   0xB006             ADD      SP,SP,#+24
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x9002             STR      R0,[SP, #+8]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9003             STR      R0,[SP, #+12]
   \   00000006   0x2002             MOVS     R0,#+2
   \   00000008   0x9004             STR      R0,[SP, #+16]
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x9005             STR      R0,[SP, #+20]
   \   0000000E   0x4770             BX       LR
    542          
    543          /**
    544            * @brief  Initializes I2C HAL.
    545            * @param  i2c_handler : I2C handler
    546            * @retval None
    547            */

   \                                 In section .text, align 2, keep-with-next
    548          static void I2Cx_Init(I2C_HandleTypeDef *i2c_handler)
    549          {
   \                     I2Cx_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    550            if(HAL_I2C_GetState(i2c_handler) == HAL_I2C_STATE_RESET)
   \   00000004   0x.... 0x....      BL       HAL_I2C_GetState
   \   00000008   0xB9C0             CBNZ.N   R0,??I2Cx_Init_0
    551            {
    552              if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
   \   0000000A   0x....             LDR.N    R0,??DataTable23_8
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xBF0C             ITE      EQ 
   \   00000010   0x....             LDREQ.N  R0,??DataTable23_11  ;; 0x40005c00
   \   00000012   0x....             LDRNE.N  R0,??DataTable23_12  ;; 0x40005400
    553              {
    554                /* Audio and LCD I2C configuration */
    555                i2c_handler->Instance = DISCOVERY_AUDIO_I2Cx;
    556              }
    557              else
    558              {
    559                /* External, camera and Arduino connector  I2C configuration */
    560                i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
   \   00000014   0x6020             STR      R0,[R4, #+0]
    561              }
    562              i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
   \   00000016   0x....             LDR.N    R0,??DataTable23_13  ;; 0x40912732
   \   00000018   0x6060             STR      R0,[R4, #+4]
    563              i2c_handler->Init.OwnAddress1      = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
    564              i2c_handler->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x60E0             STR      R0,[R4, #+12]
    565              i2c_handler->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6120             STR      R0,[R4, #+16]
    566              i2c_handler->Init.OwnAddress2      = 0;
   \   00000026   0x6160             STR      R0,[R4, #+20]
    567              i2c_handler->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
   \   00000028   0x61E0             STR      R0,[R4, #+28]
    568              i2c_handler->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
   \   0000002A   0x6220             STR      R0,[R4, #+32]
    569          
    570              /* Init the I2C */
    571              I2Cx_MspInit(i2c_handler);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       I2Cx_MspInit
    572              HAL_I2C_Init(i2c_handler);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xE8BD 0x4010      POP      {R4,LR}
   \   00000038   0x.... 0x....      B.W      HAL_I2C_Init
    573            }
    574          }
   \                     ??I2Cx_Init_0: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    575          
    576          /**
    577            * @brief  Reads multiple data.
    578            * @param  i2c_handler : I2C handler
    579            * @param  Addr: I2C address
    580            * @param  Reg: Reg address 
    581            * @param  MemAddress: Memory address 
    582            * @param  Buffer: Pointer to data buffer
    583            * @param  Length: Length of the data
    584            * @retval Number of read data
    585            */

   \                                 In section .text, align 2, keep-with-next
    586          static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef *i2c_handler,
    587                                                     uint8_t Addr,
    588                                                     uint16_t Reg,
    589                                                     uint16_t MemAddress,
    590                                                     uint8_t *Buffer,
    591                                                     uint16_t Length)
    592          {
   \                     I2Cx_ReadMultiple: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB084             SUB      SP,SP,#+16
    593            HAL_StatusTypeDef status = HAL_OK;
    594          
    595            status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
   \   00000006   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000000A   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \   0000000E   0x....             B.N      ?Subroutine2
    596          
    597            /* Check the communication status */
    598            if(status != HAL_OK)
    599            {
    600              /* I2C error occurred */
    601              I2Cx_Error(i2c_handler, Addr);
    602            }
    603            return status;    
    604          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x0006             MOVS     R6,R0
   \   00000002   0xD003             BEQ.N    ??Subroutine2_0
   \   00000004   0x4629             MOV      R1,R5
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       I2Cx_Error
   \                     ??Subroutine2_0: (+1)
   \   0000000C   0x4630             MOV      R0,R6
   \   0000000E   0xB004             ADD      SP,SP,#+16
   \   00000010   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0xF44F 0x707A      MOV      R0,#+1000
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x9002             STR      R0,[SP, #+8]
   \   00000008   0x9809             LDR      R0,[SP, #+36]
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0x9808             LDR      R0,[SP, #+32]
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x4770             BX       LR
    605          
    606          /**
    607            * @brief  Writes a value in a register of the device through BUS in using DMA mode.
    608            * @param  i2c_handler : I2C handler
    609            * @param  Addr: Device address on BUS Bus.  
    610            * @param  Reg: The target register address to write
    611            * @param  MemAddress: Memory address 
    612            * @param  Buffer: The target register value to be written 
    613            * @param  Length: buffer size to be written
    614            * @retval HAL status
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef *i2c_handler,
    617                                                      uint8_t Addr,
    618                                                      uint16_t Reg,
    619                                                      uint16_t MemAddress,
    620                                                      uint8_t *Buffer,
    621                                                      uint16_t Length)
    622          {
   \                     I2Cx_WriteMultiple: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB084             SUB      SP,SP,#+16
    623            HAL_StatusTypeDef status = HAL_OK;
    624            
    625            status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
   \   00000006   0x.... 0x....      BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_5: (+1)
   \   0000000A   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \   0000000E                      REQUIRE ?Subroutine2
   \   0000000E                      ;; // Fall through to label ?Subroutine2
    626            
    627            /* Check the communication status */
    628            if(status != HAL_OK)
    629            {
    630              /* Re-Initiaize the I2C Bus */
    631              I2Cx_Error(i2c_handler, Addr);
    632            }
    633            return status;
    634          }
    635          
    636          /**
    637            * @brief  Checks if target device is ready for communication. 
    638            * @note   This function is used with Memory devices
    639            * @param  i2c_handler : I2C handler
    640            * @param  DevAddress: Target device address
    641            * @param  Trials: Number of trials
    642            * @retval HAL status
    643            */
    644          static HAL_StatusTypeDef I2Cx_IsDeviceReady(I2C_HandleTypeDef *i2c_handler, uint16_t DevAddress, uint32_t Trials)
    645          { 
    646            return (HAL_I2C_IsDeviceReady(i2c_handler, DevAddress, Trials, 1000));
    647          }
    648          
    649          /**
    650            * @brief  Manages error callback by re-initializing I2C.
    651            * @param  i2c_handler : I2C handler
    652            * @param  Addr: I2C Address
    653            * @retval None
    654            */

   \                                 In section .text, align 2, keep-with-next
    655          static void I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr)
    656          {
   \                     I2Cx_Error: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    657            /* De-initialize the I2C communication bus */
    658            HAL_I2C_DeInit(i2c_handler);
   \   00000004   0x.... 0x....      BL       HAL_I2C_DeInit
    659            
    660            /* Re-Initialize the I2C communication bus */
    661            I2Cx_Init(i2c_handler);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000000E   0x....             B.N      I2Cx_Init
    662          }
    663          
    664          /*******************************************************************************
    665                                      LINK OPERATIONS
    666          *******************************************************************************/
    667          
    668          /********************************* LINK AUDIO *********************************/
    669          
    670          /**
    671            * @brief  Initializes Audio low level.
    672            * @retval None
    673            */

   \                                 In section .text, align 2, keep-with-next
    674          void AUDIO_IO_Init(void) 
    675          {
    676            I2Cx_Init(&hI2cAudioHandler);
   \                     AUDIO_IO_Init: (+1)
   \   00000000   0x....             B.N      ?Subroutine3
    677          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable23_8
   \   00000002   0x....             B.N      I2Cx_Init
    678          
    679          /**
    680            * @brief  Deinitializes Audio low level.
    681            * @retval None
    682            */

   \                                 In section .text, align 2, keep-with-next
    683          void AUDIO_IO_DeInit(void)
    684          {
    685          }
   \                     AUDIO_IO_DeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    686          
    687          /**
    688            * @brief  Writes a single data.
    689            * @param  Addr: I2C address
    690            * @param  Reg: Reg address 
    691            * @param  Value: Data to be written
    692            * @retval None
    693            */

   \                                 In section .text, align 2, keep-with-next
    694          void AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
    695          {
   \                     AUDIO_IO_Write: (+1)
   \   00000000   0xB507             PUSH     {R0-R2,LR}
    696            uint16_t tmp = Value;
    697            
    698            Value = ((uint16_t)(tmp >> 8) & 0x00FF);
    699            
    700            Value |= ((uint16_t)(tmp << 8)& 0xFF00);
   \   00000002   0x0213             LSLS     R3,R2,#+8
   \   00000004   0xEA43 0x2212      ORR      R2,R3,R2, LSR #+8
    701            
    702            I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2);
   \   00000008   0x2302             MOVS     R3,#+2
   \   0000000A   0xF8AD 0x2008      STRH     R2,[SP, #+8]
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0x....             B.N      ?Subroutine5
    703          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x.... 0x....      BL       ?Subroutine15
   \                     ??Subroutine5_0: (+1)
   \   00000004   0x.... 0x....      BL       I2Cx_WriteMultiple
   \   00000008   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \   00000000   0x9201             STR      R2,[SP, #+4]
   \   00000002   0xAA02             ADD      R2,SP,#+8
   \   00000004   0x9200             STR      R2,[SP, #+0]
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x....             LDR.N    R0,??DataTable23_8
   \   0000000C   0x4770             BX       LR
    704          
    705          /**
    706            * @brief  Reads a single data.
    707            * @param  Addr: I2C address
    708            * @param  Reg: Reg address 
    709            * @retval Data to be read
    710            */

   \                                 In section .text, align 2, keep-with-next
    711          uint16_t AUDIO_IO_Read(uint8_t Addr, uint16_t Reg)
    712          {
   \                     AUDIO_IO_Read: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    713            uint16_t read_value = 0, tmp = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    714            
    715            I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2);
   \   00000004   0x2302             MOVS     R3,#+2
   \   00000006   0xF8AD 0x2008      STRH     R2,[SP, #+8]
   \   0000000A   0x2202             MOVS     R2,#+2
   \   0000000C   0x.... 0x....      BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000010   0x.... 0x....      BL       I2Cx_ReadMultiple
    716            
    717            tmp = ((uint16_t)(read_value >> 8) & 0x00FF);
    718            
    719            tmp |= ((uint16_t)(read_value << 8)& 0xFF00);
    720            
    721            read_value = tmp;
    722            
    723            return read_value;
   \   00000014   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000018   0x0201             LSLS     R1,R0,#+8
   \   0000001A   0xEA41 0x2010      ORR      R0,R1,R0, LSR #+8
   \   0000001E   0xB280             UXTH     R0,R0
   \   00000020   0xBD0E             POP      {R1-R3,PC}       ;; return
    724          }
    725          
    726          /**
    727            * @brief  AUDIO Codec delay 
    728            * @param  Delay: Delay in ms
    729            * @retval None
    730            */

   \                                 In section .text, align 2, keep-with-next
    731          void AUDIO_IO_Delay(uint32_t Delay)
    732          {
    733            HAL_Delay(Delay);
   \                     AUDIO_IO_Delay: (+1)
   \   00000000   0x.... 0x....      B.W      HAL_Delay
    734          }
    735          
    736          /********************************* LINK CAMERA ********************************/
    737          
    738          /**
    739            * @brief  Initializes Camera low level.
    740            * @retval None
    741            */

   \                                 In section .text, align 2, keep-with-next
    742          void CAMERA_IO_Init(void) 
    743          {
    744            I2Cx_Init(&hI2cExtHandler);
   \                     CAMERA_IO_Init: (+1)
   \   00000000   0x....             B.N      ?Subroutine4
    745          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable23_14
   \   00000002   0x....             B.N      I2Cx_Init
    746          
    747          /**
    748            * @brief  Camera writes single data.
    749            * @param  Addr: I2C address
    750            * @param  Reg: Register address 
    751            * @param  Value: Data to be written
    752            * @retval None
    753            */

   \                                 In section .text, align 2, keep-with-next
    754          void CAMERA_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
    755          {
   \                     CAMERA_IO_Write: (+1)
   \   00000000   0xB507             PUSH     {R0-R2,LR}
    756            I2Cx_WriteMultiple(&hI2cExtHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x9201             STR      R2,[SP, #+4]
   \   00000008   0xAA02             ADD      R2,SP,#+8
   \   0000000A   0x9200             STR      R2,[SP, #+0]
   \   0000000C   0x460A             MOV      R2,R1
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0x....             LDR.N    R0,??DataTable23_14
   \   00000012   0x....             B.N      ??Subroutine5_0
    757          }
    758          
    759          /**
    760            * @brief  Camera reads single data.
    761            * @param  Addr: I2C address
    762            * @param  Reg: Register address 
    763            * @retval Read data
    764            */

   \                                 In section .text, align 2, keep-with-next
    765          uint8_t CAMERA_IO_Read(uint8_t Addr, uint8_t Reg)
    766          {
   \                     CAMERA_IO_Read: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    767            uint8_t read_value = 0;
   \   00000002   0x.... 0x....      BL       ?Subroutine11
    768          
    769            I2Cx_ReadMultiple(&hI2cExtHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable23_14
   \   00000008   0x....             B.N      ?Subroutine6
    770          
    771            return read_value;
    772          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x.... 0x....      BL       I2Cx_ReadMultiple
   \   00000004   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000008   0xBD0E             POP      {R1-R3,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0xF88D 0x2008      STRB     R2,[SP, #+8]
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x9201             STR      R2,[SP, #+4]
   \   0000000C   0xAA02             ADD      R2,SP,#+8
   \   0000000E   0x9200             STR      R2,[SP, #+0]
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x4770             BX       LR
    773          
    774          /**
    775            * @brief  Camera delay 
    776            * @param  Delay: Delay in ms
    777            * @retval None
    778            */

   \                                 In section .text, align 2, keep-with-next
    779          void CAMERA_Delay(uint32_t Delay)
    780          {
    781            HAL_Delay(Delay);
   \                     CAMERA_Delay: (+1)
   \   00000000   0x.... 0x....      B.W      HAL_Delay
    782          }
    783          
    784          /******************************** LINK I2C EEPROM *****************************/
    785          
    786          /**
    787            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    788            * @retval None
    789            */

   \                                 In section .text, align 2, keep-with-next
    790          void EEPROM_IO_Init(void)
   \                     EEPROM_IO_Init: (+1)
   \   00000000   0xBF00             Nop      
    791          {
    792            I2Cx_Init(&hI2cExtHandler);
   \   00000002                      REQUIRE ?Subroutine4
   \   00000002                      ;; // Fall through to label ?Subroutine4
    793          }
    794          
    795          /**
    796            * @brief  Write data to I2C EEPROM driver in using DMA channel.
    797            * @param  DevAddress: Target device address
    798            * @param  MemAddress: Internal memory address
    799            * @param  pBuffer: Pointer to data buffer
    800            * @param  BufferSize: Amount of data to be sent
    801            * @retval HAL status
    802            */

   \                                 In section .text, align 2, keep-with-next
    803          HAL_StatusTypeDef EEPROM_IO_WriteData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    804          {
   \                     EEPROM_IO_WriteData: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    805            return (I2Cx_WriteMultiple(&hI2cExtHandler, DevAddress, MemAddress, I2C_MEMADD_SIZE_16BIT, pBuffer, BufferSize));
   \   00000004   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_14: (+1)
   \   00000008   0x.... 0x....      BL       I2Cx_WriteMultiple
   \   0000000C   0xBD0E             POP      {R1-R3,PC}       ;; return
    806          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \   00000000   0xB29B             UXTH     R3,R3
   \   00000002   0x9200             STR      R2,[SP, #+0]
   \   00000004   0x460A             MOV      R2,R1
   \   00000006   0x9301             STR      R3,[SP, #+4]
   \   00000008   0xB2C1             UXTB     R1,R0
   \   0000000A   0x2302             MOVS     R3,#+2
   \   0000000C   0x....             LDR.N    R0,??DataTable23_14
   \   0000000E   0x4770             BX       LR
    807          
    808          /**
    809            * @brief  Read data from I2C EEPROM driver in using DMA channel.
    810            * @param  DevAddress: Target device address
    811            * @param  MemAddress: Internal memory address
    812            * @param  pBuffer: Pointer to data buffer
    813            * @param  BufferSize: Amount of data to be read
    814            * @retval HAL status
    815            */

   \                                 In section .text, align 2, keep-with-next
    816          HAL_StatusTypeDef EEPROM_IO_ReadData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    817          {
   \                     EEPROM_IO_ReadData: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    818            return (I2Cx_ReadMultiple(&hI2cExtHandler, DevAddress, MemAddress, I2C_MEMADD_SIZE_16BIT, pBuffer, BufferSize));
   \   00000004   0x.... 0x....      BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000008   0x.... 0x....      BL       I2Cx_ReadMultiple
   \   0000000C   0xBD0E             POP      {R1-R3,PC}       ;; return
    819          }
    820          
    821          /**
    822            * @brief  Checks if target device is ready for communication. 
    823            * @note   This function is used with Memory devices
    824            * @param  DevAddress: Target device address
    825            * @param  Trials: Number of trials
    826            * @retval HAL status
    827            */

   \                                 In section .text, align 2, keep-with-next
    828          HAL_StatusTypeDef EEPROM_IO_IsDeviceReady(uint16_t DevAddress, uint32_t Trials)
    829          { 
    830            return (I2Cx_IsDeviceReady(&hI2cExtHandler, DevAddress, Trials));
   \                     EEPROM_IO_IsDeviceReady: (+1)
   \   00000000   0x460A             MOV      R2,R1
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0xF44F 0x737A      MOV      R3,#+1000
   \   00000008   0x....             LDR.N    R0,??DataTable23_14
   \   0000000A   0x.... 0x....      B.W      HAL_I2C_IsDeviceReady
    831          }
    832          
    833          /********************************* LINK TOUCHSCREEN *********************************/
    834          
    835          /**
    836            * @brief  Initializes Touchscreen low level.
    837            * @retval None
    838            */

   \                                 In section .text, align 2, keep-with-next
    839          void TS_IO_Init(void)
   \                     TS_IO_Init: (+1)
   \   00000000   0xBF00             Nop      
    840          {
    841            I2Cx_Init(&hI2cAudioHandler);
   \   00000002                      REQUIRE ?Subroutine3
   \   00000002                      ;; // Fall through to label ?Subroutine3
    842          }
    843          
    844          /**
    845            * @brief  Writes a single data.
    846            * @param  Addr: I2C address
    847            * @param  Reg: Reg address
    848            * @param  Value: Data to be written
    849            * @retval None
    850            */

   \                                 In section .text, align 2, keep-with-next
    851          void TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
    852          {
   \                     TS_IO_Write: (+1)
   \   00000000   0xB507             PUSH     {R0-R2,LR}
    853            I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006                      REQUIRE ?Subroutine5
   \   00000006                      ;; // Fall through to label ?Subroutine5
    854          }
    855          
    856          /**
    857            * @brief  Reads a single data.
    858            * @param  Addr: I2C address
    859            * @param  Reg: Reg address
    860            * @retval Data to be read
    861            */

   \                                 In section .text, align 4, keep-with-next
    862          uint8_t TS_IO_Read(uint8_t Addr, uint8_t Reg)
    863          {
   \                     TS_IO_Read: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    864            uint8_t read_value = 0;
   \   00000002   0x.... 0x....      BL       ?Subroutine11
    865          
    866            I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000006   0x4801             LDR.N    R0,??TS_IO_Read_0
   \   00000008   0xE002             B.N      ??TS_IO_Read_1
   \   0000000A   0xBF00             Nop      
   \                     ??TS_IO_Read_0:
   \   0000000C   0x........         DC32     hI2cAudioHandler
   \                     ??TS_IO_Read_1: (+1)
   \   00000010                      REQUIRE ?Subroutine6
   \   00000010                      ;; // Fall through to label ?Subroutine6
    867          
    868            return read_value;
    869          }
    870          
    871          /**
    872            * @brief  TS delay
    873            * @param  Delay: Delay in ms
    874            * @retval None
    875            */

   \                                 In section .text, align 2, keep-with-next
    876          void TS_IO_Delay(uint32_t Delay)
    877          {
    878            HAL_Delay(Delay);
   \                     TS_IO_Delay: (+1)
   \   00000000   0x.... 0x....      B.W      HAL_Delay
    879          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x........         DC32     BUTTON_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x10210000         DC32     0x10210000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x........         DC32     COM_USART

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \   00000000   0x........         DC32     hI2cAudioHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \   00000000   0x40005C00         DC32     0x40005c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \   00000000   0x40912732         DC32     0x40912732

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_14:
   \   00000000   0x........         DC32     hI2cExtHandler
    880          
    881          /**
    882            * @}
    883            */
    884          
    885          /**
    886            * @}
    887            */ 
    888          
    889          /**
    890            * @}
    891            */
    892          
    893          /**
    894            * @}
    895            */    
    896              
    897          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AUDIO_IO_DeInit
       0   AUDIO_IO_Delay
         0   -> HAL_Delay
       0   AUDIO_IO_Init
         0   -> I2Cx_Init
      16   AUDIO_IO_Read
        16   -> I2Cx_ReadMultiple
      16   AUDIO_IO_Write
        16   -> I2Cx_WriteMultiple
       8   BSP_COM_DeInit
         8   -> HAL_UART_DeInit
      40   BSP_COM_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_UART_Init
       0   BSP_GetVersion
       8   BSP_LED_DeInit
         0   -> HAL_GPIO_DeInit
         8   -> HAL_GPIO_WritePin
      32   BSP_LED_Init
        32   -> HAL_GPIO_Init
        32   -> HAL_GPIO_WritePin
       0   BSP_LED_Off
         0   -> HAL_GPIO_WritePin
       0   BSP_LED_On
         0   -> HAL_GPIO_WritePin
       0   BSP_LED_Toggle
         0   -> HAL_GPIO_TogglePin
       8   BSP_PB_DeInit
         0   -> HAL_GPIO_DeInit
         8   -> HAL_NVIC_DisableIRQ
       0   BSP_PB_GetState
         0   -> HAL_GPIO_ReadPin
      48   BSP_PB_Init
        48   -> HAL_GPIO_Init
        48   -> HAL_NVIC_EnableIRQ
        48   -> HAL_NVIC_SetPriority
       0   CAMERA_Delay
         0   -> HAL_Delay
       0   CAMERA_IO_Init
         0   -> I2Cx_Init
      16   CAMERA_IO_Read
        16   -> I2Cx_ReadMultiple
      16   CAMERA_IO_Write
        16   -> I2Cx_WriteMultiple
       0   EEPROM_IO_Init
         0   -> I2Cx_Init
       0   EEPROM_IO_IsDeviceReady
         0   -> HAL_I2C_IsDeviceReady
      16   EEPROM_IO_ReadData
        16   -> I2Cx_ReadMultiple
      16   EEPROM_IO_WriteData
        16   -> I2Cx_WriteMultiple
       8   I2Cx_Error
         8   -> HAL_I2C_DeInit
         0   -> I2Cx_Init
       8   I2Cx_Init
         8   -> HAL_I2C_GetState
         0   -> HAL_I2C_Init
         8   -> I2Cx_MspInit
      40   I2Cx_MspInit
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
      32   I2Cx_ReadMultiple
        32   -> HAL_I2C_Mem_Read
        32   -> I2Cx_Error
      32   I2Cx_WriteMultiple
        32   -> HAL_I2C_Mem_Write
        32   -> I2Cx_Error
       0   TS_IO_Delay
         0   -> HAL_Delay
       0   TS_IO_Init
         0   -> I2Cx_Init
      16   TS_IO_Read
        16   -> I2Cx_ReadMultiple
      16   TS_IO_Write
        16   -> I2Cx_WriteMultiple


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_14
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
       8  ?Subroutine0
      12  ?Subroutine1
      12  ?Subroutine10
      22  ?Subroutine11
      12  ?Subroutine12
      12  ?Subroutine13
      16  ?Subroutine14
      14  ?Subroutine15
      18  ?Subroutine2
       4  ?Subroutine3
       4  ?Subroutine4
      10  ?Subroutine5
      10  ?Subroutine6
      16  ?Subroutine7
      14  ?Subroutine8
      20  ?Subroutine9
       2  AUDIO_IO_DeInit
       4  AUDIO_IO_Delay
       2  AUDIO_IO_Init
      34  AUDIO_IO_Read
      18  AUDIO_IO_Write
      32  BSP_COM_DeInit
     140  BSP_COM_Init
       6  BSP_GetVersion
      22  BSP_LED_DeInit
      60  BSP_LED_Init
       8  BSP_LED_Off
       8  BSP_LED_On
      16  BSP_LED_Toggle
      32  BSP_PB_DeInit
      18  BSP_PB_GetState
     124  BSP_PB_Init
       8  BUTTON_IRQn
       8  BUTTON_PIN
      12  BUTTON_PORT
       4  CAMERA_Delay
       2  CAMERA_IO_Init
      10  CAMERA_IO_Read
      20  CAMERA_IO_Write
       2  COM_RX_AF
       2  COM_RX_PIN
       2  COM_TX_AF
       2  COM_TX_PIN
      12  COM_USART
          COM_TX_PORT
          COM_RX_PORT
       2  EEPROM_IO_Init
      14  EEPROM_IO_IsDeviceReady
      14  EEPROM_IO_ReadData
      14  EEPROM_IO_WriteData
       4  GPIO_PIN
      16  I2Cx_Error
      62  I2Cx_Init
     246  I2Cx_MspInit
      16  I2Cx_ReadMultiple
      14  I2Cx_WriteMultiple
       4  TS_IO_Delay
       2  TS_IO_Init
      16  TS_IO_Read
       6  TS_IO_Write
      60  hI2cAudioHandler
      60  hI2cExtHandler

 
   120 bytes in section .bss
    24 bytes in section .data
     4 bytes in section .rodata
 1 276 bytes in section .text
 
 1 276 bytes of CODE  memory
     4 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: none
