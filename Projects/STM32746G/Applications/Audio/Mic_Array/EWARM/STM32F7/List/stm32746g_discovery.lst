###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       19/Feb/2016  17:44:13
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
#    Command line =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7
#    List file    =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32746g_discovery.lst
#    Object file  =  
#        D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32746g_discovery.o
#
###############################################################################

D:\sop1hc\Github\data\Mic_Array_V00\USB_STREAMING\Mic_Array\Drivers\BSP\STM32746G-Discovery\stm32746g_discovery.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32746g_discovery.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    25-June-2015
      7            * @brief   This file provides a set of firmware functions to manage LEDs, 
      8            *          push-buttons and COM ports available on STM32746G-Discovery
      9            *          board(MB1191) from STMicroelectronics.
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     14            *
     15            * Redistribution and use in source and binary forms, with or without modification,
     16            * are permitted provided that the following conditions are met:
     17            *   1. Redistributions of source code must retain the above copyright notice,
     18            *      this list of conditions and the following disclaimer.
     19            *   2. Redistributions in binary form must reproduce the above copyright notice,
     20            *      this list of conditions and the following disclaimer in the documentation
     21            *      and/or other materials provided with the distribution.
     22            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     23            *      may be used to endorse or promote products derived from this software
     24            *      without specific prior written permission.
     25            *
     26            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     27            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     28            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     29            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     30            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     31            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     32            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     33            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     34            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     35            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     36            *
     37            ******************************************************************************
     38            */ 
     39          
     40          /* Includes ------------------------------------------------------------------*/
     41          #include "stm32746g_discovery.h"
     42          
     43          /** @addtogroup BSP
     44            * @{
     45            */ 
     46          
     47          /** @addtogroup STM32746G_DISCOVERY
     48            * @{
     49            */
     50          
     51          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL STM32746G_DISCOVERY_LOW_LEVEL
     52            * @{
     53            */
     54          
     55          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_TypesDefinitions STM32746G_DISCOVERY_LOW_LEVEL Private Types Definitions
     56            * @{
     57            */
     58          /**
     59            * @}
     60            */
     61          
     62          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Defines STM32746G_DISCOVERY_LOW_LEVEL Private Defines
     63            * @{
     64            */
     65          /**
     66           * @brief STM32746G DISCOVERY BSP Driver version number V1.0.0
     67             */
     68          #define __STM32746G_DISCO_BSP_VERSION_MAIN   (0x01) /*!< [31:24] main version */
     69          #define __STM32746G_DISCO_BSP_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version */
     70          #define __STM32746G_DISCO_BSP_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
     71          #define __STM32746G_DISCO_BSP_VERSION_RC     (0x00) /*!< [7:0]  release candidate */
     72          #define __STM32746G_DISCO_BSP_VERSION         ((__STM32746G_DISCO_BSP_VERSION_MAIN << 24)\
     73                                                       |(__STM32746G_DISCO_BSP_VERSION_SUB1 << 16)\
     74                                                       |(__STM32746G_DISCO_BSP_VERSION_SUB2 << 8 )\
     75                                                       |(__STM32746G_DISCO_BSP_VERSION_RC))
     76          /**
     77            * @}
     78            */
     79          
     80          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Macros STM32746G_DISCOVERY_LOW_LEVEL Private Macros
     81            * @{
     82            */
     83          /**
     84            * @}
     85            */
     86          
     87          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_Variables STM32746G_DISCOVERY_LOW_LEVEL Private Variables
     88            * @{
     89            */
     90          

   \                                 In section .rodata, align 4
     91          const uint32_t GPIO_PIN[LEDn] = {LED1_PIN, LED2_PIN};
   \                     GPIO_PIN:
   \   00000000   0x00000400         DC32 1024, 2048
   \              0x00000800   
     92          

   \                                 In section .data, align 4
     93          GPIO_TypeDef* BUTTON_PORT[BUTTONn] = {WAKEUP_BUTTON_GPIO_PORT,
   \                     BUTTON_PORT:
   \   00000000   0x40022000         DC32 40022000H, 40022000H, 40022000H
   \              0x40022000   
   \              0x40022000   
     94                                                TAMPER_BUTTON_GPIO_PORT,
     95                                                KEY_BUTTON_GPIO_PORT};
     96          

   \                                 In section .rodata, align 4
     97          const uint16_t BUTTON_PIN[BUTTONn] = {WAKEUP_BUTTON_PIN,
   \                     BUTTON_PIN:
   \   00000000   0x0800 0x0800      DC16 2048, 2048, 2048
   \              0x0800       
   \   00000006   0x00 0x00          DC8 0, 0
     98                                                TAMPER_BUTTON_PIN,
     99                                                KEY_BUTTON_PIN};
    100          

   \                                 In section .rodata, align 4
    101          const uint16_t BUTTON_IRQn[BUTTONn] = {WAKEUP_BUTTON_EXTI_IRQn,
   \                     BUTTON_IRQn:
   \   00000000   0x0028 0x0028      DC16 40, 40, 40
   \              0x0028       
   \   00000006   0x00 0x00          DC8 0, 0
    102                                                 TAMPER_BUTTON_EXTI_IRQn,
    103                                                 KEY_BUTTON_EXTI_IRQn};
    104          

   \                                 In section .data, align 4
    105          USART_TypeDef* COM_USART[COMn] = {DISCOVERY_COM1};
   \                     COM_USART:
   \   00000000   0x40011000         DC32 40011000H
    106          

   \                                 In section .data, align 4
    107          GPIO_TypeDef* COM_TX_PORT[COMn] = {DISCOVERY_COM1_TX_GPIO_PORT};
   \                     COM_TX_PORT:
   \   00000000   0x40020000         DC32 40020000H
    108          

   \                                 In section .data, align 4
    109          GPIO_TypeDef* COM_RX_PORT[COMn] = {DISCOVERY_COM1_RX_GPIO_PORT};
   \                     COM_RX_PORT:
   \   00000000   0x40020400         DC32 40020400H
    110          

   \                                 In section .rodata, align 2
    111          const uint16_t COM_TX_PIN[COMn] = {DISCOVERY_COM1_TX_PIN};
   \                     COM_TX_PIN:
   \   00000000   0x0200             DC16 512
    112          

   \                                 In section .rodata, align 2
    113          const uint16_t COM_RX_PIN[COMn] = {DISCOVERY_COM1_RX_PIN};
   \                     COM_RX_PIN:
   \   00000000   0x0080             DC16 128
    114          

   \                                 In section .rodata, align 2
    115          const uint16_t COM_TX_AF[COMn] = {DISCOVERY_COM1_TX_AF};
   \                     COM_TX_AF:
   \   00000000   0x0007             DC16 7
    116          

   \                                 In section .rodata, align 2
    117          const uint16_t COM_RX_AF[COMn] = {DISCOVERY_COM1_RX_AF};
   \                     COM_RX_AF:
   \   00000000   0x0007             DC16 7
    118          

   \                                 In section .bss, align 4
    119          static I2C_HandleTypeDef hI2cAudioHandler = {0};
   \                     hI2cAudioHandler:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    120          static I2C_HandleTypeDef hI2cExtHandler = {0};
   \                     hI2cExtHandler:
   \   00000000                      DS8 60
    121          
    122          /**
    123            * @}
    124            */
    125          
    126          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Private_FunctionPrototypes STM32746G_DISCOVERY_LOW_LEVEL Private Function Prototypes
    127            * @{
    128            */
    129          static void     I2Cx_MspInit(I2C_HandleTypeDef *i2c_handler);
    130          static void     I2Cx_Init(I2C_HandleTypeDef *i2c_handler);
    131          
    132          static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef *i2c_handler, uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length);
    133          static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef *i2c_handler, uint8_t Addr, uint16_t Reg, uint16_t MemAddSize, uint8_t *Buffer, uint16_t Length);
    134          static HAL_StatusTypeDef I2Cx_IsDeviceReady(I2C_HandleTypeDef *i2c_handler, uint16_t DevAddress, uint32_t Trials);
    135          static void              I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr);
    136          
    137          /* AUDIO IO functions */
    138          void            AUDIO_IO_Init(void);
    139          void            AUDIO_IO_DeInit(void);
    140          void            AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value);
    141          uint16_t        AUDIO_IO_Read(uint8_t Addr, uint16_t Reg);
    142          void            AUDIO_IO_Delay(uint32_t Delay);
    143          
    144          /* TOUCHSCREEN IO functions */
    145          void            TS_IO_Init(void);
    146          void            TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value);
    147          uint8_t         TS_IO_Read(uint8_t Addr, uint8_t Reg);
    148          void            TS_IO_Delay(uint32_t Delay);
    149          
    150          /* CAMERA IO functions */
    151          void            CAMERA_IO_Init(void);
    152          void            CAMERA_Delay(uint32_t Delay);
    153          void            CAMERA_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value);
    154          uint8_t         CAMERA_IO_Read(uint8_t Addr, uint8_t Reg);
    155          
    156          /* I2C EEPROM IO function */
    157          void                EEPROM_IO_Init(void);
    158          HAL_StatusTypeDef   EEPROM_IO_WriteData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize);
    159          HAL_StatusTypeDef   EEPROM_IO_ReadData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize);
    160          HAL_StatusTypeDef   EEPROM_IO_IsDeviceReady(uint16_t DevAddress, uint32_t Trials);
    161          /**
    162            * @}
    163            */
    164          
    165          /** @defgroup STM32746G_DISCOVERY_LOW_LEVEL_Exported_Functions STM32746G_DISCOVERY_LOW_LEVELSTM32746G_DISCOVERY_LOW_LEVEL Exported Functions
    166            * @{
    167            */ 
    168          
    169            /**
    170            * @brief  This method returns the STM32746G DISCOVERY BSP Driver revision
    171            * @retval version: 0xXYZR (8bits for each decimal, R for RC)
    172            */

   \                                 In section .text, align 2, keep-with-next
    173          uint32_t BSP_GetVersion(void)
    174          {
    175            return __STM32746G_DISCO_BSP_VERSION;
   \                     BSP_GetVersion: (+1)
   \   00000000   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000004   0x4770             BX       LR               ;; return
    176          }
    177          
    178          /**
    179            * @brief  Configures LED on GPIO.
    180            * @param  Led: LED to be configured. 
    181            *          This parameter can be one of the following values:
    182            *            @arg  LED1
    183            * @retval None
    184            */

   \                                 In section .text, align 2, keep-with-next
    185          void BSP_LED_Init(Led_TypeDef Led)
    186          {
   \                     BSP_LED_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
    187            GPIO_InitTypeDef  gpio_init_structure;
    188            GPIO_TypeDef*     gpio_led;
    189          
    190            if (Led == LED1)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD12C             BNE.N    ??BSP_LED_Init_0
    191            {
    192              gpio_led = LED1_GPIO_PORT;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   00000010   0x0005             MOVS     R5,R0
    193              /* Enable the GPIO_LED clock */
    194              LED1_GPIO_CLK_ENABLE();
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023830
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
    195          
    196              /* Configure the GPIO_LED pin */
    197              gpio_init_structure.Pin = GPIO_PIN[Led];
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000003A   0x9001             STR      R0,[SP, #+4]
    198              gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x9002             STR      R0,[SP, #+8]
    199              gpio_init_structure.Pull = GPIO_PULLUP;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9003             STR      R0,[SP, #+12]
    200              gpio_init_structure.Speed = GPIO_SPEED_HIGH;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0x9004             STR      R0,[SP, #+16]
    201            
    202              HAL_GPIO_Init(gpio_led, &gpio_init_structure);
   \   00000048   0xA901             ADD      R1,SP,#+4
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x.... 0x....      BL       HAL_GPIO_Init
    203              
    204              /* By default, turn off LED */
    205              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000005C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000005E   0x0028             MOVS     R0,R5
   \   00000060   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000064   0xE02E             B.N      ??BSP_LED_Init_1
    206            }
    207            else if (Led == LED2)
   \                     ??BSP_LED_Init_0: (+1)
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x2C01             CMP      R4,#+1
   \   0000006A   0xD12B             BNE.N    ??BSP_LED_Init_1
    208            {
    209              gpio_led = LED2_GPIO_PORT;
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   00000070   0x0005             MOVS     R5,R0
    210              /* Enable the GPIO_LED clock */
    211              LED2_GPIO_CLK_ENABLE();
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023830
   \   00000080   0x6008             STR      R0,[R1, #+0]
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000008C   0x9000             STR      R0,[SP, #+0]
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
    212          
    213              /* Configure the GPIO_LED pin */
    214              gpio_init_structure.Pin = GPIO_PIN[Led];
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000094   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000096   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000009A   0x9001             STR      R0,[SP, #+4]
    215              gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0x9002             STR      R0,[SP, #+8]
    216              gpio_init_structure.Pull = GPIO_PULLUP;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x9003             STR      R0,[SP, #+12]
    217              gpio_init_structure.Speed = GPIO_SPEED_HIGH;
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0x9004             STR      R0,[SP, #+16]
    218            
    219              HAL_GPIO_Init(gpio_led, &gpio_init_structure);
   \   000000A8   0xA901             ADD      R1,SP,#+4
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0x.... 0x....      BL       HAL_GPIO_Init
    220              
    221              /* By default, turn off LED */
    222              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
   \   000000B0   0x2201             MOVS     R2,#+1
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   000000B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B8   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   000000BC   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000BE   0x0028             MOVS     R0,R5
   \   000000C0   0x.... 0x....      BL       HAL_GPIO_WritePin
    223            }
    224          }
   \                     ??BSP_LED_Init_1: (+1)
   \   000000C4   0xB007             ADD      SP,SP,#+28
   \   000000C6   0xBD30             POP      {R4,R5,PC}       ;; return
    225          
    226          /**
    227            * @brief  DeInit LEDs.
    228            * @param  Led: LED to be configured. 
    229            *          This parameter can be one of the following values:
    230            *            @arg  LED1
    231            * @note Led DeInit does not disable the GPIO clock
    232            * @retval None
    233            */

   \                                 In section .text, align 2, keep-with-next
    234          void BSP_LED_DeInit(Led_TypeDef Led)
    235          {
   \                     BSP_LED_DeInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
    236            GPIO_InitTypeDef  gpio_init_structure;
    237            GPIO_TypeDef*     gpio_led;
    238          
    239            if (Led == LED1)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD116             BNE.N    ??BSP_LED_DeInit_0
    240            {
    241              gpio_led = LED1_GPIO_PORT;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   00000010   0x0005             MOVS     R5,R0
    242              /* Turn off LED */
    243              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       HAL_GPIO_WritePin
    244              /* Configure the GPIO_LED pin */
    245              gpio_init_structure.Pin = GPIO_PIN[Led];
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000030   0x9000             STR      R0,[SP, #+0]
    246              HAL_GPIO_DeInit(gpio_led, gpio_init_structure.Pin);
   \   00000032   0x9900             LDR      R1,[SP, #+0]
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       HAL_GPIO_DeInit
    247            }
    248            
    249            if (Led == LED2)
   \                     ??BSP_LED_DeInit_0: (+1)
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x2C01             CMP      R4,#+1
   \   0000003E   0xD116             BNE.N    ??BSP_LED_DeInit_1
    250            {
    251              gpio_led = LED2_GPIO_PORT;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   00000044   0x0005             MOVS     R5,R0
    252              /* Turn off LED */
    253              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   00000052   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       HAL_GPIO_WritePin
    254              /* Configure the GPIO_LED pin */
    255              gpio_init_structure.Pin = GPIO_PIN[Led];
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000064   0x9000             STR      R0,[SP, #+0]
    256              HAL_GPIO_DeInit(gpio_led, gpio_init_structure.Pin);
   \   00000066   0x9900             LDR      R1,[SP, #+0]
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0x.... 0x....      BL       HAL_GPIO_DeInit
    257            }
    258          }
   \                     ??BSP_LED_DeInit_1: (+1)
   \   0000006E   0xB005             ADD      SP,SP,#+20
   \   00000070   0xBD30             POP      {R4,R5,PC}       ;; return
    259          
    260          /**
    261            * @brief  Turns selected LED On.
    262            * @param  Led: LED to be set on 
    263            *          This parameter can be one of the following values:
    264            *            @arg  LED1
    265            * @retval None
    266            */

   \                                 In section .text, align 2, keep-with-next
    267          void BSP_LED_On(Led_TypeDef Led)
    268          {
   \                     BSP_LED_On: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    269            GPIO_TypeDef*     gpio_led;
    270          
    271            if (Led == LED1)	/* Switch On LED connected to GPIO */
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD10C             BNE.N    ??BSP_LED_On_0
    272            {
    273              gpio_led = LED1_GPIO_PORT;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   0000000E   0x0005             MOVS     R5,R0
    274              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x.... 0x....      BL       HAL_GPIO_WritePin
    275            }
    276            
    277            if (Led == LED2)	/* Switch On LED connected to GPIO */
   \                     ??BSP_LED_On_0: (+1)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD10C             BNE.N    ??BSP_LED_On_1
    278            {
    279              gpio_led = LED2_GPIO_PORT;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   0000002E   0x0005             MOVS     R5,R0
    280              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000003C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x.... 0x....      BL       HAL_GPIO_WritePin
    281            }
    282          }
   \                     ??BSP_LED_On_1: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    283          
    284          /**
    285            * @brief  Turns selected LED Off. 
    286            * @param  Led: LED to be set off
    287            *          This parameter can be one of the following values:
    288            *            @arg  LED1
    289            * @retval None
    290            */

   \                                 In section .text, align 2, keep-with-next
    291          void BSP_LED_Off(Led_TypeDef Led)
    292          {
   \                     BSP_LED_Off: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    293            GPIO_TypeDef*     gpio_led;
    294          
    295            if (Led == LED1) /* Switch Off LED connected to GPIO */
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD10C             BNE.N    ??BSP_LED_Off_0
    296            {
    297              gpio_led = LED1_GPIO_PORT;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   0000000E   0x0005             MOVS     R5,R0
    298              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x.... 0x....      BL       HAL_GPIO_WritePin
    299            }
    300            
    301            if (Led == LED2) /* Switch Off LED connected to GPIO */
   \                     ??BSP_LED_Off_0: (+1)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xD10C             BNE.N    ??BSP_LED_Off_1
    302            {
    303              gpio_led = LED2_GPIO_PORT;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   0000002E   0x0005             MOVS     R5,R0
    304              HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_RESET);
   \   00000030   0x2200             MOVS     R2,#+0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000003C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x.... 0x....      BL       HAL_GPIO_WritePin
    305            }
    306          }
   \                     ??BSP_LED_Off_1: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    307          
    308          /**
    309            * @brief  Toggles the selected LED.
    310            * @param  Led: LED to be toggled
    311            *          This parameter can be one of the following values:
    312            *            @arg  LED1
    313            * @retval None
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          void BSP_LED_Toggle(Led_TypeDef Led)
    316          {
   \                     BSP_LED_Toggle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    317            GPIO_TypeDef*     gpio_led;
    318          
    319            if (Led == LED1)	/* Toggle LED connected to GPIO */
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD10B             BNE.N    ??BSP_LED_Toggle_0
    320            {
    321              gpio_led = LED1_GPIO_PORT;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   0000000E   0x0005             MOVS     R5,R0
    322              HAL_GPIO_TogglePin(gpio_led, GPIO_PIN[Led]);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_TogglePin
    323            }
    324            
    325            if (Led == LED2)	/* Toggle LED connected to GPIO */
   \                     ??BSP_LED_Toggle_0: (+1)
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C01             CMP      R4,#+1
   \   00000026   0xD10B             BNE.N    ??BSP_LED_Toggle_1
    326            {
    327              gpio_led = LED2_GPIO_PORT;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable24  ;; 0x40022000
   \   0000002C   0x0005             MOVS     R5,R0
    328              HAL_GPIO_TogglePin(gpio_led, GPIO_PIN[Led]);
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable24_2
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   00000038   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       HAL_GPIO_TogglePin
    329            }
    330          }
   \                     ??BSP_LED_Toggle_1: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    331          
    332          /**
    333            * @brief  Configures button GPIO and EXTI Line.
    334            * @param  Button: Button to be configured
    335            *          This parameter can be one of the following values:
    336            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    337            *            @arg  BUTTON_TAMPER: Tamper Push Button  
    338            *            @arg  BUTTON_KEY: Key Push Button
    339            * @param  ButtonMode: Button mode
    340            *          This parameter can be one of the following values:
    341            *            @arg  BUTTON_MODE_GPIO: Button will be used as simple IO
    342            *            @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line 
    343            *                                    with interrupt generation capability
    344            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons)
    345            *       are mapped on the same push button named "User"
    346            *       on the board serigraphy.
    347            * @retval None
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
    350          {
   \                     BSP_PB_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    351            GPIO_InitTypeDef gpio_init_structure;
    352            
    353            /* Enable the BUTTON clock */
    354            BUTTONx_GPIO_CLK_ENABLE(Button);
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD10F             BNE.N    ??BSP_PB_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023830
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0xE021             B.N      ??BSP_PB_Init_1
   \                     ??BSP_PB_Init_0: (+1)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C01             CMP      R4,#+1
   \   00000032   0xD10F             BNE.N    ??BSP_PB_Init_2
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023830
   \   00000042   0x6008             STR      R0,[R1, #+0]
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0xE00E             B.N      ??BSP_PB_Init_1
   \                     ??BSP_PB_Init_2: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023830
   \   00000062   0x6008             STR      R0,[R1, #+0]
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x9800             LDR      R0,[SP, #+0]
    355            
    356            if(ButtonMode == BUTTON_MODE_GPIO)
   \                     ??BSP_PB_Init_1: (+1)
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD113             BNE.N    ??BSP_PB_Init_3
    357            {
    358              /* Configure Button pin as input */
    359              gpio_init_structure.Pin = BUTTON_PIN[Button];
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000082   0x9001             STR      R0,[SP, #+4]
    360              gpio_init_structure.Mode = GPIO_MODE_INPUT;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9002             STR      R0,[SP, #+8]
    361              gpio_init_structure.Pull = GPIO_NOPULL;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x9003             STR      R0,[SP, #+12]
    362              gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   0000008C   0x2002             MOVS     R0,#+2
   \   0000008E   0x9004             STR      R0,[SP, #+16]
    363              HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
   \   00000090   0xA901             ADD      R1,SP,#+4
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable24_4
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000009C   0x.... 0x....      BL       HAL_GPIO_Init
    364            }
    365            
    366            if(ButtonMode == BUTTON_MODE_EXTI)
   \                     ??BSP_PB_Init_3: (+1)
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0x2D01             CMP      R5,#+1
   \   000000A4   0xD12D             BNE.N    ??BSP_PB_Init_4
    367            {
    368              /* Configure Button pin as input with External interrupt */
    369              gpio_init_structure.Pin = BUTTON_PIN[Button];
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   000000AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AC   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   000000B0   0x9001             STR      R0,[SP, #+4]
    370              gpio_init_structure.Pull = GPIO_NOPULL;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x9003             STR      R0,[SP, #+12]
    371              gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   000000B6   0x2002             MOVS     R0,#+2
   \   000000B8   0x9004             STR      R0,[SP, #+16]
    372              
    373              if(Button != BUTTON_WAKEUP)
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x2C00             CMP      R4,#+0
   \   000000BE   0xD003             BEQ.N    ??BSP_PB_Init_5
    374              {
    375                gpio_init_structure.Mode = GPIO_MODE_IT_FALLING; 
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable24_5  ;; 0x10210000
   \   000000C4   0x9002             STR      R0,[SP, #+8]
   \   000000C6   0xE002             B.N      ??BSP_PB_Init_6
    376              }
    377              else
    378              {
    379                gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
   \                     ??BSP_PB_Init_5: (+1)
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable24_6  ;; 0x10110000
   \   000000CC   0x9002             STR      R0,[SP, #+8]
    380              }
    381              
    382              HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
   \                     ??BSP_PB_Init_6: (+1)
   \   000000CE   0xA901             ADD      R1,SP,#+4
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable24_4
   \   000000D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000DA   0x.... 0x....      BL       HAL_GPIO_Init
    383              
    384              /* Enable and set Button EXTI Interrupt to the lowest priority */
    385              HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
   \   000000DE   0x2200             MOVS     R2,#+0
   \   000000E0   0x210F             MOVS     R1,#+15
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable24_7
   \   000000E6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E8   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   000000EC   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000EE   0x.... 0x....      BL       HAL_NVIC_SetPriority
    386              HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable24_7
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   000000FC   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000FE   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    387            }
    388          }
   \                     ??BSP_PB_Init_4: (+1)
   \   00000102   0xB007             ADD      SP,SP,#+28
   \   00000104   0xBD30             POP      {R4,R5,PC}       ;; return
    389          
    390          /**
    391            * @brief  Push Button DeInit.
    392            * @param  Button: Button to be configured
    393            *          This parameter can be one of the following values:
    394            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    395            *            @arg  BUTTON_TAMPER: Tamper Push Button  
    396            *            @arg  BUTTON_KEY: Key Push Button
    397            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons) 
    398            *       are mapped on the same push button named "User"
    399            *       on the board serigraphy.
    400            * @note PB DeInit does not disable the GPIO clock
    401            * @retval None
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          void BSP_PB_DeInit(Button_TypeDef Button)
    404          {
   \                     BSP_PB_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    405              GPIO_InitTypeDef gpio_init_structure;
    406          
    407              gpio_init_structure.Pin = BUTTON_PIN[Button];
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000010   0x9000             STR      R0,[SP, #+0]
    408              HAL_NVIC_DisableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable24_7
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   0000001C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       HAL_NVIC_DisableIRQ
    409              HAL_GPIO_DeInit(BUTTON_PORT[Button], gpio_init_structure.Pin);
   \   00000022   0x9900             LDR      R1,[SP, #+0]
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable24_4
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000002E   0x.... 0x....      BL       HAL_GPIO_DeInit
    410          }
   \   00000032   0xB006             ADD      SP,SP,#+24
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    411          
    412          
    413          /**
    414            * @brief  Returns the selected button state.
    415            * @param  Button: Button to be checked
    416            *          This parameter can be one of the following values:
    417            *            @arg  BUTTON_WAKEUP: Wakeup Push Button 
    418            *            @arg  BUTTON_TAMPER: Tamper Push Button 
    419            *            @arg  BUTTON_KEY: Key Push Button
    420            * @note On STM32746G-Discovery board, the three buttons (Wakeup, Tamper and key buttons) 
    421            *       are mapped on the same push button named "User"
    422            *       on the board serigraphy.
    423            * @retval The Button GPIO pin value
    424            */

   \                                 In section .text, align 2, keep-with-next
    425          uint32_t BSP_PB_GetState(Button_TypeDef Button)
    426          {
   \                     BSP_PB_GetState: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    427            return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable24_3
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24_4
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000018   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    428          }
    429          
    430          /**
    431            * @brief  Configures COM port.
    432            * @param  COM: COM port to be configured.
    433            *          This parameter can be one of the following values:
    434            *            @arg  COM1 
    435            *            @arg  COM2 
    436            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains the
    437            *                configuration information for the specified USART peripheral.
    438            * @retval None
    439            */

   \                                 In section .text, align 2, keep-with-next
    440          void BSP_COM_Init(COM_TypeDef COM, UART_HandleTypeDef *huart)
    441          {
   \                     BSP_COM_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    442            GPIO_InitTypeDef gpio_init_structure;
    443          
    444            /* Enable GPIO clock */
    445            DISCOVERY_COMx_TX_GPIO_CLK_ENABLE(COM);
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD10E             BNE.N    ??BSP_COM_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023830
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
    446            DISCOVERY_COMx_RX_GPIO_CLK_ENABLE(COM);
   \                     ??BSP_COM_Init_0: (+1)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD10E             BNE.N    ??BSP_COM_Init_1
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023830
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0x9800             LDR      R0,[SP, #+0]
    447          
    448            /* Enable USART clock */
    449            DISCOVERY_COMx_CLK_ENABLE(COM);
   \                     ??BSP_COM_Init_1: (+1)
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xD10E             BNE.N    ??BSP_COM_Init_2
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable24_8  ;; 0x40023844
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable24_8  ;; 0x40023844
   \   00000064   0x6008             STR      R0,[R1, #+0]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable24_8  ;; 0x40023844
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF010 0x0010      ANDS     R0,R0,#0x10
   \   00000070   0x9000             STR      R0,[SP, #+0]
   \   00000072   0x9800             LDR      R0,[SP, #+0]
    450          
    451            /* Configure USART Tx as alternate function */
    452            gpio_init_structure.Pin = COM_TX_PIN[COM];
   \                     ??BSP_COM_Init_2: (+1)
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable24_9
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   0000007E   0x9001             STR      R0,[SP, #+4]
    453            gpio_init_structure.Mode = GPIO_MODE_AF_PP;
   \   00000080   0x2002             MOVS     R0,#+2
   \   00000082   0x9002             STR      R0,[SP, #+8]
    454            gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   00000084   0x2002             MOVS     R0,#+2
   \   00000086   0x9004             STR      R0,[SP, #+16]
    455            gpio_init_structure.Pull = GPIO_PULLUP;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x9003             STR      R0,[SP, #+12]
    456            gpio_init_structure.Alternate = COM_TX_AF[COM];
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000096   0x9005             STR      R0,[SP, #+20]
    457            HAL_GPIO_Init(COM_TX_PORT[COM], &gpio_init_structure);
   \   00000098   0xA901             ADD      R1,SP,#+4
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable24_11
   \   0000009E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A0   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000A4   0x.... 0x....      BL       HAL_GPIO_Init
    458          
    459            /* Configure USART Rx as alternate function */
    460            gpio_init_structure.Pin = COM_RX_PIN[COM];
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable24_12
   \   000000AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AE   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   000000B2   0x9001             STR      R0,[SP, #+4]
    461            gpio_init_structure.Mode = GPIO_MODE_AF_PP;
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0x9002             STR      R0,[SP, #+8]
    462            gpio_init_structure.Alternate = COM_RX_AF[COM];
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable24_13
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   000000C2   0x9005             STR      R0,[SP, #+20]
    463            HAL_GPIO_Init(COM_RX_PORT[COM], &gpio_init_structure);
   \   000000C4   0xA901             ADD      R1,SP,#+4
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   000000CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CC   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000D0   0x.... 0x....      BL       HAL_GPIO_Init
    464          
    465            /* USART configuration */
    466            huart->Instance = COM_USART[COM];
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable24_15
   \   000000D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DA   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   000000DE   0x6028             STR      R0,[R5, #+0]
    467            HAL_UART_Init(huart);
   \   000000E0   0x0028             MOVS     R0,R5
   \   000000E2   0x.... 0x....      BL       HAL_UART_Init
    468          }
   \   000000E6   0xB007             ADD      SP,SP,#+28
   \   000000E8   0xBD30             POP      {R4,R5,PC}       ;; return
    469          
    470          /**
    471            * @brief  DeInit COM port.
    472            * @param  COM: COM port to be configured.
    473            *          This parameter can be one of the following values:
    474            *            @arg  COM1 
    475            *            @arg  COM2 
    476            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains the
    477            *                configuration information for the specified USART peripheral.
    478            * @retval None
    479            */

   \                                 In section .text, align 2, keep-with-next
    480          void BSP_COM_DeInit(COM_TypeDef COM, UART_HandleTypeDef *huart)
    481          {
   \                     BSP_COM_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    482            /* USART configuration */
    483            huart->Instance = COM_USART[COM];
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24_15
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000010   0x6028             STR      R0,[R5, #+0]
    484            HAL_UART_DeInit(huart);
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       HAL_UART_DeInit
    485          
    486            /* Enable USART clock */
    487            DISCOVERY_COMx_CLK_DISABLE(COM);
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD108             BNE.N    ??BSP_COM_DeInit_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable24_8  ;; 0x40023844
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF030 0x0010      BICS     R0,R0,#0x10
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable24_8  ;; 0x40023844
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   \   0000002E   0xE000             B.N      ??BSP_COM_DeInit_1
   \                     ??BSP_COM_DeInit_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
    488          
    489            /* DeInit GPIO pins can be done in the application 
    490               (by surcharging this __weak function) */
    491          
    492            /* GPIO pins clock, DMA clock can be shut down in the application 
    493               by surcharging this __weak function */
    494          }
   \                     ??BSP_COM_DeInit_1: (+1)
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    495          
    496          /*******************************************************************************
    497                                      BUS OPERATIONS
    498          *******************************************************************************/
    499          
    500          /******************************* I2C Routines *********************************/
    501          /**
    502            * @brief  Initializes I2C MSP.
    503            * @param  i2c_handler : I2C handler
    504            * @retval None
    505            */

   \                                 In section .text, align 2, keep-with-next
    506          static void I2Cx_MspInit(I2C_HandleTypeDef *i2c_handler)
    507          {
   \                     I2Cx_MspInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    508            GPIO_InitTypeDef  gpio_init_structure;
    509            
    510            if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable24_16
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD155             BNE.N    ??I2Cx_MspInit_0
    511            {
    512              /* AUDIO and LCD I2C MSP init */
    513          
    514              /*** Configure the GPIOs ***/
    515              /* Enable GPIO clock */
    516              DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable24_1  ;; 0x40023830
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable24_1  ;; 0x40023830
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
    517          
    518              /* Configure I2C Tx as alternate function */
    519              gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SCL_PIN;
   \   0000002C   0x2080             MOVS     R0,#+128
   \   0000002E   0x9001             STR      R0,[SP, #+4]
    520              gpio_init_structure.Mode = GPIO_MODE_AF_OD;
   \   00000030   0x2012             MOVS     R0,#+18
   \   00000032   0x9002             STR      R0,[SP, #+8]
    521              gpio_init_structure.Pull = GPIO_NOPULL;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x9003             STR      R0,[SP, #+12]
    522              gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x9004             STR      R0,[SP, #+16]
    523              gpio_init_structure.Alternate = DISCOVERY_AUDIO_I2Cx_SCL_SDA_AF;
   \   0000003C   0x2004             MOVS     R0,#+4
   \   0000003E   0x9005             STR      R0,[SP, #+20]
    524              HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable24_17  ;; 0x40021c00
   \   00000046   0x.... 0x....      BL       HAL_GPIO_Init
    525          
    526              /* Configure I2C Rx as alternate function */
    527              gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SDA_PIN;
   \   0000004A   0xF44F 0x7080      MOV      R0,#+256
   \   0000004E   0x9001             STR      R0,[SP, #+4]
    528              HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   00000050   0xA901             ADD      R1,SP,#+4
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable24_17  ;; 0x40021c00
   \   00000056   0x.... 0x....      BL       HAL_GPIO_Init
    529          
    530              /*** Configure the I2C peripheral ***/
    531              /* Enable I2C clock */
    532              DISCOVERY_AUDIO_I2Cx_CLK_ENABLE();
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable24_18  ;; 0x40023840
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable24_18  ;; 0x40023840
   \   00000068   0x6008             STR      R0,[R1, #+0]
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable24_18  ;; 0x40023840
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0xF410 0x0000      ANDS     R0,R0,#0x800000
   \   00000074   0x9000             STR      R0,[SP, #+0]
   \   00000076   0x9800             LDR      R0,[SP, #+0]
    533          
    534              /* Force the I2C peripheral clock reset */
    535              DISCOVERY_AUDIO_I2Cx_FORCE_RESET();
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable24_19  ;; 0x40023820
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable24_19  ;; 0x40023820
   \   00000086   0x6008             STR      R0,[R1, #+0]
    536          
    537              /* Release the I2C peripheral clock reset */
    538              DISCOVERY_AUDIO_I2Cx_RELEASE_RESET();
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable24_19  ;; 0x40023820
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable24_19  ;; 0x40023820
   \   00000096   0x6008             STR      R0,[R1, #+0]
    539          
    540              /* Enable and set I2Cx Interrupt to a lower priority */
    541              HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_EV_IRQn, 0x05, 0);
   \   00000098   0x2200             MOVS     R2,#+0
   \   0000009A   0x2105             MOVS     R1,#+5
   \   0000009C   0x2048             MOVS     R0,#+72
   \   0000009E   0x.... 0x....      BL       HAL_NVIC_SetPriority
    542              HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_EV_IRQn);
   \   000000A2   0x2048             MOVS     R0,#+72
   \   000000A4   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    543          
    544              /* Enable and set I2Cx Interrupt to a lower priority */
    545              HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_ER_IRQn, 0x05, 0);
   \   000000A8   0x2200             MOVS     R2,#+0
   \   000000AA   0x2105             MOVS     R1,#+5
   \   000000AC   0x2049             MOVS     R0,#+73
   \   000000AE   0x.... 0x....      BL       HAL_NVIC_SetPriority
    546              HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_ER_IRQn);
   \   000000B2   0x2049             MOVS     R0,#+73
   \   000000B4   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
   \   000000B8   0xE04A             B.N      ??I2Cx_MspInit_1
    547            }
    548            else
    549            {
    550              /* External, camera and Arduino connector I2C MSP init */
    551          
    552              /*** Configure the GPIOs ***/
    553              /* Enable GPIO clock */
    554              DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
   \                     ??I2Cx_MspInit_0: (+1)
   \   000000BA   0x....             LDR.N    R0,??DataTable24_1  ;; 0x40023830
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000C2   0x....             LDR.N    R1,??DataTable24_1  ;; 0x40023830
   \   000000C4   0x6008             STR      R0,[R1, #+0]
   \   000000C6   0x....             LDR.N    R0,??DataTable24_1  ;; 0x40023830
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0xF010 0x0002      ANDS     R0,R0,#0x2
   \   000000CE   0x9000             STR      R0,[SP, #+0]
   \   000000D0   0x9800             LDR      R0,[SP, #+0]
    555          
    556              /* Configure I2C Tx as alternate function */
    557              gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
   \   000000D2   0xF44F 0x7080      MOV      R0,#+256
   \   000000D6   0x9001             STR      R0,[SP, #+4]
    558              gpio_init_structure.Mode = GPIO_MODE_AF_OD;
   \   000000D8   0x2012             MOVS     R0,#+18
   \   000000DA   0x9002             STR      R0,[SP, #+8]
    559              gpio_init_structure.Pull = GPIO_NOPULL;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x9003             STR      R0,[SP, #+12]
    560              gpio_init_structure.Speed = GPIO_SPEED_FAST;
   \   000000E0   0x2002             MOVS     R0,#+2
   \   000000E2   0x9004             STR      R0,[SP, #+16]
    561              gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
   \   000000E4   0x2004             MOVS     R0,#+4
   \   000000E6   0x9005             STR      R0,[SP, #+20]
    562              HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   000000E8   0xA901             ADD      R1,SP,#+4
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable24_20  ;; 0x40020400
   \   000000EE   0x.... 0x....      BL       HAL_GPIO_Init
    563          
    564              /* Configure I2C Rx as alternate function */
    565              gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
   \   000000F2   0xF44F 0x7000      MOV      R0,#+512
   \   000000F6   0x9001             STR      R0,[SP, #+4]
    566              HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
   \   000000F8   0xA901             ADD      R1,SP,#+4
   \   000000FA   0x....             LDR.N    R0,??DataTable24_20  ;; 0x40020400
   \   000000FC   0x.... 0x....      BL       HAL_GPIO_Init
    567          
    568              /*** Configure the I2C peripheral ***/
    569              /* Enable I2C clock */
    570              DISCOVERY_EXT_I2Cx_CLK_ENABLE();
   \   00000100   0x....             LDR.N    R0,??DataTable24_18  ;; 0x40023840
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   00000108   0x....             LDR.N    R1,??DataTable24_18  ;; 0x40023840
   \   0000010A   0x6008             STR      R0,[R1, #+0]
   \   0000010C   0x....             LDR.N    R0,??DataTable24_18  ;; 0x40023840
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \   00000114   0x9000             STR      R0,[SP, #+0]
   \   00000116   0x9800             LDR      R0,[SP, #+0]
    571          
    572              /* Force the I2C peripheral clock reset */
    573              DISCOVERY_EXT_I2Cx_FORCE_RESET();
   \   00000118   0x....             LDR.N    R0,??DataTable24_19  ;; 0x40023820
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   00000120   0x....             LDR.N    R1,??DataTable24_19  ;; 0x40023820
   \   00000122   0x6008             STR      R0,[R1, #+0]
    574          
    575              /* Release the I2C peripheral clock reset */
    576              DISCOVERY_EXT_I2Cx_RELEASE_RESET();
   \   00000124   0x....             LDR.N    R0,??DataTable24_19  ;; 0x40023820
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   0000012C   0x....             LDR.N    R1,??DataTable24_19  ;; 0x40023820
   \   0000012E   0x6008             STR      R0,[R1, #+0]
    577          
    578              /* Enable and set I2Cx Interrupt to a lower priority */
    579              HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x05, 0);
   \   00000130   0x2200             MOVS     R2,#+0
   \   00000132   0x2105             MOVS     R1,#+5
   \   00000134   0x201F             MOVS     R0,#+31
   \   00000136   0x.... 0x....      BL       HAL_NVIC_SetPriority
    580              HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_EV_IRQn);
   \   0000013A   0x201F             MOVS     R0,#+31
   \   0000013C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    581          
    582              /* Enable and set I2Cx Interrupt to a lower priority */
    583              HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x05, 0);
   \   00000140   0x2200             MOVS     R2,#+0
   \   00000142   0x2105             MOVS     R1,#+5
   \   00000144   0x2020             MOVS     R0,#+32
   \   00000146   0x.... 0x....      BL       HAL_NVIC_SetPriority
    584              HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
   \   0000014A   0x2020             MOVS     R0,#+32
   \   0000014C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    585            }
    586          }
   \                     ??I2Cx_MspInit_1: (+1)
   \   00000150   0xB006             ADD      SP,SP,#+24
   \   00000152   0xBD10             POP      {R4,PC}          ;; return
    587          
    588          /**
    589            * @brief  Initializes I2C HAL.
    590            * @param  i2c_handler : I2C handler
    591            * @retval None
    592            */

   \                                 In section .text, align 2, keep-with-next
    593          static void I2Cx_Init(I2C_HandleTypeDef *i2c_handler)
    594          {
   \                     I2Cx_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    595            if(HAL_I2C_GetState(i2c_handler) == HAL_I2C_STATE_RESET)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_I2C_GetState
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD11B             BNE.N    ??I2Cx_Init_0
    596            {
    597              if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
   \   0000000E   0x....             LDR.N    R0,??DataTable24_16
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD102             BNE.N    ??I2Cx_Init_1
    598              {
    599                /* Audio and LCD I2C configuration */
    600                i2c_handler->Instance = DISCOVERY_AUDIO_I2Cx;
   \   00000014   0x....             LDR.N    R0,??DataTable24_21  ;; 0x40005c00
   \   00000016   0x6020             STR      R0,[R4, #+0]
   \   00000018   0xE001             B.N      ??I2Cx_Init_2
    601              }
    602              else
    603              {
    604                /* External, camera and Arduino connector  I2C configuration */
    605                i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
   \                     ??I2Cx_Init_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable24_22  ;; 0x40005400
   \   0000001C   0x6020             STR      R0,[R4, #+0]
    606              }
    607              i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
   \                     ??I2Cx_Init_2: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable24_23  ;; 0x40912732
   \   00000020   0x6060             STR      R0,[R4, #+4]
    608              i2c_handler->Init.OwnAddress1      = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x60A0             STR      R0,[R4, #+8]
    609              i2c_handler->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x60E0             STR      R0,[R4, #+12]
    610              i2c_handler->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6120             STR      R0,[R4, #+16]
    611              i2c_handler->Init.OwnAddress2      = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x6160             STR      R0,[R4, #+20]
    612              i2c_handler->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x61E0             STR      R0,[R4, #+28]
    613              i2c_handler->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6220             STR      R0,[R4, #+32]
    614          
    615              /* Init the I2C */
    616              I2Cx_MspInit(i2c_handler);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       I2Cx_MspInit
    617              HAL_I2C_Init(i2c_handler);
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       HAL_I2C_Init
    618            }
    619          }
   \                     ??I2Cx_Init_0: (+1)
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    620          
    621          /**
    622            * @brief  Reads multiple data.
    623            * @param  i2c_handler : I2C handler
    624            * @param  Addr: I2C address
    625            * @param  Reg: Reg address 
    626            * @param  MemAddress: Memory address 
    627            * @param  Buffer: Pointer to data buffer
    628            * @param  Length: Length of the data
    629            * @retval Number of read data
    630            */

   \                                 In section .text, align 2, keep-with-next
    631          static HAL_StatusTypeDef I2Cx_ReadMultiple(I2C_HandleTypeDef *i2c_handler,
    632                                                     uint8_t Addr,
    633                                                     uint16_t Reg,
    634                                                     uint16_t MemAddress,
    635                                                     uint8_t *Buffer,
    636                                                     uint16_t Length)
    637          {
   \                     I2Cx_ReadMultiple: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \   00000012   0x9C0D             LDR      R4,[SP, #+52]
    638            HAL_StatusTypeDef status = HAL_OK;
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
    639          
    640            status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
   \   00000018   0xF44F 0x707A      MOV      R0,#+1000
   \   0000001C   0x9002             STR      R0,[SP, #+8]
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000028   0x4643             MOV      R3,R8
   \   0000002A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002C   0x003A             MOVS     R2,R7
   \   0000002E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       HAL_I2C_Mem_Read
   \   0000003C   0x4682             MOV      R10,R0
    641          
    642            /* Check the communication status */
    643            if(status != HAL_OK)
   \   0000003E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000042   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000046   0xD004             BEQ.N    ??I2Cx_ReadMultiple_0
    644            {
    645              /* I2C error occurred */
    646              I2Cx_Error(i2c_handler, Addr);
   \   00000048   0x0031             MOVS     R1,R6
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       I2Cx_Error
    647            }
    648            return status;    
   \                     ??I2Cx_ReadMultiple_0: (+1)
   \   00000052   0x4650             MOV      R0,R10
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xB004             ADD      SP,SP,#+16
   \   00000058   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    649          }
    650          
    651          /**
    652            * @brief  Writes a value in a register of the device through BUS in using DMA mode.
    653            * @param  i2c_handler : I2C handler
    654            * @param  Addr: Device address on BUS Bus.  
    655            * @param  Reg: The target register address to write
    656            * @param  MemAddress: Memory address 
    657            * @param  Buffer: The target register value to be written 
    658            * @param  Length: buffer size to be written
    659            * @retval HAL status
    660            */

   \                                 In section .text, align 2, keep-with-next
    661          static HAL_StatusTypeDef I2Cx_WriteMultiple(I2C_HandleTypeDef *i2c_handler,
    662                                                      uint8_t Addr,
    663                                                      uint16_t Reg,
    664                                                      uint16_t MemAddress,
    665                                                      uint8_t *Buffer,
    666                                                      uint16_t Length)
    667          {
   \                     I2Cx_WriteMultiple: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0005             MOVS     R5,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0017             MOVS     R7,R2
   \   0000000C   0x4698             MOV      R8,R3
   \   0000000E   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \   00000012   0x9C0D             LDR      R4,[SP, #+52]
    668            HAL_StatusTypeDef status = HAL_OK;
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
    669            
    670            status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
   \   00000018   0xF44F 0x707A      MOV      R0,#+1000
   \   0000001C   0x9002             STR      R0,[SP, #+8]
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000028   0x4643             MOV      R3,R8
   \   0000002A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000002C   0x003A             MOVS     R2,R7
   \   0000002E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       HAL_I2C_Mem_Write
   \   0000003C   0x4682             MOV      R10,R0
    671            
    672            /* Check the communication status */
    673            if(status != HAL_OK)
   \   0000003E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000042   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000046   0xD004             BEQ.N    ??I2Cx_WriteMultiple_0
    674            {
    675              /* Re-Initiaize the I2C Bus */
    676              I2Cx_Error(i2c_handler, Addr);
   \   00000048   0x0031             MOVS     R1,R6
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x.... 0x....      BL       I2Cx_Error
    677            }
    678            return status;
   \                     ??I2Cx_WriteMultiple_0: (+1)
   \   00000052   0x4650             MOV      R0,R10
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0xB004             ADD      SP,SP,#+16
   \   00000058   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    679          }
    680          
    681          /**
    682            * @brief  Checks if target device is ready for communication. 
    683            * @note   This function is used with Memory devices
    684            * @param  i2c_handler : I2C handler
    685            * @param  DevAddress: Target device address
    686            * @param  Trials: Number of trials
    687            * @retval HAL status
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          static HAL_StatusTypeDef I2Cx_IsDeviceReady(I2C_HandleTypeDef *i2c_handler, uint16_t DevAddress, uint32_t Trials)
    690          { 
   \                     I2Cx_IsDeviceReady: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    691            return (HAL_I2C_IsDeviceReady(i2c_handler, DevAddress, Trials, 1000));
   \   00000008   0xF44F 0x737A      MOV      R3,#+1000
   \   0000000C   0x0032             MOVS     R2,R6
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       HAL_I2C_IsDeviceReady
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
    692          }
    693          
    694          /**
    695            * @brief  Manages error callback by re-initializing I2C.
    696            * @param  i2c_handler : I2C handler
    697            * @param  Addr: I2C Address
    698            * @retval None
    699            */

   \                                 In section .text, align 2, keep-with-next
    700          static void I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr)
    701          {
   \                     I2Cx_Error: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    702            /* De-initialize the I2C communication bus */
    703            HAL_I2C_DeInit(i2c_handler);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       HAL_I2C_DeInit
    704            
    705            /* Re-Initialize the I2C communication bus */
    706            I2Cx_Init(i2c_handler);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       I2Cx_Init
    707          }
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    708          
    709          /*******************************************************************************
    710                                      LINK OPERATIONS
    711          *******************************************************************************/
    712          
    713          /********************************* LINK AUDIO *********************************/
    714          
    715          /**
    716            * @brief  Initializes Audio low level.
    717            * @retval None
    718            */

   \                                 In section .text, align 2, keep-with-next
    719          void AUDIO_IO_Init(void) 
    720          {
   \                     AUDIO_IO_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    721            I2Cx_Init(&hI2cAudioHandler);
   \   00000002   0x....             LDR.N    R0,??DataTable24_16
   \   00000004   0x.... 0x....      BL       I2Cx_Init
    722          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    723          
    724          /**
    725            * @brief  Deinitializes Audio low level.
    726            * @retval None
    727            */

   \                                 In section .text, align 2, keep-with-next
    728          void AUDIO_IO_DeInit(void)
    729          {
    730          }
   \                     AUDIO_IO_DeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    731          
    732          /**
    733            * @brief  Writes a single data.
    734            * @param  Addr: I2C address
    735            * @param  Reg: Reg address 
    736            * @param  Value: Data to be written
    737            * @retval None
    738            */

   \                                 In section .text, align 2, keep-with-next
    739          void AUDIO_IO_Write(uint8_t Addr, uint16_t Reg, uint16_t Value)
    740          {
   \                     AUDIO_IO_Write: (+1)
   \   00000000   0xB574             PUSH     {R2,R4-R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    741            uint16_t tmp = Value;
   \   00000008   0xF8BD 0x600C      LDRH     R6,[SP, #+12]
    742            
    743            Value = ((uint16_t)(tmp >> 8) & 0x00FF);
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x0A00             LSRS     R0,R0,#+8
   \   00000012   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    744            
    745            Value |= ((uint16_t)(tmp << 8)& 0xFF00);
   \   00000016   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   0000001A   0xEA50 0x2006      ORRS     R0,R0,R6, LSL #+8
   \   0000001E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    746            
    747            I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT,(uint8_t*)&Value, 2);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0xA803             ADD      R0,SP,#+12
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x2302             MOVS     R3,#+2
   \   0000002C   0x002A             MOVS     R2,R5
   \   0000002E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x....             LDR.N    R0,??DataTable24_16
   \   00000036   0x.... 0x....      BL       I2Cx_WriteMultiple
    748          }
   \   0000003A   0xBD7F             POP      {R0-R6,PC}       ;; return
    749          
    750          /**
    751            * @brief  Reads a single data.
    752            * @param  Addr: I2C address
    753            * @param  Reg: Reg address 
    754            * @retval Data to be read
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          uint16_t AUDIO_IO_Read(uint8_t Addr, uint16_t Reg)
    757          {
   \                     AUDIO_IO_Read: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    758            uint16_t read_value = 0, tmp = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
   \   0000000E   0x2600             MOVS     R6,#+0
    759            
    760            I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_16BIT, (uint8_t*)&read_value, 2);
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x9001             STR      R0,[SP, #+4]
   \   00000014   0xA802             ADD      R0,SP,#+8
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x2302             MOVS     R3,#+2
   \   0000001A   0x002A             MOVS     R2,R5
   \   0000001C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x....             LDR.N    R0,??DataTable24_16
   \   00000024   0x.... 0x....      BL       I2Cx_ReadMultiple
    761            
    762            tmp = ((uint16_t)(read_value >> 8) & 0x00FF);
   \   00000028   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0x0A00             LSRS     R0,R0,#+8
   \   00000030   0x0006             MOVS     R6,R0
    763            
    764            tmp |= ((uint16_t)(read_value << 8)& 0xFF00);
   \   00000032   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000036   0xEA56 0x2600      ORRS     R6,R6,R0, LSL #+8
    765            
    766            read_value = tmp;
   \   0000003A   0xF8AD 0x6008      STRH     R6,[SP, #+8]
    767            
    768            return read_value;
   \   0000003E   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000042   0xB004             ADD      SP,SP,#+16
   \   00000044   0xBD70             POP      {R4-R6,PC}       ;; return
    769          }
    770          
    771          /**
    772            * @brief  AUDIO Codec delay 
    773            * @param  Delay: Delay in ms
    774            * @retval None
    775            */

   \                                 In section .text, align 2, keep-with-next
    776          void AUDIO_IO_Delay(uint32_t Delay)
    777          {
   \                     AUDIO_IO_Delay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    778            HAL_Delay(Delay);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_Delay
    779          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    780          
    781          /********************************* LINK CAMERA ********************************/
    782          
    783          /**
    784            * @brief  Initializes Camera low level.
    785            * @retval None
    786            */

   \                                 In section .text, align 2, keep-with-next
    787          void CAMERA_IO_Init(void) 
    788          {
   \                     CAMERA_IO_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    789            I2Cx_Init(&hI2cExtHandler);
   \   00000002   0x....             LDR.N    R0,??DataTable24_24
   \   00000004   0x.... 0x....      BL       I2Cx_Init
    790          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    791          
    792          /**
    793            * @brief  Camera writes single data.
    794            * @param  Addr: I2C address
    795            * @param  Reg: Register address 
    796            * @param  Value: Data to be written
    797            * @retval None
    798            */

   \                                 In section .text, align 2, keep-with-next
    799          void CAMERA_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
    800          {
   \                     CAMERA_IO_Write: (+1)
   \   00000000   0xB537             PUSH     {R0-R2,R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    801            I2Cx_WriteMultiple(&hI2cExtHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0xA802             ADD      R0,SP,#+8
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x....             LDR.N    R0,??DataTable24_24
   \   0000001C   0x.... 0x....      BL       I2Cx_WriteMultiple
    802          }
   \   00000020   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    803          
    804          /**
    805            * @brief  Camera reads single data.
    806            * @param  Addr: I2C address
    807            * @param  Reg: Register address 
    808            * @retval Read data
    809            */

   \                                 In section .text, align 2, keep-with-next
    810          uint8_t CAMERA_IO_Read(uint8_t Addr, uint8_t Reg)
    811          {
   \                     CAMERA_IO_Read: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    812            uint8_t read_value = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0008      STRB     R0,[SP, #+8]
    813          
    814            I2Cx_ReadMultiple(&hI2cExtHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0xA802             ADD      R0,SP,#+8
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x002A             MOVS     R2,R5
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x....             LDR.N    R0,??DataTable24_24
   \   00000022   0x.... 0x....      BL       I2Cx_ReadMultiple
    815          
    816            return read_value;
   \   00000026   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000002A   0xBD3E             POP      {R1-R5,PC}       ;; return
    817          }
    818          
    819          /**
    820            * @brief  Camera delay 
    821            * @param  Delay: Delay in ms
    822            * @retval None
    823            */

   \                                 In section .text, align 2, keep-with-next
    824          void CAMERA_Delay(uint32_t Delay)
    825          {
   \                     CAMERA_Delay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    826            HAL_Delay(Delay);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_Delay
    827          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    828          
    829          /******************************** LINK I2C EEPROM *****************************/
    830          
    831          /**
    832            * @brief  Initializes peripherals used by the I2C EEPROM driver.
    833            * @retval None
    834            */

   \                                 In section .text, align 2, keep-with-next
    835          void EEPROM_IO_Init(void)
    836          {
   \                     EEPROM_IO_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    837            I2Cx_Init(&hI2cExtHandler);
   \   00000002   0x....             LDR.N    R0,??DataTable24_24
   \   00000004   0x.... 0x....      BL       I2Cx_Init
    838          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    839          
    840          /**
    841            * @brief  Write data to I2C EEPROM driver in using DMA channel.
    842            * @param  DevAddress: Target device address
    843            * @param  MemAddress: Internal memory address
    844            * @param  pBuffer: Pointer to data buffer
    845            * @param  BufferSize: Amount of data to be sent
    846            * @retval HAL status
    847            */

   \                                 In section .text, align 2, keep-with-next
    848          HAL_StatusTypeDef EEPROM_IO_WriteData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    849          {
   \                     EEPROM_IO_WriteData: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    850            return (I2Cx_WriteMultiple(&hI2cExtHandler, DevAddress, MemAddress, I2C_MEMADD_SIZE_16BIT, pBuffer, BufferSize));
   \   0000000C   0x0038             MOVS     R0,R7
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x9600             STR      R6,[SP, #+0]
   \   00000014   0x2302             MOVS     R3,#+2
   \   00000016   0x002A             MOVS     R2,R5
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x....             LDR.N    R0,??DataTable24_24
   \   00000020   0x.... 0x....      BL       I2Cx_WriteMultiple
   \   00000024   0xBDFE             POP      {R1-R7,PC}       ;; return
    851          }
    852          
    853          /**
    854            * @brief  Read data from I2C EEPROM driver in using DMA channel.
    855            * @param  DevAddress: Target device address
    856            * @param  MemAddress: Internal memory address
    857            * @param  pBuffer: Pointer to data buffer
    858            * @param  BufferSize: Amount of data to be read
    859            * @retval HAL status
    860            */

   \                                 In section .text, align 2, keep-with-next
    861          HAL_StatusTypeDef EEPROM_IO_ReadData(uint16_t DevAddress, uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    862          {
   \                     EEPROM_IO_ReadData: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    863            return (I2Cx_ReadMultiple(&hI2cExtHandler, DevAddress, MemAddress, I2C_MEMADD_SIZE_16BIT, pBuffer, BufferSize));
   \   0000000C   0x0038             MOVS     R0,R7
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x9600             STR      R6,[SP, #+0]
   \   00000014   0x2302             MOVS     R3,#+2
   \   00000016   0x002A             MOVS     R2,R5
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x0021             MOVS     R1,R4
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0x....             LDR.N    R0,??DataTable24_24
   \   00000020   0x.... 0x....      BL       I2Cx_ReadMultiple
   \   00000024   0xBDFE             POP      {R1-R7,PC}       ;; return
    864          }
    865          
    866          /**
    867            * @brief  Checks if target device is ready for communication. 
    868            * @note   This function is used with Memory devices
    869            * @param  DevAddress: Target device address
    870            * @param  Trials: Number of trials
    871            * @retval HAL status
    872            */

   \                                 In section .text, align 2, keep-with-next
    873          HAL_StatusTypeDef EEPROM_IO_IsDeviceReady(uint16_t DevAddress, uint32_t Trials)
    874          { 
   \                     EEPROM_IO_IsDeviceReady: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    875            return (I2Cx_IsDeviceReady(&hI2cExtHandler, DevAddress, Trials));
   \   00000006   0x002A             MOVS     R2,R5
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x....             LDR.N    R0,??DataTable24_24
   \   0000000E   0x.... 0x....      BL       I2Cx_IsDeviceReady
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    876          }
    877          
    878          /********************************* LINK TOUCHSCREEN *********************************/
    879          
    880          /**
    881            * @brief  Initializes Touchscreen low level.
    882            * @retval None
    883            */

   \                                 In section .text, align 2, keep-with-next
    884          void TS_IO_Init(void)
    885          {
   \                     TS_IO_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    886            I2Cx_Init(&hI2cAudioHandler);
   \   00000002   0x....             LDR.N    R0,??DataTable24_16
   \   00000004   0x.... 0x....      BL       I2Cx_Init
    887          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    888          
    889          /**
    890            * @brief  Writes a single data.
    891            * @param  Addr: I2C address
    892            * @param  Reg: Reg address
    893            * @param  Value: Data to be written
    894            * @retval None
    895            */

   \                                 In section .text, align 2, keep-with-next
    896          void TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
    897          {
   \                     TS_IO_Write: (+1)
   \   00000000   0xB537             PUSH     {R0-R2,R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    898            I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0xA802             ADD      R0,SP,#+8
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x002A             MOVS     R2,R5
   \   00000014   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x....             LDR.N    R0,??DataTable24_16
   \   0000001C   0x.... 0x....      BL       I2Cx_WriteMultiple
    899          }
   \   00000020   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    900          
    901          /**
    902            * @brief  Reads a single data.
    903            * @param  Addr: I2C address
    904            * @param  Reg: Reg address
    905            * @retval Data to be read
    906            */

   \                                 In section .text, align 2, keep-with-next
    907          uint8_t TS_IO_Read(uint8_t Addr, uint8_t Reg)
    908          {
   \                     TS_IO_Read: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    909            uint8_t read_value = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0008      STRB     R0,[SP, #+8]
    910          
    911            I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0xA802             ADD      R0,SP,#+8
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x002A             MOVS     R2,R5
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000020   0x....             LDR.N    R0,??DataTable24_16
   \   00000022   0x.... 0x....      BL       I2Cx_ReadMultiple
    912          
    913            return read_value;
   \   00000026   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000002A   0xBD3E             POP      {R1-R5,PC}       ;; return
    914          }
    915          
    916          /**
    917            * @brief  TS delay
    918            * @param  Delay: Delay in ms
    919            * @retval None
    920            */

   \                                 In section .text, align 2, keep-with-next
    921          void TS_IO_Delay(uint32_t Delay)
    922          {
   \                     TS_IO_Delay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    923            HAL_Delay(Delay);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       HAL_Delay
    924          }
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x........         DC32     GPIO_PIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x........         DC32     BUTTON_PIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x........         DC32     BUTTON_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x10210000         DC32     0x10210000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x10110000         DC32     0x10110000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x........         DC32     BUTTON_IRQn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x........         DC32     COM_TX_PIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x........         DC32     COM_TX_AF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x........         DC32     COM_TX_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \   00000000   0x........         DC32     COM_RX_PIN

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \   00000000   0x........         DC32     COM_RX_AF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \   00000000   0x........         DC32     COM_RX_PORT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \   00000000   0x........         DC32     COM_USART

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_16:
   \   00000000   0x........         DC32     hI2cAudioHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_17:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_18:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_19:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_20:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_21:
   \   00000000   0x40005C00         DC32     0x40005c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_22:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_23:
   \   00000000   0x40912732         DC32     0x40912732

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_24:
   \   00000000   0x........         DC32     hI2cExtHandler
    925          
    926          /**
    927            * @}
    928            */
    929          
    930          /**
    931            * @}
    932            */ 
    933          
    934          /**
    935            * @}
    936            */
    937          
    938          /**
    939            * @}
    940            */    
    941              
    942          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AUDIO_IO_DeInit
       8   AUDIO_IO_Delay
         8   -> HAL_Delay
       8   AUDIO_IO_Init
         8   -> I2Cx_Init
      32   AUDIO_IO_Read
        32   -> I2Cx_ReadMultiple
      32   AUDIO_IO_Write
        32   -> I2Cx_WriteMultiple
      16   BSP_COM_DeInit
        16   -> HAL_UART_DeInit
      40   BSP_COM_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_UART_Init
       0   BSP_GetVersion
      32   BSP_LED_DeInit
        32   -> HAL_GPIO_DeInit
        32   -> HAL_GPIO_WritePin
      40   BSP_LED_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_GPIO_WritePin
      16   BSP_LED_Off
        16   -> HAL_GPIO_WritePin
      16   BSP_LED_On
        16   -> HAL_GPIO_WritePin
      16   BSP_LED_Toggle
        16   -> HAL_GPIO_TogglePin
      32   BSP_PB_DeInit
        32   -> HAL_GPIO_DeInit
        32   -> HAL_NVIC_DisableIRQ
       8   BSP_PB_GetState
         8   -> HAL_GPIO_ReadPin
      40   BSP_PB_Init
        40   -> HAL_GPIO_Init
        40   -> HAL_NVIC_EnableIRQ
        40   -> HAL_NVIC_SetPriority
       8   CAMERA_Delay
         8   -> HAL_Delay
       8   CAMERA_IO_Init
         8   -> I2Cx_Init
      24   CAMERA_IO_Read
        24   -> I2Cx_ReadMultiple
      24   CAMERA_IO_Write
        24   -> I2Cx_WriteMultiple
       8   EEPROM_IO_Init
         8   -> I2Cx_Init
      16   EEPROM_IO_IsDeviceReady
        16   -> I2Cx_IsDeviceReady
      32   EEPROM_IO_ReadData
        32   -> I2Cx_ReadMultiple
      32   EEPROM_IO_WriteData
        32   -> I2Cx_WriteMultiple
      16   I2Cx_Error
        16   -> HAL_I2C_DeInit
        16   -> I2Cx_Init
       8   I2Cx_Init
         8   -> HAL_I2C_GetState
         8   -> HAL_I2C_Init
         8   -> I2Cx_MspInit
      16   I2Cx_IsDeviceReady
        16   -> HAL_I2C_IsDeviceReady
      32   I2Cx_MspInit
        32   -> HAL_GPIO_Init
        32   -> HAL_NVIC_EnableIRQ
        32   -> HAL_NVIC_SetPriority
      48   I2Cx_ReadMultiple
        48   -> HAL_I2C_Mem_Read
        48   -> I2Cx_Error
      48   I2Cx_WriteMultiple
        48   -> HAL_I2C_Mem_Write
        48   -> I2Cx_Error
       8   TS_IO_Delay
         8   -> HAL_Delay
       8   TS_IO_Init
         8   -> I2Cx_Init
      24   TS_IO_Read
        24   -> I2Cx_ReadMultiple
      24   TS_IO_Write
        24   -> I2Cx_WriteMultiple


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_20
       4  ??DataTable24_21
       4  ??DataTable24_22
       4  ??DataTable24_23
       4  ??DataTable24_24
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       2  AUDIO_IO_DeInit
      12  AUDIO_IO_Delay
      10  AUDIO_IO_Init
      70  AUDIO_IO_Read
      60  AUDIO_IO_Write
      52  BSP_COM_DeInit
     234  BSP_COM_Init
       6  BSP_GetVersion
     114  BSP_LED_DeInit
     200  BSP_LED_Init
      70  BSP_LED_Off
      70  BSP_LED_On
      66  BSP_LED_Toggle
      54  BSP_PB_DeInit
      30  BSP_PB_GetState
     262  BSP_PB_Init
       8  BUTTON_IRQn
       8  BUTTON_PIN
      12  BUTTON_PORT
      12  CAMERA_Delay
      10  CAMERA_IO_Init
      44  CAMERA_IO_Read
      34  CAMERA_IO_Write
       2  COM_RX_AF
       2  COM_RX_PIN
       4  COM_RX_PORT
       2  COM_TX_AF
       2  COM_TX_PIN
       4  COM_TX_PORT
       4  COM_USART
      10  EEPROM_IO_Init
      20  EEPROM_IO_IsDeviceReady
      38  EEPROM_IO_ReadData
      38  EEPROM_IO_WriteData
       8  GPIO_PIN
      20  I2Cx_Error
      72  I2Cx_Init
      26  I2Cx_IsDeviceReady
     340  I2Cx_MspInit
      92  I2Cx_ReadMultiple
      92  I2Cx_WriteMultiple
      12  TS_IO_Delay
      10  TS_IO_Init
      44  TS_IO_Read
      34  TS_IO_Write
      60  hI2cAudioHandler
      60  hI2cExtHandler

 
   120 bytes in section .bss
    24 bytes in section .data
    32 bytes in section .rodata
 2 360 bytes in section .text
 
 2 360 bytes of CODE  memory
    32 bytes of CONST memory
   144 bytes of DATA  memory

Errors: none
Warnings: none
