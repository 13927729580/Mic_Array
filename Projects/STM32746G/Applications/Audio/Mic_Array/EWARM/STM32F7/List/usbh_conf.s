///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM      13/Feb/2016  11:44:40
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
//    Command line =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
//        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
//        USE_IOEXPANDER -D USE_USB_FS -lC
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -lA
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -o
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
//        --no_clustering --no_scheduling --debug --endian=little
//        --cpu=Cortex-M7 -e --fpu=VFPv5_sp --dlib_config "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench
//        7.3\arm\INC\c\DLib_Config_Full.h" -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
//        -On --use_c++_inline --require_prototypes -I "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
//        ARM_MATH_CM7
//    List file    =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_conf.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN HAL_Delay
        EXTERN HAL_GPIO_Init
        EXTERN HAL_GPIO_WritePin
        EXTERN HAL_HCD_DeInit
        EXTERN HAL_HCD_GetCurrentFrame
        EXTERN HAL_HCD_GetCurrentSpeed
        EXTERN HAL_HCD_HC_GetURBState
        EXTERN HAL_HCD_HC_GetXferCount
        EXTERN HAL_HCD_HC_Halt
        EXTERN HAL_HCD_HC_Init
        EXTERN HAL_HCD_HC_SubmitRequest
        EXTERN HAL_HCD_Init
        EXTERN HAL_HCD_ResetPort
        EXTERN HAL_HCD_Start
        EXTERN HAL_HCD_Stop
        EXTERN HAL_NVIC_EnableIRQ
        EXTERN HAL_NVIC_SetPriority
        EXTERN USBH_LL_Connect
        EXTERN USBH_LL_Disconnect
        EXTERN USBH_LL_IncTimer
        EXTERN USBH_LL_SetTimer

        PUBLIC HAL_HCD_Connect_Callback
        PUBLIC HAL_HCD_Disconnect_Callback
        PUBLIC HAL_HCD_HC_NotifyURBChange_Callback
        PUBLIC HAL_HCD_MspDeInit
        PUBLIC HAL_HCD_MspInit
        PUBLIC HAL_HCD_SOF_Callback
        PUBLIC USBH_Delay
        PUBLIC USBH_LL_ClosePipe
        PUBLIC USBH_LL_DeInit
        PUBLIC USBH_LL_DriverVBUS
        PUBLIC USBH_LL_GetLastXferSize
        PUBLIC USBH_LL_GetSpeed
        PUBLIC USBH_LL_GetToggle
        PUBLIC USBH_LL_GetURBState
        PUBLIC USBH_LL_Init
        PUBLIC USBH_LL_OpenPipe
        PUBLIC USBH_LL_ResetPort
        PUBLIC USBH_LL_SetToggle
        PUBLIC USBH_LL_Start
        PUBLIC USBH_LL_Stop
        PUBLIC USBH_LL_SubmitURB
        PUBLIC hhcd
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
//    1 /**
//    2   ******************************************************************************
//    3   * @file    Audio/Audio_playback_and_record/Src/usbh_conf.c
//    4   * @author  MCD Application Team
//    5   * @version V1.0.0
//    6   * @date    25-June-2015
//    7   * @brief   USB Host configuration file.
//    8   ******************************************************************************
//    9   * @attention
//   10   *
//   11   * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
//   12   *
//   13   * Redistribution and use in source and binary forms, with or without modification,
//   14   * are permitted provided that the following conditions are met:
//   15   *   1. Redistributions of source code must retain the above copyright notice,
//   16   *      this list of conditions and the following disclaimer.
//   17   *   2. Redistributions in binary form must reproduce the above copyright notice,
//   18   *      this list of conditions and the following disclaimer in the documentation
//   19   *      and/or other materials provided with the distribution.
//   20   *   3. Neither the name of STMicroelectronics nor the names of its contributors
//   21   *      may be used to endorse or promote products derived from this software
//   22   *      without specific prior written permission.
//   23   *
//   24   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   25   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   26   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   27   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//   28   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   29   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//   30   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//   31   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//   32   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//   33   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   34   *
//   35   ******************************************************************************
//   36   */
//   37 
//   38 /* Includes ------------------------------------------------------------------*/
//   39 #include "stm32f7xx_hal.h"
//   40 #include "usbh_core.h"
//   41 #include "stm32746g_discovery.h"
//   42 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
//   43 HCD_HandleTypeDef hhcd;
hhcd:
        DS8 660
//   44 
//   45 /*******************************************************************************
//   46                        HCD BSP Routines
//   47 *******************************************************************************/
//   48 /**
//   49   * @brief  Initializes the HCD MSP.
//   50   * @param  hhcd: HCD handle
//   51   * @retval None
//   52   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HAL_HCD_MspInit
        THUMB
//   53 void HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
//   54 {
HAL_HCD_MspInit:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+32
          CFI CFA R13+40
        MOVS     R4,R0
//   55   GPIO_InitTypeDef  GPIO_InitStruct;
//   56   
//   57   if(hhcd->Instance == USB_OTG_FS)
        LDR      R0,[R4, #+0]
        CMP      R0,#+1342177280
        BNE.N    ??HAL_HCD_MspInit_0
//   58   {
//   59     /* Configure USB FS GPIOs */
//   60     __HAL_RCC_GPIOA_CLK_ENABLE();
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.W    R1,??DataTable5  ;; 0x40023830
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x1
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//   61     __HAL_RCC_GPIOD_CLK_ENABLE();
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x8
        LDR.W    R1,??DataTable5  ;; 0x40023830
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x8
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//   62     
//   63     GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
        MOV      R0,#+6144
        STR      R0,[SP, #+4]
//   64     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
//   65     GPIO_InitStruct.Pull = GPIO_NOPULL;
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
//   66     GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
        MOVS     R0,#+3
        STR      R0,[SP, #+16]
//   67     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
//   68     HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
        ADD      R1,SP,#+4
        LDR.W    R0,??DataTable5_1  ;; 0x40020000
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//   69     
//   70     /* Configure POWER_SWITCH IO pin */
//   71     GPIO_InitStruct.Pin = GPIO_PIN_5;
        MOVS     R0,#+32
        STR      R0,[SP, #+4]
//   72     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
//   73     GPIO_InitStruct.Pull = GPIO_NOPULL;
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
//   74     HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
        ADD      R1,SP,#+4
        LDR.W    R0,??DataTable5_2  ;; 0x40020c00
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//   75     
//   76     /* Enable USB FS Clocks */ 
//   77     __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
        LDR.W    R0,??DataTable5_3  ;; 0x40023834
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x80
        LDR.W    R1,??DataTable5_3  ;; 0x40023834
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable5_3  ;; 0x40023834
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x80
        STR      R0,[SP, #+24]
        LDR      R0,[SP, #+24]
        LDR.W    R0,??DataTable5_4  ;; 0x40023844
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4000
        LDR.W    R1,??DataTable5_4  ;; 0x40023844
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable5_4  ;; 0x40023844
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x4000
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//   78     
//   79     /* Set USBFS Interrupt to the lowest priority */
//   80     HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
        MOVS     R2,#+0
        MOVS     R1,#+6
        MOVS     R0,#+67
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
//   81     
//   82     /* Enable USBFS Interrupt */
//   83     HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
        MOVS     R0,#+67
          CFI FunCall HAL_NVIC_EnableIRQ
        BL       HAL_NVIC_EnableIRQ
        B.N      ??HAL_HCD_MspInit_1
//   84   } 
//   85   else if(hhcd->Instance == USB_OTG_HS)
??HAL_HCD_MspInit_0:
        LDR      R0,[R4, #+0]
        LDR.W    R1,??DataTable5_5  ;; 0x40040000
        CMP      R0,R1
        BNE.W    ??HAL_HCD_MspInit_1
//   86   {
//   87     /* Configure USB HS GPIOs */
//   88     __HAL_RCC_GPIOA_CLK_ENABLE();
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x1
        LDR.W    R1,??DataTable5  ;; 0x40023830
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x1
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//   89     __HAL_RCC_GPIOB_CLK_ENABLE();
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x2
        LDR.W    R1,??DataTable5  ;; 0x40023830
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x2
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//   90     __HAL_RCC_GPIOC_CLK_ENABLE();
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x4
        LDR.W    R1,??DataTable5  ;; 0x40023830
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x4
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//   91     __HAL_RCC_GPIOH_CLK_ENABLE();
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x80
        LDR.W    R1,??DataTable5  ;; 0x40023830
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x80
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//   92 	
//   93     /* CLK */
//   94 	//sop1hc
//   95     //GPIO_InitStruct.Pin = GPIO_PIN_5;
//   96     //GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//   97     //GPIO_InitStruct.Pull = GPIO_NOPULL;
//   98     //GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
//   99     //GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
//  100     //HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
//  101     
//  102     /* D0 */
//  103     GPIO_InitStruct.Pin = GPIO_PIN_3;
        MOVS     R0,#+8
        STR      R0,[SP, #+4]
//  104     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
//  105     GPIO_InitStruct.Pull = GPIO_NOPULL;
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
//  106     GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
        MOVS     R0,#+3
        STR      R0,[SP, #+16]
//  107     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
//  108     HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
        ADD      R1,SP,#+4
        LDR.N    R0,??DataTable5_1  ;; 0x40020000
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  109     
//  110     /* D1 D2 D3 D4 D5 D6 D7 */
//  111     GPIO_InitStruct.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_5 |\ 
//  112       GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13;
        MOVW     R0,#+15395
        STR      R0,[SP, #+4]
//  113     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
//  114     GPIO_InitStruct.Pull = GPIO_NOPULL;
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
//  115     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
//  116     HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); 
        ADD      R1,SP,#+4
        LDR.N    R0,??DataTable5_6  ;; 0x40020400
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  117     
//  118     /* STP */     
//  119     GPIO_InitStruct.Pin = GPIO_PIN_0;
        MOVS     R0,#+1
        STR      R0,[SP, #+4]
//  120     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
//  121     GPIO_InitStruct.Pull = GPIO_NOPULL;
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
//  122     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
//  123     HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
        ADD      R1,SP,#+4
        LDR.N    R0,??DataTable5_7  ;; 0x40020800
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  124     
//  125     /* NXT */ 
//  126     GPIO_InitStruct.Pin = GPIO_PIN_4;
        MOVS     R0,#+16
        STR      R0,[SP, #+4]
//  127     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
//  128     GPIO_InitStruct.Pull = GPIO_NOPULL;
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
//  129     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
//  130     HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
        ADD      R1,SP,#+4
        LDR.N    R0,??DataTable5_8  ;; 0x40021c00
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  131     
//  132     /* DIR */
//  133     GPIO_InitStruct.Pin = GPIO_PIN_2;
        MOVS     R0,#+4
        STR      R0,[SP, #+4]
//  134     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
//  135     GPIO_InitStruct.Pull = GPIO_NOPULL;
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
//  136     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
//  137     HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        ADD      R1,SP,#+4
        LDR.N    R0,??DataTable5_7  ;; 0x40020800
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  138     __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
        LDR.N    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x40000000
        LDR.N    R1,??DataTable5  ;; 0x40023830
        STR      R0,[R1, #+0]
        LDR.N    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x40000000
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//  139 
//  140     /* Enable USB HS Clocks */ 
//  141     __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
        LDR.N    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x20000000
        LDR.N    R1,??DataTable5  ;; 0x40023830
        STR      R0,[R1, #+0]
        LDR.N    R0,??DataTable5  ;; 0x40023830
        LDR      R0,[R0, #+0]
        ANDS     R0,R0,#0x20000000
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
//  142     
//  143     /* Set USBHS Interrupt to the lowest priority */
//  144     HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
        MOVS     R2,#+0
        MOVS     R1,#+6
        MOVS     R0,#+77
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
//  145     
//  146     /* Enable USBHS Interrupt */
//  147     HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
        MOVS     R0,#+77
          CFI FunCall HAL_NVIC_EnableIRQ
        BL       HAL_NVIC_EnableIRQ
//  148   }   
//  149 }
??HAL_HCD_MspInit_1:
        ADD      SP,SP,#+32
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock0
//  150 
//  151 /**
//  152   * @brief  DeInitializes the HCD MSP.
//  153   * @param  hhcd: HCD handle
//  154   * @retval None
//  155   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function HAL_HCD_MspDeInit
          CFI NoCalls
        THUMB
//  156 void HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd)
//  157 {
//  158   if(hhcd->Instance == USB_OTG_FS)
HAL_HCD_MspDeInit:
        LDR      R1,[R0, #+0]
        CMP      R1,#+1342177280
        BNE.N    ??HAL_HCD_MspDeInit_0
//  159   {  
//  160     /* Disable USB FS Clocks */ 
//  161     __HAL_RCC_USB_OTG_FS_CLK_DISABLE();
        LDR.N    R1,??DataTable5_3  ;; 0x40023834
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x80
        LDR.N    R2,??DataTable5_3  ;; 0x40023834
        STR      R1,[R2, #+0]
        LDR.N    R1,??DataTable5_4  ;; 0x40023844
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x4000
        LDR.N    R2,??DataTable5_4  ;; 0x40023844
        STR      R1,[R2, #+0]
        B.N      ??HAL_HCD_MspDeInit_1
//  162   }
//  163   else if(hhcd->Instance == USB_OTG_HS)
??HAL_HCD_MspDeInit_0:
        LDR      R1,[R0, #+0]
        LDR.N    R2,??DataTable5_5  ;; 0x40040000
        CMP      R1,R2
        BNE.N    ??HAL_HCD_MspDeInit_1
//  164   {  
//  165     /* Disable USB HS Clocks */ 
//  166     __HAL_RCC_USB_OTG_HS_CLK_DISABLE();
        LDR.N    R1,??DataTable5  ;; 0x40023830
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x20000000
        LDR.N    R2,??DataTable5  ;; 0x40023830
        STR      R1,[R2, #+0]
//  167     __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE();
        LDR.N    R1,??DataTable5  ;; 0x40023830
        LDR      R1,[R1, #+0]
        BICS     R1,R1,#0x40000000
        LDR.N    R2,??DataTable5  ;; 0x40023830
        STR      R1,[R2, #+0]
//  168   }  
//  169 }
??HAL_HCD_MspDeInit_1:
        BX       LR               ;; return
          CFI EndBlock cfiBlock1
//  170 
//  171 /*******************************************************************************
//  172                        LL Driver Callbacks (HCD -> USB Host Library)
//  173 *******************************************************************************/
//  174 
//  175 /**
//  176   * @brief  SOF callback.
//  177   * @param  hhcd: HCD handle
//  178   * @retval None
//  179   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HAL_HCD_SOF_Callback
        THUMB
//  180 void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
//  181 {
HAL_HCD_SOF_Callback:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  182   USBH_LL_IncTimer (hhcd->pData);
        LDR      R0,[R4, #+656]
          CFI FunCall USBH_LL_IncTimer
        BL       USBH_LL_IncTimer
//  183 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock2
//  184 
//  185 /**
//  186   * @brief  Connect callback.
//  187   * @param  hhcd: HCD handle
//  188   * @retval None
//  189   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function HAL_HCD_Connect_Callback
        THUMB
//  190 void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
//  191 {
HAL_HCD_Connect_Callback:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  192   USBH_LL_Connect(hhcd->pData);
        LDR      R0,[R4, #+656]
          CFI FunCall USBH_LL_Connect
        BL       USBH_LL_Connect
//  193 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock3
//  194 
//  195 /**
//  196   * @brief  Disconnect callback.
//  197   * @param  hhcd: HCD handle
//  198   * @retval None
//  199   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function HAL_HCD_Disconnect_Callback
        THUMB
//  200 void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
//  201 {
HAL_HCD_Disconnect_Callback:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  202   USBH_LL_Disconnect(hhcd->pData);
        LDR      R0,[R4, #+656]
          CFI FunCall USBH_LL_Disconnect
        BL       USBH_LL_Disconnect
//  203 } 
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock4
//  204 
//  205 
//  206 /**
//  207   * @brief  Notify URB state change callback.
//  208   * @param  hhcd: HCD handle
//  209   * @param  chnum: Channel number 
//  210   * @param  urb_state: URB State
//  211   * @retval None
//  212   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function HAL_HCD_HC_NotifyURBChange_Callback
          CFI NoCalls
        THUMB
//  213 void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
//  214 {
//  215   /* To be used with OS to sync URB state with the global state machine */
//  216 }
HAL_HCD_HC_NotifyURBChange_Callback:
        BX       LR               ;; return
          CFI EndBlock cfiBlock5
//  217 
//  218 /*******************************************************************************
//  219                        LL Driver Interface (USB Host Library --> HCD)
//  220 *******************************************************************************/
//  221 /**
//  222   * @brief  USBH_LL_Init 
//  223   *         Initialize the Low Level portion of the Host driver.
//  224   * @param  phost: Host handle
//  225   * @retval USBH Status
//  226   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function USBH_LL_Init
        THUMB
//  227 USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
//  228 {
USBH_LL_Init:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  229 #ifdef USE_USB_FS  
//  230   /* Set the LL driver parameters */
//  231   hhcd.Instance = USB_OTG_FS;
        MOVS     R0,#+1342177280
        LDR.N    R1,??DataTable5_9
        STR      R0,[R1, #+0]
//  232   hhcd.Init.Host_channels = 11; 
        MOVS     R0,#+11
        LDR.N    R1,??DataTable5_9
        STR      R0,[R1, #+8]
//  233   hhcd.Init.dma_enable = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5_9
        STR      R0,[R1, #+16]
//  234   hhcd.Init.low_power_enable = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5_9
        STR      R0,[R1, #+32]
//  235   hhcd.Init.phy_itface = HCD_PHY_EMBEDDED; 
        MOVS     R0,#+2
        LDR.N    R1,??DataTable5_9
        STR      R0,[R1, #+24]
//  236   hhcd.Init.Sof_enable = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5_9
        STR      R0,[R1, #+28]
//  237   hhcd.Init.speed = HCD_SPEED_FULL;
        MOVS     R0,#+3
        LDR.N    R1,??DataTable5_9
        STR      R0,[R1, #+12]
//  238   hhcd.Init.vbus_sensing_enable = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable5_9
        STR      R0,[R1, #+40]
//  239   
//  240   /* Link the driver to the stack */
//  241   hhcd.pData = phost;
        LDR.N    R0,??DataTable5_9
        STR      R4,[R0, #+656]
//  242   phost->pData = &hhcd;
        LDR.N    R0,??DataTable5_9
        STR      R0,[R4, #+688]
//  243   
//  244   /* Initialize the LL Driver */
//  245   HAL_HCD_Init(&hhcd);
        LDR.N    R0,??DataTable5_9
          CFI FunCall HAL_HCD_Init
        BL       HAL_HCD_Init
//  246 #endif 
//  247 #ifdef USE_USB_HS  
//  248   /* Set the LL driver parameters */
//  249   hhcd.Instance = USB_OTG_HS;
//  250   hhcd.Init.Host_channels = 11; 
//  251   hhcd.Init.dma_enable = 1;
//  252   hhcd.Init.low_power_enable = 0;
//  253   hhcd.Init.phy_itface = HCD_PHY_ULPI; 
//  254   hhcd.Init.Sof_enable = 0;
//  255   hhcd.Init.speed = HCD_SPEED_HIGH;
//  256   hhcd.Init.vbus_sensing_enable = 0;
//  257   hhcd.Init.use_external_vbus = 1;  
//  258   
//  259   /* Link the driver to the stack */
//  260   hhcd.pData = phost;
//  261   phost->pData = &hhcd;
//  262   /* Initialize the LL driver */
//  263   HAL_HCD_Init(&hhcd);
//  264 #endif /*USE_USB_HS*/ 
//  265 
//  266   USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd));
        LDR.N    R0,??DataTable5_9
          CFI FunCall HAL_HCD_GetCurrentFrame
        BL       HAL_HCD_GetCurrentFrame
        MOVS     R1,R0
        MOVS     R0,R4
          CFI FunCall USBH_LL_SetTimer
        BL       USBH_LL_SetTimer
//  267   
//  268   return USBH_OK;
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  269 }
          CFI EndBlock cfiBlock6
//  270 
//  271 /**
//  272   * @brief  De-Initializes the Low Level portion of the Host driver.
//  273   * @param  phost: Host handle
//  274   * @retval USBH Status
//  275   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function USBH_LL_DeInit
        THUMB
//  276 USBH_StatusTypeDef USBH_LL_DeInit(USBH_HandleTypeDef *phost)
//  277 {
USBH_LL_DeInit:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  278   HAL_HCD_DeInit(phost->pData);
        LDR      R0,[R4, #+688]
          CFI FunCall HAL_HCD_DeInit
        BL       HAL_HCD_DeInit
//  279   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  280 }
          CFI EndBlock cfiBlock7
//  281 
//  282 /**
//  283   * @brief  Starts the Low Level portion of the Host driver.   
//  284   * @param  phost: Host handle
//  285   * @retval USBH Status
//  286   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function USBH_LL_Start
        THUMB
//  287 USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
//  288 {
USBH_LL_Start:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  289   HAL_HCD_Start(phost->pData);
        LDR      R0,[R4, #+688]
          CFI FunCall HAL_HCD_Start
        BL       HAL_HCD_Start
//  290   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  291 }
          CFI EndBlock cfiBlock8
//  292 
//  293 /**
//  294   * @brief  Stops the Low Level portion of the Host driver.
//  295   * @param  phost: Host handle
//  296   * @retval USBH Status
//  297   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function USBH_LL_Stop
        THUMB
//  298 USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
//  299 {
USBH_LL_Stop:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  300   HAL_HCD_Stop(phost->pData);
        LDR      R0,[R4, #+688]
          CFI FunCall HAL_HCD_Stop
        BL       HAL_HCD_Stop
//  301   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  302 }
          CFI EndBlock cfiBlock9
//  303 
//  304 /**
//  305   * @brief  Returns the USB Host Speed from the Low Level Driver.
//  306   * @param  phost: Host handle
//  307   * @retval USBH Speeds
//  308   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function USBH_LL_GetSpeed
        THUMB
//  309 USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
//  310 {
USBH_LL_GetSpeed:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
//  311   USBH_SpeedTypeDef speed = USBH_SPEED_FULL;
        MOVS     R5,#+1
//  312   
//  313   switch (HAL_HCD_GetCurrentSpeed(phost->pData))
        LDR      R0,[R4, #+688]
          CFI FunCall HAL_HCD_GetCurrentSpeed
        BL       HAL_HCD_GetCurrentSpeed
        CMP      R0,#+0
        BEQ.N    ??USBH_LL_GetSpeed_0
        CMP      R0,#+2
        BEQ.N    ??USBH_LL_GetSpeed_1
        BCC.N    ??USBH_LL_GetSpeed_2
        B.N      ??USBH_LL_GetSpeed_3
//  314   {
//  315   case 0: 
//  316     speed = USBH_SPEED_HIGH;
??USBH_LL_GetSpeed_0:
        MOVS     R0,#+0
        MOVS     R5,R0
//  317     break;
        B.N      ??USBH_LL_GetSpeed_4
//  318     
//  319   case 1: 
//  320     speed = USBH_SPEED_FULL;    
??USBH_LL_GetSpeed_2:
        MOVS     R0,#+1
        MOVS     R5,R0
//  321     break;
        B.N      ??USBH_LL_GetSpeed_4
//  322     
//  323   case 2: 
//  324     speed = USBH_SPEED_LOW;   
??USBH_LL_GetSpeed_1:
        MOVS     R0,#+2
        MOVS     R5,R0
//  325     break;
        B.N      ??USBH_LL_GetSpeed_4
//  326     
//  327   default:  
//  328     speed = USBH_SPEED_FULL;    
??USBH_LL_GetSpeed_3:
        MOVS     R0,#+1
        MOVS     R5,R0
//  329     break;    
//  330   }
//  331   return speed;
??USBH_LL_GetSpeed_4:
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,R4,R5,PC}    ;; return
//  332 }
          CFI EndBlock cfiBlock10
//  333 
//  334 /**
//  335   * @brief  Resets the Host Port of the Low Level Driver.
//  336   * @param  phost: Host handle
//  337   * @retval USBH Status
//  338   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function USBH_LL_ResetPort
        THUMB
//  339 USBH_StatusTypeDef USBH_LL_ResetPort (USBH_HandleTypeDef *phost) 
//  340 {
USBH_LL_ResetPort:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  341   HAL_HCD_ResetPort(phost->pData);
        LDR      R0,[R4, #+688]
          CFI FunCall HAL_HCD_ResetPort
        BL       HAL_HCD_ResetPort
//  342   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
//  343 }
          CFI EndBlock cfiBlock11
//  344 
//  345 /**
//  346   * @brief  Returns the last transferred packet size.
//  347   * @param  phost: Host handle
//  348   * @param  pipe: Pipe index   
//  349   * @retval Packet Size
//  350   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function USBH_LL_GetLastXferSize
        THUMB
//  351 uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)  
//  352 {
USBH_LL_GetLastXferSize:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
        MOVS     R5,R1
//  353   return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R4, #+688]
          CFI FunCall HAL_HCD_HC_GetXferCount
        BL       HAL_HCD_HC_GetXferCount
        POP      {R1,R4,R5,PC}    ;; return
//  354 }
          CFI EndBlock cfiBlock12
//  355 
//  356 /**
//  357   * @brief  Opens a pipe of the Low Level Driver.
//  358   * @param  phost: Host handle
//  359   * @param  pipe: Pipe index
//  360   * @param  epnum: Endpoint Number
//  361   * @param  dev_address: Device USB address
//  362   * @param  speed: Device Speed 
//  363   * @param  ep_type: Endpoint Type
//  364   * @param  mps: Endpoint Max Packet Size                 
//  365   * @retval USBH Status
//  366   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function USBH_LL_OpenPipe
        THUMB
//  367 USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, 
//  368                                     uint8_t pipe,
//  369                                     uint8_t epnum,                                      
//  370                                     uint8_t dev_address,
//  371                                     uint8_t speed,
//  372                                     uint8_t ep_type,
//  373                                     uint16_t mps)
//  374 {
USBH_LL_OpenPipe:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOVS     R7,R0
        MOV      R8,R1
        MOV      R9,R2
        MOV      R10,R3
        LDR      R4,[SP, #+48]
        LDR      R6,[SP, #+52]
        LDR      R5,[SP, #+56]
//  375   HAL_HCD_HC_Init(phost->pData,
//  376                   pipe,
//  377                   epnum,
//  378                   dev_address,
//  379                   speed,
//  380                   ep_type,
//  381                   mps);
        MOVS     R0,R5
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+8]
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+4]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+0]
        MOV      R3,R10
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOV      R2,R9
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOV      R1,R8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R7, #+688]
          CFI FunCall HAL_HCD_HC_Init
        BL       HAL_HCD_HC_Init
//  382   return USBH_OK; 
        MOVS     R0,#+0
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
//  383 }
          CFI EndBlock cfiBlock13
//  384 
//  385 /**
//  386   * @brief  Closes a pipe of the Low Level Driver.
//  387   * @param  phost: Host handle
//  388   * @param  pipe: Pipe index               
//  389   * @retval USBH Status
//  390   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function USBH_LL_ClosePipe
        THUMB
//  391 USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)   
//  392 {
USBH_LL_ClosePipe:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
        MOVS     R5,R1
//  393   HAL_HCD_HC_Halt(phost->pData, pipe);
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R4, #+688]
          CFI FunCall HAL_HCD_HC_Halt
        BL       HAL_HCD_HC_Halt
//  394   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
//  395 }
          CFI EndBlock cfiBlock14
//  396 
//  397 /**
//  398   * @brief  Submits a new URB to the low level driver.
//  399   * @param  phost: Host handle
//  400   * @param  pipe: Pipe index    
//  401   *          This parameter can be a value from 1 to 15
//  402   * @param  direction: Channel number
//  403   *          This parameter can be one of these values:
//  404   *           0: Output 
//  405   *           1: Input
//  406   * @param  ep_type: Endpoint Type
//  407   *          This parameter can be one of these values:
//  408   *            @arg EP_TYPE_CTRL: Control type
//  409   *            @arg EP_TYPE_ISOC: Isochronous type
//  410   *            @arg EP_TYPE_BULK: Bulk type
//  411   *            @arg EP_TYPE_INTR: Interrupt type
//  412   * @param  token: Endpoint Type
//  413   *          This parameter can be one of these values:
//  414   *            @arg 0: PID_SETUP
//  415   *            @arg 1: PID_DATA
//  416   * @param  pbuff: pointer to URB data
//  417   * @param  length: length of URB data
//  418   * @param  do_ping: activate do ping protocol (for high speed only)
//  419   *          This parameter can be one of these values:
//  420   *           0: do ping inactive 
//  421   *           1: do ping active 
//  422   * @retval USBH Status
//  423   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function USBH_LL_SubmitURB
        THUMB
//  424 USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, 
//  425                                      uint8_t pipe, 
//  426                                      uint8_t direction,
//  427                                      uint8_t ep_type,  
//  428                                      uint8_t token, 
//  429                                      uint8_t* pbuff, 
//  430                                      uint16_t length,
//  431                                      uint8_t do_ping) 
//  432 {
USBH_LL_SubmitURB:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+20
          CFI CFA R13+56
        MOVS     R7,R0
        MOV      R8,R1
        MOV      R9,R2
        MOV      R10,R3
        LDR      R4,[SP, #+56]
        LDR      R11,[SP, #+60]
        LDR      R5,[SP, #+64]
        LDR      R6,[SP, #+68]
//  433   HAL_HCD_HC_SubmitRequest(phost->pData,
//  434                            pipe, 
//  435                            direction,
//  436                            ep_type,  
//  437                            token, 
//  438                            pbuff, 
//  439                            length,
//  440                            do_ping);
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+12]
        MOVS     R0,R5
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+8]
        STR      R11,[SP, #+4]
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+0]
        MOV      R3,R10
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOV      R2,R9
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOV      R1,R8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R7, #+688]
          CFI FunCall HAL_HCD_HC_SubmitRequest
        BL       HAL_HCD_HC_SubmitRequest
//  441   return USBH_OK;   
        MOVS     R0,#+0
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
//  442 }
          CFI EndBlock cfiBlock15
//  443 
//  444 /**
//  445   * @brief  Gets a URB state from the low level driver.
//  446   * @param  phost: Host handle
//  447   * @param  pipe: Pipe index
//  448   *          This parameter can be a value from 1 to 15
//  449   * @retval URB state
//  450   *          This parameter can be one of these values:
//  451   *            @arg URB_IDLE
//  452   *            @arg URB_DONE
//  453   *            @arg URB_NOTREADY
//  454   *            @arg URB_NYET 
//  455   *            @arg URB_ERROR  
//  456   *            @arg URB_STALL      
//  457   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function USBH_LL_GetURBState
        THUMB
//  458 USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe) 
//  459 {
USBH_LL_GetURBState:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
        MOVS     R5,R1
//  460   return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R4, #+688]
          CFI FunCall HAL_HCD_HC_GetURBState
        BL       HAL_HCD_HC_GetURBState
        POP      {R1,R4,R5,PC}    ;; return
//  461 }
          CFI EndBlock cfiBlock16
//  462 
//  463 /**
//  464   * @brief  Drives VBUS.
//  465   * @param  phost: Host handle
//  466   * @param  state: VBUS state
//  467   *          This parameter can be one of these values:
//  468   *           0: VBUS Active 
//  469   *           1: VBUS Inactive
//  470   * @retval USBH Status
//  471   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function USBH_LL_DriverVBUS
        THUMB
//  472 USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
//  473 {
USBH_LL_DriverVBUS:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,R0
        MOVS     R5,R1
//  474 #ifdef USE_USB_FS
//  475   if(state == 0)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??USBH_LL_DriverVBUS_0
//  476   {
//  477     HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_SET);
        MOVS     R2,#+1
        MOVS     R1,#+32
        LDR.N    R0,??DataTable5_2  ;; 0x40020c00
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        B.N      ??USBH_LL_DriverVBUS_1
//  478   }
//  479   else
//  480   {
//  481     HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_RESET);
??USBH_LL_DriverVBUS_0:
        MOVS     R2,#+0
        MOVS     R1,#+32
        LDR.N    R0,??DataTable5_2  ;; 0x40020c00
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
//  482   }
//  483   
//  484   HAL_Delay(200);
??USBH_LL_DriverVBUS_1:
        MOVS     R0,#+200
          CFI FunCall HAL_Delay
        BL       HAL_Delay
//  485 #endif /* USE_USB_FS */
//  486   return USBH_OK;  
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
//  487 }
          CFI EndBlock cfiBlock17
//  488 
//  489 /**
//  490   * @brief  Sets toggle for a pipe.
//  491   * @param  phost: Host handle
//  492   * @param  pipe: Pipe index   
//  493   * @param  toggle: toggle (0/1)
//  494   * @retval USBH Status
//  495   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function USBH_LL_SetToggle
          CFI NoCalls
        THUMB
//  496 USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)   
//  497 {
USBH_LL_SetToggle:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
        MOVS     R3,R0
//  498   if(hhcd.hc[pipe].ep_is_in)
        LDR.N    R0,??DataTable5_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+40
        MLA      R0,R4,R1,R0
        LDRB     R0,[R0, #+55]
        CMP      R0,#+0
        BEQ.N    ??USBH_LL_SetToggle_0
//  499   {
//  500     hhcd.hc[pipe].toggle_in = toggle;
        LDR.N    R0,??DataTable5_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+40
        MLA      R0,R4,R1,R0
        STRB     R2,[R0, #+76]
        B.N      ??USBH_LL_SetToggle_1
//  501   }
//  502   else
//  503   {
//  504     hhcd.hc[pipe].toggle_out = toggle;
??USBH_LL_SetToggle_0:
        LDR.N    R0,??DataTable5_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+40
        MLA      R0,R4,R1,R0
        STRB     R2,[R0, #+77]
//  505   }
//  506   return USBH_OK; 
??USBH_LL_SetToggle_1:
        MOVS     R0,#+0
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
//  507 }
          CFI EndBlock cfiBlock18
//  508 
//  509 /**
//  510   * @brief  Returns the current toggle of a pipe.
//  511   * @param  phost: Host handle
//  512   * @param  pipe: Pipe index
//  513   * @retval toggle (0/1)
//  514   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function USBH_LL_GetToggle
          CFI NoCalls
        THUMB
//  515 uint8_t USBH_LL_GetToggle(USBH_HandleTypeDef *phost, uint8_t pipe)   
//  516 {
USBH_LL_GetToggle:
        PUSH     {R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+4
        MOVS     R2,R0
//  517   uint8_t toggle = 0;
        MOVS     R0,#+0
//  518   
//  519   if(hhcd.hc[pipe].ep_is_in)
        LDR.N    R3,??DataTable5_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+40
        MLA      R3,R4,R1,R3
        LDRB     R3,[R3, #+55]
        CMP      R3,#+0
        BEQ.N    ??USBH_LL_GetToggle_0
//  520   {
//  521     toggle = hhcd.hc[pipe].toggle_in;
        LDR.N    R3,??DataTable5_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+40
        MLA      R3,R4,R1,R3
        LDRB     R3,[R3, #+76]
        MOVS     R0,R3
        B.N      ??USBH_LL_GetToggle_1
//  522   }
//  523   else
//  524   {
//  525     toggle = hhcd.hc[pipe].toggle_out;
??USBH_LL_GetToggle_0:
        LDR.N    R3,??DataTable5_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+40
        MLA      R3,R4,R1,R3
        LDRB     R3,[R3, #+77]
        MOVS     R0,R3
//  526   }
//  527   return toggle; 
??USBH_LL_GetToggle_1:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
//  528 }
          CFI EndBlock cfiBlock19

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5:
        DC32     0x40023830

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_1:
        DC32     0x40020000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_2:
        DC32     0x40020c00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_3:
        DC32     0x40023834

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_4:
        DC32     0x40023844

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_5:
        DC32     0x40040000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_6:
        DC32     0x40020400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_7:
        DC32     0x40020800

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_8:
        DC32     0x40021c00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_9:
        DC32     hhcd
//  529 
//  530 /**
//  531   * @brief  Delay routine for the USB Host Library
//  532   * @param  Delay: Delay in ms
//  533   * @retval None
//  534   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function USBH_Delay
        THUMB
//  535 void USBH_Delay(uint32_t Delay)
//  536 {
USBH_Delay:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,R0
//  537   HAL_Delay(Delay);  
        MOVS     R0,R4
          CFI FunCall HAL_Delay
        BL       HAL_Delay
//  538 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock20

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  539 
//  540 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// 
//   660 bytes in section .bss
// 1 272 bytes in section .text
// 
// 1 272 bytes of CODE memory
//   660 bytes of DATA memory
//
//Errors: none
//Warnings: none
