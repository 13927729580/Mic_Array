///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM      07/Mar/2016  01:52:21
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
//    Command line =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
//        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
//        USE_IOEXPANDER -D USE_USB_FS -lC
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -lA
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
//        -o
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
//        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e --fpu=VFPv5_sp
//        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.3\arm\INC\c\DLib_Config_Full.h" -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
//        -I
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
//        -Oh --use_c++_inline --require_prototypes -I "D:\Program Files
//        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
//        ARM_MATH_CM7 --relaxed_fp
//    List file    =  
//        H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\usbh_conf.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        AAPCS BASE,INTERWORK,VFP
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN HAL_Delay
        EXTERN HAL_GPIO_Init
        EXTERN HAL_GPIO_WritePin
        EXTERN HAL_HCD_DeInit
        EXTERN HAL_HCD_GetCurrentFrame
        EXTERN HAL_HCD_GetCurrentSpeed
        EXTERN HAL_HCD_HC_GetURBState
        EXTERN HAL_HCD_HC_GetXferCount
        EXTERN HAL_HCD_HC_Halt
        EXTERN HAL_HCD_HC_Init
        EXTERN HAL_HCD_HC_SubmitRequest
        EXTERN HAL_HCD_Init
        EXTERN HAL_HCD_ResetPort
        EXTERN HAL_HCD_Start
        EXTERN HAL_HCD_Stop
        EXTERN HAL_NVIC_EnableIRQ
        EXTERN HAL_NVIC_SetPriority
        EXTERN USBH_LL_Connect
        EXTERN USBH_LL_Disconnect
        EXTERN USBH_LL_IncTimer
        EXTERN USBH_LL_SetTimer

        PUBLIC HAL_HCD_Connect_Callback
        PUBLIC HAL_HCD_Disconnect_Callback
        PUBLIC HAL_HCD_HC_NotifyURBChange_Callback
        PUBLIC HAL_HCD_MspDeInit
        PUBLIC HAL_HCD_MspInit
        PUBLIC HAL_HCD_SOF_Callback
        PUBLIC USBH_Delay
        PUBLIC USBH_LL_ClosePipe
        PUBLIC USBH_LL_DeInit
        PUBLIC USBH_LL_DriverVBUS
        PUBLIC USBH_LL_GetLastXferSize
        PUBLIC USBH_LL_GetSpeed
        PUBLIC USBH_LL_GetToggle
        PUBLIC USBH_LL_GetURBState
        PUBLIC USBH_LL_Init
        PUBLIC USBH_LL_OpenPipe
        PUBLIC USBH_LL_ResetPort
        PUBLIC USBH_LL_SetToggle
        PUBLIC USBH_LL_Start
        PUBLIC USBH_LL_Stop
        PUBLIC USBH_LL_SubmitURB
        PUBLIC hhcd
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI Resource D0:64, D1:64, D2:64, D3:64, D4:64, D5:64, D6:64, D7:64
          CFI Resource D8:64, D9:64, D10:64, D11:64, D12:64, D13:64, D14:64
          CFI Resource D15:64
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI D0 Undefined
          CFI D1 Undefined
          CFI D2 Undefined
          CFI D3 Undefined
          CFI D4 Undefined
          CFI D5 Undefined
          CFI D6 Undefined
          CFI D7 Undefined
          CFI D8 SameValue
          CFI D9 SameValue
          CFI D10 SameValue
          CFI D11 SameValue
          CFI D12 SameValue
          CFI D13 SameValue
          CFI D14 SameValue
          CFI D15 SameValue
          CFI EndCommon cfiCommon0
        
// H:\PhanLeSon\ActivNoise\Microphone\F7\Mic_Array_Project\Mic_Array\Projects\STM32746G\Applications\Audio\Mic_Array\Src\usbh_conf.c
//    1 /**
//    2   ******************************************************************************
//    3   * @file    Audio/Audio_playback_and_record/Src/usbh_conf.c
//    4   * @author  MCD Application Team
//    5   * @version V1.0.0
//    6   * @date    25-June-2015
//    7   * @brief   USB Host configuration file.
//    8   ******************************************************************************
//    9   * @attention
//   10   *
//   11   * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
//   12   *
//   13   * Redistribution and use in source and binary forms, with or without modification,
//   14   * are permitted provided that the following conditions are met:
//   15   *   1. Redistributions of source code must retain the above copyright notice,
//   16   *      this list of conditions and the following disclaimer.
//   17   *   2. Redistributions in binary form must reproduce the above copyright notice,
//   18   *      this list of conditions and the following disclaimer in the documentation
//   19   *      and/or other materials provided with the distribution.
//   20   *   3. Neither the name of STMicroelectronics nor the names of its contributors
//   21   *      may be used to endorse or promote products derived from this software
//   22   *      without specific prior written permission.
//   23   *
//   24   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   25   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   26   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   27   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//   28   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   29   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//   30   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//   31   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//   32   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//   33   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   34   *
//   35   ******************************************************************************
//   36   */
//   37 
//   38 /* Includes ------------------------------------------------------------------*/
//   39 #include "stm32f7xx_hal.h"
//   40 #include "usbh_core.h"
//   41 #include "stm32746g_discovery.h"
//   42 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
//   43 HCD_HandleTypeDef hhcd;
hhcd:
        DS8 660
//   44 
//   45 /*******************************************************************************
//   46                        HCD BSP Routines
//   47 *******************************************************************************/
//   48 /**
//   49   * @brief  Initializes the HCD MSP.
//   50   * @param  hhcd: HCD handle
//   51   * @retval None
//   52   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HAL_HCD_MspInit
        THUMB
//   53 void HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
//   54 {
HAL_HCD_MspInit:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+28
          CFI CFA R13+40
//   55   GPIO_InitTypeDef  GPIO_InitStruct;
//   56   
//   57   if(hhcd->Instance == USB_OTG_FS)
        LDR      R0,[R0, #+0]
        CMP      R0,#+1342177280
        BNE.N    ??HAL_HCD_MspInit_0
//   58   {
//   59     /* Configure USB FS GPIOs */
//   60     __HAL_RCC_GPIOA_CLK_ENABLE();
        LDR.N    R4,??DataTable5  ;; 0x40023830
//   61     __HAL_RCC_GPIOD_CLK_ENABLE();
//   62     
//   63     GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);
//   64     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//   65     GPIO_InitStruct.Pull = GPIO_NOPULL;
//   66     GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
//   67     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
//   68     HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
        ADD      R1,SP,#+4
        LDR      R0,[R4, #+0]
        ORR      R0,R0,#0x1
        STR      R0,[R4, #+0]
        LDR      R0,[R4, #+0]
        AND      R0,R0,#0x1
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        LDR      R0,[R4, #+0]
        ORR      R0,R0,#0x8
        STR      R0,[R4, #+0]
        LDR      R0,[R4, #+0]
        AND      R0,R0,#0x8
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        MOV      R0,#+6144
        STR      R0,[SP, #+4]
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        MOVS     R0,#+3
        STR      R0,[SP, #+16]
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
        LDR.N    R0,??DataTable5_1  ;; 0x40020000
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//   69     
//   70     /* Configure POWER_SWITCH IO pin */
//   71     GPIO_InitStruct.Pin = GPIO_PIN_5;
        MOVS     R0,#+32
//   72     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//   73     GPIO_InitStruct.Pull = GPIO_NOPULL;
//   74     HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
        ADD      R1,SP,#+4
        STR      R0,[SP, #+4]
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        LDR.N    R0,??DataTable5_2  ;; 0x40020c00
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//   75     
//   76     /* Enable USB FS Clocks */ 
//   77     __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
        LDR      R0,[R4, #+4]
//   78     
//   79     /* Set USBFS Interrupt to the lowest priority */
//   80     HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
        MOVS     R2,#+0
        MOVS     R1,#+6
        ORR      R0,R0,#0x80
        STR      R0,[R4, #+4]
        LDR      R0,[R4, #+4]
        AND      R0,R0,#0x80
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        LDR      R0,[R4, #+20]
        ORR      R0,R0,#0x4000
        STR      R0,[R4, #+20]
        LDR      R0,[R4, #+20]
        AND      R0,R0,#0x4000
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        MOVS     R0,#+67
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
//   81     
//   82     /* Enable USBFS Interrupt */
//   83     HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
        MOVS     R0,#+67
        B.N      ??HAL_HCD_MspInit_1
//   84   } 
//   85   else if(hhcd->Instance == USB_OTG_HS)
??HAL_HCD_MspInit_0:
        LDR.N    R1,??DataTable5_3  ;; 0x40040000
        CMP      R0,R1
        BNE.W    ??HAL_HCD_MspInit_2
//   86   {
//   87     /* Configure USB HS GPIOs */
//   88     __HAL_RCC_GPIOA_CLK_ENABLE();
        LDR.N    R4,??DataTable5  ;; 0x40023830
//   89     __HAL_RCC_GPIOB_CLK_ENABLE();
//   90     __HAL_RCC_GPIOC_CLK_ENABLE();
//   91     __HAL_RCC_GPIOH_CLK_ENABLE();
//   92 	
//   93     /* CLK */
//   94 	//sop1hc
//   95     //GPIO_InitStruct.Pin = GPIO_PIN_5;
//   96     //GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//   97     //GPIO_InitStruct.Pull = GPIO_NOPULL;
//   98     //GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
//   99     //GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
//  100     //HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
//  101     
//  102     /* D0 */
//  103     GPIO_InitStruct.Pin = GPIO_PIN_3;
//  104     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//  105     GPIO_InitStruct.Pull = GPIO_NOPULL;
//  106     GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
//  107     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
//  108     HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); 
        ADD      R1,SP,#+4
        LDR.N    R5,??DataTable5_4  ;; 0x40020800
        LDR      R0,[R4, #+0]
        ORR      R0,R0,#0x1
        STR      R0,[R4, #+0]
        LDR      R0,[R4, #+0]
        AND      R0,R0,#0x1
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        LDR      R0,[R4, #+0]
        ORR      R0,R0,#0x2
        STR      R0,[R4, #+0]
        LDR      R0,[R4, #+0]
        AND      R0,R0,#0x2
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        LDR      R0,[R4, #+0]
        ORR      R0,R0,#0x4
        STR      R0,[R4, #+0]
        LDR      R0,[R4, #+0]
        AND      R0,R0,#0x4
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        LDR      R0,[R4, #+0]
        ORR      R0,R0,#0x80
        STR      R0,[R4, #+0]
        LDR      R0,[R4, #+0]
        AND      R0,R0,#0x80
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        MOVS     R0,#+8
        STR      R0,[SP, #+4]
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        MOVS     R0,#+3
        STR      R0,[SP, #+16]
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
        LDR.N    R0,??DataTable5_1  ;; 0x40020000
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  109     
//  110     /* D1 D2 D3 D4 D5 D6 D7 */
//  111     GPIO_InitStruct.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_5 |\ 
//  112       GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13;
        MOVW     R0,#+15395
//  113     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//  114     GPIO_InitStruct.Pull = GPIO_NOPULL;
//  115     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
//  116     HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); 
        ADD      R1,SP,#+4
        STR      R0,[SP, #+4]
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
        LDR.N    R0,??DataTable5_5  ;; 0x40020400
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  117     
//  118     /* STP */     
//  119     GPIO_InitStruct.Pin = GPIO_PIN_0;
        MOVS     R0,#+1
//  120     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//  121     GPIO_InitStruct.Pull = GPIO_NOPULL;
//  122     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
//  123     HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); 
        ADD      R1,SP,#+4
        STR      R0,[SP, #+4]
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
        MOV      R0,R5
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  124     
//  125     /* NXT */ 
//  126     GPIO_InitStruct.Pin = GPIO_PIN_4;
        MOVS     R0,#+16
//  127     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//  128     GPIO_InitStruct.Pull = GPIO_NOPULL;
//  129     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
//  130     HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
        ADD      R1,SP,#+4
        STR      R0,[SP, #+4]
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
        LDR.N    R0,??DataTable5_6  ;; 0x40021c00
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  131     
//  132     /* DIR */
//  133     GPIO_InitStruct.Pin = GPIO_PIN_2;
        MOVS     R0,#+4
//  134     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
//  135     GPIO_InitStruct.Pull = GPIO_NOPULL;
//  136     GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
//  137     HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
        ADD      R1,SP,#+4
        STR      R0,[SP, #+4]
        MOVS     R0,#+2
        STR      R0,[SP, #+8]
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        MOVS     R0,#+10
        STR      R0,[SP, #+20]
        MOV      R0,R5
          CFI FunCall HAL_GPIO_Init
        BL       HAL_GPIO_Init
//  138     __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
        LDR      R0,[R4, #+0]
//  139 
//  140     /* Enable USB HS Clocks */ 
//  141     __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
//  142     
//  143     /* Set USBHS Interrupt to the lowest priority */
//  144     HAL_NVIC_SetPriority(OTG_HS_IRQn, 6, 0);
        MOVS     R2,#+0
        MOVS     R1,#+6
        ORR      R0,R0,#0x40000000
        STR      R0,[R4, #+0]
        LDR      R0,[R4, #+0]
        AND      R0,R0,#0x40000000
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        LDR      R0,[R4, #+0]
        ORR      R0,R0,#0x20000000
        STR      R0,[R4, #+0]
        LDR      R0,[R4, #+0]
        AND      R0,R0,#0x20000000
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+0]
        MOVS     R0,#+77
          CFI FunCall HAL_NVIC_SetPriority
        BL       HAL_NVIC_SetPriority
//  145     
//  146     /* Enable USBHS Interrupt */
//  147     HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
        MOVS     R0,#+77
??HAL_HCD_MspInit_1:
          CFI FunCall HAL_NVIC_EnableIRQ
        BL       HAL_NVIC_EnableIRQ
//  148   }   
//  149 }
??HAL_HCD_MspInit_2:
        ADD      SP,SP,#+28
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock0
//  150 
//  151 /**
//  152   * @brief  DeInitializes the HCD MSP.
//  153   * @param  hhcd: HCD handle
//  154   * @retval None
//  155   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function HAL_HCD_MspDeInit
          CFI NoCalls
        THUMB
//  156 void HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd)
//  157 {
//  158   if(hhcd->Instance == USB_OTG_FS)
HAL_HCD_MspDeInit:
        LDR      R0,[R0, #+0]
        CMP      R0,#+1342177280
        BNE.N    ??HAL_HCD_MspDeInit_0
//  159   {  
//  160     /* Disable USB FS Clocks */ 
//  161     __HAL_RCC_USB_OTG_FS_CLK_DISABLE();
        LDR.N    R0,??DataTable5  ;; 0x40023830
        LDR      R1,[R0, #+4]
        BIC      R1,R1,#0x80
        STR      R1,[R0, #+4]
        LDR      R1,[R0, #+20]
        BIC      R1,R1,#0x4000
        STR      R1,[R0, #+20]
        BX       LR
//  162   }
//  163   else if(hhcd->Instance == USB_OTG_HS)
??HAL_HCD_MspDeInit_0:
        LDR.N    R1,??DataTable5_3  ;; 0x40040000
        CMP      R0,R1
        BNE.N    ??HAL_HCD_MspDeInit_1
//  164   {  
//  165     /* Disable USB HS Clocks */ 
//  166     __HAL_RCC_USB_OTG_HS_CLK_DISABLE();
        LDR.N    R0,??DataTable5  ;; 0x40023830
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x20000000
        STR      R1,[R0, #+0]
//  167     __HAL_RCC_USB_OTG_HS_ULPI_CLK_DISABLE();
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x40000000
        STR      R1,[R0, #+0]
//  168   }  
//  169 }
??HAL_HCD_MspDeInit_1:
        BX       LR               ;; return
          CFI EndBlock cfiBlock1
//  170 
//  171 /*******************************************************************************
//  172                        LL Driver Callbacks (HCD -> USB Host Library)
//  173 *******************************************************************************/
//  174 
//  175 /**
//  176   * @brief  SOF callback.
//  177   * @param  hhcd: HCD handle
//  178   * @retval None
//  179   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HAL_HCD_SOF_Callback
        THUMB
//  180 void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
//  181 {
//  182   USBH_LL_IncTimer (hhcd->pData);
HAL_HCD_SOF_Callback:
        LDR      R0,[R0, #+656]
          CFI FunCall USBH_LL_IncTimer
        B.W      USBH_LL_IncTimer
//  183 }
          CFI EndBlock cfiBlock2
//  184 
//  185 /**
//  186   * @brief  Connect callback.
//  187   * @param  hhcd: HCD handle
//  188   * @retval None
//  189   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function HAL_HCD_Connect_Callback
        THUMB
//  190 void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
//  191 {
//  192   USBH_LL_Connect(hhcd->pData);
HAL_HCD_Connect_Callback:
        LDR      R0,[R0, #+656]
          CFI FunCall USBH_LL_Connect
        B.W      USBH_LL_Connect
//  193 }
          CFI EndBlock cfiBlock3
//  194 
//  195 /**
//  196   * @brief  Disconnect callback.
//  197   * @param  hhcd: HCD handle
//  198   * @retval None
//  199   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function HAL_HCD_Disconnect_Callback
        THUMB
//  200 void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
//  201 {
//  202   USBH_LL_Disconnect(hhcd->pData);
HAL_HCD_Disconnect_Callback:
        LDR      R0,[R0, #+656]
          CFI FunCall USBH_LL_Disconnect
        B.W      USBH_LL_Disconnect
//  203 } 
          CFI EndBlock cfiBlock4
//  204 
//  205 
//  206 /**
//  207   * @brief  Notify URB state change callback.
//  208   * @param  hhcd: HCD handle
//  209   * @param  chnum: Channel number 
//  210   * @param  urb_state: URB State
//  211   * @retval None
//  212   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function HAL_HCD_HC_NotifyURBChange_Callback
          CFI NoCalls
        THUMB
//  213 void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
//  214 {
//  215   /* To be used with OS to sync URB state with the global state machine */
//  216 }
HAL_HCD_HC_NotifyURBChange_Callback:
        BX       LR               ;; return
          CFI EndBlock cfiBlock5
//  217 
//  218 /*******************************************************************************
//  219                        LL Driver Interface (USB Host Library --> HCD)
//  220 *******************************************************************************/
//  221 /**
//  222   * @brief  USBH_LL_Init 
//  223   *         Initialize the Low Level portion of the Host driver.
//  224   * @param  phost: Host handle
//  225   * @retval USBH Status
//  226   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function USBH_LL_Init
        THUMB
//  227 USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
//  228 {
USBH_LL_Init:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
//  229 #ifdef USE_USB_FS  
//  230   /* Set the LL driver parameters */
//  231   hhcd.Instance = USB_OTG_FS;
        LDR.N    R5,??DataTable5_7
        MOV      R0,#+1342177280
//  232   hhcd.Init.Host_channels = 11; 
//  233   hhcd.Init.dma_enable = 0;
//  234   hhcd.Init.low_power_enable = 0;
//  235   hhcd.Init.phy_itface = HCD_PHY_EMBEDDED; 
//  236   hhcd.Init.Sof_enable = 0;
//  237   hhcd.Init.speed = HCD_SPEED_FULL;
//  238   hhcd.Init.vbus_sensing_enable = 0;
//  239   
//  240   /* Link the driver to the stack */
//  241   hhcd.pData = phost;
        STR      R4,[R5, #+656]
        STR      R0,[R5, #+0]
        MOVS     R0,#+11
        STR      R0,[R5, #+8]
        MOVS     R0,#+0
        STR      R0,[R5, #+16]
        STR      R0,[R5, #+32]
        MOVS     R0,#+2
        STR      R0,[R5, #+24]
        MOVS     R0,#+0
        STR      R0,[R5, #+28]
        MOVS     R0,#+3
        STR      R0,[R5, #+12]
        MOVS     R0,#+0
        STR      R0,[R5, #+40]
//  242   phost->pData = &hhcd;
//  243   
//  244   /* Initialize the LL Driver */
//  245   HAL_HCD_Init(&hhcd);
        MOV      R0,R5
        STR      R5,[R4, #+688]
          CFI FunCall HAL_HCD_Init
        BL       HAL_HCD_Init
//  246 #endif 
//  247 #ifdef USE_USB_HS  
//  248   /* Set the LL driver parameters */
//  249   hhcd.Instance = USB_OTG_HS;
//  250   hhcd.Init.Host_channels = 11; 
//  251   hhcd.Init.dma_enable = 1;
//  252   hhcd.Init.low_power_enable = 0;
//  253   hhcd.Init.phy_itface = HCD_PHY_ULPI; 
//  254   hhcd.Init.Sof_enable = 0;
//  255   hhcd.Init.speed = HCD_SPEED_HIGH;
//  256   hhcd.Init.vbus_sensing_enable = 0;
//  257   hhcd.Init.use_external_vbus = 1;  
//  258   
//  259   /* Link the driver to the stack */
//  260   hhcd.pData = phost;
//  261   phost->pData = &hhcd;
//  262   /* Initialize the LL driver */
//  263   HAL_HCD_Init(&hhcd);
//  264 #endif /*USE_USB_HS*/ 
//  265 
//  266   USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd));
        MOV      R0,R5
          CFI FunCall HAL_HCD_GetCurrentFrame
        BL       HAL_HCD_GetCurrentFrame
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall USBH_LL_SetTimer
        BL       USBH_LL_SetTimer
//  267   
//  268   return USBH_OK;
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
//  269 }
          CFI EndBlock cfiBlock6
//  270 
//  271 /**
//  272   * @brief  De-Initializes the Low Level portion of the Host driver.
//  273   * @param  phost: Host handle
//  274   * @retval USBH Status
//  275   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function USBH_LL_DeInit
        THUMB
//  276 USBH_StatusTypeDef USBH_LL_DeInit(USBH_HandleTypeDef *phost)
//  277 {
USBH_LL_DeInit:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  278   HAL_HCD_DeInit(phost->pData);
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_DeInit
        BL       HAL_HCD_DeInit
//  279   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
//  280 }
          CFI EndBlock cfiBlock7
//  281 
//  282 /**
//  283   * @brief  Starts the Low Level portion of the Host driver.   
//  284   * @param  phost: Host handle
//  285   * @retval USBH Status
//  286   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function USBH_LL_Start
        THUMB
//  287 USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
//  288 {
USBH_LL_Start:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  289   HAL_HCD_Start(phost->pData);
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_Start
        BL       HAL_HCD_Start
//  290   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
//  291 }
          CFI EndBlock cfiBlock8
//  292 
//  293 /**
//  294   * @brief  Stops the Low Level portion of the Host driver.
//  295   * @param  phost: Host handle
//  296   * @retval USBH Status
//  297   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function USBH_LL_Stop
        THUMB
//  298 USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
//  299 {
USBH_LL_Stop:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  300   HAL_HCD_Stop(phost->pData);
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_Stop
        BL       HAL_HCD_Stop
//  301   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
//  302 }
          CFI EndBlock cfiBlock9
//  303 
//  304 /**
//  305   * @brief  Returns the USB Host Speed from the Low Level Driver.
//  306   * @param  phost: Host handle
//  307   * @retval USBH Speeds
//  308   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function USBH_LL_GetSpeed
        THUMB
//  309 USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
//  310 {
USBH_LL_GetSpeed:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  311   USBH_SpeedTypeDef speed = USBH_SPEED_FULL;
//  312   
//  313   switch (HAL_HCD_GetCurrentSpeed(phost->pData))
        LDR      R0,[R0, #+688]
        MOVS     R4,#+1
          CFI FunCall HAL_HCD_GetCurrentSpeed
        BL       HAL_HCD_GetCurrentSpeed
        CBZ.N    R0,??USBH_LL_GetSpeed_0
        CMP      R0,#+2
        IT       EQ 
        MOVEQ    R4,#+2
//  314   {
//  315   case 0: 
//  316     speed = USBH_SPEED_HIGH;
//  317     break;
//  318     
//  319   case 1: 
//  320     speed = USBH_SPEED_FULL;    
//  321     break;
//  322     
//  323   case 2: 
//  324     speed = USBH_SPEED_LOW;   
        B.N      ??USBH_LL_GetSpeed_1
??USBH_LL_GetSpeed_0:
        MOVS     R4,#+0
//  325     break;
//  326     
//  327   default:  
//  328     speed = USBH_SPEED_FULL;    
//  329     break;    
//  330   }
//  331   return speed;
??USBH_LL_GetSpeed_1:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
//  332 }
          CFI EndBlock cfiBlock10
//  333 
//  334 /**
//  335   * @brief  Resets the Host Port of the Low Level Driver.
//  336   * @param  phost: Host handle
//  337   * @retval USBH Status
//  338   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function USBH_LL_ResetPort
        THUMB
//  339 USBH_StatusTypeDef USBH_LL_ResetPort (USBH_HandleTypeDef *phost) 
//  340 {
USBH_LL_ResetPort:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  341   HAL_HCD_ResetPort(phost->pData);
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_ResetPort
        BL       HAL_HCD_ResetPort
//  342   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
//  343 }
          CFI EndBlock cfiBlock11
//  344 
//  345 /**
//  346   * @brief  Returns the last transferred packet size.
//  347   * @param  phost: Host handle
//  348   * @param  pipe: Pipe index   
//  349   * @retval Packet Size
//  350   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function USBH_LL_GetLastXferSize
        THUMB
//  351 uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)  
//  352 {
//  353   return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
USBH_LL_GetLastXferSize:
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_HC_GetXferCount
        B.W      HAL_HCD_HC_GetXferCount
//  354 }
          CFI EndBlock cfiBlock12
//  355 
//  356 /**
//  357   * @brief  Opens a pipe of the Low Level Driver.
//  358   * @param  phost: Host handle
//  359   * @param  pipe: Pipe index
//  360   * @param  epnum: Endpoint Number
//  361   * @param  dev_address: Device USB address
//  362   * @param  speed: Device Speed 
//  363   * @param  ep_type: Endpoint Type
//  364   * @param  mps: Endpoint Max Packet Size                 
//  365   * @retval USBH Status
//  366   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function USBH_LL_OpenPipe
        THUMB
//  367 USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, 
//  368                                     uint8_t pipe,
//  369                                     uint8_t epnum,                                      
//  370                                     uint8_t dev_address,
//  371                                     uint8_t speed,
//  372                                     uint8_t ep_type,
//  373                                     uint16_t mps)
//  374 {
USBH_LL_OpenPipe:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+16
          CFI CFA R13+24
//  375   HAL_HCD_HC_Init(phost->pData,
//  376                   pipe,
//  377                   epnum,
//  378                   dev_address,
//  379                   speed,
//  380                   ep_type,
//  381                   mps);
        LDR      R4,[SP, #+32]
        STR      R4,[SP, #+8]
        LDR      R4,[SP, #+28]
        STR      R4,[SP, #+4]
        LDR      R4,[SP, #+24]
        STR      R4,[SP, #+0]
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_HC_Init
        BL       HAL_HCD_HC_Init
//  382   return USBH_OK; 
        B.N      ?Subroutine0
//  383 }
          CFI EndBlock cfiBlock13
//  384 
//  385 /**
//  386   * @brief  Closes a pipe of the Low Level Driver.
//  387   * @param  phost: Host handle
//  388   * @param  pipe: Pipe index               
//  389   * @retval USBH Status
//  390   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function USBH_LL_ClosePipe
        THUMB
//  391 USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)   
//  392 {
USBH_LL_ClosePipe:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
//  393   HAL_HCD_HC_Halt(phost->pData, pipe);
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_HC_Halt
        BL       HAL_HCD_HC_Halt
//  394   return USBH_OK; 
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
//  395 }
          CFI EndBlock cfiBlock14
//  396 
//  397 /**
//  398   * @brief  Submits a new URB to the low level driver.
//  399   * @param  phost: Host handle
//  400   * @param  pipe: Pipe index    
//  401   *          This parameter can be a value from 1 to 15
//  402   * @param  direction: Channel number
//  403   *          This parameter can be one of these values:
//  404   *           0: Output 
//  405   *           1: Input
//  406   * @param  ep_type: Endpoint Type
//  407   *          This parameter can be one of these values:
//  408   *            @arg EP_TYPE_CTRL: Control type
//  409   *            @arg EP_TYPE_ISOC: Isochronous type
//  410   *            @arg EP_TYPE_BULK: Bulk type
//  411   *            @arg EP_TYPE_INTR: Interrupt type
//  412   * @param  token: Endpoint Type
//  413   *          This parameter can be one of these values:
//  414   *            @arg 0: PID_SETUP
//  415   *            @arg 1: PID_DATA
//  416   * @param  pbuff: pointer to URB data
//  417   * @param  length: length of URB data
//  418   * @param  do_ping: activate do ping protocol (for high speed only)
//  419   *          This parameter can be one of these values:
//  420   *           0: do ping inactive 
//  421   *           1: do ping active 
//  422   * @retval USBH Status
//  423   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function USBH_LL_SubmitURB
        THUMB
//  424 USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, 
//  425                                      uint8_t pipe, 
//  426                                      uint8_t direction,
//  427                                      uint8_t ep_type,  
//  428                                      uint8_t token, 
//  429                                      uint8_t* pbuff, 
//  430                                      uint16_t length,
//  431                                      uint8_t do_ping) 
//  432 {
USBH_LL_SubmitURB:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+16
          CFI CFA R13+24
//  433   HAL_HCD_HC_SubmitRequest(phost->pData,
//  434                            pipe, 
//  435                            direction,
//  436                            ep_type,  
//  437                            token, 
//  438                            pbuff, 
//  439                            length,
//  440                            do_ping);
        LDR      R4,[SP, #+36]
        STR      R4,[SP, #+12]
        LDR      R4,[SP, #+32]
        STR      R4,[SP, #+8]
        LDR      R4,[SP, #+28]
        STR      R4,[SP, #+4]
        LDR      R4,[SP, #+24]
        STR      R4,[SP, #+0]
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_HC_SubmitRequest
        BL       HAL_HCD_HC_SubmitRequest
//  441   return USBH_OK;   
          CFI EndBlock cfiBlock15
        REQUIRE ?Subroutine0
        ;; // Fall through to label ?Subroutine0
//  442 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI NoFunction
          CFI CFA R13+24
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
        THUMB
?Subroutine0:
        MOVS     R0,#+0
        ADD      SP,SP,#+16
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock16
//  443 
//  444 /**
//  445   * @brief  Gets a URB state from the low level driver.
//  446   * @param  phost: Host handle
//  447   * @param  pipe: Pipe index
//  448   *          This parameter can be a value from 1 to 15
//  449   * @retval URB state
//  450   *          This parameter can be one of these values:
//  451   *            @arg URB_IDLE
//  452   *            @arg URB_DONE
//  453   *            @arg URB_NOTREADY
//  454   *            @arg URB_NYET 
//  455   *            @arg URB_ERROR  
//  456   *            @arg URB_STALL      
//  457   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function USBH_LL_GetURBState
        THUMB
//  458 USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe) 
//  459 {
//  460   return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
USBH_LL_GetURBState:
        LDR      R0,[R0, #+688]
          CFI FunCall HAL_HCD_HC_GetURBState
        B.W      HAL_HCD_HC_GetURBState
//  461 }
          CFI EndBlock cfiBlock17
//  462 
//  463 /**
//  464   * @brief  Drives VBUS.
//  465   * @param  phost: Host handle
//  466   * @param  state: VBUS state
//  467   *          This parameter can be one of these values:
//  468   *           0: VBUS Active 
//  469   *           1: VBUS Inactive
//  470   * @retval USBH Status
//  471   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function USBH_LL_DriverVBUS
        THUMB
//  472 USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
//  473 {
//  474 #ifdef USE_USB_FS
//  475   if(state == 0)
USBH_LL_DriverVBUS:
        CMP      R1,#+0
        LDR.N    R0,??DataTable5_2  ;; 0x40020c00
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        ITE      EQ 
        MOVEQ    R2,#+1
        MOVNE    R2,#+0
//  476   {
//  477     HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_SET);
//  478   }
//  479   else
//  480   {
//  481     HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_RESET);
        MOVS     R1,#+32
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
//  482   }
//  483   
//  484   HAL_Delay(200);
        MOVS     R0,#+200
          CFI FunCall HAL_Delay
        BL       HAL_Delay
//  485 #endif /* USE_USB_FS */
//  486   return USBH_OK;  
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
//  487 }
          CFI EndBlock cfiBlock18
//  488 
//  489 /**
//  490   * @brief  Sets toggle for a pipe.
//  491   * @param  phost: Host handle
//  492   * @param  pipe: Pipe index   
//  493   * @param  toggle: toggle (0/1)
//  494   * @retval USBH Status
//  495   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function USBH_LL_SetToggle
          CFI NoCalls
        THUMB
//  496 USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)   
//  497 {
//  498   if(hhcd.hc[pipe].ep_is_in)
USBH_LL_SetToggle:
        ADD      R3,R1,R1, LSL #+2
        LDR.N    R0,??DataTable5_7
        ADD      R0,R0,R3, LSL #+3
        LDRB     R1,[R0, #+55]!
        CMP      R1,#+0
        ITE      NE 
        STRBNE   R2,[R0, #+21]
        STRBEQ   R2,[R0, #+22]
//  499   {
//  500     hhcd.hc[pipe].toggle_in = toggle;
//  501   }
//  502   else
//  503   {
//  504     hhcd.hc[pipe].toggle_out = toggle;
//  505   }
//  506   return USBH_OK; 
        MOVS     R0,#+0
        BX       LR               ;; return
//  507 }
          CFI EndBlock cfiBlock19
//  508 
//  509 /**
//  510   * @brief  Returns the current toggle of a pipe.
//  511   * @param  phost: Host handle
//  512   * @param  pipe: Pipe index
//  513   * @retval toggle (0/1)
//  514   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function USBH_LL_GetToggle
          CFI NoCalls
        THUMB
//  515 uint8_t USBH_LL_GetToggle(USBH_HandleTypeDef *phost, uint8_t pipe)   
//  516 {
//  517   uint8_t toggle = 0;
//  518   
//  519   if(hhcd.hc[pipe].ep_is_in)
USBH_LL_GetToggle:
        ADD      R2,R1,R1, LSL #+2
        LDR.N    R0,??DataTable5_7
        ADD      R0,R0,R2, LSL #+3
        LDRB     R1,[R0, #+55]!
        CMP      R1,#+0
        ITE      NE 
        LDRBNE   R0,[R0, #+21]
        LDRBEQ   R0,[R0, #+22]
//  520   {
//  521     toggle = hhcd.hc[pipe].toggle_in;
//  522   }
//  523   else
//  524   {
//  525     toggle = hhcd.hc[pipe].toggle_out;
        BX       LR
//  526   }
//  527   return toggle; 
//  528 }
          CFI EndBlock cfiBlock20

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5:
        DC32     0x40023830

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_1:
        DC32     0x40020000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_2:
        DC32     0x40020c00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_3:
        DC32     0x40040000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_4:
        DC32     0x40020800

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_5:
        DC32     0x40020400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_6:
        DC32     0x40021c00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_7:
        DC32     hhcd
//  529 
//  530 /**
//  531   * @brief  Delay routine for the USB Host Library
//  532   * @param  Delay: Delay in ms
//  533   * @retval None
//  534   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function USBH_Delay
          CFI FunCall HAL_Delay
        THUMB
//  535 void USBH_Delay(uint32_t Delay)
//  536 {
//  537   HAL_Delay(Delay);  
USBH_Delay:
        B.W      HAL_Delay
//  538 }
          CFI EndBlock cfiBlock21

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  539 
//  540 /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// 
// 660 bytes in section .bss
// 854 bytes in section .text
// 
// 854 bytes of CODE memory
// 660 bytes of DATA memory
//
//Errors: none
//Warnings: none
