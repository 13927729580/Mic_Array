###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       08/Nov/2016  10:26:34
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
#    Command line =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e
#        --char_is_signed --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_tim.lst
#    Object file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_tim.o
#
###############################################################################

D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   TIM HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Timer (TIM) peripheral:
     10            *           + Time Base Initialization
     11            *           + Time Base Start
     12            *           + Time Base Start Interruption
     13            *           + Time Base Start DMA
     14            *           + Time Output Compare/PWM Initialization
     15            *           + Time Output Compare/PWM Channel Configuration
     16            *           + Time Output Compare/PWM  Start
     17            *           + Time Output Compare/PWM  Start Interruption
     18            *           + Time Output Compare/PWM Start DMA
     19            *           + Time Input Capture Initialization
     20            *           + Time Input Capture Channel Configuration
     21            *           + Time Input Capture Start
     22            *           + Time Input Capture Start Interruption 
     23            *           + Time Input Capture Start DMA
     24            *           + Time One Pulse Initialization
     25            *           + Time One Pulse Channel Configuration
     26            *           + Time One Pulse Start 
     27            *           + Time Encoder Interface Initialization
     28            *           + Time Encoder Interface Start
     29            *           + Time Encoder Interface Start Interruption
     30            *           + Time Encoder Interface Start DMA
     31            *           + Commutation Event configuration with Interruption and DMA
     32            *           + Time OCRef clear configuration
     33            *           + Time External Clock configuration
     34            @verbatim 
     35            ==============================================================================
     36                                ##### TIMER Generic features #####
     37            ==============================================================================
     38            [..] The Timer features include: 
     39                 (#) 16-bit up, down, up/down auto-reload counter.
     40                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     41                     counter clock frequency either by any factor between 1 and 65536.
     42                 (#) Up to 4 independent channels for:
     43                     (++) Input Capture
     44                     (++) Output Compare
     45                     (++) PWM generation (Edge and Center-aligned Mode)
     46                     (++) One-pulse mode output               
     47             
     48                                  ##### How to use this driver #####
     49            ==============================================================================
     50              [..]
     51               (#) Initialize the TIM low level resources by implementing the following functions 
     52                   depending from feature used :
     53                     (++) Time Base : HAL_TIM_Base_MspInit() 
     54                     (++) Input Capture : HAL_TIM_IC_MspInit()
     55                     (++) Output Compare : HAL_TIM_OC_MspInit()
     56                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     57                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     58                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     59                     
     60               (#) Initialize the TIM low level resources :
     61                  (##) Enable the TIM interface clock using __TIMx_CLK_ENABLE(); 
     62                  (##) TIM pins configuration
     63                      (+++) Enable the clock for the TIM GPIOs using the following function:
     64                           __GPIOx_CLK_ENABLE();   
     65                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     66          
     67               (#) The external Clock can be configured, if needed (the default clock is the 
     68                   internal clock from the APBx), using the following function:
     69                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     70                   any start function.
     71            
     72               (#) Configure the TIM in the desired functioning mode using one of the 
     73                   initialization function of this driver:
     74                   (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     75                   (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     76                        Output Compare signal.
     77                   (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     78                        PWM signal.
     79                   (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     80                        external signal.
     81                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     82                        in One Pulse Mode.
     83                   (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     84                   
     85               (#) Activate the TIM peripheral using one of the start functions depending from the feature used: 
     86                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     87                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     88                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     89                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     90                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     91                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     92          
     93               (#) The DMA Burst is managed with the two following functions:
     94                   HAL_TIM_DMABurst_WriteStart()
     95                   HAL_TIM_DMABurst_ReadStart()
     96            
     97            @endverbatim
     98            ******************************************************************************
     99            * @attention
    100            *
    101            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    102            *
    103            * Redistribution and use in source and binary forms, with or without modification,
    104            * are permitted provided that the following conditions are met:
    105            *   1. Redistributions of source code must retain the above copyright notice,
    106            *      this list of conditions and the following disclaimer.
    107            *   2. Redistributions in binary form must reproduce the above copyright notice,
    108            *      this list of conditions and the following disclaimer in the documentation
    109            *      and/or other materials provided with the distribution.
    110            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    111            *      may be used to endorse or promote products derived from this software
    112            *      without specific prior written permission.
    113            *
    114            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    115            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    116            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    117            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    118            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    119            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    120            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    121            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    122            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    123            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    124            *
    125            ******************************************************************************
    126            */ 
    127          
    128          /* Includes ------------------------------------------------------------------*/
    129          #include "stm32f7xx_hal.h"
    130          
    131          /** @addtogroup STM32F7xx_HAL_Driver
    132            * @{
    133            */
    134          
    135          /** @defgroup TIM TIM
    136            * @brief TIM HAL module driver
    137            * @{
    138            */
    139          
    140          #ifdef HAL_TIM_MODULE_ENABLED
    141          
    142          /* Private typedef -----------------------------------------------------------*/
    143          /* Private define ------------------------------------------------------------*/
    144          /* Private macro -------------------------------------------------------------*/
    145          /* Private variables ---------------------------------------------------------*/
    146          /** @addtogroup TIM_Private_Functions
    147            * @{
    148            */
    149          /* Private function prototypes -----------------------------------------------*/
    150          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    151          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    152                                 uint32_t TIM_ICFilter);
    153          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    154          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    155                                 uint32_t TIM_ICFilter);
    156          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    157                                 uint32_t TIM_ICFilter);
    158          
    159          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t TIM_ITRx);
    160          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    161          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    162          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    163                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    164          /**
    165            * @}
    166            */
    167            
    168          /* Exported functions --------------------------------------------------------*/
    169          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    170            * @{
    171            */
    172          
    173          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    174           *  @brief    Time Base functions 
    175           *
    176          @verbatim    
    177            ==============================================================================
    178                        ##### Time Base functions #####
    179            ==============================================================================
    180            [..]  
    181              This section provides functions allowing to:
    182              (+) Initialize and configure the TIM base. 
    183              (+) De-initialize the TIM base.
    184              (+) Start the Time Base.
    185              (+) Stop the Time Base.
    186              (+) Start the Time Base and enable interrupt.
    187              (+) Stop the Time Base and disable interrupt.
    188              (+) Start the Time Base and enable DMA transfer.
    189              (+) Stop the Time Base and disable DMA transfer.
    190           
    191          @endverbatim
    192            * @{
    193            */
    194          /**
    195            * @brief  Initializes the TIM Time base Unit according to the specified
    196            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    197            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    198            *                the configuration information for TIM module.
    199            * @retval HAL status
    200            */

   \                                 In section .text, align 2, keep-with-next
    201          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    202          { 
   \                     HAL_TIM_Base_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    203            /* Check the TIM handle allocation */
    204            if(htim == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    205            {
    206              return HAL_ERROR;
   \   0000000A   0xD066             BEQ.N    ??HAL_TIM_Base_Init_0
    207            }
    208            
    209            /* Check the parameters */
    210            assert_param(IS_TIM_INSTANCE(htim->Instance)); 
    211            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    212            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    213            
    214            if(htim->State == HAL_TIM_STATE_RESET)
   \   0000000C   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000010   0xB910             CBNZ.N   R0,??HAL_TIM_Base_Init_1
    215            {  
    216              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    217              HAL_TIM_Base_MspInit(htim);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    218            }
    219            
    220            /* Set the TIM state */
    221            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
    222            
    223            /* Set the Time Base configuration */
    224            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40010000
   \   0000001E   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000022   0x1D20             ADDS     R0,R4,#+4
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0x680B             LDR      R3,[R1, #+0]
   \   0000002A   0xBF18             IT       NE 
   \   0000002C   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000030   0xD00F             BEQ.N    ??HAL_TIM_Base_Init_2
   \   00000032   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   00000036   0x42A9             CMP      R1,R5
   \   00000038   0xBF1C             ITT      NE 
   \   0000003A   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   0000003E   0x42A9             CMPNE    R1,R5
   \   00000040   0xD007             BEQ.N    ??HAL_TIM_Base_Init_2
   \   00000042   0x.... 0x....      LDR.W    R5,??DataTable15_3  ;; 0x40000c00
   \   00000046   0x42A9             CMP      R1,R5
   \   00000048   0xBF1C             ITT      NE 
   \   0000004A   0x.... 0x....      LDRNE.W  R5,??DataTable16  ;; 0x40010400
   \   0000004E   0x42A9             CMPNE    R1,R5
   \   00000050   0xD113             BNE.N    ??HAL_TIM_Base_Init_3
   \                     ??HAL_TIM_Base_Init_2: (+1)
   \   00000052   0x6845             LDR      R5,[R0, #+4]
   \   00000054   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000058   0x432B             ORRS     R3,R5,R3
   \   0000005A   0x4291             CMP      R1,R2
   \   0000005C   0xBF18             IT       NE 
   \   0000005E   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000062   0xD025             BEQ.N    ??HAL_TIM_Base_Init_4
   \   00000064   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   00000068   0x42A9             CMP      R1,R5
   \   0000006A   0xBF1F             ITTTT    NE 
   \   0000006C   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000070   0x42A9             CMPNE    R1,R5
   \   00000072   0x.... 0x....      LDRNE.W  R5,??DataTable15_3  ;; 0x40000c00
   \   00000076   0x42A9             CMPNE    R1,R5
   \   00000078   0xD01A             BEQ.N    ??HAL_TIM_Base_Init_4
   \                     ??HAL_TIM_Base_Init_3: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R5,??DataTable16  ;; 0x40010400
   \   0000007E   0x42A9             CMP      R1,R5
   \   00000080   0xBF1C             ITT      NE 
   \   00000082   0x.... 0x....      LDRNE.W  R5,??DataTable16_1  ;; 0x40014000
   \   00000086   0x42A9             CMPNE    R1,R5
   \   00000088   0xD012             BEQ.N    ??HAL_TIM_Base_Init_4
   \   0000008A   0x.... 0x....      LDR.W    R5,??DataTable16_2  ;; 0x40014400
   \   0000008E   0x42A9             CMP      R1,R5
   \   00000090   0xBF1C             ITT      NE 
   \   00000092   0x.... 0x....      LDRNE.W  R5,??DataTable16_3  ;; 0x40014800
   \   00000096   0x42A9             CMPNE    R1,R5
   \   00000098   0xD00A             BEQ.N    ??HAL_TIM_Base_Init_4
   \   0000009A   0x.... 0x....      LDR.W    R5,??DataTable16_4  ;; 0x40001800
   \   0000009E   0x42A9             CMP      R1,R5
   \   000000A0   0xBF1F             ITTTT    NE 
   \   000000A2   0x.... 0x....      LDRNE.W  R5,??DataTable16_5  ;; 0x40001c00
   \   000000A6   0x42A9             CMPNE    R1,R5
   \   000000A8   0x.... 0x....      LDRNE.W  R5,??DataTable16_6  ;; 0x40002000
   \   000000AC   0x42A9             CMPNE    R1,R5
   \   000000AE   0xD103             BNE.N    ??HAL_TIM_Base_Init_5
   \                     ??HAL_TIM_Base_Init_4: (+1)
   \   000000B0   0x68C5             LDR      R5,[R0, #+12]
   \   000000B2   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000B6   0x432B             ORRS     R3,R5,R3
   \                     ??HAL_TIM_Base_Init_5: (+1)
   \   000000B8   0x600B             STR      R3,[R1, #+0]
   \   000000BA   0x6883             LDR      R3,[R0, #+8]
   \   000000BC   0x4291             CMP      R1,R2
   \   000000BE   0x62CB             STR      R3,[R1, #+44]
   \   000000C0   0x6803             LDR      R3,[R0, #+0]
   \   000000C2   0x628B             STR      R3,[R1, #+40]
   \   000000C4   0xBF19             ITTEE    NE 
   \   000000C6   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   000000CA   0x4291             CMPNE    R1,R2
   \   000000CC   0x6900             LDREQ    R0,[R0, #+16]
   \   000000CE   0x6308             STREQ    R0,[R1, #+48]
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0x6148             STR      R0,[R1, #+20]
    225            
    226            /* Initialize the TIM state*/
    227            htim->State= HAL_TIM_STATE_READY;
   \   000000D4   0xF884 0x0039      STRB     R0,[R4, #+57]
    228            
    229            return HAL_OK;
   \   000000D8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \   000000DA   0xB001             ADD      SP,SP,#+4
   \   000000DC   0xBD30             POP      {R4,R5,PC}       ;; return
    230          }
    231          
    232          /**
    233            * @brief  DeInitializes the TIM Base peripheral 
    234            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    235            *                the configuration information for TIM module.
    236            * @retval HAL status
    237            */

   \                                 In section .text, align 2, keep-with-next
    238          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    239          {  
   \                     HAL_TIM_Base_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    240            /* Check the parameters */
    241            assert_param(IS_TIM_INSTANCE(htim->Instance));
    242          
    243            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    244             
    245            /* Disable the TIM Peripheral Clock */
    246            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    247              
    248            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    249            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    250            
    251            /* Change TIM state */  
    252            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    253            
    254            /* Release Lock */
    255            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    256          
    257            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    258          }
    259          
    260          /**
    261            * @brief  Initializes the TIM Base MSP.
    262            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    263            *                the configuration information for TIM module.
    264            * @retval None
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    267          {
    268            /* Prevent unused argument(s) compilation warning */
    269            UNUSED(htim);
    270           
    271            /* NOTE : This function Should not be modified, when the callback is needed,
    272                      the HAL_TIM_Base_MspInit could be implemented in the user file
    273             */
    274          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    275          
    276          /**
    277            * @brief  DeInitializes TIM Base MSP.
    278            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    279            *                the configuration information for TIM module.
    280            * @retval None
    281            */

   \                                 In section .text, align 2, keep-with-next
    282          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    283          {
    284            /* Prevent unused argument(s) compilation warning */
    285            UNUSED(htim);
    286           
    287            /* NOTE : This function Should not be modified, when the callback is needed,
    288                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    289             */
    290          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    291          
    292          /**
    293            * @brief  Starts the TIM Base generation.
    294            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    295            *                the configuration information for TIM module.
    296            * @retval HAL status
    297            */

   \                                 In section .text, align 2, keep-with-next
    298          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    299          {
    300            /* Check the parameters */
    301            assert_param(IS_TIM_INSTANCE(htim->Instance));
    302            
    303            /* Set the TIM state */
    304            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Start: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0xF880 0x1039      STRB     R1,[R0, #+57]
    305            
    306            /* Enable the Peripheral */
    307            __HAL_TIM_ENABLE(htim);
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    308            
    309            /* Change the TIM state*/
    310            htim->State= HAL_TIM_STATE_READY;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x1039      STRB     R1,[R0, #+57]
    311            
    312            /* Return function status */
    313            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    314          }
    315          
    316          /**
    317            * @brief  Stops the TIM Base generation.
    318            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    319            *                the configuration information for TIM module.
    320            * @retval HAL status
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    323          {
    324            /* Check the parameters */
    325            assert_param(IS_TIM_INSTANCE(htim->Instance));
    326            
    327            /* Set the TIM state */
    328            htim->State= HAL_TIM_STATE_BUSY;
   \                     HAL_TIM_Base_Stop: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
    329            
    330            /* Disable the Peripheral */
    331            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1311      MOVW     R3,#+4369
   \   00000006   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0x421A             TST      R2,R3
   \   00000010   0xBF02             ITTT     EQ 
   \   00000012   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000014   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000018   0x421A             TSTEQ    R2,R3
   \   0000001A   0xD103             BNE.N    ??HAL_TIM_Base_Stop_0
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x0852             LSRS     R2,R2,#+1
   \   00000020   0x0052             LSLS     R2,R2,#+1
   \   00000022   0x600A             STR      R2,[R1, #+0]
    332            
    333            /* Change the TIM state*/
    334            htim->State= HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \   00000024   0x2101             MOVS     R1,#+1
   \   00000026   0xF880 0x1039      STRB     R1,[R0, #+57]
    335            
    336            /* Return function status */
    337            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
    338          }
    339          
    340          /**
    341            * @brief  Starts the TIM Base generation in interrupt mode.
    342            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    343            *                the configuration information for TIM module.
    344            * @retval HAL status
    345            */

   \                                 In section .text, align 2, keep-with-next
    346          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    347          {
    348            /* Check the parameters */
    349            assert_param(IS_TIM_INSTANCE(htim->Instance));
    350            
    351            /* Enable the TIM Update interrupt */
    352            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Start_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    353                
    354            /* Enable the Peripheral */
    355            __HAL_TIM_ENABLE(htim);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    356                
    357            /* Return function status */
    358            return HAL_OK;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
    359          }
    360          
    361          /**
    362            * @brief  Stops the TIM Base generation in interrupt mode.
    363            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    364            *                the configuration information for TIM module.
    365            * @retval HAL status
    366            */

   \                                 In section .text, align 2, keep-with-next
    367          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    368          {
    369            /* Check the parameters */
    370            assert_param(IS_TIM_INSTANCE(htim->Instance));
    371            /* Disable the TIM Update interrupt */
    372            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
    373                
    374            /* Disable the Peripheral */
    375            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1211      MOVW     R2,#+4369
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x0849             LSRS     R1,R1,#+1
   \   0000000A   0x0049             LSLS     R1,R1,#+1
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0x4211             TST      R1,R2
   \   00000012   0xBF02             ITTT     EQ 
   \   00000014   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000016   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001A   0x4211             TSTEQ    R1,R2
   \   0000001C   0xD103             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x0849             LSRS     R1,R1,#+1
   \   00000022   0x0049             LSLS     R1,R1,#+1
   \   00000024   0x6001             STR      R1,[R0, #+0]
    376              
    377            /* Return function status */
    378            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x4770             BX       LR               ;; return
    379          }
    380          
    381          /**
    382            * @brief  Starts the TIM Base generation in DMA mode.
    383            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    384            *                the configuration information for TIM module.
    385            * @param  pData: The source Buffer address.
    386            * @param  Length: The length of data to be transferred from memory to peripheral.
    387            * @retval HAL status
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    390          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    391            /* Check the parameters */
    392            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
    393            
    394            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000004   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD022             BEQ.N    ??HAL_TIM_Base_Start_DMA_0
    395            {
    396               return HAL_BUSY;
    397            }
    398            else if((htim->State == HAL_TIM_STATE_READY))
   \   0000000C   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD104             BNE.N    ??HAL_TIM_Base_Start_DMA_1
    399            {
    400              if((pData == 0 ) && (Length > 0)) 
   \   00000014   0xB901             CBNZ.N   R1,??HAL_TIM_Base_Start_DMA_2
   \   00000016   0xB9E2             CBNZ.N   R2,??HAL_TIM_Base_Start_DMA_0
    401              {
    402                return HAL_ERROR;                                    
    403              }
    404              else
    405              {
    406                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
    407              }
    408            }  
    409            /* Set the DMA Period elapsed callback */
    410            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \   0000001E   0x69E3             LDR      R3,[R4, #+28]
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000024   0x63D8             STR      R0,[R3, #+60]
    411               
    412            /* Set the DMA error callback */
    413            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000026   0x69E3             LDR      R3,[R4, #+28]
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000002C   0x6498             STR      R0,[R3, #+72]
    414            
    415            /* Enable the DMA Stream */
    416            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x4613             MOV      R3,R2
   \   00000032   0xF100 0x022C      ADD      R2,R0,#+44
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x.... 0x....      BL       HAL_DMA_Start_IT
    417            
    418            /* Enable the TIM Update DMA request */
    419            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x68C1             LDR      R1,[R0, #+12]
   \   00000040   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000044   0x60C1             STR      R1,[R0, #+12]
    420          
    421            /* Enable the Peripheral */
    422            __HAL_TIM_ENABLE(htim);  
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    423            
    424            /* Return function status */
    425            return HAL_OK;
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    426          }
    427          
    428          /**
    429            * @brief  Stops the TIM Base generation in DMA mode.
    430            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    431            *                the configuration information for TIM module.
    432            * @retval HAL status
    433            */

   \                                 In section .text, align 2, keep-with-next
    434          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    435          {
    436            /* Check the parameters */
    437            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    438            
    439            /* Disable the TIM Update DMA request */
    440            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
    441                
    442            /* Disable the Peripheral */
    443            __HAL_TIM_DISABLE(htim);
   \   00000002   0xF241 0x1311      MOVW     R3,#+4369
   \   00000006   0x68CA             LDR      R2,[R1, #+12]
   \   00000008   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000000C   0x60CA             STR      R2,[R1, #+12]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x6A0A             LDR      R2,[R1, #+32]
   \   00000012   0x421A             TST      R2,R3
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000018   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000001C   0x421A             TSTEQ    R2,R3
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \   00000020   0x680A             LDR      R2,[R1, #+0]
   \   00000022   0x0852             LSRS     R2,R2,#+1
   \   00000024   0x0052             LSLS     R2,R2,#+1
   \   00000026   0x600A             STR      R2,[R1, #+0]
    444              
    445            /* Change the htim state */
    446            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0: (+1)
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x1039      STRB     R1,[R0, #+57]
    447                
    448            /* Return function status */
    449            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR               ;; return
    450          }
    451          
    452          /**
    453            * @}
    454            */
    455            
    456          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    457           *  @brief    Time Output Compare functions 
    458           *
    459          @verbatim    
    460            ==============================================================================
    461                            ##### Time Output Compare functions #####
    462            ==============================================================================
    463            [..]
    464              This section provides functions allowing to:
    465              (+) Initialize and configure the TIM Output Compare. 
    466              (+) De-initialize the TIM Output Compare.
    467              (+) Start the Time Output Compare.
    468              (+) Stop the Time Output Compare.
    469              (+) Start the Time Output Compare and enable interrupt.
    470              (+) Stop the Time Output Compare and disable interrupt.
    471              (+) Start the Time Output Compare and enable DMA transfer.
    472              (+) Stop the Time Output Compare and disable DMA transfer.
    473           
    474          @endverbatim
    475            * @{
    476            */
    477          /**
    478            * @brief  Initializes the TIM Output Compare according to the specified
    479            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    480            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    481            *                the configuration information for TIM module.
    482            * @retval HAL status
    483            */

   \                                 In section .text, align 2, keep-with-next
    484          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    485          {
   \                     HAL_TIM_OC_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    486            /* Check the TIM handle allocation */
    487            if(htim == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    488            {
    489              return HAL_ERROR;
   \   0000000A   0xD068             BEQ.N    ??HAL_TIM_OC_Init_0
    490            }
    491          
    492            /* Check the parameters */
    493            assert_param(IS_TIM_INSTANCE(htim->Instance));
    494            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    495            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    496           
    497            if(htim->State == HAL_TIM_STATE_RESET)
   \   0000000C   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_OC_Init_1
    498            { 
    499              /* Allocate lock resource and initialize it */
    500              htim->Lock = HAL_UNLOCKED;  
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
    501              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    502              HAL_TIM_OC_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    503            }
    504            
    505            /* Set the TIM state */
    506            htim->State= HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
    507            
    508            /* Init the base time for the Output Compare */  
    509            TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40010000
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0x680B             LDR      R3,[R1, #+0]
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000034   0xD00F             BEQ.N    ??HAL_TIM_OC_Init_2
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   0000003A   0x42A9             CMP      R1,R5
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000042   0x42A9             CMPNE    R1,R5
   \   00000044   0xD007             BEQ.N    ??HAL_TIM_OC_Init_2
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable15_3  ;; 0x40000c00
   \   0000004A   0x42A9             CMP      R1,R5
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x.... 0x....      LDRNE.W  R5,??DataTable16  ;; 0x40010400
   \   00000052   0x42A9             CMPNE    R1,R5
   \   00000054   0xD113             BNE.N    ??HAL_TIM_OC_Init_3
   \                     ??HAL_TIM_OC_Init_2: (+1)
   \   00000056   0x6845             LDR      R5,[R0, #+4]
   \   00000058   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000005C   0x432B             ORRS     R3,R5,R3
   \   0000005E   0x4291             CMP      R1,R2
   \   00000060   0xBF18             IT       NE 
   \   00000062   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000066   0xD025             BEQ.N    ??HAL_TIM_OC_Init_4
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   0000006C   0x42A9             CMP      R1,R5
   \   0000006E   0xBF1F             ITTTT    NE 
   \   00000070   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000074   0x42A9             CMPNE    R1,R5
   \   00000076   0x.... 0x....      LDRNE.W  R5,??DataTable15_3  ;; 0x40000c00
   \   0000007A   0x42A9             CMPNE    R1,R5
   \   0000007C   0xD01A             BEQ.N    ??HAL_TIM_OC_Init_4
   \                     ??HAL_TIM_OC_Init_3: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R5,??DataTable16  ;; 0x40010400
   \   00000082   0x42A9             CMP      R1,R5
   \   00000084   0xBF1C             ITT      NE 
   \   00000086   0x.... 0x....      LDRNE.W  R5,??DataTable16_1  ;; 0x40014000
   \   0000008A   0x42A9             CMPNE    R1,R5
   \   0000008C   0xD012             BEQ.N    ??HAL_TIM_OC_Init_4
   \   0000008E   0x.... 0x....      LDR.W    R5,??DataTable16_2  ;; 0x40014400
   \   00000092   0x42A9             CMP      R1,R5
   \   00000094   0xBF1C             ITT      NE 
   \   00000096   0x.... 0x....      LDRNE.W  R5,??DataTable16_3  ;; 0x40014800
   \   0000009A   0x42A9             CMPNE    R1,R5
   \   0000009C   0xD00A             BEQ.N    ??HAL_TIM_OC_Init_4
   \   0000009E   0x.... 0x....      LDR.W    R5,??DataTable16_4  ;; 0x40001800
   \   000000A2   0x42A9             CMP      R1,R5
   \   000000A4   0xBF1F             ITTTT    NE 
   \   000000A6   0x.... 0x....      LDRNE.W  R5,??DataTable16_5  ;; 0x40001c00
   \   000000AA   0x42A9             CMPNE    R1,R5
   \   000000AC   0x.... 0x....      LDRNE.W  R5,??DataTable16_6  ;; 0x40002000
   \   000000B0   0x42A9             CMPNE    R1,R5
   \   000000B2   0xD103             BNE.N    ??HAL_TIM_OC_Init_5
   \                     ??HAL_TIM_OC_Init_4: (+1)
   \   000000B4   0x68C5             LDR      R5,[R0, #+12]
   \   000000B6   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000BA   0x432B             ORRS     R3,R5,R3
   \                     ??HAL_TIM_OC_Init_5: (+1)
   \   000000BC   0x600B             STR      R3,[R1, #+0]
   \   000000BE   0x6883             LDR      R3,[R0, #+8]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0x62CB             STR      R3,[R1, #+44]
   \   000000C4   0x6803             LDR      R3,[R0, #+0]
   \   000000C6   0x628B             STR      R3,[R1, #+40]
   \   000000C8   0xBF19             ITTEE    NE 
   \   000000CA   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   000000CE   0x4291             CMPNE    R1,R2
   \   000000D0   0x6900             LDREQ    R0,[R0, #+16]
   \   000000D2   0x6308             STREQ    R0,[R1, #+48]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x6148             STR      R0,[R1, #+20]
    510            
    511            /* Initialize the TIM state*/
    512            htim->State= HAL_TIM_STATE_READY;
   \   000000D8   0xF884 0x0039      STRB     R0,[R4, #+57]
    513            
    514            return HAL_OK;
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \   000000DE   0xB001             ADD      SP,SP,#+4
   \   000000E0   0xBD30             POP      {R4,R5,PC}       ;; return
    515          }
    516          
    517          /**
    518            * @brief  DeInitializes the TIM peripheral 
    519            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    520            *                the configuration information for TIM module.
    521            * @retval HAL status
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    524          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    525            /* Check the parameters */
    526            assert_param(IS_TIM_INSTANCE(htim->Instance));
    527            
    528             htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
    529             
    530            /* Disable the TIM Peripheral Clock */
    531            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OC_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
    532            
    533            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    534            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    535              
    536            /* Change TIM state */  
    537            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
    538          
    539            /* Release Lock */
    540            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
    541          
    542            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    543          }
    544          
    545          /**
    546            * @brief  Initializes the TIM Output Compare MSP.
    547            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    548            *                the configuration information for TIM module.
    549            * @retval None
    550            */

   \                                 In section .text, align 2, keep-with-next
    551          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    552          {
    553            /* Prevent unused argument(s) compilation warning */
    554            UNUSED(htim);
    555           
    556            /* NOTE : This function Should not be modified, when the callback is needed,
    557                      the HAL_TIM_OC_MspInit could be implemented in the user file
    558             */
    559          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    560          
    561          /**
    562            * @brief  DeInitializes TIM Output Compare MSP.
    563            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    564            *                the configuration information for TIM module.
    565            * @retval None
    566            */

   \                                 In section .text, align 2, keep-with-next
    567          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    568          {
    569            /* Prevent unused argument(s) compilation warning */
    570            UNUSED(htim);
    571           
    572            /* NOTE : This function Should not be modified, when the callback is needed,
    573                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    574             */
    575          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    576          
    577          /**
    578            * @brief  Starts the TIM Output Compare signal generation.
    579            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    580            *                the configuration information for TIM module.  
    581            * @param  Channel: TIM Channel to be enabled.
    582            *          This parameter can be one of the following values:
    583            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    584            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    585            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    586            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected   
    587            * @retval HAL status
    588            */

   \                                 In section .text, align 2, keep-with-next
    589          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    590          {
    591            /* Check the parameters */
    592            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    593            
    594            /* Enable the Output compare channel */
    595            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     HAL_TIM_OC_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
    596            
    597            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40010000
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x.... 0x....      LDRNE.W  R1,??DataTable16  ;; 0x40010400
   \   00000020   0x4288             CMPNE    R0,R1
   \   00000022   0xD103             BNE.N    ??HAL_TIM_OC_Start_0
    598            {
    599              /* Enable the main output */
    600              __HAL_TIM_MOE_ENABLE(htim);
   \   00000024   0x6C41             LDR      R1,[R0, #+68]
   \   00000026   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000002A   0x6441             STR      R1,[R0, #+68]
    601            }
    602            
    603            /* Enable the Peripheral */
    604            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_OC_Start_0: (+1)
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000032   0x6001             STR      R1,[R0, #+0]
    605            
    606            /* Return function status */
    607            return HAL_OK;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4770             BX       LR               ;; return
    608          }
    609          
    610          /**
    611            * @brief  Stops the TIM Output Compare signal generation.
    612            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    613            *                the configuration information for TIM module.
    614            * @param  Channel: TIM Channel to be disabled.
    615            *          This parameter can be one of the following values:
    616            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    617            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    618            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    619            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    620            * @retval HAL status
    621            */

   \                                 In section .text, align 2, keep-with-next
    622          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    623          {
    624            /* Check the parameters */
    625            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    626            
    627            /* Disable the Output compare channel */
    628            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     HAL_TIM_OC_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xEA22 0x0101      BIC      R1,R2,R1
   \   0000000E   0x6201             STR      R1,[R0, #+32]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x6201             STR      R1,[R0, #+32]
    629            
    630            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40010000
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x.... 0x....      LDRNE.W  R1,??DataTable16  ;; 0x40010400
   \   00000020   0x4288             CMPNE    R0,R1
   \   00000022   0xD10D             BNE.N    ??HAL_TIM_OC_Stop_0
    631            {
    632              /* Disable the Main Output */
    633              __HAL_TIM_MOE_DISABLE(htim);
   \   00000024   0x6A01             LDR      R1,[R0, #+32]
   \   00000026   0xF241 0x1211      MOVW     R2,#+4369
   \   0000002A   0x4211             TST      R1,R2
   \   0000002C   0xBF02             ITTT     EQ 
   \   0000002E   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000030   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000034   0x4211             TSTEQ    R1,R2
   \   00000036   0xD103             BNE.N    ??HAL_TIM_OC_Stop_0
   \   00000038   0x6C41             LDR      R1,[R0, #+68]
   \   0000003A   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   0000003E   0x6441             STR      R1,[R0, #+68]
    634            }  
    635            
    636            /* Disable the Peripheral */
    637            __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OC_Stop_0: (+1)
   \   00000040   0x6A01             LDR      R1,[R0, #+32]
   \   00000042   0xF241 0x1211      MOVW     R2,#+4369
   \   00000046   0x4211             TST      R1,R2
   \   00000048   0xBF02             ITTT     EQ 
   \   0000004A   0x6A01             LDREQ    R1,[R0, #+32]
   \   0000004C   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000050   0x4211             TSTEQ    R1,R2
   \   00000052   0xD103             BNE.N    ??HAL_TIM_OC_Stop_1
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x0849             LSRS     R1,R1,#+1
   \   00000058   0x0049             LSLS     R1,R1,#+1
   \   0000005A   0x6001             STR      R1,[R0, #+0]
    638            
    639            /* Return function status */
    640            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_1: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x4770             BX       LR               ;; return
    641          }  
    642          
    643          /**
    644            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    645            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    646            *                the configuration information for TIM module.
    647            * @param  Channel: TIM Channel to be enabled.
    648            *          This parameter can be one of the following values:
    649            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    650            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    651            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    652            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    653            * @retval HAL status
    654            */

   \                                 In section .text, align 4, keep-with-next
    655          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    656          {
    657            /* Check the parameters */
    658            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    659            
    660            switch (Channel)
   \                     HAL_TIM_OC_Start_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_OC_Start_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_OC_Start_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
    661            {
    662              case TIM_CHANNEL_1:
    663              {       
    664                /* Enable the TIM Capture/Compare 1 interrupt */
    665                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_OC_Start_IT_3
    666              }
    667              break;
    668              
    669              case TIM_CHANNEL_2:
    670              {
    671                /* Enable the TIM Capture/Compare 2 interrupt */
    672                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_OC_Start_IT_3
    673              }
    674              break;
    675              
    676              case TIM_CHANNEL_3:
    677              {
    678                /* Enable the TIM Capture/Compare 3 interrupt */
    679                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_OC_Start_IT_3
    680              }
    681              break;
    682              
    683              case TIM_CHANNEL_4:
    684              {
    685                /* Enable the TIM Capture/Compare 4 interrupt */
    686                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF043 0x0310      ORR      R3,R3,#0x10
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
    687              }
    688              break;
    689              
    690              default:
    691              break;
    692            } 
    693          
    694            /* Enable the Output compare channel */
    695            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x4088             LSLS     R0,R0,R1
   \   00000044   0x6A11             LDR      R1,[R2, #+32]
   \   00000046   0x4381             BICS     R1,R1,R0
   \   00000048   0x6211             STR      R1,[R2, #+32]
   \   0000004A   0x6A11             LDR      R1,[R2, #+32]
   \   0000004C   0x4308             ORRS     R0,R0,R1
   \   0000004E   0x6210             STR      R0,[R2, #+32]
    696            
    697            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40010000
   \   00000054   0x4282             CMP      R2,R0
   \   00000056   0xBF1C             ITT      NE 
   \   00000058   0x.... 0x....      LDRNE.W  R0,??DataTable16  ;; 0x40010400
   \   0000005C   0x4282             CMPNE    R2,R0
   \   0000005E   0xD103             BNE.N    ??HAL_TIM_OC_Start_IT_7
    698            {
    699              /* Enable the main output */
    700              __HAL_TIM_MOE_ENABLE(htim);
   \   00000060   0x6C50             LDR      R0,[R2, #+68]
   \   00000062   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000066   0x6450             STR      R0,[R2, #+68]
    701            }
    702          
    703            /* Enable the Peripheral */
    704            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_OC_Start_IT_7: (+1)
   \   00000068   0x6810             LDR      R0,[R2, #+0]
   \   0000006A   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000006E   0x6010             STR      R0,[R2, #+0]
    705            
    706            /* Return function status */
    707            return HAL_OK;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x4770             BX       LR               ;; return
    708          }
    709          
    710          /**
    711            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    712            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    713            *                the configuration information for TIM module.
    714            * @param  Channel: TIM Channel to be disabled.
    715            *          This parameter can be one of the following values:
    716            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    717            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    718            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    719            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    720            * @retval HAL status
    721            */

   \                                 In section .text, align 4, keep-with-next
    722          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    723          {
    724            /* Check the parameters */
    725            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    726            
    727            switch (Channel)
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_OC_Stop_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_OC_Stop_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
    728            {
    729              case TIM_CHANNEL_1:
    730              {       
    731                /* Disable the TIM Capture/Compare 1 interrupt */
    732                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_OC_Stop_IT_3
    733              }
    734              break;
    735              
    736              case TIM_CHANNEL_2:
    737              {
    738                /* Disable the TIM Capture/Compare 2 interrupt */
    739                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_OC_Stop_IT_3
    740              }
    741              break;
    742              
    743              case TIM_CHANNEL_3:
    744              {
    745                /* Disable the TIM Capture/Compare 3 interrupt */
    746                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_OC_Stop_IT_3
    747              }
    748              break;
    749              
    750              case TIM_CHANNEL_4:
    751              {
    752                /* Disable the TIM Capture/Compare 4 interrupt */
    753                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF023 0x0310      BIC      R3,R3,#0x10
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
    754              }
    755              break;
    756              
    757              default:
    758              break; 
    759            } 
    760            
    761            /* Disable the Output compare channel */
    762            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000046   0x6A10             LDR      R0,[R2, #+32]
   \   00000048   0x4388             BICS     R0,R0,R1
   \   0000004A   0x6210             STR      R0,[R2, #+32]
   \   0000004C   0x6A10             LDR      R0,[R2, #+32]
   \   0000004E   0x6210             STR      R0,[R2, #+32]
    763            
    764            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40010000
   \   00000054   0x4282             CMP      R2,R0
   \   00000056   0xBF1C             ITT      NE 
   \   00000058   0x.... 0x....      LDRNE.W  R0,??DataTable16  ;; 0x40010400
   \   0000005C   0x4282             CMPNE    R2,R0
   \   0000005E   0xD10D             BNE.N    ??HAL_TIM_OC_Stop_IT_7
    765            {
    766              /* Disable the Main Output */
    767              __HAL_TIM_MOE_DISABLE(htim);
   \   00000060   0x6A10             LDR      R0,[R2, #+32]
   \   00000062   0xF241 0x1111      MOVW     R1,#+4369
   \   00000066   0x4208             TST      R0,R1
   \   00000068   0xBF02             ITTT     EQ 
   \   0000006A   0x6A10             LDREQ    R0,[R2, #+32]
   \   0000006C   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   00000070   0x4208             TSTEQ    R0,R1
   \   00000072   0xD103             BNE.N    ??HAL_TIM_OC_Stop_IT_7
   \   00000074   0x6C50             LDR      R0,[R2, #+68]
   \   00000076   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   0000007A   0x6450             STR      R0,[R2, #+68]
    768            }
    769            
    770            /* Disable the Peripheral */
    771            __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OC_Stop_IT_7: (+1)
   \   0000007C   0x6A10             LDR      R0,[R2, #+32]
   \   0000007E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000082   0x4208             TST      R0,R1
   \   00000084   0xBF02             ITTT     EQ 
   \   00000086   0x6A10             LDREQ    R0,[R2, #+32]
   \   00000088   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   0000008C   0x4208             TSTEQ    R0,R1
   \   0000008E   0xD103             BNE.N    ??HAL_TIM_OC_Stop_IT_8
   \   00000090   0x6810             LDR      R0,[R2, #+0]
   \   00000092   0x0840             LSRS     R0,R0,#+1
   \   00000094   0x0040             LSLS     R0,R0,#+1
   \   00000096   0x6010             STR      R0,[R2, #+0]
    772            
    773            /* Return function status */
    774            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_8: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x4770             BX       LR               ;; return
    775          }
    776          
    777          /**
    778            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    779            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    780            *                the configuration information for TIM module.
    781            * @param  Channel: TIM Channel to be enabled.
    782            *          This parameter can be one of the following values:
    783            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    784            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    785            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    786            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    787            * @param  pData: The source Buffer address.
    788            * @param  Length: The length of data to be transferred from memory to TIM peripheral
    789            * @retval HAL status
    790            */

   \                                 In section .text, align 4, keep-with-next
    791          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    792          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
    793            /* Check the parameters */
    794            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    795            
    796            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xF000 0x807D      BEQ.W    ??HAL_TIM_OC_Start_DMA_1
    797            {
    798               return HAL_BUSY;
    799            }
    800            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD105             BNE.N    ??HAL_TIM_OC_Start_DMA_2
    801            {
    802              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000001C   0xB909             CBNZ.N   R1,??HAL_TIM_OC_Start_DMA_3
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD175             BNE.N    ??HAL_TIM_OC_Start_DMA_1
    803              {
    804                return HAL_ERROR;                                    
    805              }
    806              else
    807              {
    808                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
    809              }
    810            }    
    811            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \   00000028   0x2D0C             CMP      R5,#+12
   \   0000002A   0xD854             BHI.N    ??HAL_TIM_OC_Start_DMA_4
   \   0000002C   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??HAL_TIM_OC_Start_DMA_0:
   \   00000030   0x07 0x53          DC8      0x7,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000034   0x1A 0x53          DC8      0x1A,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000038   0x2D 0x53          DC8      0x2D,0x53,0x53,0x53
   \              0x53 0x53    
   \   0000003C   0x40 0x00          DC8      0x40,0x0
    812            {
    813              case TIM_CHANNEL_1:
    814              {      
    815                /* Set the DMA Period elapsed callback */
    816                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \   0000003E   0x6A22             LDR      R2,[R4, #+32]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000044   0x63D0             STR      R0,[R2, #+60]
    817               
    818                /* Set the DMA error callback */
    819                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000046   0x6A22             LDR      R2,[R4, #+32]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000004C   0x6490             STR      R0,[R2, #+72]
    820                
    821                /* Enable the DMA Stream */
    822                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000054   0x6A20             LDR      R0,[R4, #+32]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Start_IT
    823                
    824                /* Enable the TIM Capture/Compare 1 DMA request */
    825                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x68C1             LDR      R1,[R0, #+12]
   \   0000005E   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000062   0xE037             B.N      ??HAL_TIM_OC_Start_DMA_6
    826              }
    827              break;
    828              
    829              case TIM_CHANNEL_2:
    830              {
    831                /* Set the DMA Period elapsed callback */
    832                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \   00000064   0x6A62             LDR      R2,[R4, #+36]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000006A   0x63D0             STR      R0,[R2, #+60]
    833               
    834                /* Set the DMA error callback */
    835                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000072   0x6490             STR      R0,[R2, #+72]
    836                
    837                /* Enable the DMA Stream */
    838                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007A   0x6A60             LDR      R0,[R4, #+36]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
    839                
    840                /* Enable the TIM Capture/Compare 2 DMA request */
    841                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x68C1             LDR      R1,[R0, #+12]
   \   00000084   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000088   0xE024             B.N      ??HAL_TIM_OC_Start_DMA_6
    842              }
    843              break;
    844              
    845              case TIM_CHANNEL_3:
    846              {
    847                /* Set the DMA Period elapsed callback */
    848                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \   0000008A   0x6AA2             LDR      R2,[R4, #+40]
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000090   0x63D0             STR      R0,[R2, #+60]
    849               
    850                /* Set the DMA error callback */
    851                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000092   0x6AA2             LDR      R2,[R4, #+40]
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000098   0x6490             STR      R0,[R2, #+72]
    852                
    853                /* Enable the DMA Stream */
    854                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
    855                
    856                /* Enable the TIM Capture/Compare 3 DMA request */
    857                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x68C1             LDR      R1,[R0, #+12]
   \   000000AA   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000AE   0xE011             B.N      ??HAL_TIM_OC_Start_DMA_6
    858              }
    859              break;
    860              
    861              case TIM_CHANNEL_4:
    862              {
    863               /* Set the DMA Period elapsed callback */
    864                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \   000000B0   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000B6   0x63D0             STR      R0,[R2, #+60]
    865               
    866                /* Set the DMA error callback */
    867                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000B8   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000BE   0x6490             STR      R0,[R2, #+72]
    868                
    869                /* Enable the DMA Stream */
    870                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000C6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
    871                
    872                /* Enable the TIM Capture/Compare 4 DMA request */
    873                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x68C1             LDR      R1,[R0, #+12]
   \   000000D0   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \   000000D4   0x60C1             STR      R1,[R0, #+12]
    874              }
    875              break;
    876              
    877              default:
    878              break;
    879            }
    880          
    881            /* Enable the Output compare channel */
    882            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x40A9             LSLS     R1,R1,R5
   \   000000DC   0x6A02             LDR      R2,[R0, #+32]
   \   000000DE   0x438A             BICS     R2,R2,R1
   \   000000E0   0x6202             STR      R2,[R0, #+32]
   \   000000E2   0x6A02             LDR      R2,[R0, #+32]
   \   000000E4   0x4311             ORRS     R1,R1,R2
   \   000000E6   0x6201             STR      R1,[R0, #+32]
    883            
    884            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable15  ;; 0x40010000
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xBF1C             ITT      NE 
   \   000000F2   0x.... 0x....      LDRNE.W  R1,??DataTable16  ;; 0x40010400
   \   000000F6   0x4288             CMPNE    R0,R1
   \   000000F8   0xD103             BNE.N    ??HAL_TIM_OC_Start_DMA_10
    885            {
    886              /* Enable the main output */
    887              __HAL_TIM_MOE_ENABLE(htim);
   \   000000FA   0x6C41             LDR      R1,[R0, #+68]
   \   000000FC   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000100   0x6441             STR      R1,[R0, #+68]
    888            }  
    889            
    890            /* Enable the Peripheral */
    891            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_OC_Start_DMA_10: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000010A   0x6001             STR      R1,[R0, #+0]
    892            
    893            /* Return function status */
    894            return HAL_OK;
   \   0000010C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \   0000010E   0xB001             ADD      SP,SP,#+4
   \   00000110   0xBD30             POP      {R4,R5,PC}       ;; return
    895          }
    896          
    897          /**
    898            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    899            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    900            *                the configuration information for TIM module.
    901            * @param  Channel: TIM Channel to be disabled.
    902            *          This parameter can be one of the following values:
    903            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    904            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    905            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    906            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    907            * @retval HAL status
    908            */

   \                                 In section .text, align 4, keep-with-next
    909          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    910          {
    911            /* Check the parameters */
    912            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    913            
    914            switch (Channel)
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xD81C             BHI.N    ??HAL_TIM_OC_Stop_DMA_1
   \   00000006   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_OC_Stop_DMA_0:
   \   0000000A   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000E   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000012   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000016   0x16 0x00          DC8      0x16,0x0
    915            {
    916              case TIM_CHANNEL_1:
    917              {       
    918                /* Disable the TIM Capture/Compare 1 DMA request */
    919                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x68D3             LDR      R3,[R2, #+12]
   \   0000001C   0xF423 0x7300      BIC      R3,R3,#0x200
   \   00000020   0xE00D             B.N      ??HAL_TIM_OC_Stop_DMA_3
    920              }
    921              break;
    922              
    923              case TIM_CHANNEL_2:
    924              {
    925                /* Disable the TIM Capture/Compare 2 DMA request */
    926                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x68D3             LDR      R3,[R2, #+12]
   \   00000026   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002A   0xE008             B.N      ??HAL_TIM_OC_Stop_DMA_3
    927              }
    928              break;
    929              
    930              case TIM_CHANNEL_3:
    931              {
    932                /* Disable the TIM Capture/Compare 3 DMA request */
    933                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_5: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000034   0xE003             B.N      ??HAL_TIM_OC_Stop_DMA_3
    934              }
    935              break;
    936              
    937              case TIM_CHANNEL_4:
    938              {
    939                /* Disable the TIM Capture/Compare 4 interrupt */
    940                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_6: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0xF423 0x5380      BIC      R3,R3,#0x1000
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \   0000003E   0x60D3             STR      R3,[R2, #+12]
    941              }
    942              break;
    943              
    944              default:
    945              break;
    946            } 
    947            
    948            /* Disable the Output compare channel */
    949            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000048   0x6A13             LDR      R3,[R2, #+32]
   \   0000004A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000004E   0x6211             STR      R1,[R2, #+32]
   \   00000050   0x6A11             LDR      R1,[R2, #+32]
   \   00000052   0x6211             STR      R1,[R2, #+32]
    950            
    951            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40010000
   \   0000005A   0x4291             CMP      R1,R2
   \   0000005C   0xBF1C             ITT      NE 
   \   0000005E   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   00000062   0x4291             CMPNE    R1,R2
   \   00000064   0xD10D             BNE.N    ??HAL_TIM_OC_Stop_DMA_7
    952            {
    953              /* Disable the Main Output */
    954              __HAL_TIM_MOE_DISABLE(htim);
   \   00000066   0x6A0A             LDR      R2,[R1, #+32]
   \   00000068   0xF241 0x1311      MOVW     R3,#+4369
   \   0000006C   0x421A             TST      R2,R3
   \   0000006E   0xBF02             ITTT     EQ 
   \   00000070   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000072   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000076   0x421A             TSTEQ    R2,R3
   \   00000078   0xD103             BNE.N    ??HAL_TIM_OC_Stop_DMA_7
   \   0000007A   0x6C4A             LDR      R2,[R1, #+68]
   \   0000007C   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000080   0x644A             STR      R2,[R1, #+68]
    955            }
    956            
    957            /* Disable the Peripheral */
    958            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_DMA_7: (+1)
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0xF241 0x1311      MOVW     R3,#+4369
   \   00000088   0x6A0A             LDR      R2,[R1, #+32]
   \   0000008A   0x421A             TST      R2,R3
   \   0000008C   0xBF02             ITTT     EQ 
   \   0000008E   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000090   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000094   0x421A             TSTEQ    R2,R3
   \   00000096   0xD103             BNE.N    ??HAL_TIM_OC_Stop_DMA_8
   \   00000098   0x680A             LDR      R2,[R1, #+0]
   \   0000009A   0x0852             LSRS     R2,R2,#+1
   \   0000009C   0x0052             LSLS     R2,R2,#+1
   \   0000009E   0x600A             STR      R2,[R1, #+0]
    959            
    960            /* Change the htim state */
    961            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_8: (+1)
   \   000000A0   0xF880 0x4039      STRB     R4,[R0, #+57]
    962            
    963            /* Return function status */
    964            return HAL_OK;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBC10             POP      {R4}
   \   000000A8   0x4770             BX       LR               ;; return
    965          }
    966          
    967          /**
    968            * @}
    969            */
    970          
    971          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    972           *  @brief    Time PWM functions 
    973           *
    974          @verbatim    
    975            ==============================================================================
    976                                    ##### Time PWM functions #####
    977            ==============================================================================
    978            [..]  
    979              This section provides functions allowing to:
    980              (+) Initialize and configure the TIM OPWM. 
    981              (+) De-initialize the TIM PWM.
    982              (+) Start the Time PWM.
    983              (+) Stop the Time PWM.
    984              (+) Start the Time PWM and enable interrupt.
    985              (+) Stop the Time PWM and disable interrupt.
    986              (+) Start the Time PWM and enable DMA transfer.
    987              (+) Stop the Time PWM and disable DMA transfer.
    988           
    989          @endverbatim
    990            * @{
    991            */
    992          /**
    993            * @brief  Initializes the TIM PWM Time Base according to the specified
    994            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    995            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
    996            *                the configuration information for TIM module.
    997            * @retval HAL status
    998            */

   \                                 In section .text, align 2, keep-with-next
    999          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1000          {
   \                     HAL_TIM_PWM_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1001            /* Check the TIM handle allocation */
   1002            if(htim == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
   1003            {
   1004              return HAL_ERROR;
   \   0000000A   0xD068             BEQ.N    ??HAL_TIM_PWM_Init_0
   1005            }
   1006          
   1007            /* Check the parameters */
   1008            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1009            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1010            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1011          
   1012            if(htim->State == HAL_TIM_STATE_RESET)
   \   0000000C   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_PWM_Init_1
   1013            {
   1014              /* Allocate lock resource and initialize it */
   1015              htim->Lock = HAL_UNLOCKED;  
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   1016              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1017              HAL_TIM_PWM_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
   1018            }
   1019          
   1020            /* Set the TIM state */
   1021            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   1022            
   1023            /* Init the base time for the PWM */  
   1024            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0x40010000
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0x680B             LDR      R3,[R1, #+0]
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000034   0xD00F             BEQ.N    ??HAL_TIM_PWM_Init_2
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   0000003A   0x42A9             CMP      R1,R5
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000042   0x42A9             CMPNE    R1,R5
   \   00000044   0xD007             BEQ.N    ??HAL_TIM_PWM_Init_2
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable15_3  ;; 0x40000c00
   \   0000004A   0x42A9             CMP      R1,R5
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x.... 0x....      LDRNE.W  R5,??DataTable16  ;; 0x40010400
   \   00000052   0x42A9             CMPNE    R1,R5
   \   00000054   0xD113             BNE.N    ??HAL_TIM_PWM_Init_3
   \                     ??HAL_TIM_PWM_Init_2: (+1)
   \   00000056   0x6845             LDR      R5,[R0, #+4]
   \   00000058   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000005C   0x432B             ORRS     R3,R5,R3
   \   0000005E   0x4291             CMP      R1,R2
   \   00000060   0xBF18             IT       NE 
   \   00000062   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000066   0xD025             BEQ.N    ??HAL_TIM_PWM_Init_4
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable15_1  ;; 0x40000400
   \   0000006C   0x42A9             CMP      R1,R5
   \   0000006E   0xBF1F             ITTTT    NE 
   \   00000070   0x.... 0x....      LDRNE.W  R5,??DataTable15_2  ;; 0x40000800
   \   00000074   0x42A9             CMPNE    R1,R5
   \   00000076   0x.... 0x....      LDRNE.W  R5,??DataTable15_3  ;; 0x40000c00
   \   0000007A   0x42A9             CMPNE    R1,R5
   \   0000007C   0xD01A             BEQ.N    ??HAL_TIM_PWM_Init_4
   \                     ??HAL_TIM_PWM_Init_3: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R5,??DataTable16  ;; 0x40010400
   \   00000082   0x42A9             CMP      R1,R5
   \   00000084   0xBF1C             ITT      NE 
   \   00000086   0x.... 0x....      LDRNE.W  R5,??DataTable16_1  ;; 0x40014000
   \   0000008A   0x42A9             CMPNE    R1,R5
   \   0000008C   0xD012             BEQ.N    ??HAL_TIM_PWM_Init_4
   \   0000008E   0x.... 0x....      LDR.W    R5,??DataTable16_2  ;; 0x40014400
   \   00000092   0x42A9             CMP      R1,R5
   \   00000094   0xBF1C             ITT      NE 
   \   00000096   0x.... 0x....      LDRNE.W  R5,??DataTable16_3  ;; 0x40014800
   \   0000009A   0x42A9             CMPNE    R1,R5
   \   0000009C   0xD00A             BEQ.N    ??HAL_TIM_PWM_Init_4
   \   0000009E   0x.... 0x....      LDR.W    R5,??DataTable16_4  ;; 0x40001800
   \   000000A2   0x42A9             CMP      R1,R5
   \   000000A4   0xBF1F             ITTTT    NE 
   \   000000A6   0x.... 0x....      LDRNE.W  R5,??DataTable16_5  ;; 0x40001c00
   \   000000AA   0x42A9             CMPNE    R1,R5
   \   000000AC   0x.... 0x....      LDRNE.W  R5,??DataTable16_6  ;; 0x40002000
   \   000000B0   0x42A9             CMPNE    R1,R5
   \   000000B2   0xD103             BNE.N    ??HAL_TIM_PWM_Init_5
   \                     ??HAL_TIM_PWM_Init_4: (+1)
   \   000000B4   0x68C5             LDR      R5,[R0, #+12]
   \   000000B6   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000BA   0x432B             ORRS     R3,R5,R3
   \                     ??HAL_TIM_PWM_Init_5: (+1)
   \   000000BC   0x600B             STR      R3,[R1, #+0]
   \   000000BE   0x6883             LDR      R3,[R0, #+8]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0x62CB             STR      R3,[R1, #+44]
   \   000000C4   0x6803             LDR      R3,[R0, #+0]
   \   000000C6   0x628B             STR      R3,[R1, #+40]
   \   000000C8   0xBF19             ITTEE    NE 
   \   000000CA   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   000000CE   0x4291             CMPNE    R1,R2
   \   000000D0   0x6900             LDREQ    R0,[R0, #+16]
   \   000000D2   0x6308             STREQ    R0,[R1, #+48]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x6148             STR      R0,[R1, #+20]
   1025             
   1026            /* Initialize the TIM state*/
   1027            htim->State= HAL_TIM_STATE_READY;
   \   000000D8   0xF884 0x0039      STRB     R0,[R4, #+57]
   1028            
   1029            return HAL_OK;
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \   000000DE   0xB001             ADD      SP,SP,#+4
   \   000000E0   0xBD30             POP      {R4,R5,PC}       ;; return
   1030          }  
   1031          
   1032          /**
   1033            * @brief  DeInitializes the TIM peripheral 
   1034            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1035            *                the configuration information for TIM module.
   1036            * @retval HAL status
   1037            */

   \                                 In section .text, align 2, keep-with-next
   1038          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1039          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1040            /* Check the parameters */
   1041            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1042            
   1043            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1044            
   1045            /* Disable the TIM Peripheral Clock */
   1046            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1047              
   1048            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1049            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1050              
   1051            /* Change TIM state */  
   1052            htim->State = HAL_TIM_STATE_RESET; 
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1053          
   1054            /* Release Lock */
   1055            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   1056          
   1057            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1058          }
   1059          
   1060          /**
   1061            * @brief  Initializes the TIM PWM MSP.
   1062            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1063            *                the configuration information for TIM module.
   1064            * @retval None
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1067          {
   1068            /* Prevent unused argument(s) compilation warning */
   1069            UNUSED(htim);
   1070           
   1071            /* NOTE : This function Should not be modified, when the callback is needed,
   1072                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1073             */
   1074          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1075          
   1076          /**
   1077            * @brief  DeInitializes TIM PWM MSP.
   1078            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1079            *                the configuration information for TIM module.
   1080            * @retval None
   1081            */

   \                                 In section .text, align 2, keep-with-next
   1082          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1083          {
   1084            /* Prevent unused argument(s) compilation warning */
   1085            UNUSED(htim);
   1086           
   1087            /* NOTE : This function Should not be modified, when the callback is needed,
   1088                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1089             */
   1090          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1091          
   1092          /**
   1093            * @brief  Starts the PWM signal generation.
   1094            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1095            *                the configuration information for TIM module.
   1096            * @param  Channel: TIM Channels to be enabled.
   1097            *          This parameter can be one of the following values:
   1098            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1099            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1100            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1101            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1102            * @retval HAL status
   1103            */

   \                                 In section .text, align 2, keep-with-next
   1104          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1105          {
   1106            /* Check the parameters */
   1107            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1108          
   1109            /* Enable the Capture compare channel */
   1110            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     HAL_TIM_PWM_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
   1111            
   1112            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000014   0x....             LDR.N    R1,??DataTable15  ;; 0x40010000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xBF1C             ITT      NE 
   \   0000001A   0x.... 0x....      LDRNE.W  R1,??DataTable16  ;; 0x40010400
   \   0000001E   0x4288             CMPNE    R0,R1
   \   00000020   0xD103             BNE.N    ??HAL_TIM_PWM_Start_0
   1113            {
   1114              /* Enable the main output */
   1115              __HAL_TIM_MOE_ENABLE(htim);
   \   00000022   0x6C41             LDR      R1,[R0, #+68]
   \   00000024   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000028   0x6441             STR      R1,[R0, #+68]
   1116            }
   1117              
   1118            /* Enable the Peripheral */
   1119            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_0: (+1)
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000030   0x6001             STR      R1,[R0, #+0]
   1120            
   1121            /* Return function status */
   1122            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4770             BX       LR               ;; return
   1123          } 
   1124          
   1125          /**
   1126            * @brief  Stops the PWM signal generation.
   1127            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1128            *                the configuration information for TIM module.
   1129            * @param  Channel: TIM Channels to be disabled.
   1130            *          This parameter can be one of the following values:
   1131            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1132            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1133            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1134            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1135            * @retval HAL status
   1136            */

   \                                 In section .text, align 2, keep-with-next
   1137          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1138          { 
   1139            /* Check the parameters */
   1140            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1141              
   1142            /* Disable the Capture compare channel */
   1143            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     HAL_TIM_PWM_Stop: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0xF04F 0x0C01      MOV      R12,#+1
   \   00000006   0xFA0C 0xF101      LSL      R1,R12,R1
   \   0000000A   0x6A13             LDR      R3,[R2, #+32]
   \   0000000C   0xEA23 0x0101      BIC      R1,R3,R1
   \   00000010   0x6211             STR      R1,[R2, #+32]
   \   00000012   0x6A11             LDR      R1,[R2, #+32]
   \   00000014   0x6211             STR      R1,[R2, #+32]
   1144            
   1145            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x....             LDR.N    R2,??DataTable15  ;; 0x40010000
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x.... 0x....      LDRNE.W  R2,??DataTable16  ;; 0x40010400
   \   00000022   0x4291             CMPNE    R1,R2
   \   00000024   0xD10D             BNE.N    ??HAL_TIM_PWM_Stop_0
   1146            {
   1147              /* Disable the Main Output */
   1148              __HAL_TIM_MOE_DISABLE(htim);
   \   00000026   0x6A0A             LDR      R2,[R1, #+32]
   \   00000028   0xF241 0x1311      MOVW     R3,#+4369
   \   0000002C   0x421A             TST      R2,R3
   \   0000002E   0xBF02             ITTT     EQ 
   \   00000030   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000032   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000036   0x421A             TSTEQ    R2,R3
   \   00000038   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_0
   \   0000003A   0x6C4A             LDR      R2,[R1, #+68]
   \   0000003C   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   00000040   0x644A             STR      R2,[R1, #+68]
   1149            }
   1150            
   1151            /* Disable the Peripheral */
   1152            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_0: (+1)
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xF241 0x1311      MOVW     R3,#+4369
   \   00000048   0x6A0A             LDR      R2,[R1, #+32]
   \   0000004A   0x421A             TST      R2,R3
   \   0000004C   0xBF02             ITTT     EQ 
   \   0000004E   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000050   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000054   0x421A             TSTEQ    R2,R3
   \   00000056   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_1
   \   00000058   0x680A             LDR      R2,[R1, #+0]
   \   0000005A   0x0852             LSRS     R2,R2,#+1
   \   0000005C   0x0052             LSLS     R2,R2,#+1
   \   0000005E   0x600A             STR      R2,[R1, #+0]
   1153            
   1154            /* Change the htim state */
   1155            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_1: (+1)
   \   00000060   0xF880 0xC039      STRB     R12,[R0, #+57]
   1156            
   1157            /* Return function status */
   1158            return HAL_OK;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x4770             BX       LR               ;; return
   1159          } 
   1160          
   1161          /**
   1162            * @brief  Starts the PWM signal generation in interrupt mode.
   1163            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1164            *                the configuration information for TIM module.
   1165            * @param  Channel: TIM Channel to be disabled.
   1166            *          This parameter can be one of the following values:
   1167            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1168            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1169            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1170            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1171            * @retval HAL status
   1172            */

   \                                 In section .text, align 4, keep-with-next
   1173          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1174          {
   1175            /* Check the parameters */
   1176            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1177            
   1178            switch (Channel)
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_PWM_Start_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_PWM_Start_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1179            {
   1180              case TIM_CHANNEL_1:
   1181              {       
   1182                /* Enable the TIM Capture/Compare 1 interrupt */
   1183                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_PWM_Start_IT_3
   1184              }
   1185              break;
   1186              
   1187              case TIM_CHANNEL_2:
   1188              {
   1189                /* Enable the TIM Capture/Compare 2 interrupt */
   1190                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_PWM_Start_IT_3
   1191              }
   1192              break;
   1193              
   1194              case TIM_CHANNEL_3:
   1195              {
   1196                /* Enable the TIM Capture/Compare 3 interrupt */
   1197                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_PWM_Start_IT_3
   1198              }
   1199              break;
   1200              
   1201              case TIM_CHANNEL_4:
   1202              {
   1203                /* Enable the TIM Capture/Compare 4 interrupt */
   1204                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF043 0x0310      ORR      R3,R3,#0x10
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1205              }
   1206              break;
   1207              
   1208              default:
   1209              break;
   1210            } 
   1211            
   1212            /* Enable the Capture compare channel */
   1213            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x4088             LSLS     R0,R0,R1
   \   00000044   0x6A11             LDR      R1,[R2, #+32]
   \   00000046   0x4381             BICS     R1,R1,R0
   \   00000048   0x6211             STR      R1,[R2, #+32]
   \   0000004A   0x6A11             LDR      R1,[R2, #+32]
   \   0000004C   0x4308             ORRS     R0,R0,R1
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   1214            
   1215            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000050   0x....             LDR.N    R0,??DataTable15  ;; 0x40010000
   \   00000052   0x4282             CMP      R2,R0
   \   00000054   0xBF1C             ITT      NE 
   \   00000056   0x....             LDRNE.N  R0,??DataTable16  ;; 0x40010400
   \   00000058   0x4282             CMPNE    R2,R0
   \   0000005A   0xD103             BNE.N    ??HAL_TIM_PWM_Start_IT_7
   1216            {
   1217              /* Enable the main output */
   1218              __HAL_TIM_MOE_ENABLE(htim);
   \   0000005C   0x6C50             LDR      R0,[R2, #+68]
   \   0000005E   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000062   0x6450             STR      R0,[R2, #+68]
   1219            }
   1220          
   1221            /* Enable the Peripheral */
   1222            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_PWM_Start_IT_7: (+1)
   \   00000064   0x6810             LDR      R0,[R2, #+0]
   \   00000066   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000006A   0x6010             STR      R0,[R2, #+0]
   1223            
   1224            /* Return function status */
   1225            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x4770             BX       LR               ;; return
   1226          } 
   1227          
   1228          /**
   1229            * @brief  Stops the PWM signal generation in interrupt mode.
   1230            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1231            *                the configuration information for TIM module.
   1232            * @param  Channel: TIM Channels to be disabled.
   1233            *          This parameter can be one of the following values:
   1234            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1235            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1236            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1237            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1238            * @retval HAL status
   1239            */

   \                                 In section .text, align 4, keep-with-next
   1240          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1241          {
   1242            /* Check the parameters */
   1243            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1244            
   1245            switch (Channel)
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_PWM_Stop_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_PWM_Stop_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1246            {
   1247              case TIM_CHANNEL_1:
   1248              {       
   1249                /* Disable the TIM Capture/Compare 1 interrupt */
   1250                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_PWM_Stop_IT_3
   1251              }
   1252              break;
   1253              
   1254              case TIM_CHANNEL_2:
   1255              {
   1256                /* Disable the TIM Capture/Compare 2 interrupt */
   1257                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_PWM_Stop_IT_3
   1258              }
   1259              break;
   1260              
   1261              case TIM_CHANNEL_3:
   1262              {
   1263                /* Disable the TIM Capture/Compare 3 interrupt */
   1264                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_PWM_Stop_IT_3
   1265              }
   1266              break;
   1267              
   1268              case TIM_CHANNEL_4:
   1269              {
   1270                /* Disable the TIM Capture/Compare 4 interrupt */
   1271                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF023 0x0310      BIC      R3,R3,#0x10
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1272              }
   1273              break;
   1274              
   1275              default:
   1276              break; 
   1277            }
   1278            
   1279            /* Disable the Capture compare channel */
   1280            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000046   0x6A10             LDR      R0,[R2, #+32]
   \   00000048   0x4388             BICS     R0,R0,R1
   \   0000004A   0x6210             STR      R0,[R2, #+32]
   \   0000004C   0x6A10             LDR      R0,[R2, #+32]
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   1281            
   1282            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000050   0x....             LDR.N    R0,??DataTable15  ;; 0x40010000
   \   00000052   0x4282             CMP      R2,R0
   \   00000054   0xBF1C             ITT      NE 
   \   00000056   0x....             LDRNE.N  R0,??DataTable16  ;; 0x40010400
   \   00000058   0x4282             CMPNE    R2,R0
   \   0000005A   0xD10D             BNE.N    ??HAL_TIM_PWM_Stop_IT_7
   1283            {
   1284              /* Disable the Main Output */
   1285              __HAL_TIM_MOE_DISABLE(htim);
   \   0000005C   0x6A10             LDR      R0,[R2, #+32]
   \   0000005E   0xF241 0x1111      MOVW     R1,#+4369
   \   00000062   0x4208             TST      R0,R1
   \   00000064   0xBF02             ITTT     EQ 
   \   00000066   0x6A10             LDREQ    R0,[R2, #+32]
   \   00000068   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   0000006C   0x4208             TSTEQ    R0,R1
   \   0000006E   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_IT_7
   \   00000070   0x6C50             LDR      R0,[R2, #+68]
   \   00000072   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   00000076   0x6450             STR      R0,[R2, #+68]
   1286            }
   1287            
   1288            /* Disable the Peripheral */
   1289            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_IT_7: (+1)
   \   00000078   0x6A10             LDR      R0,[R2, #+32]
   \   0000007A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000007E   0x4208             TST      R0,R1
   \   00000080   0xBF02             ITTT     EQ 
   \   00000082   0x6A10             LDREQ    R0,[R2, #+32]
   \   00000084   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   00000088   0x4208             TSTEQ    R0,R1
   \   0000008A   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_IT_8
   \   0000008C   0x6810             LDR      R0,[R2, #+0]
   \   0000008E   0x0840             LSRS     R0,R0,#+1
   \   00000090   0x0040             LSLS     R0,R0,#+1
   \   00000092   0x6010             STR      R0,[R2, #+0]
   1290            
   1291            /* Return function status */
   1292            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_8: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x4770             BX       LR               ;; return
   1293          } 
   1294          
   1295          /**
   1296            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1297            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1298            *                the configuration information for TIM module.
   1299            * @param  Channel: TIM Channels to be enabled.
   1300            *          This parameter can be one of the following values:
   1301            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1302            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1303            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1304            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1305            * @param  pData: The source Buffer address.
   1306            * @param  Length: The length of data to be transferred from memory to TIM peripheral
   1307            * @retval HAL status
   1308            */

   \                                 In section .text, align 4, keep-with-next
   1309          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1310          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
   1311            /* Check the parameters */
   1312            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1313            
   1314            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xF000 0x807B      BEQ.W    ??HAL_TIM_PWM_Start_DMA_1
   1315            {
   1316               return HAL_BUSY;
   1317            }
   1318            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000014   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD105             BNE.N    ??HAL_TIM_PWM_Start_DMA_2
   1319            {
   1320              if(((uint32_t)pData == 0 ) && (Length > 0)) 
   \   0000001C   0xB909             CBNZ.N   R1,??HAL_TIM_PWM_Start_DMA_3
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD173             BNE.N    ??HAL_TIM_PWM_Start_DMA_1
   1321              {
   1322                return HAL_ERROR;                                    
   1323              }
   1324              else
   1325              {
   1326                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
   1327              }
   1328            }    
   1329            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \   00000028   0x2D0C             CMP      R5,#+12
   \   0000002A   0xD854             BHI.N    ??HAL_TIM_PWM_Start_DMA_4
   \   0000002C   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??HAL_TIM_PWM_Start_DMA_0:
   \   00000030   0x07 0x53          DC8      0x7,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000034   0x1A 0x53          DC8      0x1A,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000038   0x2D 0x53          DC8      0x2D,0x53,0x53,0x53
   \              0x53 0x53    
   \   0000003C   0x40 0x00          DC8      0x40,0x0
   1330            {
   1331              case TIM_CHANNEL_1:
   1332              {      
   1333                /* Set the DMA Period elapsed callback */
   1334                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \   0000003E   0x6A22             LDR      R2,[R4, #+32]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000044   0x63D0             STR      R0,[R2, #+60]
   1335               
   1336                /* Set the DMA error callback */
   1337                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000046   0x6A22             LDR      R2,[R4, #+32]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000004C   0x6490             STR      R0,[R2, #+72]
   1338                
   1339                /* Enable the DMA Stream */
   1340                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0xF100 0x0234      ADD      R2,R0,#+52
   \   00000054   0x6A20             LDR      R0,[R4, #+32]
   \   00000056   0x.... 0x....      BL       HAL_DMA_Start_IT
   1341                
   1342                /* Enable the TIM Capture/Compare 1 DMA request */
   1343                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x68C1             LDR      R1,[R0, #+12]
   \   0000005E   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000062   0xE037             B.N      ??HAL_TIM_PWM_Start_DMA_6
   1344              }
   1345              break;
   1346              
   1347              case TIM_CHANNEL_2:
   1348              {
   1349                /* Set the DMA Period elapsed callback */
   1350                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \   00000064   0x6A62             LDR      R2,[R4, #+36]
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000006A   0x63D0             STR      R0,[R2, #+60]
   1351               
   1352                /* Set the DMA error callback */
   1353                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000006C   0x6A62             LDR      R2,[R4, #+36]
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000072   0x6490             STR      R0,[R2, #+72]
   1354                
   1355                /* Enable the DMA Stream */
   1356                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF100 0x0238      ADD      R2,R0,#+56
   \   0000007A   0x6A60             LDR      R0,[R4, #+36]
   \   0000007C   0x.... 0x....      BL       HAL_DMA_Start_IT
   1357                
   1358                /* Enable the TIM Capture/Compare 2 DMA request */
   1359                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x68C1             LDR      R1,[R0, #+12]
   \   00000084   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000088   0xE024             B.N      ??HAL_TIM_PWM_Start_DMA_6
   1360              }
   1361              break;
   1362              
   1363              case TIM_CHANNEL_3:
   1364              {
   1365                /* Set the DMA Period elapsed callback */
   1366                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \   0000008A   0x6AA2             LDR      R2,[R4, #+40]
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000090   0x63D0             STR      R0,[R2, #+60]
   1367               
   1368                /* Set the DMA error callback */
   1369                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000092   0x6AA2             LDR      R2,[R4, #+40]
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000098   0x6490             STR      R0,[R2, #+72]
   1370                
   1371                /* Enable the DMA Stream */
   1372                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0xF100 0x023C      ADD      R2,R0,#+60
   \   000000A0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000A2   0x.... 0x....      BL       HAL_DMA_Start_IT
   1373                
   1374                /* Enable the TIM Output Capture/Compare 3 request */
   1375                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x68C1             LDR      R1,[R0, #+12]
   \   000000AA   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000AE   0xE011             B.N      ??HAL_TIM_PWM_Start_DMA_6
   1376              }
   1377              break;
   1378              
   1379              case TIM_CHANNEL_4:
   1380              {
   1381               /* Set the DMA Period elapsed callback */
   1382                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \   000000B0   0x6AE2             LDR      R2,[R4, #+44]
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000B6   0x63D0             STR      R0,[R2, #+60]
   1383               
   1384                /* Set the DMA error callback */
   1385                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000B8   0x6AE2             LDR      R2,[R4, #+44]
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000BE   0x6490             STR      R0,[R2, #+72]
   1386                
   1387                /* Enable the DMA Stream */
   1388                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0xF100 0x0240      ADD      R2,R0,#+64
   \   000000C6   0x6AE0             LDR      R0,[R4, #+44]
   \   000000C8   0x.... 0x....      BL       HAL_DMA_Start_IT
   1389                
   1390                /* Enable the TIM Capture/Compare 4 DMA request */
   1391                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x68C1             LDR      R1,[R0, #+12]
   \   000000D0   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \   000000D4   0x60C1             STR      R1,[R0, #+12]
   1392              }
   1393              break;
   1394              
   1395              default:
   1396              break;
   1397            }
   1398          
   1399            /* Enable the Capture compare channel */
   1400            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x2101             MOVS     R1,#+1
   \   000000DA   0x40A9             LSLS     R1,R1,R5
   \   000000DC   0x6A02             LDR      R2,[R0, #+32]
   \   000000DE   0x438A             BICS     R2,R2,R1
   \   000000E0   0x6202             STR      R2,[R0, #+32]
   \   000000E2   0x6A02             LDR      R2,[R0, #+32]
   \   000000E4   0x4311             ORRS     R1,R1,R2
   \   000000E6   0x6201             STR      R1,[R0, #+32]
   1401              
   1402            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x....             LDR.N    R1,??DataTable15  ;; 0x40010000
   \   000000EC   0x4288             CMP      R0,R1
   \   000000EE   0xBF1C             ITT      NE 
   \   000000F0   0x....             LDRNE.N  R1,??DataTable16  ;; 0x40010400
   \   000000F2   0x4288             CMPNE    R0,R1
   \   000000F4   0xD103             BNE.N    ??HAL_TIM_PWM_Start_DMA_10
   1403            {
   1404              /* Enable the main output */
   1405              __HAL_TIM_MOE_ENABLE(htim);
   \   000000F6   0x6C41             LDR      R1,[R0, #+68]
   \   000000F8   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   000000FC   0x6441             STR      R1,[R0, #+68]
   1406            }
   1407            
   1408            /* Enable the Peripheral */
   1409            __HAL_TIM_ENABLE(htim); 
   \                     ??HAL_TIM_PWM_Start_DMA_10: (+1)
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6801             LDR      R1,[R0, #+0]
   \   00000102   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000106   0x6001             STR      R1,[R0, #+0]
   1410            
   1411            /* Return function status */
   1412            return HAL_OK;
   \   00000108   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \   0000010A   0xB001             ADD      SP,SP,#+4
   \   0000010C   0xBD30             POP      {R4,R5,PC}       ;; return
   1413          }
   1414          
   1415          /**
   1416            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1417            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1418            *                the configuration information for TIM module.
   1419            * @param  Channel: TIM Channels to be disabled.
   1420            *          This parameter can be one of the following values:
   1421            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1422            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1423            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1424            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1425            * @retval HAL status
   1426            */

   \                                 In section .text, align 4, keep-with-next
   1427          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1428          {
   1429            /* Check the parameters */
   1430            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1431            
   1432            switch (Channel)
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xD81C             BHI.N    ??HAL_TIM_PWM_Stop_DMA_1
   \   00000006   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_PWM_Stop_DMA_0:
   \   0000000A   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000E   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000012   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000016   0x16 0x00          DC8      0x16,0x0
   1433            {
   1434              case TIM_CHANNEL_1:
   1435              {       
   1436                /* Disable the TIM Capture/Compare 1 DMA request */
   1437                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x68D3             LDR      R3,[R2, #+12]
   \   0000001C   0xF423 0x7300      BIC      R3,R3,#0x200
   \   00000020   0xE00D             B.N      ??HAL_TIM_PWM_Stop_DMA_3
   1438              }
   1439              break;
   1440              
   1441              case TIM_CHANNEL_2:
   1442              {
   1443                /* Disable the TIM Capture/Compare 2 DMA request */
   1444                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x68D3             LDR      R3,[R2, #+12]
   \   00000026   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002A   0xE008             B.N      ??HAL_TIM_PWM_Stop_DMA_3
   1445              }
   1446              break;
   1447              
   1448              case TIM_CHANNEL_3:
   1449              {
   1450                /* Disable the TIM Capture/Compare 3 DMA request */
   1451                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_5: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000034   0xE003             B.N      ??HAL_TIM_PWM_Stop_DMA_3
   1452              }
   1453              break;
   1454              
   1455              case TIM_CHANNEL_4:
   1456              {
   1457                /* Disable the TIM Capture/Compare 4 interrupt */
   1458                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_6: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0xF423 0x5380      BIC      R3,R3,#0x1000
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \   0000003E   0x60D3             STR      R3,[R2, #+12]
   1459              }
   1460              break;
   1461              
   1462              default:
   1463              break;
   1464            } 
   1465            
   1466            /* Disable the Capture compare channel */
   1467            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000048   0x6A13             LDR      R3,[R2, #+32]
   \   0000004A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000004E   0x6211             STR      R1,[R2, #+32]
   \   00000050   0x6A11             LDR      R1,[R2, #+32]
   \   00000052   0x6211             STR      R1,[R2, #+32]
   1468            
   1469            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x....             LDR.N    R2,??DataTable15  ;; 0x40010000
   \   00000058   0x4291             CMP      R1,R2
   \   0000005A   0xBF1C             ITT      NE 
   \   0000005C   0x....             LDRNE.N  R2,??DataTable16  ;; 0x40010400
   \   0000005E   0x4291             CMPNE    R1,R2
   \   00000060   0xD10D             BNE.N    ??HAL_TIM_PWM_Stop_DMA_7
   1470            {
   1471              /* Disable the Main Output */
   1472              __HAL_TIM_MOE_DISABLE(htim);
   \   00000062   0x6A0A             LDR      R2,[R1, #+32]
   \   00000064   0xF241 0x1311      MOVW     R3,#+4369
   \   00000068   0x421A             TST      R2,R3
   \   0000006A   0xBF02             ITTT     EQ 
   \   0000006C   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000006E   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000072   0x421A             TSTEQ    R2,R3
   \   00000074   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_DMA_7
   \   00000076   0x6C4A             LDR      R2,[R1, #+68]
   \   00000078   0xF422 0x4200      BIC      R2,R2,#0x8000
   \   0000007C   0x644A             STR      R2,[R1, #+68]
   1473            }
   1474            
   1475            /* Disable the Peripheral */
   1476            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_DMA_7: (+1)
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0xF241 0x1311      MOVW     R3,#+4369
   \   00000084   0x6A0A             LDR      R2,[R1, #+32]
   \   00000086   0x421A             TST      R2,R3
   \   00000088   0xBF02             ITTT     EQ 
   \   0000008A   0x6A0A             LDREQ    R2,[R1, #+32]
   \   0000008C   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000090   0x421A             TSTEQ    R2,R3
   \   00000092   0xD103             BNE.N    ??HAL_TIM_PWM_Stop_DMA_8
   \   00000094   0x680A             LDR      R2,[R1, #+0]
   \   00000096   0x0852             LSRS     R2,R2,#+1
   \   00000098   0x0052             LSLS     R2,R2,#+1
   \   0000009A   0x600A             STR      R2,[R1, #+0]
   1477            
   1478            /* Change the htim state */
   1479            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_8: (+1)
   \   0000009C   0xF880 0x4039      STRB     R4,[R0, #+57]
   1480            
   1481            /* Return function status */
   1482            return HAL_OK;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xBC10             POP      {R4}
   \   000000A4   0x4770             BX       LR               ;; return
   1483          }
   1484          
   1485          /**
   1486            * @}
   1487            */
   1488          
   1489          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1490           *  @brief    Time Input Capture functions 
   1491           *
   1492          @verbatim    
   1493            ==============================================================================
   1494                        ##### Time Input Capture functions #####
   1495            ==============================================================================
   1496           [..]  
   1497             This section provides functions allowing to:
   1498             (+) Initialize and configure the TIM Input Capture. 
   1499             (+) De-initialize the TIM Input Capture.
   1500             (+) Start the Time Input Capture.
   1501             (+) Stop the Time Input Capture.
   1502             (+) Start the Time Input Capture and enable interrupt.
   1503             (+) Stop the Time Input Capture and disable interrupt.
   1504             (+) Start the Time Input Capture and enable DMA transfer.
   1505             (+) Stop the Time Input Capture and disable DMA transfer.
   1506           
   1507          @endverbatim
   1508            * @{
   1509            */
   1510          /**
   1511            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1512            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1513            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1514            *                the configuration information for TIM module.
   1515            * @retval HAL status
   1516            */

   \                                 In section .text, align 2, keep-with-next
   1517          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1518          {
   \                     HAL_TIM_IC_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1519            /* Check the TIM handle allocation */
   1520            if(htim == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
   1521            {
   1522              return HAL_ERROR;
   \   0000000A   0xD05F             BEQ.N    ??HAL_TIM_IC_Init_0
   1523            }
   1524          
   1525            /* Check the parameters */
   1526            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1527            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1528            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
   1529          
   1530            if(htim->State == HAL_TIM_STATE_RESET)
   \   0000000C   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_IC_Init_1
   1531            { 
   1532              /* Allocate lock resource and initialize it */
   1533              htim->Lock = HAL_UNLOCKED;   
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   1534              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1535              HAL_TIM_IC_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1536            }
   1537            
   1538            /* Set the TIM state */
   1539            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   1540            
   1541            /* Init the base time for the input capture */  
   1542            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable24  ;; 0x40010000
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0x680B             LDR      R3,[R1, #+0]
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000034   0xD00E             BEQ.N    ??HAL_TIM_IC_Init_2
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable24_1  ;; 0x40000400
   \   0000003A   0x42A9             CMP      R1,R5
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x.... 0x....      LDRNE.W  R5,??DataTable24_2  ;; 0x40000800
   \   00000042   0x42A9             CMPNE    R1,R5
   \   00000044   0xD006             BEQ.N    ??HAL_TIM_IC_Init_2
   \   00000046   0x.... 0x....      LDR.W    R5,??DataTable24_3  ;; 0x40000c00
   \   0000004A   0x42A9             CMP      R1,R5
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x....             LDRNE.N  R5,??DataTable16  ;; 0x40010400
   \   00000050   0x42A9             CMPNE    R1,R5
   \   00000052   0xD113             BNE.N    ??HAL_TIM_IC_Init_3
   \                     ??HAL_TIM_IC_Init_2: (+1)
   \   00000054   0x6845             LDR      R5,[R0, #+4]
   \   00000056   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000005A   0x432B             ORRS     R3,R5,R3
   \   0000005C   0x4291             CMP      R1,R2
   \   0000005E   0xBF18             IT       NE 
   \   00000060   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000064   0xD01E             BEQ.N    ??HAL_TIM_IC_Init_4
   \   00000066   0x.... 0x....      LDR.W    R5,??DataTable24_1  ;; 0x40000400
   \   0000006A   0x42A9             CMP      R1,R5
   \   0000006C   0xBF1F             ITTTT    NE 
   \   0000006E   0x.... 0x....      LDRNE.W  R5,??DataTable24_2  ;; 0x40000800
   \   00000072   0x42A9             CMPNE    R1,R5
   \   00000074   0x.... 0x....      LDRNE.W  R5,??DataTable24_3  ;; 0x40000c00
   \   00000078   0x42A9             CMPNE    R1,R5
   \   0000007A   0xD013             BEQ.N    ??HAL_TIM_IC_Init_4
   \                     ??HAL_TIM_IC_Init_3: (+1)
   \   0000007C   0x....             LDR.N    R5,??DataTable16  ;; 0x40010400
   \   0000007E   0x42A9             CMP      R1,R5
   \   00000080   0xBF1C             ITT      NE 
   \   00000082   0x....             LDRNE.N  R5,??DataTable16_1  ;; 0x40014000
   \   00000084   0x42A9             CMPNE    R1,R5
   \   00000086   0xD00D             BEQ.N    ??HAL_TIM_IC_Init_4
   \   00000088   0x....             LDR.N    R5,??DataTable16_2  ;; 0x40014400
   \   0000008A   0x42A9             CMP      R1,R5
   \   0000008C   0xBF1C             ITT      NE 
   \   0000008E   0x....             LDRNE.N  R5,??DataTable16_3  ;; 0x40014800
   \   00000090   0x42A9             CMPNE    R1,R5
   \   00000092   0xD007             BEQ.N    ??HAL_TIM_IC_Init_4
   \   00000094   0x....             LDR.N    R5,??DataTable16_4  ;; 0x40001800
   \   00000096   0x42A9             CMP      R1,R5
   \   00000098   0xBF1F             ITTTT    NE 
   \   0000009A   0x....             LDRNE.N  R5,??DataTable16_5  ;; 0x40001c00
   \   0000009C   0x42A9             CMPNE    R1,R5
   \   0000009E   0x....             LDRNE.N  R5,??DataTable16_6  ;; 0x40002000
   \   000000A0   0x42A9             CMPNE    R1,R5
   \   000000A2   0xD103             BNE.N    ??HAL_TIM_IC_Init_5
   \                     ??HAL_TIM_IC_Init_4: (+1)
   \   000000A4   0x68C5             LDR      R5,[R0, #+12]
   \   000000A6   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000AA   0x432B             ORRS     R3,R5,R3
   \                     ??HAL_TIM_IC_Init_5: (+1)
   \   000000AC   0x600B             STR      R3,[R1, #+0]
   \   000000AE   0x6883             LDR      R3,[R0, #+8]
   \   000000B0   0x4291             CMP      R1,R2
   \   000000B2   0x62CB             STR      R3,[R1, #+44]
   \   000000B4   0x6803             LDR      R3,[R0, #+0]
   \   000000B6   0x628B             STR      R3,[R1, #+40]
   \   000000B8   0xBF19             ITTEE    NE 
   \   000000BA   0x....             LDRNE.N  R2,??DataTable16  ;; 0x40010400
   \   000000BC   0x4291             CMPNE    R1,R2
   \   000000BE   0x6900             LDREQ    R0,[R0, #+16]
   \   000000C0   0x6308             STREQ    R0,[R1, #+48]
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x6148             STR      R0,[R1, #+20]
   1543             
   1544            /* Initialize the TIM state*/
   1545            htim->State= HAL_TIM_STATE_READY;
   \   000000C6   0xF884 0x0039      STRB     R0,[R4, #+57]
   1546            
   1547            return HAL_OK;
   \   000000CA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \   000000CC   0xB001             ADD      SP,SP,#+4
   \   000000CE   0xBD30             POP      {R4,R5,PC}       ;; return
   1548          }
   1549          
   1550          /**
   1551            * @brief  DeInitializes the TIM peripheral 
   1552            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1553            *                the configuration information for TIM module.
   1554            * @retval HAL status
   1555            */

   \                                 In section .text, align 2, keep-with-next
   1556          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1557          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1558            /* Check the parameters */
   1559            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1560          
   1561            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   1562            
   1563            /* Disable the TIM Peripheral Clock */
   1564            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_IC_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1565              
   1566            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1567            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1568              
   1569            /* Change TIM state */  
   1570            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   1571          
   1572            /* Release Lock */
   1573            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   1574          
   1575            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1576          }
   1577          
   1578          /**
   1579            * @brief  Initializes the TIM INput Capture MSP.
   1580            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1581            *                the configuration information for TIM module.
   1582            * @retval None
   1583            */

   \                                 In section .text, align 2, keep-with-next
   1584          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1585          {
   1586            /* Prevent unused argument(s) compilation warning */
   1587            UNUSED(htim);
   1588           
   1589            /* NOTE : This function Should not be modified, when the callback is needed,
   1590                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1591             */
   1592          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1593          
   1594          /**
   1595            * @brief  DeInitializes TIM Input Capture MSP.
   1596            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1597            *                the configuration information for TIM module.
   1598            * @retval None
   1599            */

   \                                 In section .text, align 2, keep-with-next
   1600          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1601          {
   1602            /* Prevent unused argument(s) compilation warning */
   1603            UNUSED(htim);
   1604             
   1605            /* NOTE : This function Should not be modified, when the callback is needed,
   1606                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1607             */
   1608          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1609          
   1610          /**
   1611            * @brief  Starts the TIM Input Capture measurement.
   1612            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1613            *                the configuration information for TIM module.
   1614            * @param  Channel: TIM Channels to be enabled.
   1615            *          This parameter can be one of the following values:
   1616            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1617            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1618            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1619            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1620            * @retval HAL status
   1621            */

   \                                 In section .text, align 2, keep-with-next
   1622          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1623          {
   1624            /* Check the parameters */
   1625            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1626            
   1627            /* Enable the Input Capture channel */
   1628            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     HAL_TIM_IC_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0x438A             BICS     R2,R2,R1
   \   0000000C   0x6202             STR      R2,[R0, #+32]
   \   0000000E   0x6A02             LDR      R2,[R0, #+32]
   \   00000010   0x4311             ORRS     R1,R1,R2
   \   00000012   0x6201             STR      R1,[R0, #+32]
   1629              
   1630            /* Enable the Peripheral */
   1631            __HAL_TIM_ENABLE(htim);  
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000001A   0x6001             STR      R1,[R0, #+0]
   1632          
   1633            /* Return function status */
   1634            return HAL_OK;  
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR               ;; return
   1635          } 
   1636          
   1637          /**
   1638            * @brief  Stops the TIM Input Capture measurement.
   1639            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1640            *                the configuration information for TIM module.
   1641            * @param  Channel: TIM Channels to be disabled.
   1642            *          This parameter can be one of the following values:
   1643            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1644            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1645            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1646            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1647            * @retval HAL status
   1648            */

   \                                 In section .text, align 2, keep-with-next
   1649          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1650          { 
   1651            /* Check the parameters */
   1652            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1653            
   1654            /* Disable the Input Capture channel */
   1655            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     HAL_TIM_IC_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   \   0000000A   0xEA22 0x0101      BIC      R1,R2,R1
   1656            
   1657            /* Disable the Peripheral */
   1658            __HAL_TIM_DISABLE(htim); 
   \   0000000E   0xF241 0x1211      MOVW     R2,#+4369
   \   00000012   0x6201             STR      R1,[R0, #+32]
   \   00000014   0x6A01             LDR      R1,[R0, #+32]
   \   00000016   0x6201             STR      R1,[R0, #+32]
   \   00000018   0x6A01             LDR      R1,[R0, #+32]
   \   0000001A   0x4211             TST      R1,R2
   \   0000001C   0xBF02             ITTT     EQ 
   \   0000001E   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000020   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000024   0x4211             TSTEQ    R1,R2
   \   00000026   0xD103             BNE.N    ??HAL_TIM_IC_Stop_0
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x0849             LSRS     R1,R1,#+1
   \   0000002C   0x0049             LSLS     R1,R1,#+1
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   1659            
   1660            /* Return function status */
   1661            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x4770             BX       LR               ;; return
   1662          }
   1663          
   1664          /**
   1665            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1666            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1667            *                the configuration information for TIM module.
   1668            * @param  Channel: TIM Channels to be enabled.
   1669            *          This parameter can be one of the following values:
   1670            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1671            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1672            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1673            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1674            * @retval HAL status
   1675            */

   \                                 In section .text, align 4, keep-with-next
   1676          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1677          {
   1678            /* Check the parameters */
   1679            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1680            
   1681            switch (Channel)
   \                     HAL_TIM_IC_Start_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_IC_Start_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_IC_Start_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1682            {
   1683              case TIM_CHANNEL_1:
   1684              {       
   1685                /* Enable the TIM Capture/Compare 1 interrupt */
   1686                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_IC_Start_IT_3
   1687              }
   1688              break;
   1689              
   1690              case TIM_CHANNEL_2:
   1691              {
   1692                /* Enable the TIM Capture/Compare 2 interrupt */
   1693                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF043 0x0304      ORR      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_IC_Start_IT_3
   1694              }
   1695              break;
   1696              
   1697              case TIM_CHANNEL_3:
   1698              {
   1699                /* Enable the TIM Capture/Compare 3 interrupt */
   1700                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF043 0x0308      ORR      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_IC_Start_IT_3
   1701              }
   1702              break;
   1703              
   1704              case TIM_CHANNEL_4:
   1705              {
   1706                /* Enable the TIM Capture/Compare 4 interrupt */
   1707                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF043 0x0310      ORR      R3,R3,#0x10
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1708              }
   1709              break;
   1710              
   1711              default:
   1712              break;
   1713            }  
   1714            /* Enable the Input Capture channel */
   1715            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x4088             LSLS     R0,R0,R1
   \   00000044   0x6A11             LDR      R1,[R2, #+32]
   \   00000046   0x4381             BICS     R1,R1,R0
   \   00000048   0x6211             STR      R1,[R2, #+32]
   \   0000004A   0x6A11             LDR      R1,[R2, #+32]
   \   0000004C   0x4308             ORRS     R0,R0,R1
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   1716              
   1717            /* Enable the Peripheral */
   1718            __HAL_TIM_ENABLE(htim);  
   \   00000050   0x6810             LDR      R0,[R2, #+0]
   \   00000052   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000056   0x6010             STR      R0,[R2, #+0]
   1719          
   1720            /* Return function status */
   1721            return HAL_OK;  
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x4770             BX       LR               ;; return
   1722          } 
   1723          
   1724          /**
   1725            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1726            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1727            *                the configuration information for TIM module.
   1728            * @param  Channel: TIM Channels to be disabled.
   1729            *          This parameter can be one of the following values:
   1730            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1731            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1732            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1733            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1734            * @retval HAL status
   1735            */

   \                                 In section .text, align 4, keep-with-next
   1736          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1737          {
   1738            /* Check the parameters */
   1739            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1740            
   1741            switch (Channel)
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xD81C             BHI.N    ??HAL_TIM_IC_Stop_IT_1
   \   00000004   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_IC_Stop_IT_0:
   \   00000008   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000C   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000010   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000014   0x16 0x00          DC8      0x16,0x0
   1742            {
   1743              case TIM_CHANNEL_1:
   1744              {       
   1745                /* Disable the TIM Capture/Compare 1 interrupt */
   1746                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x68D3             LDR      R3,[R2, #+12]
   \   0000001A   0xF023 0x0302      BIC      R3,R3,#0x2
   \   0000001E   0xE00D             B.N      ??HAL_TIM_IC_Stop_IT_3
   1747              }
   1748              break;
   1749              
   1750              case TIM_CHANNEL_2:
   1751              {
   1752                /* Disable the TIM Capture/Compare 2 interrupt */
   1753                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x68D3             LDR      R3,[R2, #+12]
   \   00000024   0xF023 0x0304      BIC      R3,R3,#0x4
   \   00000028   0xE008             B.N      ??HAL_TIM_IC_Stop_IT_3
   1754              }
   1755              break;
   1756              
   1757              case TIM_CHANNEL_3:
   1758              {
   1759                /* Disable the TIM Capture/Compare 3 interrupt */
   1760                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_5: (+1)
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0x68D3             LDR      R3,[R2, #+12]
   \   0000002E   0xF023 0x0308      BIC      R3,R3,#0x8
   \   00000032   0xE003             B.N      ??HAL_TIM_IC_Stop_IT_3
   1761              }
   1762              break;
   1763              
   1764              case TIM_CHANNEL_4:
   1765              {
   1766                /* Disable the TIM Capture/Compare 4 interrupt */
   1767                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_6: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x68D3             LDR      R3,[R2, #+12]
   \   00000038   0xF023 0x0310      BIC      R3,R3,#0x10
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \   0000003C   0x60D3             STR      R3,[R2, #+12]
   1768              }
   1769              break;
   1770              
   1771              default:
   1772              break; 
   1773            } 
   1774            
   1775            /* Disable the Input Capture channel */
   1776            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2301             MOVS     R3,#+1
   \   00000042   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000046   0x6A10             LDR      R0,[R2, #+32]
   \   00000048   0x4388             BICS     R0,R0,R1
   1777            
   1778            /* Disable the Peripheral */
   1779            __HAL_TIM_DISABLE(htim); 
   \   0000004A   0xF241 0x1111      MOVW     R1,#+4369
   \   0000004E   0x6210             STR      R0,[R2, #+32]
   \   00000050   0x6A10             LDR      R0,[R2, #+32]
   \   00000052   0x6210             STR      R0,[R2, #+32]
   \   00000054   0x6A10             LDR      R0,[R2, #+32]
   \   00000056   0x4208             TST      R0,R1
   \   00000058   0xBF02             ITTT     EQ 
   \   0000005A   0x6A10             LDREQ    R0,[R2, #+32]
   \   0000005C   0xF240 0x4144      MOVWEQ   R1,#+1092
   \   00000060   0x4208             TSTEQ    R0,R1
   \   00000062   0xD103             BNE.N    ??HAL_TIM_IC_Stop_IT_7
   \   00000064   0x6810             LDR      R0,[R2, #+0]
   \   00000066   0x0840             LSRS     R0,R0,#+1
   \   00000068   0x0040             LSLS     R0,R0,#+1
   \   0000006A   0x6010             STR      R0,[R2, #+0]
   1780            
   1781            /* Return function status */
   1782            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_7: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x4770             BX       LR               ;; return
   1783          }
   1784          
   1785          /**
   1786            * @brief  Starts the TIM Input Capture measurement on in DMA mode.
   1787            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1788            *                the configuration information for TIM module.
   1789            * @param  Channel: TIM Channels to be enabled.
   1790            *          This parameter can be one of the following values:
   1791            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1792            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1793            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1794            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1795            * @param  pData: The destination Buffer address.
   1796            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   1797            * @retval HAL status
   1798            */

   \                                 In section .text, align 4, keep-with-next
   1799          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1800          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   1801            /* Check the parameters */
   1802            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1803            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1804            
   1805            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD06B             BEQ.N    ??HAL_TIM_IC_Start_DMA_1
   1806            {
   1807               return HAL_BUSY;
   1808            }
   1809            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000010   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD105             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   1810            {
   1811              if((pData == 0 ) && (Length > 0)) 
   \   00000018   0xB90A             CBNZ.N   R2,??HAL_TIM_IC_Start_DMA_3
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD164             BNE.N    ??HAL_TIM_IC_Start_DMA_1
   1812              {
   1813                return HAL_ERROR;                                    
   1814              }
   1815              else
   1816              {
   1817                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x0039      STRB     R0,[R4, #+57]
   1818              }
   1819            }  
   1820             
   1821            switch (Channel)
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \   00000024   0x2D0C             CMP      R5,#+12
   \   00000026   0xD850             BHI.N    ??HAL_TIM_IC_Start_DMA_4
   \   00000028   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??HAL_TIM_IC_Start_DMA_0:
   \   0000002C   0x07 0x4F          DC8      0x7,0x4F,0x4F,0x4F
   \              0x4F 0x4F    
   \   00000030   0x19 0x4F          DC8      0x19,0x4F,0x4F,0x4F
   \              0x4F 0x4F    
   \   00000034   0x2B 0x4F          DC8      0x2B,0x4F,0x4F,0x4F
   \              0x4F 0x4F    
   \   00000038   0x3D 0x00          DC8      0x3D,0x0
   1822            {
   1823              case TIM_CHANNEL_1:
   1824              {
   1825                /* Set the DMA Period elapsed callback */
   1826                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \   0000003A   0x6A21             LDR      R1,[R4, #+32]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000040   0x63C8             STR      R0,[R1, #+60]
   1827               
   1828                /* Set the DMA error callback */
   1829                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000042   0x6A21             LDR      R1,[R4, #+32]
   \   00000044   0x....             LDR.N    R0,??DataTable21_1
   \   00000046   0x6488             STR      R0,[R1, #+72]
   1830                
   1831                /* Enable the DMA Stream */
   1832                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0xF100 0x0134      ADD      R1,R0,#+52
   \   0000004E   0x6A20             LDR      R0,[R4, #+32]
   \   00000050   0x.... 0x....      BL       HAL_DMA_Start_IT
   1833                
   1834                /* Enable the TIM Capture/Compare 1 DMA request */      
   1835                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x68C1             LDR      R1,[R0, #+12]
   \   00000058   0xF441 0x7100      ORR      R1,R1,#0x200
   \   0000005C   0xE034             B.N      ??HAL_TIM_IC_Start_DMA_6
   1836              }
   1837              break;
   1838              
   1839              case TIM_CHANNEL_2:
   1840              {
   1841                /* Set the DMA Period elapsed callback */
   1842                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \   0000005E   0x6A61             LDR      R1,[R4, #+36]
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000064   0x63C8             STR      R0,[R1, #+60]
   1843               
   1844                /* Set the DMA error callback */
   1845                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000066   0x6A61             LDR      R1,[R4, #+36]
   \   00000068   0x....             LDR.N    R0,??DataTable21_1
   \   0000006A   0x6488             STR      R0,[R1, #+72]
   1846                
   1847                /* Enable the DMA Stream */
   1848                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0xF100 0x0138      ADD      R1,R0,#+56
   \   00000072   0x6A60             LDR      R0,[R4, #+36]
   \   00000074   0x.... 0x....      BL       HAL_DMA_Start_IT
   1849                
   1850                /* Enable the TIM Capture/Compare 2  DMA request */
   1851                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x68C1             LDR      R1,[R0, #+12]
   \   0000007C   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000080   0xE022             B.N      ??HAL_TIM_IC_Start_DMA_6
   1852              }
   1853              break;
   1854              
   1855              case TIM_CHANNEL_3:
   1856              {
   1857                /* Set the DMA Period elapsed callback */
   1858                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_8: (+1)
   \   00000082   0x6AA1             LDR      R1,[R4, #+40]
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000088   0x63C8             STR      R0,[R1, #+60]
   1859               
   1860                /* Set the DMA error callback */
   1861                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000008A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000008C   0x....             LDR.N    R0,??DataTable21_1
   \   0000008E   0x6488             STR      R0,[R1, #+72]
   1862                
   1863                /* Enable the DMA Stream */
   1864                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0xF100 0x013C      ADD      R1,R0,#+60
   \   00000096   0x6AA0             LDR      R0,[R4, #+40]
   \   00000098   0x.... 0x....      BL       HAL_DMA_Start_IT
   1865                
   1866                /* Enable the TIM Capture/Compare 3  DMA request */
   1867                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x68C1             LDR      R1,[R0, #+12]
   \   000000A0   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000A4   0xE010             B.N      ??HAL_TIM_IC_Start_DMA_6
   1868              }
   1869              break;
   1870              
   1871              case TIM_CHANNEL_4:
   1872              {
   1873                /* Set the DMA Period elapsed callback */
   1874                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_9: (+1)
   \   000000A6   0x6AE1             LDR      R1,[R4, #+44]
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000000AC   0x63C8             STR      R0,[R1, #+60]
   1875               
   1876                /* Set the DMA error callback */
   1877                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000AE   0x6AE1             LDR      R1,[R4, #+44]
   \   000000B0   0x....             LDR.N    R0,??DataTable21_1
   \   000000B2   0x6488             STR      R0,[R1, #+72]
   1878                
   1879                /* Enable the DMA Stream */
   1880                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   \   000000B4   0x6820             LDR      R0,[R4, #+0]
   \   000000B6   0xF100 0x0140      ADD      R1,R0,#+64
   \   000000BA   0x6AE0             LDR      R0,[R4, #+44]
   \   000000BC   0x.... 0x....      BL       HAL_DMA_Start_IT
   1881                
   1882                /* Enable the TIM Capture/Compare 4  DMA request */
   1883                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x68C1             LDR      R1,[R0, #+12]
   \   000000C4   0xF441 0x5180      ORR      R1,R1,#0x1000
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \   000000C8   0x60C1             STR      R1,[R0, #+12]
   1884              }
   1885              break;
   1886              
   1887              default:
   1888              break;
   1889            }
   1890          
   1891            /* Enable the Input Capture channel */
   1892            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x2101             MOVS     R1,#+1
   \   000000CE   0x40A9             LSLS     R1,R1,R5
   \   000000D0   0x6A02             LDR      R2,[R0, #+32]
   \   000000D2   0x438A             BICS     R2,R2,R1
   \   000000D4   0x6202             STR      R2,[R0, #+32]
   \   000000D6   0x6A02             LDR      R2,[R0, #+32]
   \   000000D8   0x4311             ORRS     R1,R1,R2
   \   000000DA   0x6201             STR      R1,[R0, #+32]
   1893             
   1894            /* Enable the Peripheral */
   1895            __HAL_TIM_ENABLE(htim); 
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6801             LDR      R1,[R0, #+0]
   \   000000E0   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000E4   0x6001             STR      R1,[R0, #+0]
   1896            
   1897            /* Return function status */
   1898            return HAL_OK;
   \   000000E6   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \   000000E8   0xB001             ADD      SP,SP,#+4
   \   000000EA   0xBD30             POP      {R4,R5,PC}       ;; return
   1899          }
   1900          
   1901          /**
   1902            * @brief  Stops the TIM Input Capture measurement on in DMA mode.
   1903            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1904            *                the configuration information for TIM module.
   1905            * @param  Channel: TIM Channels to be disabled.
   1906            *          This parameter can be one of the following values:
   1907            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1908            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1909            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1910            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1911            * @retval HAL status
   1912            */

   \                                 In section .text, align 4, keep-with-next
   1913          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1914          {
   1915            /* Check the parameters */
   1916            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1917            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1918            
   1919            switch (Channel)
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \   00000000   0x290C             CMP      R1,#+12
   \   00000002   0xB410             PUSH     {R4}
   \   00000004   0xD81C             BHI.N    ??HAL_TIM_IC_Stop_DMA_1
   \   00000006   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_IC_Stop_DMA_0:
   \   0000000A   0x07 0x1B          DC8      0x7,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   0000000E   0x0C 0x1B          DC8      0xC,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000012   0x11 0x1B          DC8      0x11,0x1B,0x1B,0x1B
   \              0x1B 0x1B    
   \   00000016   0x16 0x00          DC8      0x16,0x0
   1920            {
   1921              case TIM_CHANNEL_1:
   1922              {       
   1923                /* Disable the TIM Capture/Compare 1 DMA request */
   1924                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x68D3             LDR      R3,[R2, #+12]
   \   0000001C   0xF423 0x7300      BIC      R3,R3,#0x200
   \   00000020   0xE00D             B.N      ??HAL_TIM_IC_Stop_DMA_3
   1925              }
   1926              break;
   1927              
   1928              case TIM_CHANNEL_2:
   1929              {
   1930                /* Disable the TIM Capture/Compare 2 DMA request */
   1931                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \   00000022   0x6802             LDR      R2,[R0, #+0]
   \   00000024   0x68D3             LDR      R3,[R2, #+12]
   \   00000026   0xF423 0x6380      BIC      R3,R3,#0x400
   \   0000002A   0xE008             B.N      ??HAL_TIM_IC_Stop_DMA_3
   1932              }
   1933              break;
   1934              
   1935              case TIM_CHANNEL_3:
   1936              {
   1937                /* Disable the TIM Capture/Compare 3  DMA request */
   1938                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \   0000002C   0x6802             LDR      R2,[R0, #+0]
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0xF423 0x6300      BIC      R3,R3,#0x800
   \   00000034   0xE003             B.N      ??HAL_TIM_IC_Stop_DMA_3
   1939              }
   1940              break;
   1941              
   1942              case TIM_CHANNEL_4:
   1943              {
   1944                /* Disable the TIM Capture/Compare 4  DMA request */
   1945                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_6: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x68D3             LDR      R3,[R2, #+12]
   \   0000003A   0xF423 0x5380      BIC      R3,R3,#0x1000
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \   0000003E   0x60D3             STR      R3,[R2, #+12]
   1946              }
   1947              break;
   1948              
   1949              default:
   1950              break;
   1951            }
   1952          
   1953            /* Disable the Input Capture channel */
   1954            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2401             MOVS     R4,#+1
   \   00000044   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000048   0x6A13             LDR      R3,[R2, #+32]
   \   0000004A   0xEA23 0x0101      BIC      R1,R3,R1
   1955            
   1956            /* Disable the Peripheral */
   1957            __HAL_TIM_DISABLE(htim); 
   \   0000004E   0xF241 0x1311      MOVW     R3,#+4369
   \   00000052   0x6211             STR      R1,[R2, #+32]
   \   00000054   0x6A11             LDR      R1,[R2, #+32]
   \   00000056   0x6211             STR      R1,[R2, #+32]
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000005C   0x421A             TST      R2,R3
   \   0000005E   0xBF02             ITTT     EQ 
   \   00000060   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000062   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   00000066   0x421A             TSTEQ    R2,R3
   \   00000068   0xD103             BNE.N    ??HAL_TIM_IC_Stop_DMA_7
   \   0000006A   0x680A             LDR      R2,[R1, #+0]
   \   0000006C   0x0852             LSRS     R2,R2,#+1
   \   0000006E   0x0052             LSLS     R2,R2,#+1
   \   00000070   0x600A             STR      R2,[R1, #+0]
   1958            
   1959            /* Change the htim state */
   1960            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_7: (+1)
   \   00000072   0xF880 0x4039      STRB     R4,[R0, #+57]
   1961            
   1962            /* Return function status */
   1963            return HAL_OK;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBC10             POP      {R4}
   \   0000007A   0x4770             BX       LR               ;; return
   1964          }  
   1965          /**
   1966            * @}
   1967            */
   1968            
   1969          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1970           *  @brief    Time One Pulse functions 
   1971           *
   1972          @verbatim    
   1973            ==============================================================================
   1974                                  ##### Time One Pulse functions #####
   1975            ==============================================================================
   1976            [..]  
   1977              This section provides functions allowing to:
   1978              (+) Initialize and configure the TIM One Pulse. 
   1979              (+) De-initialize the TIM One Pulse.
   1980              (+) Start the Time One Pulse.
   1981              (+) Stop the Time One Pulse.
   1982              (+) Start the Time One Pulse and enable interrupt.
   1983              (+) Stop the Time One Pulse and disable interrupt.
   1984              (+) Start the Time One Pulse and enable DMA transfer.
   1985              (+) Stop the Time One Pulse and disable DMA transfer.
   1986           
   1987          @endverbatim
   1988            * @{
   1989            */
   1990          /**
   1991            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1992            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1993            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   1994            *                the configuration information for TIM module.
   1995            * @param  OnePulseMode: Select the One pulse mode.
   1996            *         This parameter can be one of the following values:
   1997            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1998            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   1999            * @retval HAL status
   2000            */

   \                                 In section .text, align 2, keep-with-next
   2001          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2002          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2003            /* Check the TIM handle allocation */
   2004            if(htim == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   2005            {
   2006              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   2007            }
   2008          
   2009            /* Check the parameters */
   2010            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2011            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2012            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2013            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2014            
   2015            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \   0000000C   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_OnePulse_Init_1
   2016            { 
   2017              /* Allocate lock resource and initialize it */
   2018              htim->Lock = HAL_UNLOCKED;    
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   2019              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2020              HAL_TIM_OnePulse_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   2021            }
   2022            
   2023            /* Set the TIM state */
   2024            htim->State= HAL_TIM_STATE_BUSY;  
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   2025            
   2026            /* Configure the Time base in the One Pulse Mode */
   2027            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable24  ;; 0x40010000
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0x680B             LDR      R3,[R1, #+0]
   \   0000002E   0xBF18             IT       NE 
   \   00000030   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000034   0xD00F             BEQ.N    ??HAL_TIM_OnePulse_Init_2
   \   00000036   0x.... 0x....      LDR.W    R6,??DataTable24_1  ;; 0x40000400
   \   0000003A   0x42B1             CMP      R1,R6
   \   0000003C   0xBF1C             ITT      NE 
   \   0000003E   0x.... 0x....      LDRNE.W  R6,??DataTable24_2  ;; 0x40000800
   \   00000042   0x42B1             CMPNE    R1,R6
   \   00000044   0xD007             BEQ.N    ??HAL_TIM_OnePulse_Init_2
   \   00000046   0x.... 0x....      LDR.W    R6,??DataTable24_3  ;; 0x40000c00
   \   0000004A   0x42B1             CMP      R1,R6
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x.... 0x....      LDRNE.W  R6,??DataTable27  ;; 0x40010400
   \   00000052   0x42B1             CMPNE    R1,R6
   \   00000054   0xD113             BNE.N    ??HAL_TIM_OnePulse_Init_3
   \                     ??HAL_TIM_OnePulse_Init_2: (+1)
   \   00000056   0x6846             LDR      R6,[R0, #+4]
   \   00000058   0xF023 0x0370      BIC      R3,R3,#0x70
   \   0000005C   0x4333             ORRS     R3,R6,R3
   \   0000005E   0x4291             CMP      R1,R2
   \   00000060   0xBF18             IT       NE 
   \   00000062   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000066   0xD025             BEQ.N    ??HAL_TIM_OnePulse_Init_4
   \   00000068   0x.... 0x....      LDR.W    R6,??DataTable24_1  ;; 0x40000400
   \   0000006C   0x42B1             CMP      R1,R6
   \   0000006E   0xBF1F             ITTTT    NE 
   \   00000070   0x.... 0x....      LDRNE.W  R6,??DataTable24_2  ;; 0x40000800
   \   00000074   0x42B1             CMPNE    R1,R6
   \   00000076   0x.... 0x....      LDRNE.W  R6,??DataTable24_3  ;; 0x40000c00
   \   0000007A   0x42B1             CMPNE    R1,R6
   \   0000007C   0xD01A             BEQ.N    ??HAL_TIM_OnePulse_Init_4
   \                     ??HAL_TIM_OnePulse_Init_3: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R6,??DataTable27  ;; 0x40010400
   \   00000082   0x42B1             CMP      R1,R6
   \   00000084   0xBF1C             ITT      NE 
   \   00000086   0x.... 0x....      LDRNE.W  R6,??DataTable26  ;; 0x40014000
   \   0000008A   0x42B1             CMPNE    R1,R6
   \   0000008C   0xD012             BEQ.N    ??HAL_TIM_OnePulse_Init_4
   \   0000008E   0x.... 0x....      LDR.W    R6,??DataTable26_1  ;; 0x40014400
   \   00000092   0x42B1             CMP      R1,R6
   \   00000094   0xBF1C             ITT      NE 
   \   00000096   0x.... 0x....      LDRNE.W  R6,??DataTable26_2  ;; 0x40014800
   \   0000009A   0x42B1             CMPNE    R1,R6
   \   0000009C   0xD00A             BEQ.N    ??HAL_TIM_OnePulse_Init_4
   \   0000009E   0x.... 0x....      LDR.W    R6,??DataTable26_3  ;; 0x40001800
   \   000000A2   0x42B1             CMP      R1,R6
   \   000000A4   0xBF1F             ITTTT    NE 
   \   000000A6   0x.... 0x....      LDRNE.W  R6,??DataTable26_4  ;; 0x40001c00
   \   000000AA   0x42B1             CMPNE    R1,R6
   \   000000AC   0x.... 0x....      LDRNE.W  R6,??DataTable26_5  ;; 0x40002000
   \   000000B0   0x42B1             CMPNE    R1,R6
   \   000000B2   0xD103             BNE.N    ??HAL_TIM_OnePulse_Init_5
   \                     ??HAL_TIM_OnePulse_Init_4: (+1)
   \   000000B4   0x68C6             LDR      R6,[R0, #+12]
   \   000000B6   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000BA   0x4333             ORRS     R3,R6,R3
   \                     ??HAL_TIM_OnePulse_Init_5: (+1)
   \   000000BC   0x600B             STR      R3,[R1, #+0]
   \   000000BE   0x6883             LDR      R3,[R0, #+8]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0x62CB             STR      R3,[R1, #+44]
   \   000000C4   0x6803             LDR      R3,[R0, #+0]
   \   000000C6   0x628B             STR      R3,[R1, #+40]
   \   000000C8   0xBF19             ITTEE    NE 
   \   000000CA   0x.... 0x....      LDRNE.W  R2,??DataTable27  ;; 0x40010400
   \   000000CE   0x4291             CMPNE    R1,R2
   \   000000D0   0x6900             LDREQ    R0,[R0, #+16]
   \   000000D2   0x6308             STREQ    R0,[R1, #+48]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0x6148             STR      R0,[R1, #+20]
   2028            
   2029            /* Reset the OPM Bit */
   2030            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0xF021 0x0108      BIC      R1,R1,#0x8
   \   000000E0   0x6001             STR      R1,[R0, #+0]
   2031          
   2032            /* Configure the OPM Mode */
   2033            htim->Instance->CR1 |= OnePulseMode;
   \   000000E2   0x6820             LDR      R0,[R4, #+0]
   \   000000E4   0x6801             LDR      R1,[R0, #+0]
   \   000000E6   0x4329             ORRS     R1,R5,R1
   \   000000E8   0x6001             STR      R1,[R0, #+0]
   2034             
   2035            /* Initialize the TIM state*/
   2036            htim->State= HAL_TIM_STATE_READY;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xF884 0x0039      STRB     R0,[R4, #+57]
   2037            
   2038            return HAL_OK;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xBD70             POP      {R4-R6,PC}       ;; return
   2039          }
   2040          
   2041          /**
   2042            * @brief  DeInitializes the TIM One Pulse  
   2043            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2044            *                the configuration information for TIM module.
   2045            * @retval HAL status
   2046            */

   \                                 In section .text, align 2, keep-with-next
   2047          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2048          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2049            /* Check the parameters */
   2050            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2051            
   2052            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2053            
   2054            /* Disable the TIM Peripheral Clock */
   2055            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2056            
   2057            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2058            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   2059              
   2060            /* Change TIM state */  
   2061            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   2062          
   2063            /* Release Lock */
   2064            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   2065          
   2066            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   2067          }
   2068          
   2069          /**
   2070            * @brief  Initializes the TIM One Pulse MSP.
   2071            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2072            *                the configuration information for TIM module.
   2073            * @retval None
   2074            */

   \                                 In section .text, align 2, keep-with-next
   2075          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2076          {
   2077            /* Prevent unused argument(s) compilation warning */
   2078            UNUSED(htim);
   2079           
   2080            /* NOTE : This function Should not be modified, when the callback is needed,
   2081                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2082             */
   2083          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2084          
   2085          /**
   2086            * @brief  DeInitializes TIM One Pulse MSP.
   2087            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2088            *                the configuration information for TIM module.
   2089            * @retval None
   2090            */

   \                                 In section .text, align 2, keep-with-next
   2091          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2092          {
   2093            /* Prevent unused argument(s) compilation warning */
   2094            UNUSED(htim);
   2095           
   2096            /* NOTE : This function Should not be modified, when the callback is needed,
   2097                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2098             */
   2099          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2100          
   2101          /**
   2102            * @brief  Starts the TIM One Pulse signal generation.
   2103            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2104            *                the configuration information for TIM module.
   2105            * @param  OutputChannel : TIM Channels to be enabled.
   2106            *          This parameter can be one of the following values:
   2107            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2108            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2109            * @retval HAL status
   2110            */

   \                                 In section .text, align 2, keep-with-next
   2111          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2112          {
   2113            /* Enable the Capture compare and the Input Capture channels 
   2114              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2115              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2116              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2117              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2118              
   2119              No need to enable the counter, it's enabled automatically by hardware 
   2120              (the counter starts in response to a stimulus and generate a pulse */
   2121            
   2122            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \                     HAL_TIM_OnePulse_Start: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6A01             LDR      R1,[R0, #+32]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6201             STR      R1,[R0, #+32]
   \   0000000A   0x6A01             LDR      R1,[R0, #+32]
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0x6201             STR      R1,[R0, #+32]
   2123            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \   00000012   0x6A01             LDR      R1,[R0, #+32]
   \   00000014   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000018   0x6201             STR      R1,[R0, #+32]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000020   0x6201             STR      R1,[R0, #+32]
   2124            
   2125            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x40010000
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x.... 0x....      LDRNE.W  R1,??DataTable27  ;; 0x40010400
   \   0000002E   0x4288             CMPNE    R0,R1
   \   00000030   0xD103             BNE.N    ??HAL_TIM_OnePulse_Start_0
   2126            {
   2127              /* Enable the main output */
   2128              __HAL_TIM_MOE_ENABLE(htim);
   \   00000032   0x6C41             LDR      R1,[R0, #+68]
   \   00000034   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000038   0x6441             STR      R1,[R0, #+68]
   2129            }
   2130            
   2131            /* Return function status */
   2132            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x4770             BX       LR               ;; return
   2133          }
   2134          
   2135          /**
   2136            * @brief  Stops the TIM One Pulse signal generation.
   2137            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2138            *                the configuration information for TIM module.
   2139            * @param  OutputChannel : TIM Channels to be disable.
   2140            *          This parameter can be one of the following values:
   2141            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2142            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2143            * @retval HAL status
   2144            */

   \                                 In section .text, align 2, keep-with-next
   2145          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2146          {
   2147            /* Disable the Capture compare and the Input Capture channels 
   2148            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2149            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2150            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2151            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2152            
   2153            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6A01             LDR      R1,[R0, #+32]
   \   00000004   0x0849             LSRS     R1,R1,#+1
   \   00000006   0x0049             LSLS     R1,R1,#+1
   \   00000008   0x6201             STR      R1,[R0, #+32]
   \   0000000A   0x6A01             LDR      R1,[R0, #+32]
   \   0000000C   0x6201             STR      R1,[R0, #+32]
   2154            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000000E   0x6A01             LDR      R1,[R0, #+32]
   \   00000010   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000014   0x6201             STR      R1,[R0, #+32]
   \   00000016   0x6A01             LDR      R1,[R0, #+32]
   \   00000018   0x6201             STR      R1,[R0, #+32]
   2155              
   2156            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x40010000
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xBF1C             ITT      NE 
   \   00000022   0x.... 0x....      LDRNE.W  R1,??DataTable27  ;; 0x40010400
   \   00000026   0x4288             CMPNE    R0,R1
   \   00000028   0xD10D             BNE.N    ??HAL_TIM_OnePulse_Stop_0
   2157            {
   2158              /* Disable the Main Output */
   2159              __HAL_TIM_MOE_DISABLE(htim);
   \   0000002A   0x6A01             LDR      R1,[R0, #+32]
   \   0000002C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000030   0x4211             TST      R1,R2
   \   00000032   0xBF02             ITTT     EQ 
   \   00000034   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000036   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000003A   0x4211             TSTEQ    R1,R2
   \   0000003C   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_0
   \   0000003E   0x6C41             LDR      R1,[R0, #+68]
   \   00000040   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000044   0x6441             STR      R1,[R0, #+68]
   2160            }
   2161              
   2162            /* Disable the Peripheral */
   2163            __HAL_TIM_DISABLE(htim); 
   \                     ??HAL_TIM_OnePulse_Stop_0: (+1)
   \   00000046   0x6A01             LDR      R1,[R0, #+32]
   \   00000048   0xF241 0x1211      MOVW     R2,#+4369
   \   0000004C   0x4211             TST      R1,R2
   \   0000004E   0xBF02             ITTT     EQ 
   \   00000050   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000052   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000056   0x4211             TSTEQ    R1,R2
   \   00000058   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_1
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0x0849             LSRS     R1,R1,#+1
   \   0000005E   0x0049             LSLS     R1,R1,#+1
   \   00000060   0x6001             STR      R1,[R0, #+0]
   2164            
   2165            /* Return function status */
   2166            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_1: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x4770             BX       LR               ;; return
   2167          }
   2168          
   2169          /**
   2170            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2171            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2172            *                the configuration information for TIM module.
   2173            * @param  OutputChannel : TIM Channels to be enabled.
   2174            *          This parameter can be one of the following values:
   2175            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2176            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2177            * @retval HAL status
   2178            */

   \                                 In section .text, align 2, keep-with-next
   2179          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2180          {
   2181            /* Enable the Capture compare and the Input Capture channels 
   2182              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2183              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2184              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2185              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2186              
   2187              No need to enable the counter, it's enabled automatically by hardware 
   2188              (the counter starts in response to a stimulus and generate a pulse */
   2189           
   2190            /* Enable the TIM Capture/Compare 1 interrupt */
   2191            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   2192            
   2193            /* Enable the TIM Capture/Compare 2 interrupt */
   2194            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000010   0x60C1             STR      R1,[R0, #+12]
   2195            
   2196            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   \   00000012   0x6A01             LDR      R1,[R0, #+32]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6201             STR      R1,[R0, #+32]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000020   0x6201             STR      R1,[R0, #+32]
   2197            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \   00000022   0x6A01             LDR      R1,[R0, #+32]
   \   00000024   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000028   0x6201             STR      R1,[R0, #+32]
   \   0000002A   0x6A01             LDR      R1,[R0, #+32]
   \   0000002C   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000030   0x6201             STR      R1,[R0, #+32]
   2198            
   2199            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x40010000
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xBF1C             ITT      NE 
   \   0000003A   0x.... 0x....      LDRNE.W  R1,??DataTable28  ;; 0x40010400
   \   0000003E   0x4288             CMPNE    R0,R1
   \   00000040   0xD103             BNE.N    ??HAL_TIM_OnePulse_Start_IT_0
   2200            {
   2201              /* Enable the main output */
   2202              __HAL_TIM_MOE_ENABLE(htim);
   \   00000042   0x6C41             LDR      R1,[R0, #+68]
   \   00000044   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000048   0x6441             STR      R1,[R0, #+68]
   2203            }
   2204            
   2205            /* Return function status */
   2206            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_IT_0: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x4770             BX       LR               ;; return
   2207          }
   2208          
   2209          /**
   2210            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2211            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2212            *                the configuration information for TIM module.
   2213            * @param  OutputChannel : TIM Channels to be enabled.
   2214            *          This parameter can be one of the following values:
   2215            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2216            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2217            * @retval HAL status
   2218            */

   \                                 In section .text, align 2, keep-with-next
   2219          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2220          {
   2221            /* Disable the TIM Capture/Compare 1 interrupt */
   2222            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   2223            
   2224            /* Disable the TIM Capture/Compare 2 interrupt */
   2225            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0xF021 0x0104      BIC      R1,R1,#0x4
   \   00000010   0x60C1             STR      R1,[R0, #+12]
   2226            
   2227            /* Disable the Capture compare and the Input Capture channels 
   2228            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2229            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2230            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2231            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
   2232            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000012   0x6A01             LDR      R1,[R0, #+32]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6201             STR      R1,[R0, #+32]
   \   0000001A   0x6A01             LDR      R1,[R0, #+32]
   \   0000001C   0x6201             STR      R1,[R0, #+32]
   2233            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   0000001E   0x6A01             LDR      R1,[R0, #+32]
   \   00000020   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000024   0x6201             STR      R1,[R0, #+32]
   \   00000026   0x6A01             LDR      R1,[R0, #+32]
   \   00000028   0x6201             STR      R1,[R0, #+32]
   2234              
   2235            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x40010000
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xBF1C             ITT      NE 
   \   00000032   0x.... 0x....      LDRNE.W  R1,??DataTable28  ;; 0x40010400
   \   00000036   0x4288             CMPNE    R0,R1
   \   00000038   0xD10D             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_0
   2236            {
   2237              /* Disable the Main Output */
   2238              __HAL_TIM_MOE_DISABLE(htim);
   \   0000003A   0x6A01             LDR      R1,[R0, #+32]
   \   0000003C   0xF241 0x1211      MOVW     R2,#+4369
   \   00000040   0x4211             TST      R1,R2
   \   00000042   0xBF02             ITTT     EQ 
   \   00000044   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000046   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000004A   0x4211             TSTEQ    R1,R2
   \   0000004C   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_0
   \   0000004E   0x6C41             LDR      R1,[R0, #+68]
   \   00000050   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000054   0x6441             STR      R1,[R0, #+68]
   2239            }
   2240              
   2241            /* Disable the Peripheral */
   2242             __HAL_TIM_DISABLE(htim);  
   \                     ??HAL_TIM_OnePulse_Stop_IT_0: (+1)
   \   00000056   0x6A01             LDR      R1,[R0, #+32]
   \   00000058   0xF241 0x1211      MOVW     R2,#+4369
   \   0000005C   0x4211             TST      R1,R2
   \   0000005E   0xBF02             ITTT     EQ 
   \   00000060   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000062   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000066   0x4211             TSTEQ    R1,R2
   \   00000068   0xD103             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_1
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x0849             LSRS     R1,R1,#+1
   \   0000006E   0x0049             LSLS     R1,R1,#+1
   \   00000070   0x6001             STR      R1,[R0, #+0]
   2243            
   2244            /* Return function status */
   2245            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_1: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4770             BX       LR               ;; return
   2246          }
   2247          
   2248          /**
   2249            * @}
   2250            */
   2251          
   2252          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2253           *  @brief    Time Encoder functions 
   2254           *
   2255          @verbatim    
   2256            ==============================================================================
   2257                                    ##### Time Encoder functions #####
   2258            ==============================================================================
   2259            [..]
   2260              This section provides functions allowing to:
   2261              (+) Initialize and configure the TIM Encoder. 
   2262              (+) De-initialize the TIM Encoder.
   2263              (+) Start the Time Encoder.
   2264              (+) Stop the Time Encoder.
   2265              (+) Start the Time Encoder and enable interrupt.
   2266              (+) Stop the Time Encoder and disable interrupt.
   2267              (+) Start the Time Encoder and enable DMA transfer.
   2268              (+) Stop the Time Encoder and disable DMA transfer.
   2269           
   2270          @endverbatim
   2271            * @{
   2272            */
   2273          /**
   2274            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2275            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2276            *                the configuration information for TIM module.
   2277            * @param  sConfig: TIM Encoder Interface configuration structure
   2278            * @retval HAL status
   2279            */

   \                                 In section .text, align 2, keep-with-next
   2280          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2281          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2282            uint32_t tmpsmcr = 0;
   2283            uint32_t tmpccmr1 = 0;
   2284            uint32_t tmpccer = 0;
   2285            
   2286            /* Check the TIM handle allocation */
   2287            if(htim == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2288            {
   2289              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   2290            }
   2291             
   2292            /* Check the parameters */
   2293            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2294            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2295            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2296            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2297            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2298            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2299            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2300            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2301            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2302            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2303          
   2304            if(htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \   0000000C   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_TIM_Encoder_Init_1
   2305            { 
   2306              /* Allocate lock resource and initialize it */
   2307              htim->Lock = HAL_UNLOCKED;  
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   2308              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2309              HAL_TIM_Encoder_MspInit(htim);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2310            }
   2311            
   2312            /* Set the TIM state */
   2313            htim->State= HAL_TIM_STATE_BUSY;   
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   2314              
   2315            /* Reset the SMS bits */
   2316            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable28_1  ;; 0xfffefff8
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6881             LDR      R1,[R0, #+8]
   \   0000002A   0x4011             ANDS     R1,R2,R1
   2317            
   2318            /* Configure the Time base in the Encoder Mode */
   2319            TIM_Base_SetConfig(htim->Instance, &htim->Init);  
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable24  ;; 0x40010000
   \   00000030   0x6081             STR      R1,[R0, #+8]
   \   00000032   0x1D20             ADDS     R0,R4,#+4
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x4291             CMP      R1,R2
   \   00000038   0x680B             LDR      R3,[R1, #+0]
   \   0000003A   0xBF18             IT       NE 
   \   0000003C   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000040   0xD00F             BEQ.N    ??HAL_TIM_Encoder_Init_2
   \   00000042   0x.... 0x....      LDR.W    R6,??DataTable24_1  ;; 0x40000400
   \   00000046   0x42B1             CMP      R1,R6
   \   00000048   0xBF1C             ITT      NE 
   \   0000004A   0x.... 0x....      LDRNE.W  R6,??DataTable24_2  ;; 0x40000800
   \   0000004E   0x42B1             CMPNE    R1,R6
   \   00000050   0xD007             BEQ.N    ??HAL_TIM_Encoder_Init_2
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable24_3  ;; 0x40000c00
   \   00000056   0x42B1             CMP      R1,R6
   \   00000058   0xBF1C             ITT      NE 
   \   0000005A   0x.... 0x....      LDRNE.W  R6,??DataTable27  ;; 0x40010400
   \   0000005E   0x42B1             CMPNE    R1,R6
   \   00000060   0xD113             BNE.N    ??HAL_TIM_Encoder_Init_3
   \                     ??HAL_TIM_Encoder_Init_2: (+1)
   \   00000062   0x6846             LDR      R6,[R0, #+4]
   \   00000064   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000068   0x4333             ORRS     R3,R6,R3
   \   0000006A   0x4291             CMP      R1,R2
   \   0000006C   0xBF18             IT       NE 
   \   0000006E   0xF1B1 0x4F80      CMPNE    R1,#+1073741824
   \   00000072   0xD025             BEQ.N    ??HAL_TIM_Encoder_Init_4
   \   00000074   0x.... 0x....      LDR.W    R6,??DataTable24_1  ;; 0x40000400
   \   00000078   0x42B1             CMP      R1,R6
   \   0000007A   0xBF1F             ITTTT    NE 
   \   0000007C   0x.... 0x....      LDRNE.W  R6,??DataTable24_2  ;; 0x40000800
   \   00000080   0x42B1             CMPNE    R1,R6
   \   00000082   0x.... 0x....      LDRNE.W  R6,??DataTable24_3  ;; 0x40000c00
   \   00000086   0x42B1             CMPNE    R1,R6
   \   00000088   0xD01A             BEQ.N    ??HAL_TIM_Encoder_Init_4
   \                     ??HAL_TIM_Encoder_Init_3: (+1)
   \   0000008A   0x.... 0x....      LDR.W    R6,??DataTable27  ;; 0x40010400
   \   0000008E   0x42B1             CMP      R1,R6
   \   00000090   0xBF1C             ITT      NE 
   \   00000092   0x.... 0x....      LDRNE.W  R6,??DataTable26  ;; 0x40014000
   \   00000096   0x42B1             CMPNE    R1,R6
   \   00000098   0xD012             BEQ.N    ??HAL_TIM_Encoder_Init_4
   \   0000009A   0x.... 0x....      LDR.W    R6,??DataTable26_1  ;; 0x40014400
   \   0000009E   0x42B1             CMP      R1,R6
   \   000000A0   0xBF1C             ITT      NE 
   \   000000A2   0x.... 0x....      LDRNE.W  R6,??DataTable26_2  ;; 0x40014800
   \   000000A6   0x42B1             CMPNE    R1,R6
   \   000000A8   0xD00A             BEQ.N    ??HAL_TIM_Encoder_Init_4
   \   000000AA   0x.... 0x....      LDR.W    R6,??DataTable26_3  ;; 0x40001800
   \   000000AE   0x42B1             CMP      R1,R6
   \   000000B0   0xBF1F             ITTTT    NE 
   \   000000B2   0x.... 0x....      LDRNE.W  R6,??DataTable26_4  ;; 0x40001c00
   \   000000B6   0x42B1             CMPNE    R1,R6
   \   000000B8   0x.... 0x....      LDRNE.W  R6,??DataTable26_5  ;; 0x40002000
   \   000000BC   0x42B1             CMPNE    R1,R6
   \   000000BE   0xD103             BNE.N    ??HAL_TIM_Encoder_Init_5
   \                     ??HAL_TIM_Encoder_Init_4: (+1)
   \   000000C0   0x68C6             LDR      R6,[R0, #+12]
   \   000000C2   0xF423 0x7340      BIC      R3,R3,#0x300
   \   000000C6   0x4333             ORRS     R3,R6,R3
   \                     ??HAL_TIM_Encoder_Init_5: (+1)
   \   000000C8   0x600B             STR      R3,[R1, #+0]
   \   000000CA   0x6883             LDR      R3,[R0, #+8]
   \   000000CC   0x4291             CMP      R1,R2
   2320            
   2321            /* Get the TIMx SMCR register value */
   2322            tmpsmcr = htim->Instance->SMCR;
   2323          
   2324            /* Get the TIMx CCMR1 register value */
   2325            tmpccmr1 = htim->Instance->CCMR1;
   2326          
   2327            /* Get the TIMx CCER register value */
   2328            tmpccer = htim->Instance->CCER;
   2329          
   2330            /* Set the encoder Mode */
   2331            tmpsmcr |= sConfig->EncoderMode;
   2332          
   2333            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2334            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2335            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
   2336            
   2337            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2338            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2339            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2340            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
   2341            tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
   \   000000CE   0x.... 0x....      LDR.W    R6,??DataTable28_2  ;; 0xfffffcfc
   \   000000D2   0x62CB             STR      R3,[R1, #+44]
   \   000000D4   0x6803             LDR      R3,[R0, #+0]
   \   000000D6   0x628B             STR      R3,[R1, #+40]
   \   000000D8   0xBF19             ITTEE    NE 
   \   000000DA   0x.... 0x....      LDRNE.W  R2,??DataTable27  ;; 0x40010400
   \   000000DE   0x4291             CMPNE    R1,R2
   \   000000E0   0x6900             LDREQ    R0,[R0, #+16]
   \   000000E2   0x6308             STREQ    R0,[R1, #+48]
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x6148             STR      R0,[R1, #+20]
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6881             LDR      R1,[R0, #+8]
   \   000000EC   0x6983             LDR      R3,[R0, #+24]
   \   000000EE   0x6A02             LDR      R2,[R0, #+32]
   \   000000F0   0x4033             ANDS     R3,R6,R3
   \   000000F2   0x68AE             LDR      R6,[R5, #+8]
   2342          
   2343            /* Set the TI1 and the TI2 Polarities */
   2344            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2345            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2346            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
   \   000000F4   0xF022 0x02AA      BIC      R2,R2,#0xAA
   \   000000F8   0x4333             ORRS     R3,R6,R3
   \   000000FA   0x69AE             LDR      R6,[R5, #+24]
   \   000000FC   0xEA43 0x2306      ORR      R3,R3,R6, LSL #+8
   \   00000100   0x.... 0x....      LDR.W    R6,??DataTable28_3  ;; 0xffff0303
   \   00000104   0x4033             ANDS     R3,R6,R3
   \   00000106   0x68EE             LDR      R6,[R5, #+12]
   \   00000108   0x4333             ORRS     R3,R6,R3
   \   0000010A   0x69EE             LDR      R6,[R5, #+28]
   \   0000010C   0xEA43 0x2306      ORR      R3,R3,R6, LSL #+8
   \   00000110   0x692E             LDR      R6,[R5, #+16]
   \   00000112   0xEA43 0x1306      ORR      R3,R3,R6, LSL #+4
   \   00000116   0x6A2E             LDR      R6,[R5, #+32]
   \   00000118   0xEA43 0x3306      ORR      R3,R3,R6, LSL #+12
   \   0000011C   0x686E             LDR      R6,[R5, #+4]
   \   0000011E   0x4332             ORRS     R2,R6,R2
   \   00000120   0x696E             LDR      R6,[R5, #+20]
   2347            
   2348            /* Write to TIMx SMCR */
   2349            htim->Instance->SMCR = tmpsmcr;
   \   00000122   0x682D             LDR      R5,[R5, #+0]
   \   00000124   0xEA42 0x1206      ORR      R2,R2,R6, LSL #+4
   \   00000128   0x4329             ORRS     R1,R5,R1
   \   0000012A   0x6081             STR      R1,[R0, #+8]
   2350          
   2351            /* Write to TIMx CCMR1 */
   2352            htim->Instance->CCMR1 = tmpccmr1;
   \   0000012C   0x6820             LDR      R0,[R4, #+0]
   \   0000012E   0x6183             STR      R3,[R0, #+24]
   2353          
   2354            /* Write to TIMx CCER */
   2355            htim->Instance->CCER = tmpccer;
   \   00000130   0x6820             LDR      R0,[R4, #+0]
   \   00000132   0x6202             STR      R2,[R0, #+32]
   2356            
   2357            /* Initialize the TIM state*/
   2358            htim->State= HAL_TIM_STATE_READY;
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0xF884 0x0039      STRB     R0,[R4, #+57]
   2359            
   2360            return HAL_OK;
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xBD70             POP      {R4-R6,PC}       ;; return
   2361          }
   2362          
   2363          /**
   2364            * @brief  DeInitializes the TIM Encoder interface  
   2365            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2366            *                the configuration information for TIM module.
   2367            * @retval HAL status
   2368            */

   \                                 In section .text, align 2, keep-with-next
   2369          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2370          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2371            /* Check the parameters */
   2372            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2373            
   2374            htim->State = HAL_TIM_STATE_BUSY;
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0xF884 0x0039      STRB     R0,[R4, #+57]
   2375            
   2376            /* Disable the TIM Peripheral Clock */
   2377            __HAL_TIM_DISABLE(htim);
   \   0000000A   0xF241 0x1211      MOVW     R2,#+4369
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6A01             LDR      R1,[R0, #+32]
   \   00000012   0x4211             TST      R1,R2
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x6A01             LDREQ    R1,[R0, #+32]
   \   00000018   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   0000001C   0x4211             TSTEQ    R1,R2
   \   0000001E   0xD103             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x0849             LSRS     R1,R1,#+1
   \   00000024   0x0049             LSLS     R1,R1,#+1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2378            
   2379            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2380            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2381              
   2382            /* Change TIM state */  
   2383            htim->State = HAL_TIM_STATE_RESET;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xF884 0x0039      STRB     R0,[R4, #+57]
   2384           
   2385            /* Release Lock */
   2386            __HAL_UNLOCK(htim);
   \   00000034   0xF884 0x0038      STRB     R0,[R4, #+56]
   2387          
   2388            return HAL_OK;
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   2389          }
   2390          
   2391          /**
   2392            * @brief  Initializes the TIM Encoder Interface MSP.
   2393            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2394            *                the configuration information for TIM module.
   2395            * @retval None
   2396            */

   \                                 In section .text, align 2, keep-with-next
   2397          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2398          {
   2399            /* Prevent unused argument(s) compilation warning */
   2400            UNUSED(htim);
   2401           
   2402            /* NOTE : This function Should not be modified, when the callback is needed,
   2403                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2404             */
   2405          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2406          
   2407          /**
   2408            * @brief  DeInitializes TIM Encoder Interface MSP.
   2409            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2410            *                the configuration information for TIM module.
   2411            * @retval None
   2412            */

   \                                 In section .text, align 2, keep-with-next
   2413          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2414          {
   2415            /* Prevent unused argument(s) compilation warning */
   2416            UNUSED(htim);
   2417           
   2418            /* NOTE : This function Should not be modified, when the callback is needed,
   2419                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2420             */
   2421          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2422          
   2423          /**
   2424            * @brief  Starts the TIM Encoder Interface.
   2425            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2426            *                the configuration information for TIM module.
   2427            * @param  Channel: TIM Channels to be enabled.
   2428            *          This parameter can be one of the following values:
   2429            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2430            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2431            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2432            * @retval HAL status
   2433            */

   \                                 In section .text, align 2, keep-with-next
   2434          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2435          {
   2436            /* Check the parameters */
   2437            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2438            
   2439            /* Enable the encoder interface channels */
   2440            switch (Channel)
   \                     HAL_TIM_Encoder_Start: (+1)
   \   00000000   0xB111             CBZ.N    R1,??HAL_TIM_Encoder_Start_0
   \   00000002   0x2904             CMP      R1,#+4
   \   00000004   0xD009             BEQ.N    ??HAL_TIM_Encoder_Start_1
   \   00000006   0xE00A             B.N      ??HAL_TIM_Encoder_Start_2
   2441            {
   2442              case TIM_CHANNEL_1:
   2443              {
   2444                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000C   0x0852             LSRS     R2,R2,#+1
   \   0000000E   0x0052             LSLS     R2,R2,#+1
   \   00000010   0x620A             STR      R2,[R1, #+32]
   \   00000012   0x6A0A             LDR      R2,[R1, #+32]
   \   00000014   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000018   0xE011             B.N      ??HAL_TIM_Encoder_Start_3
   2445                break; 
   2446              }
   2447              case TIM_CHANNEL_2:
   2448              { 
   2449                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xE008             B.N      ??HAL_TIM_Encoder_Start_4
   2450                break;
   2451              }  
   2452              default :
   2453              {
   2454               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x6A0A             LDR      R2,[R1, #+32]
   \   00000022   0x0852             LSRS     R2,R2,#+1
   \   00000024   0x0052             LSLS     R2,R2,#+1
   \   00000026   0x620A             STR      R2,[R1, #+32]
   \   00000028   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000002E   0x620A             STR      R2,[R1, #+32]
   2455               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_4: (+1)
   \   00000030   0x6A0A             LDR      R2,[R1, #+32]
   \   00000032   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000036   0x620A             STR      R2,[R1, #+32]
   \   00000038   0x6A0A             LDR      R2,[R1, #+32]
   \   0000003A   0xF042 0x0210      ORR      R2,R2,#0x10
   \                     ??HAL_TIM_Encoder_Start_3: (+1)
   \   0000003E   0x620A             STR      R2,[R1, #+32]
   2456               break; 
   2457              }
   2458            }  
   2459            /* Enable the Peripheral */
   2460            __HAL_TIM_ENABLE(htim);
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x6808             LDR      R0,[R1, #+0]
   \   00000044   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000048   0x6008             STR      R0,[R1, #+0]
   2461            
   2462            /* Return function status */
   2463            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x4770             BX       LR               ;; return
   2464          }
   2465          
   2466          /**
   2467            * @brief  Stops the TIM Encoder Interface.
   2468            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2469            *                the configuration information for TIM module.
   2470            * @param  Channel: TIM Channels to be disabled.
   2471            *          This parameter can be one of the following values:
   2472            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2473            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2474            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2475            * @retval HAL status
   2476            */

   \                                 In section .text, align 2, keep-with-next
   2477          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2478          {
   2479            /* Check the parameters */
   2480              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2481              
   2482             /* Disable the Input Capture channels 1 and 2
   2483              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2484            switch (Channel)
   \                     HAL_TIM_Encoder_Stop: (+1)
   \   00000000   0xB111             CBZ.N    R1,??HAL_TIM_Encoder_Stop_0
   \   00000002   0x2904             CMP      R1,#+4
   \   00000004   0xD005             BEQ.N    ??HAL_TIM_Encoder_Stop_1
   \   00000006   0xE006             B.N      ??HAL_TIM_Encoder_Stop_2
   2485            {
   2486              case TIM_CHANNEL_1:
   2487              {
   2488                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000C   0x0852             LSRS     R2,R2,#+1
   \   0000000E   0x0052             LSLS     R2,R2,#+1
   \   00000010   0xE00B             B.N      ??HAL_TIM_Encoder_Stop_3
   2489                break; 
   2490              }
   2491              case TIM_CHANNEL_2:
   2492              { 
   2493                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xE006             B.N      ??HAL_TIM_Encoder_Stop_4
   2494                break;
   2495              }  
   2496              default :
   2497              {
   2498               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x6A0A             LDR      R2,[R1, #+32]
   \   0000001A   0x0852             LSRS     R2,R2,#+1
   \   0000001C   0x0052             LSLS     R2,R2,#+1
   \   0000001E   0x620A             STR      R2,[R1, #+32]
   \   00000020   0x6A0A             LDR      R2,[R1, #+32]
   \   00000022   0x620A             STR      R2,[R1, #+32]
   2499               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_4: (+1)
   \   00000024   0x6A0A             LDR      R2,[R1, #+32]
   \   00000026   0xF022 0x0210      BIC      R2,R2,#0x10
   \                     ??HAL_TIM_Encoder_Stop_3: (+1)
   \   0000002A   0x620A             STR      R2,[R1, #+32]
   \   0000002C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002E   0x620A             STR      R2,[R1, #+32]
   2500               break; 
   2501              }
   2502            }  
   2503            /* Disable the Peripheral */
   2504            __HAL_TIM_DISABLE(htim);
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0xF241 0x1211      MOVW     R2,#+4369
   \   00000036   0x6A08             LDR      R0,[R1, #+32]
   \   00000038   0x4210             TST      R0,R2
   \   0000003A   0xBF02             ITTT     EQ 
   \   0000003C   0x6A08             LDREQ    R0,[R1, #+32]
   \   0000003E   0xF240 0x4244      MOVWEQ   R2,#+1092
   \   00000042   0x4210             TSTEQ    R0,R2
   \   00000044   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_5
   \   00000046   0x6808             LDR      R0,[R1, #+0]
   \   00000048   0x0840             LSRS     R0,R0,#+1
   \   0000004A   0x0040             LSLS     R0,R0,#+1
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   2505            
   2506            /* Return function status */
   2507            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_5: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x4770             BX       LR               ;; return
   2508          }
   2509          
   2510          /**
   2511            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2512            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2513            *                the configuration information for TIM module.
   2514            * @param  Channel: TIM Channels to be enabled.
   2515            *          This parameter can be one of the following values:
   2516            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2517            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2518            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2519            * @retval HAL status
   2520            */

   \                                 In section .text, align 2, keep-with-next
   2521          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2522          {
   2523            /* Check the parameters */
   2524            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2525            
   2526            /* Enable the encoder interface channels */
   2527            /* Enable the capture compare Interrupts 1 and/or 2 */
   2528            switch (Channel)
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \   00000000   0xB111             CBZ.N    R1,??HAL_TIM_Encoder_Start_IT_0
   \   00000002   0x2904             CMP      R1,#+4
   \   00000004   0xD00D             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \   00000006   0xE016             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2529            {
   2530              case TIM_CHANNEL_1:
   2531              {
   2532                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000C   0x0852             LSRS     R2,R2,#+1
   \   0000000E   0x0052             LSLS     R2,R2,#+1
   \   00000010   0x620A             STR      R2,[R1, #+32]
   \   00000012   0x6A0A             LDR      R2,[R1, #+32]
   \   00000014   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000018   0x620A             STR      R2,[R1, #+32]
   2533                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000020   0xE021             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2534                break; 
   2535              }
   2536              case TIM_CHANNEL_2:
   2537              { 
   2538                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x6A0A             LDR      R2,[R1, #+32]
   \   00000026   0xF022 0x0210      BIC      R2,R2,#0x10
   \   0000002A   0x620A             STR      R2,[R1, #+32]
   \   0000002C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002E   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000032   0x620A             STR      R2,[R1, #+32]
   2539                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
   \   00000034   0xE014             B.N      ??HAL_TIM_Encoder_Start_IT_4
   2540                break;
   2541              }  
   2542              default :
   2543              {
   2544               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x6A0A             LDR      R2,[R1, #+32]
   \   0000003A   0x0852             LSRS     R2,R2,#+1
   \   0000003C   0x0052             LSLS     R2,R2,#+1
   \   0000003E   0x620A             STR      R2,[R1, #+32]
   \   00000040   0x6A0A             LDR      R2,[R1, #+32]
   \   00000042   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000046   0x620A             STR      R2,[R1, #+32]
   2545               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   00000048   0x6A0A             LDR      R2,[R1, #+32]
   \   0000004A   0xF022 0x0210      BIC      R2,R2,#0x10
   \   0000004E   0x620A             STR      R2,[R1, #+32]
   \   00000050   0x6A0A             LDR      R2,[R1, #+32]
   \   00000052   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000056   0x620A             STR      R2,[R1, #+32]
   2546               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \   00000058   0x68CA             LDR      R2,[R1, #+12]
   \   0000005A   0xF042 0x0202      ORR      R2,R2,#0x2
   \   0000005E   0x60CA             STR      R2,[R1, #+12]
   2547               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_Encoder_Start_IT_4: (+1)
   \   00000060   0x68CA             LDR      R2,[R1, #+12]
   \   00000062   0xF042 0x0204      ORR      R2,R2,#0x4
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \   00000066   0x60CA             STR      R2,[R1, #+12]
   2548               break; 
   2549              }
   2550            }
   2551            
   2552            /* Enable the Peripheral */
   2553            __HAL_TIM_ENABLE(htim);
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x6808             LDR      R0,[R1, #+0]
   \   0000006C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000070   0x6008             STR      R0,[R1, #+0]
   2554            
   2555            /* Return function status */
   2556            return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4770             BX       LR               ;; return
   2557          }
   2558          
   2559          /**
   2560            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2561            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2562            *                the configuration information for TIM module.
   2563            * @param  Channel: TIM Channels to be disabled.
   2564            *          This parameter can be one of the following values:
   2565            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2566            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2567            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2568            * @retval HAL status
   2569            */

   \                                 In section .text, align 2, keep-with-next
   2570          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2571          {
   2572            /* Check the parameters */
   2573            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2574              
   2575            /* Disable the Input Capture channels 1 and 2
   2576              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2577            if(Channel == TIM_CHANNEL_1)
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \   00000000   0xB959             CBNZ.N   R1,??HAL_TIM_Encoder_Stop_IT_0
   2578            {
   2579              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x6A0A             LDR      R2,[R1, #+32]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x620A             STR      R2,[R1, #+32]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0x620A             STR      R2,[R1, #+32]
   2580              
   2581              /* Disable the capture compare Interrupts 1 */
   2582            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x68CA             LDR      R2,[R1, #+12]
   \   00000014   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000018   0xE01E             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2583            }  
   2584            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \   0000001A   0x2904             CMP      R1,#+4
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x6A0A             LDR      R2,[R1, #+32]
   \   00000020   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2585            {  
   2586              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000022   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000026   0x620A             STR      R2,[R1, #+32]
   \   00000028   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002A   0x620A             STR      R2,[R1, #+32]
   2587              
   2588              /* Disable the capture compare Interrupts 2 */
   2589            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \   0000002C   0xE010             B.N      ??HAL_TIM_Encoder_Stop_IT_3
   2590            }  
   2591            else
   2592            {
   2593              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \   0000002E   0x0852             LSRS     R2,R2,#+1
   \   00000030   0x0052             LSLS     R2,R2,#+1
   \   00000032   0x620A             STR      R2,[R1, #+32]
   \   00000034   0x6A0A             LDR      R2,[R1, #+32]
   \   00000036   0x620A             STR      R2,[R1, #+32]
   2594              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000003C   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000040   0x620A             STR      R2,[R1, #+32]
   \   00000042   0x6A0A             LDR      R2,[R1, #+32]
   \   00000044   0x620A             STR      R2,[R1, #+32]
   2595              
   2596              /* Disable the capture compare Interrupts 1 and 2 */
   2597              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x68CA             LDR      R2,[R1, #+12]
   \   0000004A   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000004E   0x60CA             STR      R2,[R1, #+12]
   2598              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x68CA             LDR      R2,[R1, #+12]
   \   00000054   0xF022 0x0204      BIC      R2,R2,#0x4
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \   00000058   0x60CA             STR      R2,[R1, #+12]
   2599            }
   2600              
   2601            /* Disable the Peripheral */
   2602            __HAL_TIM_DISABLE(htim);
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF241 0x1311      MOVW     R3,#+4369
   \   00000060   0x6A0A             LDR      R2,[R1, #+32]
   \   00000062   0x421A             TST      R2,R3
   \   00000064   0xBF02             ITTT     EQ 
   \   00000066   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000068   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000006C   0x421A             TSTEQ    R2,R3
   \   0000006E   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_IT_4
   \   00000070   0x680A             LDR      R2,[R1, #+0]
   \   00000072   0x0852             LSRS     R2,R2,#+1
   \   00000074   0x0052             LSLS     R2,R2,#+1
   \   00000076   0x600A             STR      R2,[R1, #+0]
   2603            
   2604            /* Change the htim state */
   2605            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_4: (+1)
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0xF880 0x1039      STRB     R1,[R0, #+57]
   2606            
   2607            /* Return function status */
   2608            return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x4770             BX       LR               ;; return
   2609          }
   2610          
   2611          /**
   2612            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2613            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2614            *                the configuration information for TIM module.
   2615            * @param  Channel: TIM Channels to be enabled.
   2616            *          This parameter can be one of the following values:
   2617            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2618            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2619            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2620            * @param  pData1: The destination Buffer address for IC1.
   2621            * @param  pData2: The destination Buffer address for IC2.
   2622            * @param  Length: The length of data to be transferred from TIM peripheral to memory.
   2623            * @retval HAL status
   2624            */

   \                                 In section .text, align 2, keep-with-next
   2625          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2626          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4698             MOV      R8,R3
   2627            /* Check the parameters */
   2628            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2629            
   2630            if((htim->State == HAL_TIM_STATE_BUSY))
   \   00000008   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xF000 0x809A      BEQ.W    ??HAL_TIM_Encoder_Start_DMA_0
   \   00000012   0x9C06             LDR      R4,[SP, #+24]
   2631            {
   2632               return HAL_BUSY;
   2633            }
   2634            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000014   0xF995 0x0039      LDRSB    R0,[R5, #+57]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD10A             BNE.N    ??HAL_TIM_Encoder_Start_DMA_1
   2635            {
   2636              if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xBF18             IT       NE 
   \   00000020   0xF1B8 0x0F00      CMPNE    R8,#+0
   \   00000024   0xD102             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xF040 0x808D      BNE.W    ??HAL_TIM_Encoder_Start_DMA_0
   2637              {
   2638                return HAL_ERROR;                                    
   2639              }
   2640              else
   2641              {
   2642                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xF885 0x0039      STRB     R0,[R5, #+57]
   2643              }
   2644            }  
   2645             
   2646            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \   00000032   0xB121             CBZ.N    R1,??HAL_TIM_Encoder_Start_DMA_3
   \   00000034   0x2904             CMP      R1,#+4
   \   00000036   0xD025             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   \   00000038   0x293C             CMP      R1,#+60
   \   0000003A   0xD047             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \   0000003C   0xE082             B.N      ??HAL_TIM_Encoder_Start_DMA_6
   2647            {
   2648              case TIM_CHANNEL_1:
   2649              {
   2650                /* Set the DMA Period elapsed callback */
   2651                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \   0000003E   0x6A29             LDR      R1,[R5, #+32]
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable25
   2652               
   2653                /* Set the DMA error callback */
   2654                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   2655                
   2656                /* Enable the DMA Stream */
   2657                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
   \   00000044   0x4623             MOV      R3,R4
   \   00000046   0x63C8             STR      R0,[R1, #+60]
   \   00000048   0x6A29             LDR      R1,[R5, #+32]
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable30
   \   0000004E   0x6488             STR      R0,[R1, #+72]
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000056   0x6A28             LDR      R0,[R5, #+32]
   \   00000058   0x.... 0x....      BL       HAL_DMA_Start_IT
   2658                
   2659                /* Enable the TIM Input Capture DMA request */      
   2660                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000064   0x60C1             STR      R1,[R0, #+12]
   2661                      
   2662                /* Enable the Peripheral */
   2663                __HAL_TIM_ENABLE(htim);
   \   00000066   0x6828             LDR      R0,[R5, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   2664                
   2665                /* Enable the Capture compare channel */
   2666                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   00000070   0x6828             LDR      R0,[R5, #+0]
   \   00000072   0x6A01             LDR      R1,[R0, #+32]
   \   00000074   0x0849             LSRS     R1,R1,#+1
   \   00000076   0x0049             LSLS     R1,R1,#+1
   \   00000078   0x6201             STR      R1,[R0, #+32]
   \   0000007A   0x6A01             LDR      R1,[R0, #+32]
   \   0000007C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000080   0x6201             STR      R1,[R0, #+32]
   2667              }
   2668              break;
   2669              
   2670              case TIM_CHANNEL_2:
   2671              {
   2672                /* Set the DMA Period elapsed callback */
   2673                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   2674               
   2675                /* Set the DMA error callback */
   2676                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
   2677                /* Enable the DMA Stream */
   2678                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2679                
   2680                /* Enable the TIM Input Capture  DMA request */
   2681                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2682               
   2683                /* Enable the Peripheral */
   2684                __HAL_TIM_ENABLE(htim);
   2685                
   2686                /* Enable the Capture compare channel */
   2687                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2688              }
   2689              break;
   \   00000082   0xE05F             B.N      ??HAL_TIM_Encoder_Start_DMA_6
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \   00000084   0x6A69             LDR      R1,[R5, #+36]
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000008A   0x4623             MOV      R3,R4
   \   0000008C   0x4642             MOV      R2,R8
   \   0000008E   0x63C8             STR      R0,[R1, #+60]
   \   00000090   0x6A69             LDR      R1,[R5, #+36]
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable30
   \   00000096   0x6488             STR      R0,[R1, #+72]
   \   00000098   0x6828             LDR      R0,[R5, #+0]
   \   0000009A   0xF100 0x0138      ADD      R1,R0,#+56
   \   0000009E   0x6A68             LDR      R0,[R5, #+36]
   \   000000A0   0x.... 0x....      BL       HAL_DMA_Start_IT
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0x68C1             LDR      R1,[R0, #+12]
   \   000000A8   0xF441 0x6180      ORR      R1,R1,#0x400
   \   000000AC   0x60C1             STR      R1,[R0, #+12]
   \   000000AE   0x6828             LDR      R0,[R5, #+0]
   \   000000B0   0x6801             LDR      R1,[R0, #+0]
   \   000000B2   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000B6   0x6001             STR      R1,[R0, #+0]
   \   000000B8   0x6828             LDR      R0,[R5, #+0]
   \   000000BA   0x6A01             LDR      R1,[R0, #+32]
   \   000000BC   0xF021 0x0110      BIC      R1,R1,#0x10
   \   000000C0   0x6201             STR      R1,[R0, #+32]
   \   000000C2   0x6A01             LDR      R1,[R0, #+32]
   \   000000C4   0xF041 0x0110      ORR      R1,R1,#0x10
   \   000000C8   0x6201             STR      R1,[R0, #+32]
   \   000000CA   0xE03B             B.N      ??HAL_TIM_Encoder_Start_DMA_6
   2690              
   2691              case TIM_CHANNEL_ALL:
   2692              {
   2693                /* Set the DMA Period elapsed callback */
   2694                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \   000000CC   0x6A28             LDR      R0,[R5, #+32]
   \   000000CE   0x.... 0x....      LDR.W    R7,??DataTable25
   2695               
   2696                /* Set the DMA error callback */
   2697                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000D2   0x.... 0x....      LDR.W    R6,??DataTable30
   2698                
   2699                /* Enable the DMA Stream */
   2700                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   \   000000D6   0x4623             MOV      R3,R4
   \   000000D8   0x63C7             STR      R7,[R0, #+60]
   \   000000DA   0x6A28             LDR      R0,[R5, #+32]
   \   000000DC   0x6486             STR      R6,[R0, #+72]
   \   000000DE   0x6828             LDR      R0,[R5, #+0]
   \   000000E0   0xF100 0x0134      ADD      R1,R0,#+52
   \   000000E4   0x6A28             LDR      R0,[R5, #+32]
   \   000000E6   0x.... 0x....      BL       HAL_DMA_Start_IT
   2701                
   2702                /* Set the DMA Period elapsed callback */
   2703                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \   000000EA   0x6A68             LDR      R0,[R5, #+36]
   2704               
   2705                /* Set the DMA error callback */
   2706                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   2707                
   2708                /* Enable the DMA Stream */
   2709                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   \   000000EC   0x4623             MOV      R3,R4
   \   000000EE   0x4642             MOV      R2,R8
   \   000000F0   0x63C7             STR      R7,[R0, #+60]
   \   000000F2   0x6A68             LDR      R0,[R5, #+36]
   \   000000F4   0x6486             STR      R6,[R0, #+72]
   \   000000F6   0x6828             LDR      R0,[R5, #+0]
   \   000000F8   0xF100 0x0138      ADD      R1,R0,#+56
   \   000000FC   0x6A68             LDR      R0,[R5, #+36]
   \   000000FE   0x.... 0x....      BL       HAL_DMA_Start_IT
   2710                    
   2711               /* Enable the Peripheral */
   2712                __HAL_TIM_ENABLE(htim);
   \   00000102   0x6828             LDR      R0,[R5, #+0]
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000010A   0x6001             STR      R1,[R0, #+0]
   2713                
   2714                /* Enable the Capture compare channel */
   2715                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \   0000010C   0x6828             LDR      R0,[R5, #+0]
   \   0000010E   0x6A01             LDR      R1,[R0, #+32]
   \   00000110   0x0849             LSRS     R1,R1,#+1
   \   00000112   0x0049             LSLS     R1,R1,#+1
   \   00000114   0x6201             STR      R1,[R0, #+32]
   \   00000116   0x6A01             LDR      R1,[R0, #+32]
   \   00000118   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000011C   0x6201             STR      R1,[R0, #+32]
   2716                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \   0000011E   0x6828             LDR      R0,[R5, #+0]
   \   00000120   0x6A01             LDR      R1,[R0, #+32]
   \   00000122   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000126   0x6201             STR      R1,[R0, #+32]
   \   00000128   0x6A01             LDR      R1,[R0, #+32]
   \   0000012A   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000012E   0x6201             STR      R1,[R0, #+32]
   2717                
   2718                /* Enable the TIM Input Capture  DMA request */
   2719                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \   00000130   0x6828             LDR      R0,[R5, #+0]
   \   00000132   0x68C1             LDR      R1,[R0, #+12]
   \   00000134   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000138   0x60C1             STR      R1,[R0, #+12]
   2720                /* Enable the TIM Input Capture  DMA request */
   2721                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \   0000013A   0x6828             LDR      R0,[R5, #+0]
   \   0000013C   0x68C1             LDR      R1,[R0, #+12]
   \   0000013E   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000142   0x60C1             STR      R1,[R0, #+12]
   2722              }
   2723              break;
   2724              
   2725              default:
   2726              break;
   2727            }  
   2728            /* Return function status */
   2729            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \   00000146   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2730          }
   2731          
   2732          /**
   2733            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2734            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2735            *                the configuration information for TIM module.
   2736            * @param  Channel: TIM Channels to be enabled.
   2737            *          This parameter can be one of the following values:
   2738            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2739            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2740            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2741            * @retval HAL status
   2742            */

   \                                 In section .text, align 2, keep-with-next
   2743          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2744          {
   2745            /* Check the parameters */
   2746            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2747            
   2748            /* Disable the Input Capture channels 1 and 2
   2749              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2750            if(Channel == TIM_CHANNEL_1)
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \   00000000   0xB959             CBNZ.N   R1,??HAL_TIM_Encoder_Stop_DMA_0
   2751            {
   2752              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x6A0A             LDR      R2,[R1, #+32]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x620A             STR      R2,[R1, #+32]
   \   0000000C   0x6A0A             LDR      R2,[R1, #+32]
   \   0000000E   0x620A             STR      R2,[R1, #+32]
   2753              
   2754              /* Disable the capture compare DMA Request 1 */
   2755              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x68CA             LDR      R2,[R1, #+12]
   \   00000014   0xF422 0x7200      BIC      R2,R2,#0x200
   \   00000018   0xE01E             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   2756            }  
   2757            else if(Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \   0000001A   0x2904             CMP      R1,#+4
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x6A0A             LDR      R2,[R1, #+32]
   \   00000020   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   2758            {  
   2759              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000022   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000026   0x620A             STR      R2,[R1, #+32]
   \   00000028   0x6A0A             LDR      R2,[R1, #+32]
   \   0000002A   0x620A             STR      R2,[R1, #+32]
   2760              
   2761              /* Disable the capture compare DMA Request 2 */
   2762              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \   0000002C   0xE010             B.N      ??HAL_TIM_Encoder_Stop_DMA_3
   2763            }  
   2764            else
   2765            {
   2766              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \   0000002E   0x0852             LSRS     R2,R2,#+1
   \   00000030   0x0052             LSLS     R2,R2,#+1
   \   00000032   0x620A             STR      R2,[R1, #+32]
   \   00000034   0x6A0A             LDR      R2,[R1, #+32]
   \   00000036   0x620A             STR      R2,[R1, #+32]
   2767              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6A0A             LDR      R2,[R1, #+32]
   \   0000003C   0xF022 0x0210      BIC      R2,R2,#0x10
   \   00000040   0x620A             STR      R2,[R1, #+32]
   \   00000042   0x6A0A             LDR      R2,[R1, #+32]
   \   00000044   0x620A             STR      R2,[R1, #+32]
   2768              
   2769              /* Disable the capture compare DMA Request 1 and 2 */
   2770              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x68CA             LDR      R2,[R1, #+12]
   \   0000004A   0xF422 0x7200      BIC      R2,R2,#0x200
   \   0000004E   0x60CA             STR      R2,[R1, #+12]
   2771              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x68CA             LDR      R2,[R1, #+12]
   \   00000054   0xF422 0x6280      BIC      R2,R2,#0x400
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \   00000058   0x60CA             STR      R2,[R1, #+12]
   2772            }
   2773            
   2774            /* Disable the Peripheral */
   2775            __HAL_TIM_DISABLE(htim);
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF241 0x1311      MOVW     R3,#+4369
   \   00000060   0x6A0A             LDR      R2,[R1, #+32]
   \   00000062   0x421A             TST      R2,R3
   \   00000064   0xBF02             ITTT     EQ 
   \   00000066   0x6A0A             LDREQ    R2,[R1, #+32]
   \   00000068   0xF240 0x4344      MOVWEQ   R3,#+1092
   \   0000006C   0x421A             TSTEQ    R2,R3
   \   0000006E   0xD103             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_4
   \   00000070   0x680A             LDR      R2,[R1, #+0]
   \   00000072   0x0852             LSRS     R2,R2,#+1
   \   00000074   0x0052             LSLS     R2,R2,#+1
   \   00000076   0x600A             STR      R2,[R1, #+0]
   2776            
   2777            /* Change the htim state */
   2778            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_4: (+1)
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0xF880 0x1039      STRB     R1,[R0, #+57]
   2779            
   2780            /* Return function status */
   2781            return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x4770             BX       LR               ;; return
   2782          }
   2783          
   2784          /**
   2785            * @}
   2786            */
   2787          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2788           *  @brief    IRQ handler management 
   2789           *
   2790          @verbatim   
   2791            ==============================================================================
   2792                                  ##### IRQ handler management #####
   2793            ==============================================================================  
   2794            [..]  
   2795              This section provides Timer IRQ handler function.
   2796                         
   2797          @endverbatim
   2798            * @{
   2799            */
   2800          /**
   2801            * @brief  This function handles TIM interrupts requests.
   2802            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2803            *                the configuration information for TIM module.
   2804            * @retval None
   2805            */

   \                                 In section .text, align 2, keep-with-next
   2806          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2807          {
   \                     HAL_TIM_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2808            /* Capture compare 1 event */
   2809            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6901             LDR      R1,[R0, #+16]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD516             BPL.N    ??HAL_TIM_IRQHandler_0
   2810            {
   2811              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   \   0000000C   0x68C1             LDR      R1,[R0, #+12]
   \   0000000E   0x0789             LSLS     R1,R1,#+30
   \   00000010   0xD513             BPL.N    ??HAL_TIM_IRQHandler_0
   2812              {
   2813                {
   2814                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \   00000012   0xF06F 0x0102      MVN      R1,#+2
   \   00000016   0x6101             STR      R1,[R0, #+16]
   2815                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x7621             STRB     R1,[R4, #+24]
   2816                  
   2817                  /* Input capture event */
   2818                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
   \   0000001C   0x6980             LDR      R0,[R0, #+24]
   \   0000001E   0xF010 0x0F03      TST      R0,#0x3
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_1
   2819                  {
   2820                    HAL_TIM_IC_CaptureCallback(htim);
   \   00000026   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   0000002A   0xE004             B.N      ??HAL_TIM_IRQHandler_2
   2821                  }
   2822                  /* Output compare event */
   2823                  else
   2824                  {
   2825                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \   0000002C   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2826                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2827                  }
   2828                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7620             STRB     R0,[R4, #+24]
   2829                }
   2830              }
   2831            }
   2832            /* Capture compare 2 event */
   2833            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6901             LDR      R1,[R0, #+16]
   \   0000003E   0x0749             LSLS     R1,R1,#+29
   \   00000040   0xD516             BPL.N    ??HAL_TIM_IRQHandler_3
   2834            {
   2835              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   \   00000042   0x68C1             LDR      R1,[R0, #+12]
   \   00000044   0x0749             LSLS     R1,R1,#+29
   \   00000046   0xD513             BPL.N    ??HAL_TIM_IRQHandler_3
   2836              {
   2837                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \   00000048   0xF06F 0x0104      MVN      R1,#+4
   \   0000004C   0x6101             STR      R1,[R0, #+16]
   2838                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000004E   0x2102             MOVS     R1,#+2
   \   00000050   0x7621             STRB     R1,[R4, #+24]
   2839                /* Input capture event */
   2840                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
   \   00000052   0x6980             LDR      R0,[R0, #+24]
   \   00000054   0xF410 0x7F40      TST      R0,#0x300
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_4
   2841                {          
   2842                  HAL_TIM_IC_CaptureCallback(htim);
   \   0000005C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000060   0xE004             B.N      ??HAL_TIM_IRQHandler_5
   2843                }
   2844                /* Output compare event */
   2845                else
   2846                {
   2847                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \   00000062   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2848                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2849                }
   2850                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x7620             STRB     R0,[R4, #+24]
   2851              }
   2852            }
   2853            /* Capture compare 3 event */
   2854            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6901             LDR      R1,[R0, #+16]
   \   00000074   0x0709             LSLS     R1,R1,#+28
   \   00000076   0xD516             BPL.N    ??HAL_TIM_IRQHandler_6
   2855            {
   2856              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   \   00000078   0x68C1             LDR      R1,[R0, #+12]
   \   0000007A   0x0709             LSLS     R1,R1,#+28
   \   0000007C   0xD513             BPL.N    ??HAL_TIM_IRQHandler_6
   2857              {
   2858                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \   0000007E   0xF06F 0x0108      MVN      R1,#+8
   \   00000082   0x6101             STR      R1,[R0, #+16]
   2859                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000084   0x2104             MOVS     R1,#+4
   \   00000086   0x7621             STRB     R1,[R4, #+24]
   2860                /* Input capture event */
   2861                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
   \   00000088   0x69C0             LDR      R0,[R0, #+28]
   \   0000008A   0xF010 0x0F03      TST      R0,#0x3
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_7
   2862                {          
   2863                  HAL_TIM_IC_CaptureCallback(htim);
   \   00000092   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   00000096   0xE004             B.N      ??HAL_TIM_IRQHandler_8
   2864                }
   2865                /* Output compare event */
   2866                else
   2867                {
   2868                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \   00000098   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2869                  HAL_TIM_PWM_PulseFinishedCallback(htim); 
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2870                }
   2871                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x7620             STRB     R0,[R4, #+24]
   2872              }
   2873            }
   2874            /* Capture compare 4 event */
   2875            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6901             LDR      R1,[R0, #+16]
   \   000000AA   0x06C9             LSLS     R1,R1,#+27
   \   000000AC   0xD516             BPL.N    ??HAL_TIM_IRQHandler_9
   2876            {
   2877              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   \   000000AE   0x68C1             LDR      R1,[R0, #+12]
   \   000000B0   0x06C9             LSLS     R1,R1,#+27
   \   000000B2   0xD513             BPL.N    ??HAL_TIM_IRQHandler_9
   2878              {
   2879                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \   000000B4   0xF06F 0x0110      MVN      R1,#+16
   \   000000B8   0x6101             STR      R1,[R0, #+16]
   2880                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   000000BA   0x2108             MOVS     R1,#+8
   \   000000BC   0x7621             STRB     R1,[R4, #+24]
   2881                /* Input capture event */
   2882                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
   \   000000BE   0x69C0             LDR      R0,[R0, #+28]
   \   000000C0   0xF410 0x7F40      TST      R0,#0x300
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0xD002             BEQ.N    ??HAL_TIM_IRQHandler_10
   2883                {          
   2884                  HAL_TIM_IC_CaptureCallback(htim);
   \   000000C8   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \   000000CC   0xE004             B.N      ??HAL_TIM_IRQHandler_11
   2885                }
   2886                /* Output compare event */
   2887                else
   2888                {
   2889                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \   000000CE   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   2890                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   2891                }
   2892                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x7620             STRB     R0,[R4, #+24]
   2893              }
   2894            }
   2895            /* TIM Update event */
   2896            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0x6901             LDR      R1,[R0, #+16]
   \   000000E0   0x07C9             LSLS     R1,R1,#+31
   \   000000E2   0xD508             BPL.N    ??HAL_TIM_IRQHandler_12
   2897            {
   2898              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   \   000000E4   0x68C1             LDR      R1,[R0, #+12]
   \   000000E6   0x07C9             LSLS     R1,R1,#+31
   \   000000E8   0xD505             BPL.N    ??HAL_TIM_IRQHandler_12
   2899              {
   2900                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \   000000EA   0xF06F 0x0101      MVN      R1,#+1
   \   000000EE   0x6101             STR      R1,[R0, #+16]
   2901                HAL_TIM_PeriodElapsedCallback(htim);
   \   000000F0   0x4620             MOV      R0,R4
   \   000000F2   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   2902              }
   2903            }
   2904            /* TIM Break input event */
   2905            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x6901             LDR      R1,[R0, #+16]
   \   000000FA   0x0609             LSLS     R1,R1,#+24
   \   000000FC   0xD508             BPL.N    ??HAL_TIM_IRQHandler_13
   2906            {
   2907              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   000000FE   0x68C1             LDR      R1,[R0, #+12]
   \   00000100   0x0609             LSLS     R1,R1,#+24
   \   00000102   0xD505             BPL.N    ??HAL_TIM_IRQHandler_13
   2908              {
   2909                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   00000104   0xF06F 0x0180      MVN      R1,#+128
   \   00000108   0x6101             STR      R1,[R0, #+16]
   2910                HAL_TIMEx_BreakCallback(htim);
   \   0000010A   0x4620             MOV      R0,R4
   \   0000010C   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2911              }
   2912            }
   2913            
   2914              /* TIM Break input event */
   2915            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \   00000110   0x6820             LDR      R0,[R4, #+0]
   \   00000112   0x6901             LDR      R1,[R0, #+16]
   \   00000114   0x05C9             LSLS     R1,R1,#+23
   \   00000116   0xD508             BPL.N    ??HAL_TIM_IRQHandler_14
   2916            {
   2917              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   \   00000118   0x68C1             LDR      R1,[R0, #+12]
   \   0000011A   0x0609             LSLS     R1,R1,#+24
   \   0000011C   0xD505             BPL.N    ??HAL_TIM_IRQHandler_14
   2918              {
   2919                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \   0000011E   0xF06F 0x0180      MVN      R1,#+128
   \   00000122   0x6101             STR      R1,[R0, #+16]
   2920                HAL_TIMEx_BreakCallback(htim);
   \   00000124   0x4620             MOV      R0,R4
   \   00000126   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   2921              }
   2922            }
   2923          
   2924            /* TIM Trigger detection event */
   2925            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_14: (+1)
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x6901             LDR      R1,[R0, #+16]
   \   0000012E   0x0649             LSLS     R1,R1,#+25
   \   00000130   0xD508             BPL.N    ??HAL_TIM_IRQHandler_15
   2926            {
   2927              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   \   00000132   0x68C1             LDR      R1,[R0, #+12]
   \   00000134   0x0649             LSLS     R1,R1,#+25
   \   00000136   0xD505             BPL.N    ??HAL_TIM_IRQHandler_15
   2928              {
   2929                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \   00000138   0xF06F 0x0140      MVN      R1,#+64
   \   0000013C   0x6101             STR      R1,[R0, #+16]
   2930                HAL_TIM_TriggerCallback(htim);
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   2931              }
   2932            }
   2933            /* TIM commutation event */
   2934            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_15: (+1)
   \   00000144   0x6820             LDR      R0,[R4, #+0]
   \   00000146   0x6901             LDR      R1,[R0, #+16]
   \   00000148   0x0689             LSLS     R1,R1,#+26
   \   0000014A   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_16
   2935            {
   2936              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   \   0000014C   0x68C1             LDR      R1,[R0, #+12]
   \   0000014E   0x0689             LSLS     R1,R1,#+26
   \   00000150   0xD507             BPL.N    ??HAL_TIM_IRQHandler_16
   2937              {
   2938                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \   00000152   0xF06F 0x0120      MVN      R1,#+32
   \   00000156   0x6101             STR      R1,[R0, #+16]
   2939                HAL_TIMEx_CommutationCallback(htim);
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000015E   0x.... 0x....      B.W      HAL_TIMEx_CommutationCallback
   2940              }
   2941            }
   2942          }
   \                     ??HAL_TIM_IRQHandler_16: (+1)
   \   00000162   0xBD10             POP      {R4,PC}          ;; return
   2943          
   2944          /**
   2945            * @}
   2946            */
   2947            
   2948          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2949           *  @brief   	Peripheral Control functions 
   2950           *
   2951          @verbatim   
   2952            ==============================================================================
   2953                             ##### Peripheral Control functions #####
   2954            ==============================================================================  
   2955           [..] 
   2956             This section provides functions allowing to:
   2957             (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   2958             (+) Configure External Clock source.
   2959             (+) Configure Complementary channels, break features and dead time.
   2960             (+) Configure Master and the Slave synchronization.
   2961             (+) Configure the DMA Burst Mode.
   2962                
   2963          @endverbatim
   2964            * @{
   2965            */
   2966            
   2967          /**
   2968            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2969            *         parameters in the TIM_OC_InitTypeDef.
   2970            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   2971            *                the configuration information for TIM module.
   2972            * @param  sConfig: TIM Output Compare configuration structure
   2973            * @param  Channel: TIM Channels to be enabled.
   2974            *          This parameter can be one of the following values:
   2975            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2976            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2977            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2978            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2979            * @retval HAL status
   2980            */

   \                                 In section .text, align 4, keep-with-next
   2981          __weak HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2982          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2983            /* Check the parameters */ 
   2984            assert_param(IS_TIM_CHANNELS(Channel)); 
   2985            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2986            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2987            
   2988            /* Check input state */
   2989            __HAL_LOCK(htim); 
   \   00000004   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_1
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x0038      STRB     R0,[R4, #+56]
   2990            
   2991            htim->State = HAL_TIM_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   2992            
   2993            switch (Channel)
   \   00000018   0x2A0C             CMP      R2,#+12
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000001E   0xD817             BHI.N    ??HAL_TIM_OC_ConfigChannel_2
   \   00000020   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_TIM_OC_ConfigChannel_0:
   \   00000024   0x07 0x16          DC8      0x7,0x16,0x16,0x16
   \              0x16 0x16    
   \   00000028   0x0B 0x16          DC8      0xB,0x16,0x16,0x16
   \              0x16 0x16    
   \   0000002C   0x0F 0x16          DC8      0xF,0x16,0x16,0x16
   \              0x16 0x16    
   \   00000030   0x13 0x00          DC8      0x13,0x0
   2994            {
   2995              case TIM_CHANNEL_1:
   2996              {
   2997                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2998                /* Configure the TIM Channel 1 in Output Compare */
   2999                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       TIM_OC1_SetConfig
   3000              }
   3001              break;
   \   00000038   0xE00A             B.N      ??HAL_TIM_OC_ConfigChannel_2
   3002              
   3003              case TIM_CHANNEL_2:
   3004              {
   3005                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3006                /* Configure the TIM Channel 2 in Output Compare */
   3007                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       TIM_OC2_SetConfig
   3008              }
   3009              break;
   \   00000040   0xE006             B.N      ??HAL_TIM_OC_ConfigChannel_2
   3010              
   3011              case TIM_CHANNEL_3:
   3012              {
   3013                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3014                /* Configure the TIM Channel 3 in Output Compare */
   3015                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      BL       TIM_OC3_SetConfig
   3016              }
   3017              break;
   \   00000048   0xE002             B.N      ??HAL_TIM_OC_ConfigChannel_2
   3018              
   3019              case TIM_CHANNEL_4:
   3020              {
   3021                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3022                /* Configure the TIM Channel 4 in Output Compare */
   3023                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_6: (+1)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x.... 0x....      BL       TIM_OC4_SetConfig
   3024              }
   3025              break;
   3026              
   3027              default:
   3028              break;    
   3029            }
   3030            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF884 0x0039      STRB     R0,[R4, #+57]
   3031            
   3032            __HAL_UNLOCK(htim); 
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF884 0x0038      STRB     R0,[R4, #+56]
   3033            
   3034            return HAL_OK;
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   3035          }
   3036          
   3037          /**
   3038            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3039            *         parameters in the TIM_IC_InitTypeDef.
   3040            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3041            *                the configuration information for TIM module.
   3042            * @param  sConfig: TIM Input Capture configuration structure
   3043            * @param  Channel: TIM Channels to be enabled.
   3044            *          This parameter can be one of the following values:
   3045            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3046            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3047            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3048            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   3049            * @retval HAL status
   3050            */

   \                                 In section .text, align 2, keep-with-next
   3051          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   3052          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   3053            /* Check the parameters */
   3054            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3055            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3056            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3057            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3058            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3059            
   3060            __HAL_LOCK(htim);
   \   00000002   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   3061            
   3062            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2302             MOVS     R3,#+2
   3063            
   3064            if (Channel == TIM_CHANNEL_1)
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xF880 0x3039      STRB     R3,[R0, #+57]
   \   0000001C   0xD149             BNE.N    ??HAL_TIM_IC_ConfigChannel_1
   3065            {
   3066              /* TI1 Configuration */
   3067              TIM_TI1_SetConfig(htim->Instance,
   3068                         sConfig->ICPolarity,
   3069                         sConfig->ICSelection,
   3070                         sConfig->ICFilter);
   \   0000001E   0x6805             LDR      R5,[R0, #+0]
   \   00000020   0x68CB             LDR      R3,[R1, #+12]
   \   00000022   0x684E             LDR      R6,[R1, #+4]
   \   00000024   0x680C             LDR      R4,[R1, #+0]
   \   00000026   0x.... 0x....      LDR.W    LR,??DataTable32  ;; 0x40010000
   \   0000002A   0x6A2A             LDR      R2,[R5, #+32]
   \   0000002C   0x0852             LSRS     R2,R2,#+1
   \   0000002E   0x0052             LSLS     R2,R2,#+1
   \   00000030   0x622A             STR      R2,[R5, #+32]
   \   00000032   0xF105 0x0218      ADD      R2,R5,#+24
   \   00000036   0x4575             CMP      R5,LR
   \   00000038   0xF8D2 0xC000      LDR      R12,[R2, #+0]
   \   0000003C   0x6A2F             LDR      R7,[R5, #+32]
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0xF1B5 0x4F80      CMPNE    R5,#+1073741824
   \   00000044   0xD019             BEQ.N    ??HAL_TIM_IC_ConfigChannel_2
   \   00000046   0x.... 0x....      LDR.W    LR,??DataTable32_1  ;; 0x40000400
   \   0000004A   0x4575             CMP      R5,LR
   \   0000004C   0xBF1C             ITT      NE 
   \   0000004E   0x.... 0x....      LDRNE.W  LR,??DataTable32_2  ;; 0x40000800
   \   00000052   0x4575             CMPNE    R5,LR
   \   00000054   0xD011             BEQ.N    ??HAL_TIM_IC_ConfigChannel_2
   \   00000056   0x.... 0x....      LDR.W    LR,??DataTable32_3  ;; 0x40000c00
   \   0000005A   0x4575             CMP      R5,LR
   \   0000005C   0xBF1C             ITT      NE 
   \   0000005E   0x.... 0x....      LDRNE.W  LR,??DataTable27  ;; 0x40010400
   \   00000062   0x4575             CMPNE    R5,LR
   \   00000064   0xD009             BEQ.N    ??HAL_TIM_IC_ConfigChannel_2
   \   00000066   0x.... 0x....      LDR.W    LR,??DataTable26  ;; 0x40014000
   \   0000006A   0x4575             CMP      R5,LR
   \   0000006C   0xBF1E             ITTT     NE 
   \   0000006E   0x.... 0x....      LDRNE.W  LR,??DataTable26_3  ;; 0x40001800
   \   00000072   0x4575             CMPNE    R5,LR
   \   00000074   0xF04C 0x0601      ORRNE    R6,R12,#0x1
   \   00000078   0xD103             BNE.N    ??HAL_TIM_IC_ConfigChannel_3
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \   0000007A   0xEA4F 0x0C9C      LSR      R12,R12,#+2
   \   0000007E   0xEA46 0x068C      ORR      R6,R6,R12, LSL #+2
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \   00000082   0x011B             LSLS     R3,R3,#+4
   \   00000084   0xF026 0x06F0      BIC      R6,R6,#0xF0
   \   00000088   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   0000008C   0x4333             ORRS     R3,R3,R6
   \   0000008E   0x6013             STR      R3,[R2, #+0]
   \   00000090   0xF027 0x020A      BIC      R2,R7,#0xA
   \   00000094   0xF004 0x030A      AND      R3,R4,#0xA
   \   00000098   0x431A             ORRS     R2,R3,R2
   \   0000009A   0x622A             STR      R2,[R5, #+32]
   3071                         
   3072              /* Reset the IC1PSC Bits */
   3073              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000009C   0x6802             LDR      R2,[R0, #+0]
   \   0000009E   0x6993             LDR      R3,[R2, #+24]
   \   000000A0   0xF023 0x030C      BIC      R3,R3,#0xC
   \   000000A4   0x6193             STR      R3,[R2, #+24]
   3074          
   3075              /* Set the IC1PSC value */
   3076              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \   000000A6   0x6802             LDR      R2,[R0, #+0]
   \   000000A8   0x6993             LDR      R3,[R2, #+24]
   \   000000AA   0x6889             LDR      R1,[R1, #+8]
   \   000000AC   0x4319             ORRS     R1,R1,R3
   \   000000AE   0x6191             STR      R1,[R2, #+24]
   \   000000B0   0xE076             B.N      ??HAL_TIM_IC_ConfigChannel_4
   3077            }
   3078            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \   000000B2   0x2A04             CMP      R2,#+4
   \   000000B4   0xD128             BNE.N    ??HAL_TIM_IC_ConfigChannel_5
   3079            {
   3080              /* TI2 Configuration */
   3081              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3082              
   3083              TIM_TI2_SetConfig(htim->Instance, 
   3084                                sConfig->ICPolarity,
   3085                                sConfig->ICSelection,
   3086                                sConfig->ICFilter);
   \   000000B6   0x6802             LDR      R2,[R0, #+0]
   \   000000B8   0x68CC             LDR      R4,[R1, #+12]
   \   000000BA   0x684D             LDR      R5,[R1, #+4]
   \   000000BC   0x680B             LDR      R3,[R1, #+0]
   \   000000BE   0x3218             ADDS     R2,R2,#+24
   \   000000C0   0x0324             LSLS     R4,R4,#+12
   \   000000C2   0xF404 0x4470      AND      R4,R4,#0xF000
   \   000000C6   0x011B             LSLS     R3,R3,#+4
   \   000000C8   0x6896             LDR      R6,[R2, #+8]
   \   000000CA   0xF003 0x03A0      AND      R3,R3,#0xA0
   \   000000CE   0xF026 0x0610      BIC      R6,R6,#0x10
   \   000000D2   0x6096             STR      R6,[R2, #+8]
   \   000000D4   0x6816             LDR      R6,[R2, #+0]
   \   000000D6   0x6897             LDR      R7,[R2, #+8]
   \   000000D8   0xF426 0x7640      BIC      R6,R6,#0x300
   \   000000DC   0xEA46 0x2505      ORR      R5,R6,R5, LSL #+8
   \   000000E0   0xF425 0x4570      BIC      R5,R5,#0xF000
   \   000000E4   0x432C             ORRS     R4,R4,R5
   \   000000E6   0x6014             STR      R4,[R2, #+0]
   \   000000E8   0xF027 0x04A0      BIC      R4,R7,#0xA0
   \   000000EC   0x4323             ORRS     R3,R3,R4
   \   000000EE   0x6093             STR      R3,[R2, #+8]
   3087                         
   3088              /* Reset the IC2PSC Bits */
   3089              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   000000F0   0x6802             LDR      R2,[R0, #+0]
   \   000000F2   0x6993             LDR      R3,[R2, #+24]
   \   000000F4   0xF423 0x6340      BIC      R3,R3,#0xC00
   \   000000F8   0x6193             STR      R3,[R2, #+24]
   3090          
   3091              /* Set the IC2PSC value */
   3092              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
   \   000000FA   0x6802             LDR      R2,[R0, #+0]
   \   000000FC   0x6993             LDR      R3,[R2, #+24]
   \   000000FE   0x6889             LDR      R1,[R1, #+8]
   \   00000100   0xEA43 0x2101      ORR      R1,R3,R1, LSL #+8
   \   00000104   0x6191             STR      R1,[R2, #+24]
   \   00000106   0xE04B             B.N      ??HAL_TIM_IC_ConfigChannel_4
   3093            }
   3094            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_5: (+1)
   \   00000108   0x2A08             CMP      R2,#+8
   \   0000010A   0x68CC             LDR      R4,[R1, #+12]
   \   0000010C   0x684D             LDR      R5,[R1, #+4]
   \   0000010E   0x680B             LDR      R3,[R1, #+0]
   \   00000110   0x6802             LDR      R2,[R0, #+0]
   \   00000112   0xD121             BNE.N    ??HAL_TIM_IC_ConfigChannel_6
   3095            {
   3096              /* TI3 Configuration */
   3097              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3098              
   3099              TIM_TI3_SetConfig(htim->Instance,  
   3100                         sConfig->ICPolarity,
   3101                         sConfig->ICSelection,
   3102                         sConfig->ICFilter);
   \   00000114   0x321C             ADDS     R2,R2,#+28
   \   00000116   0x0124             LSLS     R4,R4,#+4
   \   00000118   0xF004 0x04F0      AND      R4,R4,#0xF0
   \   0000011C   0x021B             LSLS     R3,R3,#+8
   \   0000011E   0x6856             LDR      R6,[R2, #+4]
   \   00000120   0xF403 0x6320      AND      R3,R3,#0xA00
   \   00000124   0xF426 0x7680      BIC      R6,R6,#0x100
   \   00000128   0x6056             STR      R6,[R2, #+4]
   \   0000012A   0x6816             LDR      R6,[R2, #+0]
   \   0000012C   0x6857             LDR      R7,[R2, #+4]
   \   0000012E   0x08B6             LSRS     R6,R6,#+2
   \   00000130   0xEA45 0x0586      ORR      R5,R5,R6, LSL #+2
   \   00000134   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000138   0x432C             ORRS     R4,R4,R5
   \   0000013A   0x6014             STR      R4,[R2, #+0]
   \   0000013C   0xF427 0x6420      BIC      R4,R7,#0xA00
   \   00000140   0x4323             ORRS     R3,R3,R4
   \   00000142   0x6053             STR      R3,[R2, #+4]
   3103                         
   3104              /* Reset the IC3PSC Bits */
   3105              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \   00000144   0x6802             LDR      R2,[R0, #+0]
   \   00000146   0x69D3             LDR      R3,[R2, #+28]
   \   00000148   0xF023 0x030C      BIC      R3,R3,#0xC
   \   0000014C   0x61D3             STR      R3,[R2, #+28]
   3106          
   3107              /* Set the IC3PSC value */
   3108              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \   0000014E   0x6802             LDR      R2,[R0, #+0]
   \   00000150   0x69D3             LDR      R3,[R2, #+28]
   \   00000152   0x6889             LDR      R1,[R1, #+8]
   \   00000154   0x4319             ORRS     R1,R1,R3
   \   00000156   0xE022             B.N      ??HAL_TIM_IC_ConfigChannel_7
   3109            }
   3110            else
   3111            {
   3112              /* TI4 Configuration */
   3113              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3114              
   3115              TIM_TI4_SetConfig(htim->Instance, 
   3116                         sConfig->ICPolarity,
   3117                         sConfig->ICSelection,
   3118                         sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_6: (+1)
   \   00000158   0x321C             ADDS     R2,R2,#+28
   \   0000015A   0x0324             LSLS     R4,R4,#+12
   \   0000015C   0xF404 0x4470      AND      R4,R4,#0xF000
   \   00000160   0x031B             LSLS     R3,R3,#+12
   \   00000162   0x6856             LDR      R6,[R2, #+4]
   \   00000164   0xF403 0x4320      AND      R3,R3,#0xA000
   \   00000168   0xF426 0x5680      BIC      R6,R6,#0x1000
   \   0000016C   0x6056             STR      R6,[R2, #+4]
   \   0000016E   0x6816             LDR      R6,[R2, #+0]
   \   00000170   0x6857             LDR      R7,[R2, #+4]
   \   00000172   0xF426 0x7640      BIC      R6,R6,#0x300
   \   00000176   0xEA46 0x2505      ORR      R5,R6,R5, LSL #+8
   \   0000017A   0xF425 0x4570      BIC      R5,R5,#0xF000
   \   0000017E   0x432C             ORRS     R4,R4,R5
   \   00000180   0x6014             STR      R4,[R2, #+0]
   \   00000182   0xF427 0x4420      BIC      R4,R7,#0xA000
   \   00000186   0x4323             ORRS     R3,R3,R4
   \   00000188   0x6053             STR      R3,[R2, #+4]
   3119                         
   3120              /* Reset the IC4PSC Bits */
   3121              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \   0000018A   0x6802             LDR      R2,[R0, #+0]
   \   0000018C   0x69D3             LDR      R3,[R2, #+28]
   \   0000018E   0xF423 0x6340      BIC      R3,R3,#0xC00
   \   00000192   0x61D3             STR      R3,[R2, #+28]
   3122          
   3123              /* Set the IC4PSC value */
   3124              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
   \   00000194   0x6802             LDR      R2,[R0, #+0]
   \   00000196   0x69D3             LDR      R3,[R2, #+28]
   \   00000198   0x6889             LDR      R1,[R1, #+8]
   \   0000019A   0xEA43 0x2101      ORR      R1,R3,R1, LSL #+8
   \                     ??HAL_TIM_IC_ConfigChannel_7: (+1)
   \   0000019E   0x61D1             STR      R1,[R2, #+28]
   3125            }
   3126            
   3127            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \   000001A0   0x2101             MOVS     R1,#+1
   \   000001A2   0xF880 0x1039      STRB     R1,[R0, #+57]
   3128              
   3129            __HAL_UNLOCK(htim);
   \   000001A6   0x2100             MOVS     R1,#+0
   \   000001A8   0xF880 0x1038      STRB     R1,[R0, #+56]
   3130            
   3131            return HAL_OK; 
   \   000001AC   0x2000             MOVS     R0,#+0
   \   000001AE   0xBDF0             POP      {R4-R7,PC}       ;; return
   3132          }
   3133          
   3134          /**
   3135            * @brief  Initializes the TIM PWM  channels according to the specified
   3136            *         parameters in the TIM_OC_InitTypeDef.
   3137            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3138            *                the configuration information for TIM module.
   3139            * @param  sConfig: TIM PWM configuration structure
   3140            * @param  Channel: TIM Channels to be enabled.
   3141            *          This parameter can be one of the following values:
   3142            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3143            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3144            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3145            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3146            * @retval HAL status
   3147            */

   \                                 In section .text, align 4, keep-with-next
   3148          __weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3149          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   3150            __HAL_LOCK(htim);
   \   00000008   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2002             MOVEQ    R0,#+2
   \   00000012   0xD062             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_1
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
   3151            
   3152            /* Check the parameters */ 
   3153            assert_param(IS_TIM_CHANNELS(Channel)); 
   3154            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3155            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3156            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode)); 
   3157            
   3158            htim->State = HAL_TIM_STATE_BUSY;
   \   0000001A   0x2002             MOVS     R0,#+2
   3159              
   3160            switch (Channel)
   \   0000001C   0x2A0C             CMP      R2,#+12
   \   0000001E   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000022   0xD854             BHI.N    ??HAL_TIM_PWM_ConfigChannel_2
   \   00000024   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_TIM_PWM_ConfigChannel_0:
   \   00000028   0x07 0x53          DC8      0x7,0x53,0x53,0x53
   \              0x53 0x53    
   \   0000002C   0x1A 0x53          DC8      0x1A,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000030   0x2E 0x53          DC8      0x2E,0x53,0x53,0x53
   \              0x53 0x53    
   \   00000034   0x40 0x00          DC8      0x40,0x0
   3161            {
   3162              case TIM_CHANNEL_1:
   3163              {
   3164                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3165                /* Configure the Channel 1 in PWM mode */
   3166                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       TIM_OC1_SetConfig
   3167                
   3168                /* Set the Preload enable bit for channel1 */
   3169                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6981             LDR      R1,[R0, #+24]
   \   00000040   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000044   0x6181             STR      R1,[R0, #+24]
   3170                
   3171                /* Configure the Output Fast mode */
   3172                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6981             LDR      R1,[R0, #+24]
   \   0000004A   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000004E   0x6181             STR      R1,[R0, #+24]
   3173                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6981             LDR      R1,[R0, #+24]
   \   00000054   0x692A             LDR      R2,[R5, #+16]
   \   00000056   0x4311             ORRS     R1,R2,R1
   \   00000058   0x6181             STR      R1,[R0, #+24]
   3174              }
   3175              break;
   3176              
   3177              case TIM_CHANNEL_2:
   3178              {
   3179                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3180                /* Configure the Channel 2 in PWM mode */
   3181                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3182                
   3183                /* Set the Preload enable bit for channel2 */
   3184                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   3185                
   3186                /* Configure the Output Fast mode */
   3187                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   3188                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   3189              }
   3190              break;
   \   0000005A   0xE038             B.N      ??HAL_TIM_PWM_ConfigChannel_2
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       TIM_OC2_SetConfig
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x6981             LDR      R1,[R0, #+24]
   \   00000066   0xF441 0x6100      ORR      R1,R1,#0x800
   \   0000006A   0x6181             STR      R1,[R0, #+24]
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6981             LDR      R1,[R0, #+24]
   \   00000070   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000074   0x6181             STR      R1,[R0, #+24]
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x6981             LDR      R1,[R0, #+24]
   \   0000007A   0x692A             LDR      R2,[R5, #+16]
   \   0000007C   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000080   0x6181             STR      R1,[R0, #+24]
   \   00000082   0xE024             B.N      ??HAL_TIM_PWM_ConfigChannel_2
   3191              
   3192              case TIM_CHANNEL_3:
   3193              {
   3194                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3195                /* Configure the Channel 3 in PWM mode */
   3196                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x.... 0x....      BL       TIM_OC3_SetConfig
   3197                
   3198                /* Set the Preload enable bit for channel3 */
   3199                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x69C1             LDR      R1,[R0, #+28]
   \   0000008E   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000092   0x61C1             STR      R1,[R0, #+28]
   3200                
   3201               /* Configure the Output Fast mode */
   3202                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x69C1             LDR      R1,[R0, #+28]
   \   00000098   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000009C   0x61C1             STR      R1,[R0, #+28]
   3203                htim->Instance->CCMR2 |= sConfig->OCFastMode;  
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x69C1             LDR      R1,[R0, #+28]
   \   000000A2   0x692A             LDR      R2,[R5, #+16]
   \   000000A4   0x4311             ORRS     R1,R2,R1
   \   000000A6   0xE011             B.N      ??HAL_TIM_PWM_ConfigChannel_6
   3204              }
   3205              break;
   3206              
   3207              case TIM_CHANNEL_4:
   3208              {
   3209                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3210                /* Configure the Channel 4 in PWM mode */
   3211                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x.... 0x....      BL       TIM_OC4_SetConfig
   3212                
   3213                /* Set the Preload enable bit for channel4 */
   3214                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x69C1             LDR      R1,[R0, #+28]
   \   000000B2   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000B6   0x61C1             STR      R1,[R0, #+28]
   3215                
   3216               /* Configure the Output Fast mode */
   3217                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x69C1             LDR      R1,[R0, #+28]
   \   000000BC   0xF421 0x6180      BIC      R1,R1,#0x400
   \   000000C0   0x61C1             STR      R1,[R0, #+28]
   3218                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x69C1             LDR      R1,[R0, #+28]
   \   000000C6   0x692A             LDR      R2,[R5, #+16]
   \   000000C8   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \   000000CC   0x61C1             STR      R1,[R0, #+28]
   3219              }
   3220              break;
   3221              
   3222              default:
   3223              break;    
   3224            }
   3225            
   3226            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0xF884 0x0039      STRB     R0,[R4, #+57]
   3227              
   3228            __HAL_UNLOCK(htim);
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0xF884 0x0038      STRB     R0,[R4, #+56]
   3229            
   3230            return HAL_OK;
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \   000000DA   0xB001             ADD      SP,SP,#+4
   \   000000DC   0xBD30             POP      {R4,R5,PC}       ;; return
   3231          }
   3232          
   3233          /**
   3234            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3235            *         parameters in the TIM_OnePulse_InitTypeDef.
   3236            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3237            *                the configuration information for TIM module.
   3238            * @param  sConfig: TIM One Pulse configuration structure
   3239            * @param  OutputChannel: TIM Channels to be enabled.
   3240            *          This parameter can be one of the following values:
   3241            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3242            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3243            * @param  InputChannel: TIM Channels to be enabled.
   3244            *          This parameter can be one of the following values:
   3245            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3246            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3247            * @retval HAL status
   3248            */

   \                                 In section .text, align 2, keep-with-next
   3249          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3250          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x461E             MOV      R6,R3
   3251            TIM_OC_InitTypeDef temp1;
   3252            
   3253            /* Check the parameters */
   3254            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3255            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3256          
   3257            if(OutputChannel != InputChannel)  
   \   00000004   0x42B2             CMP      R2,R6
   \   00000006   0xB088             SUB      SP,SP,#+32
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0xD07A             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_0
   3258            {
   3259              __HAL_LOCK(htim);
   \   0000000E   0xF994 0x0038      LDRSB    R0,[R4, #+56]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xBF08             IT       EQ 
   \   00000016   0x2002             MOVEQ    R0,#+2
   \   00000018   0xD075             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF884 0x0038      STRB     R0,[R4, #+56]
   3260            
   3261              htim->State = HAL_TIM_STATE_BUSY;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   3262          
   3263              /* Extract the Output compare configuration from sConfig structure */  
   3264              temp1.OCMode = sConfig->OCMode;
   \   00000026   0x6828             LDR      R0,[R5, #+0]
   \   00000028   0x9000             STR      R0,[SP, #+0]
   3265              temp1.Pulse = sConfig->Pulse;
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   3266              temp1.OCPolarity = sConfig->OCPolarity;
   \   0000002E   0x68A8             LDR      R0,[R5, #+8]
   \   00000030   0x9002             STR      R0,[SP, #+8]
   3267              temp1.OCNPolarity = sConfig->OCNPolarity;
   \   00000032   0x68E8             LDR      R0,[R5, #+12]
   \   00000034   0x9003             STR      R0,[SP, #+12]
   3268              temp1.OCIdleState = sConfig->OCIdleState;
   \   00000036   0x6928             LDR      R0,[R5, #+16]
   \   00000038   0x9005             STR      R0,[SP, #+20]
   3269              temp1.OCNIdleState = sConfig->OCNIdleState; 
   \   0000003A   0x6968             LDR      R0,[R5, #+20]
   \   0000003C   0x9006             STR      R0,[SP, #+24]
   3270              
   3271              switch (OutputChannel)
   \   0000003E   0xB132             CBZ.N    R2,??HAL_TIM_OnePulse_ConfigChannel_2
   \   00000040   0x2A04             CMP      R2,#+4
   \   00000042   0xBF02             ITTT     EQ 
   3272              {
   3273                case TIM_CHANNEL_1:
   3274                {
   3275                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3276                
   3277                  TIM_OC1_SetConfig(htim->Instance, &temp1); 
   3278                }
   3279                break;
   3280                case TIM_CHANNEL_2:
   3281                {
   3282                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3283                
   3284                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \   00000044   0x4669             MOVEQ    R1,SP
   \   00000046   0x6820             LDREQ    R0,[R4, #+0]
   \   00000048   0x.... 0x....      BLEQ     TIM_OC2_SetConfig
   \   0000004C   0xE003             B.N      ??HAL_TIM_OnePulse_ConfigChannel_3
   3285                }
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x.... 0x....      BL       TIM_OC1_SetConfig
   3286                break;
   3287                default:
   3288                break;  
   3289              } 
   3290              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \   00000056   0xB116             CBZ.N    R6,??HAL_TIM_OnePulse_ConfigChannel_4
   \   00000058   0x2E04             CMP      R6,#+4
   \   0000005A   0xD015             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_5
   \   0000005C   0xE04A             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3291              {
   3292                case TIM_CHANNEL_1:
   3293                {
   3294                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3295                
   3296                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3297                                  sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \   0000005E   0x6A2B             LDR      R3,[R5, #+32]
   \   00000060   0x69EA             LDR      R2,[R5, #+28]
   \   00000062   0x69A9             LDR      R1,[R5, #+24]
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x.... 0x....      BL       TIM_TI1_SetConfig
   3298                         
   3299                  /* Reset the IC1PSC Bits */
   3300                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6981             LDR      R1,[R0, #+24]
   \   0000006E   0xF021 0x010C      BIC      R1,R1,#0xC
   \   00000072   0x6181             STR      R1,[R0, #+24]
   3301          
   3302                  /* Select the Trigger source */
   3303                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6881             LDR      R1,[R0, #+8]
   \   00000078   0xF021 0x0170      BIC      R1,R1,#0x70
   \   0000007C   0x6081             STR      R1,[R0, #+8]
   3304                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x6881             LDR      R1,[R0, #+8]
   \   00000082   0xF041 0x0150      ORR      R1,R1,#0x50
   \   00000086   0xE029             B.N      ??HAL_TIM_OnePulse_ConfigChannel_7
   3305                
   3306                  /* Select the Slave Mode */      
   3307                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3308                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3309                }
   3310                break;
   3311                case TIM_CHANNEL_2:
   3312                {
   3313                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3314                
   3315                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3316                           sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6A2A             LDR      R2,[R5, #+32]
   \   0000008C   0x69EB             LDR      R3,[R5, #+28]
   \   0000008E   0x69A8             LDR      R0,[R5, #+24]
   \   00000090   0x0312             LSLS     R2,R2,#+12
   \   00000092   0xF402 0x4270      AND      R2,R2,#0xF000
   \   00000096   0x6A0D             LDR      R5,[R1, #+32]
   \   00000098   0x0100             LSLS     R0,R0,#+4
   \   0000009A   0xF000 0x00A0      AND      R0,R0,#0xA0
   \   0000009E   0xF025 0x0510      BIC      R5,R5,#0x10
   \   000000A2   0x620D             STR      R5,[R1, #+32]
   \   000000A4   0x698D             LDR      R5,[R1, #+24]
   \   000000A6   0x6A0E             LDR      R6,[R1, #+32]
   \   000000A8   0xF425 0x7540      BIC      R5,R5,#0x300
   \   000000AC   0xEA45 0x2303      ORR      R3,R5,R3, LSL #+8
   \   000000B0   0xF423 0x4370      BIC      R3,R3,#0xF000
   \   000000B4   0x431A             ORRS     R2,R2,R3
   \   000000B6   0x618A             STR      R2,[R1, #+24]
   \   000000B8   0xF026 0x02A0      BIC      R2,R6,#0xA0
   \   000000BC   0x4310             ORRS     R0,R0,R2
   \   000000BE   0x6208             STR      R0,[R1, #+32]
   3317                         
   3318                  /* Reset the IC2PSC Bits */
   3319                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \   000000C0   0x6820             LDR      R0,[R4, #+0]
   \   000000C2   0x6981             LDR      R1,[R0, #+24]
   \   000000C4   0xF421 0x6140      BIC      R1,R1,#0xC00
   \   000000C8   0x6181             STR      R1,[R0, #+24]
   3320          
   3321                  /* Select the Trigger source */
   3322                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \   000000CA   0x6820             LDR      R0,[R4, #+0]
   \   000000CC   0x6881             LDR      R1,[R0, #+8]
   \   000000CE   0xF021 0x0170      BIC      R1,R1,#0x70
   \   000000D2   0x6081             STR      R1,[R0, #+8]
   3323                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \   000000D4   0x6820             LDR      R0,[R4, #+0]
   \   000000D6   0x6881             LDR      R1,[R0, #+8]
   \   000000D8   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \   000000DC   0x6081             STR      R1,[R0, #+8]
   3324                
   3325                  /* Select the Slave Mode */      
   3326                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x.... 0x....      LDR.W    R2,??DataTable37  ;; 0xfffefff8
   \   000000E4   0x6881             LDR      R1,[R0, #+8]
   \   000000E6   0x4011             ANDS     R1,R2,R1
   \   000000E8   0x6081             STR      R1,[R0, #+8]
   3327                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6881             LDR      R1,[R0, #+8]
   \   000000EE   0xF041 0x0106      ORR      R1,R1,#0x6
   \   000000F2   0x6081             STR      R1,[R0, #+8]
   3328                }
   3329                break;
   3330              
   3331                default:
   3332                break;  
   3333              }
   3334            
   3335              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xF884 0x0039      STRB     R0,[R4, #+57]
   3336              
   3337              __HAL_UNLOCK(htim);
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF884 0x0038      STRB     R0,[R4, #+56]
   3338            
   3339              return HAL_OK;
   \   00000100   0xB008             ADD      SP,SP,#+32
   \   00000102   0xBD70             POP      {R4-R6,PC}
   3340            }
   3341            else
   3342            {
   3343              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \   00000104   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \   00000106   0xB008             ADD      SP,SP,#+32
   \   00000108   0xBD70             POP      {R4-R6,PC}       ;; return
   3344            }
   3345          } 
   3346          
   3347          /**
   3348            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral  
   3349            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3350            *                the configuration information for TIM module.
   3351            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data write.
   3352            *         This parameters can be on of the following values:
   3353            *            @arg TIM_DMABASE_CR1  
   3354            *            @arg TIM_DMABASE_CR2
   3355            *            @arg TIM_DMABASE_SMCR
   3356            *            @arg TIM_DMABASE_DIER
   3357            *            @arg TIM_DMABASE_SR
   3358            *            @arg TIM_DMABASE_EGR
   3359            *            @arg TIM_DMABASE_CCMR1
   3360            *            @arg TIM_DMABASE_CCMR2
   3361            *            @arg TIM_DMABASE_CCER
   3362            *            @arg TIM_DMABASE_CNT   
   3363            *            @arg TIM_DMABASE_PSC   
   3364            *            @arg TIM_DMABASE_ARR
   3365            *            @arg TIM_DMABASE_RCR
   3366            *            @arg TIM_DMABASE_CCR1
   3367            *            @arg TIM_DMABASE_CCR2
   3368            *            @arg TIM_DMABASE_CCR3  
   3369            *            @arg TIM_DMABASE_CCR4
   3370            *            @arg TIM_DMABASE_BDTR
   3371            *            @arg TIM_DMABASE_DCR
   3372            * @param  BurstRequestSrc: TIM DMA Request sources.
   3373            *         This parameters can be on of the following values:
   3374            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3375            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3376            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3377            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3378            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3379            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3380            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3381            * @param  BurstBuffer: The Buffer address.
   3382            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3383            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3384            * @retval HAL status
   3385            */

   \                                 In section .text, align 2, keep-with-next
   3386          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3387                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3388          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4615             MOV      R5,R2
   3389            /* Check the parameters */
   3390            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3391            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3392            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3393            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3394            
   3395            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x4619             MOV      R1,R3
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xF000 0x8098      BEQ.W    ??HAL_TIM_DMABurst_WriteStart_0
   \   00000016   0x9F06             LDR      R7,[SP, #+24]
   3396            {
   3397               return HAL_BUSY;
   3398            }
   3399            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000018   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD106             BNE.N    ??HAL_TIM_DMABurst_WriteStart_1
   3400            {
   3401              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   \   00000020   0xB911             CBNZ.N   R1,??HAL_TIM_DMABurst_WriteStart_2
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xF040 0x808F      BNE.W    ??HAL_TIM_DMABurst_WriteStart_0
   3402              {
   3403                return HAL_ERROR;                                    
   3404              }
   3405              else
   3406              {
   3407                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   3408              }
   3409            }
   3410            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \   0000002E   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000032   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   \   00000034   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000038   0xD01E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \   0000003A   0xF5B5 0x6F80      CMP      R5,#+1024
   \   0000003E   0xD02A             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \   00000040   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000044   0xD036             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \   00000046   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000004A   0xD042             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \   0000004C   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000050   0xD04E             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \   00000052   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000056   0xD05A             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_9
   \   00000058   0xE069             B.N      ??HAL_TIM_DMABurst_WriteStart_10
   3411            {
   3412              case TIM_DMA_UPDATE:
   3413              {  
   3414                /* Set the DMA Period elapsed callback */
   3415                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \   0000005A   0x69E2             LDR      R2,[R4, #+28]
   \   0000005C   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000060   0x63D0             STR      R0,[R2, #+60]
   3416               
   3417                /* Set the DMA error callback */
   3418                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000062   0x69E2             LDR      R2,[R4, #+28]
   \   00000064   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000068   0x6490             STR      R0,[R2, #+72]
   3419            
   3420                /* Enable the DMA Stream */
   3421                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
   \   0000006A   0x0A38             LSRS     R0,R7,#+8
   \   0000006C   0x1C43             ADDS     R3,R0,#+1
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000074   0x69E0             LDR      R0,[R4, #+28]
   \   00000076   0xE058             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3422              }
   3423              break;
   3424              case TIM_DMA_CC1:
   3425              {  
   3426                /* Set the DMA Period elapsed callback */
   3427                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \   00000078   0x6A22             LDR      R2,[R4, #+32]
   \   0000007A   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   0000007E   0x63D0             STR      R0,[R2, #+60]
   3428               
   3429                /* Set the DMA error callback */
   3430                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000080   0x6A22             LDR      R2,[R4, #+32]
   \   00000082   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000086   0x6490             STR      R0,[R2, #+72]
   3431            
   3432                /* Enable the DMA Stream */
   3433                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   00000088   0x0A38             LSRS     R0,R7,#+8
   \   0000008A   0x1C43             ADDS     R3,R0,#+1
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000092   0x6A20             LDR      R0,[R4, #+32]
   \   00000094   0xE049             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3434              }
   3435              break;
   3436              case TIM_DMA_CC2:
   3437              {  
   3438                /* Set the DMA Period elapsed callback */
   3439                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \   00000096   0x6A62             LDR      R2,[R4, #+36]
   \   00000098   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   0000009C   0x63D0             STR      R0,[R2, #+60]
   3440               
   3441                /* Set the DMA error callback */
   3442                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000009E   0x6A62             LDR      R2,[R4, #+36]
   \   000000A0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000A4   0x6490             STR      R0,[R2, #+72]
   3443            
   3444                /* Enable the DMA Stream */
   3445                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   000000A6   0x0A38             LSRS     R0,R7,#+8
   \   000000A8   0x1C43             ADDS     R3,R0,#+1
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000B0   0x6A60             LDR      R0,[R4, #+36]
   \   000000B2   0xE03A             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3446              }
   3447              break;
   3448              case TIM_DMA_CC3:
   3449              {  
   3450                /* Set the DMA Period elapsed callback */
   3451                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \   000000B4   0x6AA2             LDR      R2,[R4, #+40]
   \   000000B6   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000BA   0x63D0             STR      R0,[R2, #+60]
   3452               
   3453                /* Set the DMA error callback */
   3454                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000BC   0x6AA2             LDR      R2,[R4, #+40]
   \   000000BE   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000C2   0x6490             STR      R0,[R2, #+72]
   3455            
   3456                /* Enable the DMA Stream */
   3457                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   000000C4   0x0A38             LSRS     R0,R7,#+8
   \   000000C6   0x1C43             ADDS     R3,R0,#+1
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000CE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D0   0xE02B             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3458              }
   3459              break;
   3460              case TIM_DMA_CC4:
   3461              {  
   3462                /* Set the DMA Period elapsed callback */
   3463                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \   000000D2   0x6AE2             LDR      R2,[R4, #+44]
   \   000000D4   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \   000000D8   0x63D0             STR      R0,[R2, #+60]
   3464               
   3465                /* Set the DMA error callback */
   3466                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000DA   0x6AE2             LDR      R2,[R4, #+44]
   \   000000DC   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000E0   0x6490             STR      R0,[R2, #+72]
   3467            
   3468                /* Enable the DMA Stream */
   3469                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   000000E2   0x0A38             LSRS     R0,R7,#+8
   \   000000E4   0x1C43             ADDS     R3,R0,#+1
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0xF100 0x024C      ADD      R2,R0,#+76
   \   000000EC   0x6AE0             LDR      R0,[R4, #+44]
   \   000000EE   0xE01C             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3470              }
   3471              break;
   3472              case TIM_DMA_COM:
   3473              {  
   3474                /* Set the DMA Period elapsed callback */
   3475                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \   000000F0   0x6B22             LDR      R2,[R4, #+48]
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \   000000F6   0x63D0             STR      R0,[R2, #+60]
   3476               
   3477                /* Set the DMA error callback */
   3478                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000F8   0x6B22             LDR      R2,[R4, #+48]
   \   000000FA   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FE   0x6490             STR      R0,[R2, #+72]
   3479            
   3480                /* Enable the DMA Stream */
   3481                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   00000100   0x0A38             LSRS     R0,R7,#+8
   \   00000102   0x1C43             ADDS     R3,R0,#+1
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0xF100 0x024C      ADD      R2,R0,#+76
   \   0000010A   0x6B20             LDR      R0,[R4, #+48]
   \   0000010C   0xE00D             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3482              }
   3483              break;
   3484              case TIM_DMA_TRIGGER:
   3485              {  
   3486                /* Set the DMA Period elapsed callback */
   3487                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \   0000010E   0x6B62             LDR      R2,[R4, #+52]
   \   00000110   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   00000114   0x63D0             STR      R0,[R2, #+60]
   3488               
   3489                /* Set the DMA error callback */
   3490                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000116   0x6B62             LDR      R2,[R4, #+52]
   \   00000118   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000011C   0x6490             STR      R0,[R2, #+72]
   3491            
   3492                /* Enable the DMA Stream */
   3493                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
   \   0000011E   0x0A38             LSRS     R0,R7,#+8
   \   00000120   0x1C43             ADDS     R3,R0,#+1
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0xF100 0x024C      ADD      R2,R0,#+76
   \   00000128   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_WriteStart_11: (+1)
   \   0000012A   0x.... 0x....      BL       HAL_DMA_Start_IT
   3494              }
   3495              break;
   3496              default:
   3497              break;  
   3498            }
   3499             /* configure the DMA Burst Mode */
   3500             htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \   0000012E   0x6821             LDR      R1,[R4, #+0]
   \   00000130   0xEA47 0x0006      ORR      R0,R7,R6
   \   00000134   0x6488             STR      R0,[R1, #+72]
   3501             
   3502             /* Enable the TIM DMA Request */
   3503             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x68C1             LDR      R1,[R0, #+12]
   \   0000013A   0x4329             ORRS     R1,R5,R1
   \   0000013C   0x60C1             STR      R1,[R0, #+12]
   3504             
   3505             htim->State = HAL_TIM_STATE_READY;
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0xF884 0x0039      STRB     R0,[R4, #+57]
   3506            
   3507            /* Return function status */
   3508            return HAL_OK;
   \   00000144   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \   00000146   0xB001             ADD      SP,SP,#+4
   \   00000148   0xBDF0             POP      {R4-R7,PC}       ;; return
   3509          }
   3510          
   3511          /**
   3512            * @brief  Stops the TIM DMA Burst mode 
   3513            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3514            *                the configuration information for TIM module.
   3515            * @param  BurstRequestSrc: TIM DMA Request sources to disable
   3516            * @retval HAL status
   3517            */

   \                                 In section .text, align 2, keep-with-next
   3518          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3519          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   3520            /* Check the parameters */
   3521            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3522            
   3523            /* Abort the DMA transfer (at least disable the DMA channel) */
   3524            switch(BurstRequestSrc)
   \   00000004   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_0
   \   0000000E   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000012   0xD011             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_1
   \   00000014   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000018   0xD010             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_2
   \   0000001A   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000001E   0xD00F             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_3
   \   00000020   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000024   0xD00E             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_4
   \   00000026   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000002A   0xD00D             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_5
   \   0000002C   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000030   0xD00C             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_6
   \   00000032   0xE00E             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3525            {
   3526              case TIM_DMA_UPDATE:
   3527              {  
   3528                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0xE00A             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3529              }
   3530              break;
   3531              case TIM_DMA_CC1:
   3532              {  
   3533                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1: (+1)
   \   00000038   0x6A20             LDR      R0,[R4, #+32]
   \   0000003A   0xE008             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3534              }
   3535              break;
   3536              case TIM_DMA_CC2:
   3537              {  
   3538                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2: (+1)
   \   0000003C   0x6A60             LDR      R0,[R4, #+36]
   \   0000003E   0xE006             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3539              }
   3540              break;
   3541              case TIM_DMA_CC3:
   3542              {  
   3543                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3: (+1)
   \   00000040   0x6AA0             LDR      R0,[R4, #+40]
   \   00000042   0xE004             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3544              }
   3545              break;
   3546              case TIM_DMA_CC4:
   3547              {  
   3548                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4: (+1)
   \   00000044   0x6AE0             LDR      R0,[R4, #+44]
   \   00000046   0xE002             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3549              }
   3550              break;
   3551              case TIM_DMA_COM:
   3552              {  
   3553                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5: (+1)
   \   00000048   0x6B20             LDR      R0,[R4, #+48]
   \   0000004A   0xE000             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3554              }
   3555              break;
   3556              case TIM_DMA_TRIGGER:
   3557              {  
   3558                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_6: (+1)
   \   0000004C   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_WriteStop_8: (+1)
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3559              }
   3560              break;
   3561              default:
   3562              break;
   3563            }
   3564          
   3565            /* Disable the TIM Update DMA request */
   3566            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_WriteStop_7: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0x43A9             BICS     R1,R1,R5
   \   00000058   0x60C1             STR      R1,[R0, #+12]
   3567                
   3568            /* Return function status */
   3569            return HAL_OK;  
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xB001             ADD      SP,SP,#+4
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
   3570          }
   3571          
   3572          /**
   3573            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3574            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3575            *                the configuration information for TIM module.
   3576            * @param  BurstBaseAddress: TIM Base address from when the DMA will starts the Data read.
   3577            *         This parameters can be on of the following values:
   3578            *            @arg TIM_DMABASE_CR1  
   3579            *            @arg TIM_DMABASE_CR2
   3580            *            @arg TIM_DMABASE_SMCR
   3581            *            @arg TIM_DMABASE_DIER
   3582            *            @arg TIM_DMABASE_SR
   3583            *            @arg TIM_DMABASE_EGR
   3584            *            @arg TIM_DMABASE_CCMR1
   3585            *            @arg TIM_DMABASE_CCMR2
   3586            *            @arg TIM_DMABASE_CCER
   3587            *            @arg TIM_DMABASE_CNT   
   3588            *            @arg TIM_DMABASE_PSC   
   3589            *            @arg TIM_DMABASE_ARR
   3590            *            @arg TIM_DMABASE_RCR
   3591            *            @arg TIM_DMABASE_CCR1
   3592            *            @arg TIM_DMABASE_CCR2
   3593            *            @arg TIM_DMABASE_CCR3  
   3594            *            @arg TIM_DMABASE_CCR4
   3595            *            @arg TIM_DMABASE_BDTR
   3596            *            @arg TIM_DMABASE_DCR
   3597            * @param  BurstRequestSrc: TIM DMA Request sources.
   3598            *         This parameters can be on of the following values:
   3599            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3600            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3601            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3602            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3603            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3604            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3605            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3606            * @param  BurstBuffer: The Buffer address.
   3607            * @param  BurstLength: DMA Burst length. This parameter can be one value
   3608            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3609            * @retval HAL status
   3610            */

   \                                 In section .text, align 2, keep-with-next
   3611          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3612                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3613          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x460E             MOV      R6,R1
   3614            /* Check the parameters */
   3615            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3616            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3617            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3618            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3619            
   3620            if((htim->State == HAL_TIM_STATE_BUSY))
   \   0000000A   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000000E   0x461A             MOV      R2,R3
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xF000 0x8098      BEQ.W    ??HAL_TIM_DMABurst_ReadStart_0
   \   00000016   0x9F06             LDR      R7,[SP, #+24]
   3621            {
   3622               return HAL_BUSY;
   3623            }
   3624            else if((htim->State == HAL_TIM_STATE_READY))
   \   00000018   0xF994 0x0039      LDRSB    R0,[R4, #+57]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD106             BNE.N    ??HAL_TIM_DMABurst_ReadStart_1
   3625            {
   3626              if((BurstBuffer == 0 ) && (BurstLength > 0)) 
   \   00000020   0xB912             CBNZ.N   R2,??HAL_TIM_DMABurst_ReadStart_2
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0xF040 0x808F      BNE.W    ??HAL_TIM_DMABurst_ReadStart_0
   3627              {
   3628                return HAL_ERROR;                                    
   3629              }
   3630              else
   3631              {
   3632                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   3633              }
   3634            }  
   3635            switch(BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \   0000002E   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000032   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   \   00000034   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000038   0xD01E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \   0000003A   0xF5B5 0x6F80      CMP      R5,#+1024
   \   0000003E   0xD02A             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \   00000040   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000044   0xD036             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \   00000046   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000004A   0xD042             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \   0000004C   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000050   0xD04E             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \   00000052   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000056   0xD05A             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_9
   \   00000058   0xE069             B.N      ??HAL_TIM_DMABurst_ReadStart_10
   3636            {
   3637              case TIM_DMA_UPDATE:
   3638              {  
   3639                /* Set the DMA Period elapsed callback */
   3640                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \   0000005A   0x69E1             LDR      R1,[R4, #+28]
   \   0000005C   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \   00000060   0x63C8             STR      R0,[R1, #+60]
   3641               
   3642                /* Set the DMA error callback */
   3643                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000062   0x69E1             LDR      R1,[R4, #+28]
   \   00000064   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000068   0x6488             STR      R0,[R1, #+72]
   3644            
   3645                /* Enable the DMA Stream */
   3646                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   \   0000006A   0x0A38             LSRS     R0,R7,#+8
   \   0000006C   0x1C43             ADDS     R3,R0,#+1
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000074   0x69E0             LDR      R0,[R4, #+28]
   \   00000076   0xE058             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3647              }
   3648              break;
   3649              case TIM_DMA_CC1:
   3650              {  
   3651                /* Set the DMA Period elapsed callback */
   3652                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \   00000078   0x6A21             LDR      R1,[R4, #+32]
   \   0000007A   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   0000007E   0x63C8             STR      R0,[R1, #+60]
   3653               
   3654                /* Set the DMA error callback */
   3655                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000080   0x6A21             LDR      R1,[R4, #+32]
   \   00000082   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   00000086   0x6488             STR      R0,[R1, #+72]
   3656            
   3657                /* Enable the DMA Stream */
   3658                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   00000088   0x0A38             LSRS     R0,R7,#+8
   \   0000008A   0x1C43             ADDS     R3,R0,#+1
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000092   0x6A20             LDR      R0,[R4, #+32]
   \   00000094   0xE049             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3659              }
   3660              break;
   3661              case TIM_DMA_CC2:
   3662              {  
   3663                /* Set the DMA Period elapsed callback */
   3664                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \   00000096   0x6A61             LDR      R1,[R4, #+36]
   \   00000098   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   0000009C   0x63C8             STR      R0,[R1, #+60]
   3665               
   3666                /* Set the DMA error callback */
   3667                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
   \   0000009E   0x6A61             LDR      R1,[R4, #+36]
   \   000000A0   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000A4   0x6488             STR      R0,[R1, #+72]
   3668            
   3669                /* Enable the DMA Stream */
   3670                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
   \   000000A6   0x0A38             LSRS     R0,R7,#+8
   \   000000A8   0x1C43             ADDS     R3,R0,#+1
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000B0   0x6A60             LDR      R0,[R4, #+36]
   \   000000B2   0xE03A             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3671              }
   3672              break;
   3673              case TIM_DMA_CC3:
   3674              {  
   3675                /* Set the DMA Period elapsed callback */
   3676                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \   000000B4   0x6AA1             LDR      R1,[R4, #+40]
   \   000000B6   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000BA   0x63C8             STR      R0,[R1, #+60]
   3677               
   3678                /* Set the DMA error callback */
   3679                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000BC   0x6AA1             LDR      R1,[R4, #+40]
   \   000000BE   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000C2   0x6488             STR      R0,[R1, #+72]
   3680            
   3681                /* Enable the DMA Stream */
   3682                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   000000C4   0x0A38             LSRS     R0,R7,#+8
   \   000000C6   0x1C43             ADDS     R3,R0,#+1
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000CE   0x6AA0             LDR      R0,[R4, #+40]
   \   000000D0   0xE02B             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3683              }
   3684              break;
   3685              case TIM_DMA_CC4:
   3686              {  
   3687                /* Set the DMA Period elapsed callback */
   3688                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \   000000D2   0x6AE1             LDR      R1,[R4, #+44]
   \   000000D4   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \   000000D8   0x63C8             STR      R0,[R1, #+60]
   3689               
   3690                /* Set the DMA error callback */
   3691                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000DA   0x6AE1             LDR      R1,[R4, #+44]
   \   000000DC   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000E0   0x6488             STR      R0,[R1, #+72]
   3692            
   3693                /* Enable the DMA Stream */
   3694                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   000000E2   0x0A38             LSRS     R0,R7,#+8
   \   000000E4   0x1C43             ADDS     R3,R0,#+1
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0xF100 0x014C      ADD      R1,R0,#+76
   \   000000EC   0x6AE0             LDR      R0,[R4, #+44]
   \   000000EE   0xE01C             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3695              }
   3696              break;
   3697              case TIM_DMA_COM:
   3698              {  
   3699                /* Set the DMA Period elapsed callback */
   3700                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \   000000F0   0x6B21             LDR      R1,[R4, #+48]
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable37_1
   \   000000F6   0x63C8             STR      R0,[R1, #+60]
   3701               
   3702                /* Set the DMA error callback */
   3703                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
   \   000000F8   0x6B21             LDR      R1,[R4, #+48]
   \   000000FA   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   000000FE   0x6488             STR      R0,[R1, #+72]
   3704            
   3705                /* Enable the DMA Stream */
   3706                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   00000100   0x0A38             LSRS     R0,R7,#+8
   \   00000102   0x1C43             ADDS     R3,R0,#+1
   \   00000104   0x6820             LDR      R0,[R4, #+0]
   \   00000106   0xF100 0x014C      ADD      R1,R0,#+76
   \   0000010A   0x6B20             LDR      R0,[R4, #+48]
   \   0000010C   0xE00D             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   3707              }
   3708              break;
   3709              case TIM_DMA_TRIGGER:
   3710              {  
   3711                /* Set the DMA Period elapsed callback */
   3712                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \   0000010E   0x6B61             LDR      R1,[R4, #+52]
   \   00000110   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \   00000114   0x63C8             STR      R0,[R1, #+60]
   3713               
   3714                /* Set the DMA error callback */
   3715                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
   \   00000116   0x6B61             LDR      R1,[R4, #+52]
   \   00000118   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \   0000011C   0x6488             STR      R0,[R1, #+72]
   3716            
   3717                /* Enable the DMA Stream */
   3718                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
   \   0000011E   0x0A38             LSRS     R0,R7,#+8
   \   00000120   0x1C43             ADDS     R3,R0,#+1
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0xF100 0x014C      ADD      R1,R0,#+76
   \   00000128   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_ReadStart_11: (+1)
   \   0000012A   0x.... 0x....      BL       HAL_DMA_Start_IT
   3719              }
   3720              break;
   3721              default:
   3722              break;  
   3723            }
   3724          
   3725            /* configure the DMA Burst Mode */
   3726            htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \   0000012E   0x6821             LDR      R1,[R4, #+0]
   \   00000130   0xEA47 0x0006      ORR      R0,R7,R6
   \   00000134   0x6488             STR      R0,[R1, #+72]
   3727            
   3728            /* Enable the TIM DMA Request */
   3729            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x68C1             LDR      R1,[R0, #+12]
   \   0000013A   0x4329             ORRS     R1,R5,R1
   \   0000013C   0x60C1             STR      R1,[R0, #+12]
   3730            
   3731            htim->State = HAL_TIM_STATE_READY;
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0xF884 0x0039      STRB     R0,[R4, #+57]
   3732            
   3733            /* Return function status */
   3734            return HAL_OK;
   \   00000144   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \   00000146   0xB001             ADD      SP,SP,#+4
   \   00000148   0xBDF0             POP      {R4-R7,PC}       ;; return
   3735          }
   3736          
   3737          /**
   3738            * @brief  Stop the DMA burst reading 
   3739            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3740            *                the configuration information for TIM module.
   3741            * @param  BurstRequestSrc: TIM DMA Request sources to disable.
   3742            * @retval HAL status
   3743            */

   \                                 In section .text, align 2, keep-with-next
   3744          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3745          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x460D             MOV      R5,R1
   3746            /* Check the parameters */
   3747            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3748            
   3749            /* Abort the DMA transfer (at least disable the DMA channel) */
   3750            switch(BurstRequestSrc)
   \   00000004   0xF5B5 0x7F80      CMP      R5,#+256
   \   00000008   0xB081             SUB      SP,SP,#+4
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_0
   \   0000000E   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000012   0xD011             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_1
   \   00000014   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000018   0xD010             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_2
   \   0000001A   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000001E   0xD00F             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_3
   \   00000020   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000024   0xD00E             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_4
   \   00000026   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000002A   0xD00D             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_5
   \   0000002C   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000030   0xD00C             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_6
   \   00000032   0xE00E             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   3751            {
   3752              case TIM_DMA_UPDATE:
   3753              {  
   3754                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0: (+1)
   \   00000034   0x69E0             LDR      R0,[R4, #+28]
   \   00000036   0xE00A             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3755              }
   3756              break;
   3757              case TIM_DMA_CC1:
   3758              {  
   3759                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1: (+1)
   \   00000038   0x6A20             LDR      R0,[R4, #+32]
   \   0000003A   0xE008             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3760              }
   3761              break;
   3762              case TIM_DMA_CC2:
   3763              {  
   3764                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2: (+1)
   \   0000003C   0x6A60             LDR      R0,[R4, #+36]
   \   0000003E   0xE006             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3765              }
   3766              break;
   3767              case TIM_DMA_CC3:
   3768              {  
   3769                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3: (+1)
   \   00000040   0x6AA0             LDR      R0,[R4, #+40]
   \   00000042   0xE004             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3770              }
   3771              break;
   3772              case TIM_DMA_CC4:
   3773              {  
   3774                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4: (+1)
   \   00000044   0x6AE0             LDR      R0,[R4, #+44]
   \   00000046   0xE002             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3775              }
   3776              break;
   3777              case TIM_DMA_COM:
   3778              {  
   3779                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5: (+1)
   \   00000048   0x6B20             LDR      R0,[R4, #+48]
   \   0000004A   0xE000             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   3780              }
   3781              break;
   3782              case TIM_DMA_TRIGGER:
   3783              {  
   3784                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_6: (+1)
   \   0000004C   0x6B60             LDR      R0,[R4, #+52]
   \                     ??HAL_TIM_DMABurst_ReadStop_8: (+1)
   \   0000004E   0x.... 0x....      BL       HAL_DMA_Abort
   3785              }
   3786              break;
   3787              default:
   3788              break;  
   3789            }
   3790            
   3791            /* Disable the TIM Update DMA request */
   3792            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \                     ??HAL_TIM_DMABurst_ReadStop_7: (+1)
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0x43A9             BICS     R1,R1,R5
   \   00000058   0x60C1             STR      R1,[R0, #+12]
   3793                
   3794            /* Return function status */
   3795            return HAL_OK;  
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xB001             ADD      SP,SP,#+4
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
   3796          }
   3797          
   3798          /**
   3799            * @brief  Generate a software event
   3800            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3801            *                the configuration information for TIM module.
   3802            * @param  EventSource: specifies the event source.
   3803            *          This parameter can be one of the following values:
   3804            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3805            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3806            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3807            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3808            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3809            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source  
   3810            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3811            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3812            *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source  
   3813            * @note   TIM6 and TIM7 can only generate an update event. 
   3814            * @note   TIM_EVENTSOURCE_COM, TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are used only with TIM1 and TIM8.
   3815            * @retval HAL status
   3816            */ 
   3817          

   \                                 In section .text, align 2, keep-with-next
   3818          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3819          {
   3820            /* Check the parameters */
   3821            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3822            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3823            
   3824            /* Process Locked */
   3825            __HAL_LOCK(htim);
   \                     HAL_TIM_GenerateEvent: (+1)
   \   00000000   0xF990 0x2038      LDRSB    R2,[R0, #+56]
   \   00000004   0x2A01             CMP      R2,#+1
   \   00000006   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xF880 0x2038      STRB     R2,[R0, #+56]
   3826            
   3827            /* Change the TIM state */
   3828            htim->State = HAL_TIM_STATE_BUSY;
   \   00000012   0x2202             MOVS     R2,#+2
   \   00000014   0xF880 0x2039      STRB     R2,[R0, #+57]
   3829            
   3830            /* Set the event sources */
   3831            htim->Instance->EGR = EventSource;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6151             STR      R1,[R2, #+20]
   3832            
   3833            /* Change the TIM state */
   3834            htim->State = HAL_TIM_STATE_READY;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0xF880 0x1039      STRB     R1,[R0, #+57]
   3835            
   3836            __HAL_UNLOCK(htim);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF880 0x1038      STRB     R1,[R0, #+56]
   3837            
   3838            /* Return function status */
   3839            return HAL_OK;  
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR               ;; return
   3840          }
   3841          
   3842          /**
   3843            * @brief  Configures the OCRef clear feature
   3844            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3845            *                the configuration information for TIM module.
   3846            * @param  sClearInputConfig: pointer to a TIM_ClearInputConfigTypeDef structure that
   3847            *         contains the OCREF clear feature and parameters for the TIM peripheral. 
   3848            * @param  Channel: specifies the TIM Channel.
   3849            *          This parameter can be one of the following values:
   3850            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3851            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3852            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3853            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3854            * @retval HAL status
   3855            */ 

   \                                 In section .text, align 4, keep-with-next
   3856          __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3857          { 
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   3858            /* Check the parameters */
   3859            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3860            assert_param(IS_TIM_CHANNELS(Channel));
   3861            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3862             
   3863            /* Process Locked */
   3864            __HAL_LOCK(htim);
   \   00000002   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD050             BEQ.N    ??HAL_TIM_ConfigOCrefClear_1
   \   0000000E   0x2301             MOVS     R3,#+1
   \   00000010   0xF880 0x3038      STRB     R3,[R0, #+56]
   3865            
   3866            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2302             MOVS     R3,#+2
   \   00000016   0xF880 0x3039      STRB     R3,[R0, #+57]
   3867            
   3868            if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
   \   0000001A   0x684B             LDR      R3,[R1, #+4]
   \   0000001C   0x2B01             CMP      R3,#+1
   \   0000001E   0xD10B             BNE.N    ??HAL_TIM_ConfigOCrefClear_2
   3869            {
   3870              assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3871              assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3872              assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3873            
   3874              TIM_ETR_SetConfig(htim->Instance, 
   3875                                sClearInputConfig->ClearInputPrescaler,
   3876                                sClearInputConfig->ClearInputPolarity,
   3877                                sClearInputConfig->ClearInputFilter);
   \   00000020   0x6806             LDR      R6,[R0, #+0]
   \   00000022   0x690B             LDR      R3,[R1, #+16]
   \   00000024   0x688C             LDR      R4,[R1, #+8]
   \   00000026   0x68CD             LDR      R5,[R1, #+12]
   \   00000028   0x68B7             LDR      R7,[R6, #+8]
   \   0000002A   0xF427 0x477F      BIC      R7,R7,#0xFF00
   \   0000002E   0x433D             ORRS     R5,R5,R7
   \   00000030   0x432C             ORRS     R4,R4,R5
   \   00000032   0xEA44 0x2303      ORR      R3,R4,R3, LSL #+8
   \   00000036   0x60B3             STR      R3,[R6, #+8]
   3878            }
   3879            
   3880            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \   00000038   0x2A0C             CMP      R2,#+12
   \   0000003A   0xD832             BHI.N    ??HAL_TIM_ConfigOCrefClear_3
   \   0000003C   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_TIM_ConfigOCrefClear_0:
   \   00000040   0x07 0x31          DC8      0x7,0x31,0x31,0x31
   \              0x31 0x31    
   \   00000044   0x12 0x31          DC8      0x12,0x31,0x31,0x31
   \              0x31 0x31    
   \   00000048   0x1D 0x31          DC8      0x1D,0x31,0x31,0x31
   \              0x31 0x31    
   \   0000004C   0x27 0x00          DC8      0x27,0x0
   3881            {
   3882              case TIM_CHANNEL_1:
   3883              {        
   3884                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x2900             CMP      R1,#+0
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x698A             LDR      R2,[R1, #+24]
   \   00000056   0xBF0C             ITE      EQ 
   \   00000058   0xF022 0x0280      BICEQ    R2,R2,#0x80
   \   0000005C   0xF042 0x0280      ORRNE    R2,R2,#0x80
   3885                {
   3886                  /* Enable the Ocref clear feature for Channel 1 */
   3887                  htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   3888                }
   3889                else
   3890                {
   3891                  /* Disable the Ocref clear feature for Channel 1 */
   3892                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
   \   00000060   0x618A             STR      R2,[R1, #+24]
   \   00000062   0xE01E             B.N      ??HAL_TIM_ConfigOCrefClear_3
   3893                }
   3894              }    
   3895              break;
   3896              case TIM_CHANNEL_2:    
   3897              { 
   3898                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   3899                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x2900             CMP      R1,#+0
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x698A             LDR      R2,[R1, #+24]
   \   0000006C   0xBF14             ITE      NE 
   \   0000006E   0xF442 0x4200      ORRNE    R2,R2,#0x8000
   \   00000072   0xF422 0x4200      BICEQ    R2,R2,#0x8000
   3900                {
   3901                  /* Enable the Ocref clear feature for Channel 2 */
   3902                  htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   3903                }
   3904                else
   3905                {
   3906                  /* Disable the Ocref clear feature for Channel 2 */
   3907                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
   \   00000076   0x618A             STR      R2,[R1, #+24]
   \   00000078   0xE013             B.N      ??HAL_TIM_ConfigOCrefClear_3
   3908                }
   3909              } 
   3910              break;
   3911              case TIM_CHANNEL_3:   
   3912              {  
   3913                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3914                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0x69CA             LDR      R2,[R1, #+28]
   \   00000082   0xBF0C             ITE      EQ 
   \   00000084   0xF022 0x0280      BICEQ    R2,R2,#0x80
   \   00000088   0xF042 0x0280      ORRNE    R2,R2,#0x80
   3915                {
   3916                  /* Enable the Ocref clear feature for Channel 3 */
   3917                  htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   3918                }
   3919                else
   3920                {
   3921                  /* Disable the Ocref clear feature for Channel 3 */
   3922                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
   \   0000008C   0xE008             B.N      ??HAL_TIM_ConfigOCrefClear_7
   3923                }
   3924              } 
   3925              break;
   3926              case TIM_CHANNEL_4:    
   3927              {  
   3928                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3929                if(sClearInputConfig->ClearInputState != RESET)  
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \   0000008E   0x6809             LDR      R1,[R1, #+0]
   \   00000090   0x2900             CMP      R1,#+0
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0x69CA             LDR      R2,[R1, #+28]
   \   00000096   0xBF14             ITE      NE 
   \   00000098   0xF442 0x4200      ORRNE    R2,R2,#0x8000
   \   0000009C   0xF422 0x4200      BICEQ    R2,R2,#0x8000
   3930                {
   3931                  /* Enable the Ocref clear feature for Channel 4 */
   3932                  htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   3933                }
   3934                else
   3935                {
   3936                  /* Disable the Ocref clear feature for Channel 4 */
   3937                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \   000000A0   0x61CA             STR      R2,[R1, #+28]
   3938                }
   3939              } 
   3940              break;
   3941              default:  
   3942              break;
   3943            } 
   3944          
   3945            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0xF880 0x1039      STRB     R1,[R0, #+57]
   3946            
   3947            __HAL_UNLOCK(htim);
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0xF880 0x1038      STRB     R1,[R0, #+56]
   3948            
   3949            return HAL_OK;  
   \   000000AE   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \   000000B0   0xBCF0             POP      {R4-R7}
   \   000000B2   0x4770             BX       LR               ;; return
   3950          }  
   3951          
   3952          /**
   3953            * @brief   Configures the clock source to be used
   3954            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   3955            *                the configuration information for TIM module.
   3956            * @param  sClockSourceConfig: pointer to a TIM_ClockConfigTypeDef structure that
   3957            *         contains the clock source information for the TIM peripheral. 
   3958            * @retval HAL status
   3959            */ 

   \                                 In section .text, align 2, keep-with-next
   3960          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
   3961          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   3962            uint32_t tmpsmcr = 0;
   3963              
   3964            /* Process Locked */
   3965            __HAL_LOCK(htim);
   \   00000002   0xF990 0x2038      LDRSB    R2,[R0, #+56]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xF000 0x80C5      BEQ.W    ??HAL_TIM_ConfigClockSource_0
   \   00000010   0x2201             MOVS     R2,#+1
   3966            
   3967            htim->State = HAL_TIM_STATE_BUSY;
   3968            
   3969            /* Check the parameters */
   3970            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3971            
   3972            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3973            tmpsmcr = htim->Instance->SMCR;
   3974            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3975            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3976            htim->Instance->SMCR = tmpsmcr;
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable37_2  ;; 0xfffe0088
   \   00000016   0xF880 0x2038      STRB     R2,[R0, #+56]
   \   0000001A   0x2202             MOVS     R2,#+2
   \   0000001C   0xF880 0x2039      STRB     R2,[R0, #+57]
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0x6893             LDR      R3,[R2, #+8]
   \   00000024   0x4023             ANDS     R3,R4,R3
   \   00000026   0x6093             STR      R3,[R2, #+8]
   3977            
   3978            switch (sClockSourceConfig->ClockSource)
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xF000 0x8092      BEQ.W    ??HAL_TIM_ConfigClockSource_1
   \   00000030   0x2A10             CMP      R2,#+16
   \   00000032   0xF000 0x8096      BEQ.W    ??HAL_TIM_ConfigClockSource_2
   \   00000036   0x2A20             CMP      R2,#+32
   \   00000038   0xF000 0x809A      BEQ.W    ??HAL_TIM_ConfigClockSource_3
   \   0000003C   0x2A30             CMP      R2,#+48
   \   0000003E   0xF000 0x809E      BEQ.W    ??HAL_TIM_ConfigClockSource_4
   \   00000042   0x2A40             CMP      R2,#+64
   \   00000044   0xD06C             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \   00000046   0x2A50             CMP      R2,#+80
   \   00000048   0xD035             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \   0000004A   0x2A60             CMP      R2,#+96
   \   0000004C   0xD04D             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \   0000004E   0x2A70             CMP      R2,#+112
   \   00000050   0xD00C             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \   00000052   0xF5B2 0x5F80      CMP      R2,#+4096
   \   00000056   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_9
   \   00000058   0xF5B2 0x5F00      CMP      R2,#+8192
   \   0000005C   0xD01A             BEQ.N    ??HAL_TIM_ConfigClockSource_10
   \   0000005E   0xE095             B.N      ??HAL_TIM_ConfigClockSource_11
   3979            {
   3980              case TIM_CLOCKSOURCE_INTERNAL:
   3981              { 
   3982                assert_param(IS_TIM_INSTANCE(htim->Instance));      
   3983                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3984                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable37  ;; 0xfffefff8
   \   00000066   0x688A             LDR      R2,[R1, #+8]
   \   00000068   0x401A             ANDS     R2,R3,R2
   \   0000006A   0xE08E             B.N      ??HAL_TIM_ConfigClockSource_12
   3985              }
   3986              break;
   3987              
   3988              case TIM_CLOCKSOURCE_ETRMODE1:
   3989              {
   3990                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3991                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3992                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3993                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3994                /* Configure the ETR Clock source */
   3995                TIM_ETR_SetConfig(htim->Instance, 
   3996                                  sClockSourceConfig->ClockPrescaler, 
   3997                                  sClockSourceConfig->ClockPolarity, 
   3998                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \   0000006C   0x6804             LDR      R4,[R0, #+0]
   \   0000006E   0x68CA             LDR      R2,[R1, #+12]
   \   00000070   0x684B             LDR      R3,[R1, #+4]
   \   00000072   0x6889             LDR      R1,[R1, #+8]
   \   00000074   0x68A5             LDR      R5,[R4, #+8]
   \   00000076   0xF425 0x457F      BIC      R5,R5,#0xFF00
   \   0000007A   0x4329             ORRS     R1,R1,R5
   \   0000007C   0x4319             ORRS     R1,R3,R1
   3999                /* Get the TIMx SMCR register value */
   4000                tmpsmcr = htim->Instance->SMCR;
   4001                /* Reset the SMS and TS Bits */
   4002                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   4003                /* Select the External clock mode1 and the ETRF trigger */
   4004                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   4005                /* Write to TIMx SMCR */
   4006                htim->Instance->SMCR = tmpsmcr;
   \   0000007E   0x.... 0x....      LDR.W    R3,??DataTable37_3  ;; 0xfffeff88
   \   00000082   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000086   0x60A1             STR      R1,[R4, #+8]
   \   00000088   0x6801             LDR      R1,[R0, #+0]
   \   0000008A   0x688A             LDR      R2,[R1, #+8]
   \   0000008C   0x401A             ANDS     R2,R3,R2
   \   0000008E   0xF042 0x0277      ORR      R2,R2,#0x77
   \   00000092   0xE07A             B.N      ??HAL_TIM_ConfigClockSource_12
   4007              }
   4008              break;
   4009              
   4010              case TIM_CLOCKSOURCE_ETRMODE2:
   4011              {
   4012                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4013                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4014                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4015                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4016                
   4017                /* Configure the ETR Clock source */
   4018                TIM_ETR_SetConfig(htim->Instance, 
   4019                                  sClockSourceConfig->ClockPrescaler, 
   4020                                  sClockSourceConfig->ClockPolarity,
   4021                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \   00000094   0x6804             LDR      R4,[R0, #+0]
   \   00000096   0x68CA             LDR      R2,[R1, #+12]
   \   00000098   0x684B             LDR      R3,[R1, #+4]
   \   0000009A   0x6889             LDR      R1,[R1, #+8]
   \   0000009C   0x68A5             LDR      R5,[R4, #+8]
   \   0000009E   0xF425 0x457F      BIC      R5,R5,#0xFF00
   \   000000A2   0x4329             ORRS     R1,R1,R5
   \   000000A4   0x4319             ORRS     R1,R3,R1
   \   000000A6   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000AA   0x60A1             STR      R1,[R4, #+8]
   4022                /* Enable the External clock mode2 */
   4023                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \   000000AC   0x6801             LDR      R1,[R0, #+0]
   \   000000AE   0x688A             LDR      R2,[R1, #+8]
   \   000000B0   0xF442 0x4280      ORR      R2,R2,#0x4000
   \   000000B4   0xE069             B.N      ??HAL_TIM_ConfigClockSource_12
   4024              }
   4025              break;
   4026              
   4027              case TIM_CLOCKSOURCE_TI1:
   4028              {
   4029                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4030            
   4031                /* Check TI1 input conditioning related parameters */
   4032                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4033                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4034          
   4035                TIM_TI1_ConfigInputStage(htim->Instance, 
   4036                                  sClockSourceConfig->ClockPolarity, 
   4037                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \   000000B6   0x68CA             LDR      R2,[R1, #+12]
   \   000000B8   0x684B             LDR      R3,[R1, #+4]
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0x3118             ADDS     R1,R1,#+24
   \   000000BE   0x688C             LDR      R4,[R1, #+8]
   \   000000C0   0x688D             LDR      R5,[R1, #+8]
   \   000000C2   0x086D             LSRS     R5,R5,#+1
   \   000000C4   0x006D             LSLS     R5,R5,#+1
   \   000000C6   0x608D             STR      R5,[R1, #+8]
   \   000000C8   0x680D             LDR      R5,[R1, #+0]
   \   000000CA   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   000000CE   0xEA45 0x1202      ORR      R2,R5,R2, LSL #+4
   \   000000D2   0x600A             STR      R2,[R1, #+0]
   \   000000D4   0xF024 0x020A      BIC      R2,R4,#0xA
   \   000000D8   0x431A             ORRS     R2,R3,R2
   \   000000DA   0x608A             STR      R2,[R1, #+8]
   4038                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0x688A             LDR      R2,[R1, #+8]
   \   000000E0   0xF022 0x0270      BIC      R2,R2,#0x70
   \   000000E4   0xF042 0x0257      ORR      R2,R2,#0x57
   \   000000E8   0xE04F             B.N      ??HAL_TIM_ConfigClockSource_12
   4039              }
   4040              break;
   4041              case TIM_CLOCKSOURCE_TI2:
   4042              {
   4043                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4044                
   4045                /* Check TI1 input conditioning related parameters */
   4046                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4047                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4048          
   4049                TIM_TI2_ConfigInputStage(htim->Instance, 
   4050                                  sClockSourceConfig->ClockPolarity, 
   4051                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \   000000EA   0x68CA             LDR      R2,[R1, #+12]
   \   000000EC   0x684B             LDR      R3,[R1, #+4]
   \   000000EE   0x6801             LDR      R1,[R0, #+0]
   \   000000F0   0x3118             ADDS     R1,R1,#+24
   \   000000F2   0x688C             LDR      R4,[R1, #+8]
   \   000000F4   0xF024 0x0410      BIC      R4,R4,#0x10
   \   000000F8   0x608C             STR      R4,[R1, #+8]
   \   000000FA   0x680C             LDR      R4,[R1, #+0]
   \   000000FC   0x688D             LDR      R5,[R1, #+8]
   \   000000FE   0xF424 0x4470      BIC      R4,R4,#0xF000
   \   00000102   0xEA44 0x3202      ORR      R2,R4,R2, LSL #+12
   \   00000106   0x600A             STR      R2,[R1, #+0]
   \   00000108   0xF025 0x02A0      BIC      R2,R5,#0xA0
   \   0000010C   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \   00000110   0x608A             STR      R2,[R1, #+8]
   4052                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \   00000112   0x6801             LDR      R1,[R0, #+0]
   \   00000114   0x688A             LDR      R2,[R1, #+8]
   \   00000116   0xF022 0x0270      BIC      R2,R2,#0x70
   \   0000011A   0xF042 0x0267      ORR      R2,R2,#0x67
   \   0000011E   0xE034             B.N      ??HAL_TIM_ConfigClockSource_12
   4053              }
   4054              break;
   4055              case TIM_CLOCKSOURCE_TI1ED:
   4056              {
   4057                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4058                /* Check TI1 input conditioning related parameters */
   4059                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4060                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4061            
   4062                TIM_TI1_ConfigInputStage(htim->Instance, 
   4063                                  sClockSourceConfig->ClockPolarity,
   4064                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \   00000120   0x68CA             LDR      R2,[R1, #+12]
   \   00000122   0x684B             LDR      R3,[R1, #+4]
   \   00000124   0x6801             LDR      R1,[R0, #+0]
   \   00000126   0x3118             ADDS     R1,R1,#+24
   \   00000128   0x688C             LDR      R4,[R1, #+8]
   \   0000012A   0x688D             LDR      R5,[R1, #+8]
   \   0000012C   0x086D             LSRS     R5,R5,#+1
   \   0000012E   0x006D             LSLS     R5,R5,#+1
   \   00000130   0x608D             STR      R5,[R1, #+8]
   \   00000132   0x680D             LDR      R5,[R1, #+0]
   \   00000134   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000138   0xEA45 0x1202      ORR      R2,R5,R2, LSL #+4
   \   0000013C   0x600A             STR      R2,[R1, #+0]
   \   0000013E   0xF024 0x020A      BIC      R2,R4,#0xA
   \   00000142   0x431A             ORRS     R2,R3,R2
   \   00000144   0x608A             STR      R2,[R1, #+8]
   4065                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \   00000146   0x6801             LDR      R1,[R0, #+0]
   \   00000148   0x688A             LDR      R2,[R1, #+8]
   \   0000014A   0xF022 0x0270      BIC      R2,R2,#0x70
   \   0000014E   0xF042 0x0247      ORR      R2,R2,#0x47
   \   00000152   0xE01A             B.N      ??HAL_TIM_ConfigClockSource_12
   4066              }
   4067              break;
   4068              case TIM_CLOCKSOURCE_ITR0:
   4069              {
   4070                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4071                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \   00000154   0x6801             LDR      R1,[R0, #+0]
   \   00000156   0x688A             LDR      R2,[R1, #+8]
   \   00000158   0xF022 0x0270      BIC      R2,R2,#0x70
   \   0000015C   0xF042 0x0207      ORR      R2,R2,#0x7
   \   00000160   0xE013             B.N      ??HAL_TIM_ConfigClockSource_12
   4072              }
   4073              break;
   4074              case TIM_CLOCKSOURCE_ITR1:
   4075              {
   4076                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4077                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \   00000162   0x6801             LDR      R1,[R0, #+0]
   \   00000164   0x688A             LDR      R2,[R1, #+8]
   \   00000166   0xF022 0x0270      BIC      R2,R2,#0x70
   \   0000016A   0xF042 0x0217      ORR      R2,R2,#0x17
   \   0000016E   0xE00C             B.N      ??HAL_TIM_ConfigClockSource_12
   4078              }
   4079              break;
   4080              case TIM_CLOCKSOURCE_ITR2:
   4081              {
   4082                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4083                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \   00000170   0x6801             LDR      R1,[R0, #+0]
   \   00000172   0x688A             LDR      R2,[R1, #+8]
   \   00000174   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000178   0xF042 0x0227      ORR      R2,R2,#0x27
   \   0000017C   0xE005             B.N      ??HAL_TIM_ConfigClockSource_12
   4084              }
   4085              break;
   4086              case TIM_CLOCKSOURCE_ITR3:
   4087              {
   4088                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4089                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \   0000017E   0x6801             LDR      R1,[R0, #+0]
   \   00000180   0x688A             LDR      R2,[R1, #+8]
   \   00000182   0xF022 0x0270      BIC      R2,R2,#0x70
   \   00000186   0xF042 0x0237      ORR      R2,R2,#0x37
   \                     ??HAL_TIM_ConfigClockSource_12: (+1)
   \   0000018A   0x608A             STR      R2,[R1, #+8]
   4090              }
   4091              break;
   4092              
   4093              default:
   4094              break;    
   4095            }
   4096            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_11: (+1)
   \   0000018C   0x2101             MOVS     R1,#+1
   \   0000018E   0xF880 0x1039      STRB     R1,[R0, #+57]
   4097            
   4098            __HAL_UNLOCK(htim);
   \   00000192   0x2100             MOVS     R1,#+0
   \   00000194   0xF880 0x1038      STRB     R1,[R0, #+56]
   4099            
   4100            return HAL_OK;
   \   00000198   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \   0000019A   0xBC30             POP      {R4,R5}
   \   0000019C   0x4770             BX       LR               ;; return
   4101          }
   4102          
   4103          /**
   4104            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4105            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4106            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4107            *                the configuration information for TIM module.
   4108            * @param  TI1_Selection: Indicate whether or not channel 1 is connected to the
   4109            *         output of a XOR gate.
   4110            *         This parameter can be one of the following values:
   4111            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4112            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4113            *            pins are connected to the TI1 input (XOR combination)
   4114            * @retval HAL status
   4115            */

   \                                 In section .text, align 2, keep-with-next
   4116          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4117          {
   4118            uint32_t tmpcr2 = 0;
   4119            
   4120            /* Check the parameters */
   4121            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
   4122            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4123          
   4124            /* Get the TIMx CR2 register value */
   4125            tmpcr2 = htim->Instance->CR2;
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6842             LDR      R2,[R0, #+4]
   4126          
   4127            /* Reset the TI1 selection */
   4128            tmpcr2 &= ~TIM_CR2_TI1S;
   4129          
   4130            /* Set the TI1 selection */
   4131            tmpcr2 |= TI1_Selection;
   4132            
   4133            /* Write to TIMxCR2 */
   4134            htim->Instance->CR2 = tmpcr2;
   \   00000004   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   4135          
   4136            return HAL_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   4137          }
   4138          
   4139          /**
   4140            * @brief  Configures the TIM in Slave mode
   4141            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4142            *                the configuration information for TIM module.
   4143            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4144            *         contains the selected trigger (internal trigger input, filtered
   4145            *         timer input or external trigger input) and the ) and the Slave 
   4146            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4147            * @retval HAL status
   4148            */

   \                                 In section .text, align 2, keep-with-next
   4149          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4150          {
   \                     HAL_TIM_SlaveConfigSynchronization: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4151            uint32_t tmpsmcr  = 0;
   4152            uint32_t tmpccmr1 = 0;
   4153            uint32_t tmpccer = 0;
   4154          
   4155            /* Check the parameters */
   4156            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4157            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4158            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4159             
   4160            __HAL_LOCK(htim);
   \   00000002   0xF990 0x2038      LDRSB    R2,[R0, #+56]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD066             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_0
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x2038      STRB     R2,[R0, #+56]
   4161            
   4162            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0xF880 0x2039      STRB     R2,[R0, #+57]
   4163          
   4164            /* Get the TIMx SMCR register value */
   4165            tmpsmcr = htim->Instance->SMCR;
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6893             LDR      R3,[R2, #+8]
   4166          
   4167            /* Reset the Trigger Selection Bits */
   4168            tmpsmcr &= ~TIM_SMCR_TS;
   4169            /* Set the Input Trigger source */
   4170            tmpsmcr |= sSlaveConfig->InputTrigger;
   4171          
   4172            /* Reset the slave mode Bits */
   4173            tmpsmcr &= ~TIM_SMCR_SMS;
   4174            /* Set the slave mode */
   4175            tmpsmcr |= sSlaveConfig->SlaveMode;
   4176          
   4177            /* Write to TIMx SMCR */
   4178            htim->Instance->SMCR = tmpsmcr;
   \   0000001E   0x684C             LDR      R4,[R1, #+4]
   \   00000020   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000024   0x4323             ORRS     R3,R4,R3
   \   00000026   0x.... 0x....      LDR.W    R4,??DataTable37  ;; 0xfffefff8
   \   0000002A   0x4023             ANDS     R3,R4,R3
   \   0000002C   0x680C             LDR      R4,[R1, #+0]
   \   0000002E   0x4323             ORRS     R3,R4,R3
   \   00000030   0x6093             STR      R3,[R2, #+8]
   4179            
   4180            /* Configure the trigger prescaler, filter, and polarity */
   4181            switch (sSlaveConfig->InputTrigger)
   \   00000032   0x684A             LDR      R2,[R1, #+4]
   \   00000034   0x2A40             CMP      R2,#+64
   \   00000036   0xD012             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_1
   \   00000038   0x2A50             CMP      R2,#+80
   \   0000003A   0xD021             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_2
   \   0000003C   0x2A60             CMP      R2,#+96
   \   0000003E   0xD032             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_3
   \   00000040   0x2A70             CMP      R2,#+112
   \   00000042   0xD144             BNE.N    ??HAL_TIM_SlaveConfigSynchronization_4
   4182            {
   4183            case TIM_TS_ETRF:
   4184              {
   4185                /* Check the parameters */
   4186                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4187                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4188                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4189                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4190                /* Configure the ETR Trigger source */
   4191                TIM_ETR_SetConfig(htim->Instance, 
   4192                                  sSlaveConfig->TriggerPrescaler, 
   4193                                  sSlaveConfig->TriggerPolarity, 
   4194                                  sSlaveConfig->TriggerFilter);
   \   00000044   0x6804             LDR      R4,[R0, #+0]
   \   00000046   0x690A             LDR      R2,[R1, #+16]
   \   00000048   0x688B             LDR      R3,[R1, #+8]
   \   0000004A   0x68C9             LDR      R1,[R1, #+12]
   \   0000004C   0x68A5             LDR      R5,[R4, #+8]
   \   0000004E   0xF425 0x457F      BIC      R5,R5,#0xFF00
   \   00000052   0x4329             ORRS     R1,R1,R5
   \   00000054   0x4319             ORRS     R1,R3,R1
   \   00000056   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000005A   0x60A1             STR      R1,[R4, #+8]
   4195              }
   4196              break;
   \   0000005C   0xE037             B.N      ??HAL_TIM_SlaveConfigSynchronization_4
   4197              
   4198            case TIM_TS_TI1F_ED:
   4199              {
   4200                /* Check the parameters */
   4201                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4202                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4203                
   4204                /* Disable the Channel 1: Reset the CC1E Bit */
   4205                tmpccer = htim->Instance->CCER;
   \                     ??HAL_TIM_SlaveConfigSynchronization_1: (+1)
   \   0000005E   0x6802             LDR      R2,[R0, #+0]
   \   00000060   0x6A13             LDR      R3,[R2, #+32]
   4206                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \   00000062   0x6A14             LDR      R4,[R2, #+32]
   \   00000064   0x0864             LSRS     R4,R4,#+1
   \   00000066   0x0064             LSLS     R4,R4,#+1
   \   00000068   0x6214             STR      R4,[R2, #+32]
   4207                tmpccmr1 = htim->Instance->CCMR1;    
   \   0000006A   0x6802             LDR      R2,[R0, #+0]
   \   0000006C   0x6994             LDR      R4,[R2, #+24]
   4208                
   4209                /* Set the filter */
   4210                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4211                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   4212                
   4213                /* Write to TIMx CCMR1 and CCER registers */
   4214                htim->Instance->CCMR1 = tmpccmr1;
   \   0000006E   0x6909             LDR      R1,[R1, #+16]
   \   00000070   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   00000074   0xEA44 0x1101      ORR      R1,R4,R1, LSL #+4
   \   00000078   0x6191             STR      R1,[R2, #+24]
   4215                htim->Instance->CCER = tmpccer;                               
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0x620B             STR      R3,[R1, #+32]
   4216                                         
   4217              }
   4218              break;
   \   0000007E   0xE026             B.N      ??HAL_TIM_SlaveConfigSynchronization_4
   4219              
   4220            case TIM_TS_TI1FP1:
   4221              {
   4222                /* Check the parameters */
   4223                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4224                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4225                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4226          
   4227                /* Configure TI1 Filter and Polarity */
   4228                TIM_TI1_ConfigInputStage(htim->Instance,
   4229                                         sSlaveConfig->TriggerPolarity,
   4230                                         sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_2: (+1)
   \   00000080   0x690A             LDR      R2,[R1, #+16]
   \   00000082   0x688B             LDR      R3,[R1, #+8]
   \   00000084   0x6801             LDR      R1,[R0, #+0]
   \   00000086   0x3118             ADDS     R1,R1,#+24
   \   00000088   0x688C             LDR      R4,[R1, #+8]
   \   0000008A   0x688D             LDR      R5,[R1, #+8]
   \   0000008C   0x086D             LSRS     R5,R5,#+1
   \   0000008E   0x006D             LSLS     R5,R5,#+1
   \   00000090   0x608D             STR      R5,[R1, #+8]
   \   00000092   0x680D             LDR      R5,[R1, #+0]
   \   00000094   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000098   0xEA45 0x1202      ORR      R2,R5,R2, LSL #+4
   \   0000009C   0x600A             STR      R2,[R1, #+0]
   \   0000009E   0xF024 0x020A      BIC      R2,R4,#0xA
   \   000000A2   0x431A             ORRS     R2,R3,R2
   \   000000A4   0xE012             B.N      ??HAL_TIM_SlaveConfigSynchronization_5
   4231              }
   4232              break;
   4233              
   4234            case TIM_TS_TI2FP2:
   4235              {
   4236                /* Check the parameters */
   4237                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4238                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4239                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4240                
   4241                /* Configure TI2 Filter and Polarity */
   4242                TIM_TI2_ConfigInputStage(htim->Instance,
   4243                                          sSlaveConfig->TriggerPolarity,
   4244                                          sSlaveConfig->TriggerFilter);
   \                     ??HAL_TIM_SlaveConfigSynchronization_3: (+1)
   \   000000A6   0x690A             LDR      R2,[R1, #+16]
   \   000000A8   0x688B             LDR      R3,[R1, #+8]
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0x3118             ADDS     R1,R1,#+24
   \   000000AE   0x688C             LDR      R4,[R1, #+8]
   \   000000B0   0xF024 0x0410      BIC      R4,R4,#0x10
   \   000000B4   0x608C             STR      R4,[R1, #+8]
   \   000000B6   0x680C             LDR      R4,[R1, #+0]
   \   000000B8   0x688D             LDR      R5,[R1, #+8]
   \   000000BA   0xF424 0x4470      BIC      R4,R4,#0xF000
   \   000000BE   0xEA44 0x3202      ORR      R2,R4,R2, LSL #+12
   \   000000C2   0x600A             STR      R2,[R1, #+0]
   \   000000C4   0xF025 0x02A0      BIC      R2,R5,#0xA0
   \   000000C8   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \                     ??HAL_TIM_SlaveConfigSynchronization_5: (+1)
   \   000000CC   0x608A             STR      R2,[R1, #+8]
   4245              }
   4246              break;
   4247              
   4248            case TIM_TS_ITR0:
   4249              {
   4250                /* Check the parameter */
   4251                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4252              }
   4253              break;
   4254              
   4255            case TIM_TS_ITR1:
   4256              {
   4257                /* Check the parameter */
   4258                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4259              }
   4260              break;
   4261              
   4262            case TIM_TS_ITR2:
   4263              {
   4264                /* Check the parameter */
   4265                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4266              }
   4267              break;
   4268              
   4269            case TIM_TS_ITR3:
   4270              {
   4271                /* Check the parameter */
   4272                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4273              }
   4274              break;
   4275                 
   4276            default:
   4277              break;
   4278            }
   4279            
   4280            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_SlaveConfigSynchronization_4: (+1)
   \   000000CE   0x2101             MOVS     R1,#+1
   \   000000D0   0xF880 0x1039      STRB     R1,[R0, #+57]
   4281               
   4282            __HAL_UNLOCK(htim);  
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0xF880 0x1038      STRB     R1,[R0, #+56]
   4283            
   4284            return HAL_OK;
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_0: (+1)
   \   000000DC   0xBC30             POP      {R4,R5}
   \   000000DE   0x4770             BX       LR               ;; return
   4285          } 
   4286          
   4287          /**
   4288            * @brief  Configures the TIM in Slave mode in interrupt mode
   4289            * @param  htim: TIM handle.
   4290            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4291            *         contains the selected trigger (internal trigger input, filtered
   4292            *         timer input or external trigger input) and the ) and the Slave 
   4293            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4294            * @retval HAL status
   4295            */

   \                                 In section .text, align 2, keep-with-next
   4296          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
   4297                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4298          {
   \                     HAL_TIM_SlaveConfigSynchronization_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4299            /* Check the parameters */
   4300            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4301            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4302            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4303            
   4304            __HAL_LOCK(htim);
   \   00000002   0xF990 0x2038      LDRSB    R2,[R0, #+56]
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD072             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_0
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0xF880 0x2038      STRB     R2,[R0, #+56]
   4305          
   4306            htim->State = HAL_TIM_STATE_BUSY;
   \   00000014   0x2202             MOVS     R2,#+2
   \   00000016   0xF880 0x2039      STRB     R2,[R0, #+57]
   4307            
   4308            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   \   0000001A   0x6802             LDR      R2,[R0, #+0]
   \   0000001C   0x6893             LDR      R3,[R2, #+8]
   \   0000001E   0x684C             LDR      R4,[R1, #+4]
   \   00000020   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000024   0x4323             ORRS     R3,R4,R3
   \   00000026   0x.... 0x....      LDR.W    R4,??DataTable37  ;; 0xfffefff8
   \   0000002A   0x4023             ANDS     R3,R4,R3
   \   0000002C   0x680C             LDR      R4,[R1, #+0]
   \   0000002E   0x4323             ORRS     R3,R4,R3
   \   00000030   0x6093             STR      R3,[R2, #+8]
   \   00000032   0x684A             LDR      R2,[R1, #+4]
   \   00000034   0x2A40             CMP      R2,#+64
   \   00000036   0xD02F             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_1
   \   00000038   0x2A50             CMP      R2,#+80
   \   0000003A   0xD019             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_2
   \   0000003C   0x2A60             CMP      R2,#+96
   \   0000003E   0xD002             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_3
   \   00000040   0x2A70             CMP      R2,#+112
   \   00000042   0xD03A             BEQ.N    ??HAL_TIM_SlaveConfigSynchronization_IT_4
   \   00000044   0xE045             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_3: (+1)
   \   00000046   0x690A             LDR      R2,[R1, #+16]
   \   00000048   0x688B             LDR      R3,[R1, #+8]
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0x3118             ADDS     R1,R1,#+24
   \   0000004E   0x688C             LDR      R4,[R1, #+8]
   \   00000050   0xF024 0x0410      BIC      R4,R4,#0x10
   \   00000054   0x608C             STR      R4,[R1, #+8]
   \   00000056   0x680C             LDR      R4,[R1, #+0]
   \   00000058   0x688D             LDR      R5,[R1, #+8]
   \   0000005A   0xF424 0x4470      BIC      R4,R4,#0xF000
   \   0000005E   0xEA44 0x3202      ORR      R2,R4,R2, LSL #+12
   \   00000062   0x600A             STR      R2,[R1, #+0]
   \   00000064   0xF025 0x02A0      BIC      R2,R5,#0xA0
   \   00000068   0xEA42 0x1203      ORR      R2,R2,R3, LSL #+4
   \   0000006C   0x608A             STR      R2,[R1, #+8]
   \   0000006E   0xE030             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_2: (+1)
   \   00000070   0x690A             LDR      R2,[R1, #+16]
   \   00000072   0x688B             LDR      R3,[R1, #+8]
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x3118             ADDS     R1,R1,#+24
   \   00000078   0x688C             LDR      R4,[R1, #+8]
   \   0000007A   0x688D             LDR      R5,[R1, #+8]
   \   0000007C   0x086D             LSRS     R5,R5,#+1
   \   0000007E   0x006D             LSLS     R5,R5,#+1
   \   00000080   0x608D             STR      R5,[R1, #+8]
   \   00000082   0x680D             LDR      R5,[R1, #+0]
   \   00000084   0xF025 0x05F0      BIC      R5,R5,#0xF0
   \   00000088   0xEA45 0x1202      ORR      R2,R5,R2, LSL #+4
   \   0000008C   0x600A             STR      R2,[R1, #+0]
   \   0000008E   0xF024 0x020A      BIC      R2,R4,#0xA
   \   00000092   0x431A             ORRS     R2,R3,R2
   \   00000094   0x608A             STR      R2,[R1, #+8]
   \   00000096   0xE01C             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_1: (+1)
   \   00000098   0x6802             LDR      R2,[R0, #+0]
   \   0000009A   0x6A13             LDR      R3,[R2, #+32]
   \   0000009C   0x6A14             LDR      R4,[R2, #+32]
   \   0000009E   0x0864             LSRS     R4,R4,#+1
   \   000000A0   0x0064             LSLS     R4,R4,#+1
   \   000000A2   0x6214             STR      R4,[R2, #+32]
   \   000000A4   0x6802             LDR      R2,[R0, #+0]
   \   000000A6   0x6994             LDR      R4,[R2, #+24]
   \   000000A8   0x6909             LDR      R1,[R1, #+16]
   \   000000AA   0xF024 0x04F0      BIC      R4,R4,#0xF0
   \   000000AE   0xEA44 0x1101      ORR      R1,R4,R1, LSL #+4
   \   000000B2   0x6191             STR      R1,[R2, #+24]
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0x620B             STR      R3,[R1, #+32]
   \   000000B8   0xE00B             B.N      ??HAL_TIM_SlaveConfigSynchronization_IT_5
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_4: (+1)
   \   000000BA   0x6804             LDR      R4,[R0, #+0]
   \   000000BC   0x690A             LDR      R2,[R1, #+16]
   \   000000BE   0x688B             LDR      R3,[R1, #+8]
   \   000000C0   0x68C9             LDR      R1,[R1, #+12]
   \   000000C2   0x68A5             LDR      R5,[R4, #+8]
   \   000000C4   0xF425 0x457F      BIC      R5,R5,#0xFF00
   \   000000C8   0x4329             ORRS     R1,R1,R5
   \   000000CA   0x4319             ORRS     R1,R3,R1
   \   000000CC   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000D0   0x60A1             STR      R1,[R4, #+8]
   4309            
   4310            /* Enable Trigger Interrupt */
   4311            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_5: (+1)
   \   000000D2   0x6801             LDR      R1,[R0, #+0]
   \   000000D4   0x68CA             LDR      R2,[R1, #+12]
   \   000000D6   0xF042 0x0240      ORR      R2,R2,#0x40
   \   000000DA   0x60CA             STR      R2,[R1, #+12]
   4312            
   4313            /* Disable Trigger DMA request */
   4314            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \   000000DC   0x6801             LDR      R1,[R0, #+0]
   \   000000DE   0x68CA             LDR      R2,[R1, #+12]
   \   000000E0   0xF422 0x4280      BIC      R2,R2,#0x4000
   \   000000E4   0x60CA             STR      R2,[R1, #+12]
   4315            
   4316            htim->State = HAL_TIM_STATE_READY;
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0xF880 0x1039      STRB     R1,[R0, #+57]
   4317               
   4318            __HAL_UNLOCK(htim);  
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0xF880 0x1038      STRB     R1,[R0, #+56]
   4319            
   4320            return HAL_OK;
   \   000000F2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchronization_IT_0: (+1)
   \   000000F4   0xBC30             POP      {R4,R5}
   \   000000F6   0x4770             BX       LR               ;; return
   4321          }
   4322          
   4323          /**
   4324            * @brief  Read the captured value from Capture Compare unit
   4325            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4326            *                the configuration information for TIM module.
   4327            * @param  Channel: TIM Channels to be enabled.
   4328            *          This parameter can be one of the following values:
   4329            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4330            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4331            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4332            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4333            * @retval Captured value
   4334            */

   \                                 In section .text, align 4, keep-with-next
   4335          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4336          {
   4337            uint32_t tmpreg = 0;
   4338            
   4339            __HAL_LOCK(htim);
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \   00000000   0xF990 0x3038      LDRSB    R3,[R0, #+56]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2B01             CMP      R3,#+1
   \   00000008   0xD101             BNE.N    ??HAL_TIM_ReadCapturedValue_1
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \   0000000E   0x2301             MOVS     R3,#+1
   4340            
   4341            switch (Channel)
   \   00000010   0x290C             CMP      R1,#+12
   \   00000012   0xF880 0x3038      STRB     R3,[R0, #+56]
   \   00000016   0xD81F             BHI.N    ??HAL_TIM_ReadCapturedValue_2
   \   00000018   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_TIM_ReadCapturedValue_0:
   \   0000001C   0x07 0x1E          DC8      0x7,0x1E,0x1E,0x1E
   \              0x1E 0x1E    
   \   00000020   0x0E 0x1E          DC8      0xE,0x1E,0x1E,0x1E
   \              0x1E 0x1E    
   \   00000024   0x15 0x1E          DC8      0x15,0x1E,0x1E,0x1E
   \              0x1E 0x1E    
   \   00000028   0x1C 0x00          DC8      0x1C,0x0
   4342            {
   4343              case TIM_CHANNEL_1:
   4344              {
   4345                /* Check the parameters */
   4346                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4347                
   4348                /* Return the capture 1 value */
   4349                tmpreg = htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x6B4A             LDR      R2,[R1, #+52]
   4350                
   4351                break;
   4352              }
   4353              case TIM_CHANNEL_2:
   4354              {
   4355                /* Check the parameters */
   4356                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4357                
   4358                /* Return the capture 2 value */
   4359                tmpreg = htim->Instance->CCR2;
   4360                
   4361                break;
   4362              }
   4363              
   4364              case TIM_CHANNEL_3:
   4365              {
   4366                /* Check the parameters */
   4367                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4368                
   4369                /* Return the capture 3 value */
   4370                tmpreg = htim->Instance->CCR3;
   4371                
   4372                break;
   4373              }
   4374              
   4375              case TIM_CHANNEL_4:
   4376              {
   4377                /* Check the parameters */
   4378                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4379                
   4380                /* Return the capture 4 value */
   4381                tmpreg = htim->Instance->CCR4;
   4382                
   4383                break;
   4384              }
   4385              
   4386              default:
   4387              break;  
   4388            }
   4389               
   4390            __HAL_UNLOCK(htim);  
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF880 0x1038      STRB     R1,[R0, #+56]
   4391            return tmpreg;
   \   00000034   0x4610             MOV      R0,R2
   \   00000036   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_4: (+1)
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x6B8A             LDR      R2,[R1, #+56]
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   00000042   0x4610             MOV      R0,R2
   \   00000044   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_5: (+1)
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x6BCA             LDR      R2,[R1, #+60]
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   00000050   0x4610             MOV      R0,R2
   \   00000052   0x4770             BX       LR
   \                     ??HAL_TIM_ReadCapturedValue_6: (+1)
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x6C0A             LDR      R2,[R1, #+64]
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   0000005E   0x4610             MOV      R0,R2
   \   00000060   0x4770             BX       LR               ;; return
   4392          }
   4393          
   4394          /**
   4395            * @}
   4396            */
   4397            
   4398          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4399           *  @brief    TIM Callbacks functions 
   4400           *
   4401          @verbatim   
   4402            ==============================================================================
   4403                                  ##### TIM Callbacks functions #####
   4404            ==============================================================================  
   4405           [..]  
   4406             This section provides TIM callback functions:
   4407             (+) Timer Period elapsed callback
   4408             (+) Timer Output Compare callback
   4409             (+) Timer Input capture callback
   4410             (+) Timer Trigger callback
   4411             (+) Timer Error callback
   4412          
   4413          @endverbatim
   4414            * @{
   4415            */
   4416          
   4417          /**
   4418            * @brief  Period elapsed callback in non blocking mode 
   4419            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4420            *                the configuration information for TIM module.
   4421            * @retval None
   4422            */

   \                                 In section .text, align 2, keep-with-next
   4423          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4424          {
   4425            /* Prevent unused argument(s) compilation warning */
   4426            UNUSED(htim);
   4427           
   4428            /* NOTE : This function Should not be modified, when the callback is needed,
   4429                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4430             */
   4431            
   4432          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4433          /**
   4434            * @brief  Output Compare callback in non blocking mode 
   4435            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4436            *                the configuration information for TIM module.
   4437            * @retval None
   4438            */

   \                                 In section .text, align 2, keep-with-next
   4439          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4440          {
   4441            /* Prevent unused argument(s) compilation warning */
   4442            UNUSED(htim);
   4443           
   4444            /* NOTE : This function Should not be modified, when the callback is needed,
   4445                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4446             */
   4447          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4448          /**
   4449            * @brief  Input Capture callback in non blocking mode 
   4450            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4451            *                the configuration information for TIM module.
   4452            * @retval None
   4453            */

   \                                 In section .text, align 2, keep-with-next
   4454          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4455          {
   4456            /* Prevent unused argument(s) compilation warning */
   4457            UNUSED(htim);
   4458           
   4459            /* NOTE : This function Should not be modified, when the callback is needed,
   4460                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4461             */
   4462          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4463          
   4464          /**
   4465            * @brief  PWM Pulse finished callback in non blocking mode 
   4466            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4467            *                the configuration information for TIM module.
   4468            * @retval None
   4469            */

   \                                 In section .text, align 2, keep-with-next
   4470          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4471          {
   4472            /* Prevent unused argument(s) compilation warning */
   4473            UNUSED(htim);
   4474           
   4475            /* NOTE : This function Should not be modified, when the callback is needed,
   4476                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4477             */
   4478          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4479          
   4480          /**
   4481            * @brief  Hall Trigger detection callback in non blocking mode 
   4482            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4483            *                the configuration information for TIM module.
   4484            * @retval None
   4485            */

   \                                 In section .text, align 2, keep-with-next
   4486          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4487          {
   4488            /* Prevent unused argument(s) compilation warning */
   4489            UNUSED(htim);
   4490           
   4491            /* NOTE : This function Should not be modified, when the callback is needed,
   4492                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4493             */
   4494          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4495          
   4496          /**
   4497            * @brief  Timer error callback in non blocking mode 
   4498            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4499            *                the configuration information for TIM module.
   4500            * @retval None
   4501            */

   \                                 In section .text, align 2, keep-with-next
   4502          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4503          {
   4504            /* Prevent unused argument(s) compilation warning */
   4505            UNUSED(htim);
   4506           
   4507            /* NOTE : This function Should not be modified, when the callback is needed,
   4508                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4509             */
   4510          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   4511          
   4512          /**
   4513            * @}
   4514            */
   4515          
   4516          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4517           *  @brief   Peripheral State functions 
   4518           *
   4519          @verbatim   
   4520            ==============================================================================
   4521                                  ##### Peripheral State functions #####
   4522            ==============================================================================  
   4523            [..]
   4524              This subsection permits to get in run-time the status of the peripheral 
   4525              and the data flow.
   4526          
   4527          @endverbatim
   4528            * @{
   4529            */
   4530          
   4531          /**
   4532            * @brief  Return the TIM Base state
   4533            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4534            *                the configuration information for TIM module.
   4535            * @retval HAL state
   4536            */

   \                                 In section .text, align 2, keep-with-next
   4537          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4538          {
   4539            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4540          }
   4541          
   4542          /**
   4543            * @brief  Return the TIM OC state
   4544            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4545            *                the configuration information for TIM module.
   4546            * @retval HAL state
   4547            */

   \                                 In section .text, align 2, keep-with-next
   4548          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4549          {
   4550            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4551          }
   4552          
   4553          /**
   4554            * @brief  Return the TIM PWM state
   4555            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4556            *                the configuration information for TIM module.
   4557            * @retval HAL state
   4558            */

   \                                 In section .text, align 2, keep-with-next
   4559          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4560          {
   4561            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4562          }
   4563          
   4564          /**
   4565            * @brief  Return the TIM Input Capture state
   4566            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4567            *                the configuration information for TIM module.
   4568            * @retval HAL state
   4569            */

   \                                 In section .text, align 2, keep-with-next
   4570          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4571          {
   4572            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4573          }
   4574          
   4575          /**
   4576            * @brief  Return the TIM One Pulse Mode state
   4577            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4578            *                the configuration information for TIM module.
   4579            * @retval HAL state
   4580            */

   \                                 In section .text, align 2, keep-with-next
   4581          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4582          {
   4583            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4584          }
   4585          
   4586          /**
   4587            * @brief  Return the TIM Encoder Mode state
   4588            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4589            *                the configuration information for TIM module.
   4590            * @retval HAL state
   4591            */

   \                                 In section .text, align 2, keep-with-next
   4592          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4593          {
   4594            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \   00000000   0xF990 0x0039      LDRSB    R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   4595          }
   4596          
   4597          /**
   4598            * @}
   4599            */
   4600          
   4601          /**
   4602            * @brief  TIM DMA error callback 
   4603            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4604            *                the configuration information for the specified DMA module.
   4605            * @retval None
   4606            */

   \                                 In section .text, align 4, keep-with-next
   4607          void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
   4608          {
   \                     TIM_DMAError: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   4609            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   4610            
   4611            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x1039      STRB     R1,[R0, #+57]
   4612             
   4613            HAL_TIM_ErrorCallback(htim);
   \   0000000C   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   4614          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBD00             POP      {PC}             ;; return
   4615          
   4616          /**
   4617            * @brief  TIM DMA Delay Pulse complete callback. 
   4618            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4619            *                the configuration information for the specified DMA module.
   4620            * @retval None
   4621            */

   \                                 In section .text, align 4, keep-with-next
   4622          void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4623          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4624            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   4625            
   4626            htim->State= HAL_TIM_STATE_READY; 
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x1039      STRB     R1,[R4, #+57]
   4627            
   4628            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0x6A21             LDR      R1,[R4, #+32]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2001             MOVEQ    R0,#+1
   4629            {
   4630              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000012   0xD00D             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4631            }
   4632            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \   00000014   0x6A61             LDR      R1,[R4, #+36]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2002             MOVEQ    R0,#+2
   4633            {
   4634              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001C   0xD008             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4635            }
   4636            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \   0000001E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2004             MOVEQ    R0,#+4
   4637            {
   4638              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000026   0xD003             BEQ.N    ??TIM_DMADelayPulseCplt_0
   4639            }
   4640            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \   00000028   0x6AE1             LDR      R1,[R4, #+44]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   4641            {
   4642              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   0000002E   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \   00000030   0x7620             STRB     R0,[R4, #+24]
   4643            }
   4644          
   4645            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   4646          
   4647            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
   4648          }
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   4649          /**
   4650            * @brief  TIM DMA Capture complete callback. 
   4651            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4652            *                the configuration information for the specified DMA module.
   4653            * @retval None
   4654            */

   \                                 In section .text, align 4, keep-with-next
   4655          void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4656          {
   \                     TIM_DMACaptureCplt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4657            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   4658              
   4659             htim->State= HAL_TIM_STATE_READY; 
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF884 0x1039      STRB     R1,[R4, #+57]
   4660              
   4661            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \   0000000A   0x6A21             LDR      R1,[R4, #+32]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xBF08             IT       EQ 
   \   00000010   0x2001             MOVEQ    R0,#+1
   4662            {
   4663              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \   00000012   0xD00D             BEQ.N    ??TIM_DMACaptureCplt_0
   4664            }
   4665            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \   00000014   0x6A61             LDR      R1,[R4, #+36]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2002             MOVEQ    R0,#+2
   4666            {
   4667              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \   0000001C   0xD008             BEQ.N    ??TIM_DMACaptureCplt_0
   4668            }
   4669            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \   0000001E   0x6AA1             LDR      R1,[R4, #+40]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xBF08             IT       EQ 
   \   00000024   0x2004             MOVEQ    R0,#+4
   4670            {
   4671              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \   00000026   0xD003             BEQ.N    ??TIM_DMACaptureCplt_0
   4672            }
   4673            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \   00000028   0x6AE1             LDR      R1,[R4, #+44]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   4674            {
   4675              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \   0000002E   0x2008             MOVS     R0,#+8
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \   00000030   0x7620             STRB     R0,[R4, #+24]
   4676            }
   4677            
   4678            HAL_TIM_IC_CaptureCallback(htim); 
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   4679            
   4680            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7620             STRB     R0,[R4, #+24]
   4681          
   4682          }
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   4683          
   4684          /**
   4685            * @brief  TIM DMA Period Elapse complete callback. 
   4686            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4687            *                the configuration information for the specified DMA module.
   4688            * @retval None
   4689            */

   \                                 In section .text, align 4, keep-with-next
   4690          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4691          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   4692            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   4693            
   4694            htim->State= HAL_TIM_STATE_READY;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x1039      STRB     R1,[R0, #+57]
   4695            
   4696            HAL_TIM_PeriodElapsedCallback(htim);
   \   0000000C   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   4697          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBD00             POP      {PC}             ;; return
   4698          
   4699          /**
   4700            * @brief  TIM DMA Trigger callback. 
   4701            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   4702            *                the configuration information for the specified DMA module.
   4703            * @retval None
   4704            */

   \                                 In section .text, align 4, keep-with-next
   4705          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4706          {
   \                     TIM_DMATriggerCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   4707            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   4708            
   4709            htim->State= HAL_TIM_STATE_READY; 
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x1039      STRB     R1,[R0, #+57]
   4710            
   4711            HAL_TIM_TriggerCallback(htim);
   \   0000000C   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   4712          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBD00             POP      {PC}             ;; return
   4713          
   4714          /**
   4715            * @brief  Time Base configuration
   4716            * @param  TIMx: TIM peripheral
   4717            * @param  Structure: pointer on TIM Time Base required parameters  
   4718            * @retval None
   4719            */

   \                                 In section .text, align 2, keep-with-next
   4720          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4721          {
   4722            uint32_t tmpcr1 = 0;
   4723            tmpcr1 = TIMx->CR1;
   4724            
   4725            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4726            if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
   \                     TIM_Base_SetConfig: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable32  ;; 0x40010000
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x4290             CMP      R0,R2
   \   00000006   0xBF18             IT       NE 
   \   00000008   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   0000000C   0xD00F             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R12,??DataTable32_1  ;; 0x40000400
   \   00000012   0x4560             CMP      R0,R12
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x.... 0x....      LDRNE.W  R12,??DataTable32_2  ;; 0x40000800
   \   0000001A   0x4560             CMPNE    R0,R12
   \   0000001C   0xD007             BEQ.N    ??TIM_Base_SetConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R12,??DataTable32_3  ;; 0x40000c00
   \   00000022   0x4560             CMP      R0,R12
   \   00000024   0xBF1C             ITT      NE 
   \   00000026   0x.... 0x....      LDRNE.W  R12,??DataTable37_4  ;; 0x40010400
   \   0000002A   0x4560             CMPNE    R0,R12
   \   0000002C   0xD115             BNE.N    ??TIM_Base_SetConfig_1
   4727            {
   4728              /* Select the Counter Mode */
   4729              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   4730              tmpcr1 |= Structure->CounterMode;
   4731            }
   4732           
   4733            if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
   \                     ??TIM_Base_SetConfig_0: (+1)
   \   0000002E   0x4290             CMP      R0,R2
   \   00000030   0xF8D1 0xC004      LDR      R12,[R1, #+4]
   \   00000034   0xF023 0x0370      BIC      R3,R3,#0x70
   \   00000038   0xEA4C 0x0303      ORR      R3,R12,R3
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   00000042   0xD025             BEQ.N    ??TIM_Base_SetConfig_2
   \   00000044   0x.... 0x....      LDR.W    R12,??DataTable32_1  ;; 0x40000400
   \   00000048   0x4560             CMP      R0,R12
   \   0000004A   0xBF1F             ITTTT    NE 
   \   0000004C   0x.... 0x....      LDRNE.W  R12,??DataTable32_2  ;; 0x40000800
   \   00000050   0x4560             CMPNE    R0,R12
   \   00000052   0x.... 0x....      LDRNE.W  R12,??DataTable32_3  ;; 0x40000c00
   \   00000056   0x4560             CMPNE    R0,R12
   \   00000058   0xD01A             BEQ.N    ??TIM_Base_SetConfig_2
   \                     ??TIM_Base_SetConfig_1: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R12,??DataTable37_4  ;; 0x40010400
   \   0000005E   0x4560             CMP      R0,R12
   \   00000060   0xBF1C             ITT      NE 
   \   00000062   0x.... 0x....      LDRNE.W  R12,??DataTable37_5  ;; 0x40014000
   \   00000066   0x4560             CMPNE    R0,R12
   \   00000068   0xD012             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000006A   0x.... 0x....      LDR.W    R12,??DataTable37_6  ;; 0x40014400
   \   0000006E   0x4560             CMP      R0,R12
   \   00000070   0xBF1C             ITT      NE 
   \   00000072   0x.... 0x....      LDRNE.W  R12,??DataTable37_7  ;; 0x40014800
   \   00000076   0x4560             CMPNE    R0,R12
   \   00000078   0xD00A             BEQ.N    ??TIM_Base_SetConfig_2
   \   0000007A   0x.... 0x....      LDR.W    R12,??DataTable37_8  ;; 0x40001800
   \   0000007E   0x4560             CMP      R0,R12
   \   00000080   0xBF1F             ITTTT    NE 
   \   00000082   0x.... 0x....      LDRNE.W  R12,??DataTable37_9  ;; 0x40001c00
   \   00000086   0x4560             CMPNE    R0,R12
   \   00000088   0x.... 0x....      LDRNE.W  R12,??DataTable37_10  ;; 0x40002000
   \   0000008C   0x4560             CMPNE    R0,R12
   \   0000008E   0xD105             BNE.N    ??TIM_Base_SetConfig_3
   4734            {
   4735              /* Set the clock division */
   4736              tmpcr1 &= ~TIM_CR1_CKD;
   4737              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \   00000090   0xF8D1 0xC00C      LDR      R12,[R1, #+12]
   \   00000094   0xF423 0x7340      BIC      R3,R3,#0x300
   \   00000098   0xEA4C 0x0303      ORR      R3,R12,R3
   4738            }
   4739          
   4740            TIMx->CR1 = tmpcr1;
   \                     ??TIM_Base_SetConfig_3: (+1)
   \   0000009C   0x6003             STR      R3,[R0, #+0]
   4741          
   4742            /* Set the Auto-reload value */
   4743            TIMx->ARR = (uint32_t)Structure->Period ;
   \   0000009E   0x688B             LDR      R3,[R1, #+8]
   4744           
   4745            /* Set the Prescaler value */
   4746            TIMx->PSC = (uint32_t)Structure->Prescaler;
   4747              
   4748            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
   \   000000A0   0x4290             CMP      R0,R2
   \   000000A2   0x62C3             STR      R3,[R0, #+44]
   \   000000A4   0x680B             LDR      R3,[R1, #+0]
   \   000000A6   0x6283             STR      R3,[R0, #+40]
   \   000000A8   0xBF19             ITTEE    NE 
   \   000000AA   0x....             LDRNE.N  R2,??DataTable37_4  ;; 0x40010400
   \   000000AC   0x4290             CMPNE    R0,R2
   \   000000AE   0x6909             LDREQ    R1,[R1, #+16]
   \   000000B0   0x6301             STREQ    R1,[R0, #+48]
   4749            {
   4750              /* Set the Repetition Counter value */
   4751              TIMx->RCR = Structure->RepetitionCounter;
   4752            }
   4753          
   4754            /* Generate an update event to reload the Prescaler 
   4755               and the repetition counter(only for TIM1 and TIM8) value immediately */
   4756            TIMx->EGR = TIM_EGR_UG;
   \   000000B2   0x2101             MOVS     R1,#+1
   \   000000B4   0x6141             STR      R1,[R0, #+20]
   4757          }
   \   000000B6   0x4770             BX       LR               ;; return
   4758          
   4759          /**
   4760            * @brief  Time Output Compare 1 configuration
   4761            * @param  TIMx to select the TIM peripheral
   4762            * @param  OC_Config: The output configuration structure
   4763            * @retval None
   4764            */

   \                                 In section .text, align 2, keep-with-next
   4765          void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4766          {
   \                     TIM_OC1_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4767            uint32_t tmpccmrx = 0;
   4768            uint32_t tmpccer = 0;
   4769            uint32_t tmpcr2 = 0;  
   4770          
   4771            /* Disable the Channel 1: Reset the CC1E Bit */
   4772            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4773            
   4774            /* Get the TIMx CCER register value */
   4775            tmpccer = TIMx->CCER;
   4776            /* Get the TIMx CR2 register value */
   4777            tmpcr2 = TIMx->CR2;
   4778            
   4779            /* Get the TIMx CCMR1 register value */
   4780            tmpccmrx = TIMx->CCMR1;
   4781              
   4782            /* Reset the Output Compare Mode Bits */
   4783            tmpccmrx &= ~TIM_CCMR1_OC1M;
   4784            tmpccmrx &= ~TIM_CCMR1_CC1S;
   4785            /* Select the Output Compare Mode */
   4786            tmpccmrx |= OC_Config->OCMode;
   \   00000004   0x....             LDR.N    R5,??DataTable37_11  ;; 0xfffeff8c
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x6983             LDR      R3,[R0, #+24]
   4787            
   4788            /* Reset the Output Polarity level */
   4789            tmpccer &= ~TIM_CCER_CC1P;
   4790            /* Set the Output Compare Polarity */
   4791            tmpccer |= OC_Config->OCPolarity;
   \   00000012   0xF024 0x0402      BIC      R4,R4,#0x2
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0x432B             ORRS     R3,R5,R3
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0x432C             ORRS     R4,R5,R4
   4792          
   4793              
   4794            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000020   0x....             LDR.N    R5,??DataTable37_12  ;; 0x40010000
   \   00000022   0x42A8             CMP      R0,R5
   \   00000024   0xBF1C             ITT      NE 
   \   00000026   0x....             LDRNE.N  R5,??DataTable37_4  ;; 0x40010400
   \   00000028   0x42A8             CMPNE    R0,R5
   \   0000002A   0xD10B             BNE.N    ??TIM_OC1_SetConfig_0
   4795            {   
   4796              /* Reset the Output N Polarity level */
   4797              tmpccer &= ~TIM_CCER_CC1NP;
   4798              /* Set the Output N Polarity */
   4799              tmpccer |= OC_Config->OCNPolarity;
   4800              /* Reset the Output N State */
   4801              tmpccer &= ~TIM_CCER_CC1NE;
   4802              
   4803              /* Reset the Output Compare and Output Compare N IDLE State */
   4804              tmpcr2 &= ~TIM_CR2_OIS1;
   4805              tmpcr2 &= ~TIM_CR2_OIS1N;
   4806              /* Set the Output Idle state */
   4807              tmpcr2 |= OC_Config->OCIdleState;
   4808              /* Set the Output N Idle state */
   4809              tmpcr2 |= OC_Config->OCNIdleState;
   \   0000002C   0xF422 0x7240      BIC      R2,R2,#0x300
   \   00000030   0x68CD             LDR      R5,[R1, #+12]
   \   00000032   0xF024 0x0408      BIC      R4,R4,#0x8
   \   00000036   0x432C             ORRS     R4,R5,R4
   \   00000038   0x694D             LDR      R5,[R1, #+20]
   \   0000003A   0xF024 0x0404      BIC      R4,R4,#0x4
   \   0000003E   0x432A             ORRS     R2,R5,R2
   \   00000040   0x698D             LDR      R5,[R1, #+24]
   \   00000042   0x432A             ORRS     R2,R5,R2
   4810            }
   4811            /* Write to TIMx CR2 */
   4812            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \   00000044   0x6042             STR      R2,[R0, #+4]
   4813            
   4814            /* Write to TIMx CCMR1 */
   4815            TIMx->CCMR1 = tmpccmrx;
   \   00000046   0x6183             STR      R3,[R0, #+24]
   4816            
   4817            /* Set the Capture Compare Register value */
   4818            TIMx->CCR1 = OC_Config->Pulse;
   \   00000048   0x6849             LDR      R1,[R1, #+4]
   \   0000004A   0x6341             STR      R1,[R0, #+52]
   4819            
   4820            /* Write to TIMx CCER */
   4821            TIMx->CCER = tmpccer;  
   \   0000004C   0x6204             STR      R4,[R0, #+32]
   4822          } 
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
   4823          
   4824          /**
   4825            * @brief  Time Output Compare 2 configuration
   4826            * @param  TIMx to select the TIM peripheral
   4827            * @param  OC_Config: The output configuration structure
   4828            * @retval None
   4829            */

   \                                 In section .text, align 2, keep-with-next
   4830          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4831          {
   \                     TIM_OC2_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4832            uint32_t tmpccmrx = 0;
   4833            uint32_t tmpccer = 0;
   4834            uint32_t tmpcr2 = 0;
   4835             
   4836            /* Disable the Channel 2: Reset the CC2E Bit */
   4837            TIMx->CCER &= ~TIM_CCER_CC2E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4838            
   4839            /* Get the TIMx CCER register value */  
   4840            tmpccer = TIMx->CCER;
   4841            /* Get the TIMx CR2 register value */
   4842            tmpcr2 = TIMx->CR2;
   4843            
   4844            /* Get the TIMx CCMR1 register value */
   4845            tmpccmrx = TIMx->CCMR1;
   4846              
   4847            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4848            tmpccmrx &= ~TIM_CCMR1_OC2M;
   4849            tmpccmrx &= ~TIM_CCMR1_CC2S;
   4850            
   4851            /* Select the Output Compare Mode */
   4852            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000004   0x....             LDR.N    R5,??DataTable37_13  ;; 0xfeff8cff
   \   00000006   0xF022 0x0210      BIC      R2,R2,#0x10
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x6983             LDR      R3,[R0, #+24]
   4853            
   4854            /* Reset the Output Polarity level */
   4855            tmpccer &= ~TIM_CCER_CC2P;
   4856            /* Set the Output Compare Polarity */
   4857            tmpccer |= (OC_Config->OCPolarity << 4);
   \   00000012   0xF024 0x0420      BIC      R4,R4,#0x20
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0xEA43 0x2305      ORR      R3,R3,R5, LSL #+8
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   4858              
   4859            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000024   0x....             LDR.N    R5,??DataTable37_12  ;; 0x40010000
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x....             LDRNE.N  R5,??DataTable37_4  ;; 0x40010400
   \   0000002C   0x42A8             CMPNE    R0,R5
   \   0000002E   0xD10D             BNE.N    ??TIM_OC2_SetConfig_0
   4860            {
   4861              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4862              
   4863              /* Reset the Output N Polarity level */
   4864              tmpccer &= ~TIM_CCER_CC2NP;
   4865              /* Set the Output N Polarity */
   4866              tmpccer |= (OC_Config->OCNPolarity << 4);
   4867              /* Reset the Output N State */
   4868              tmpccer &= ~TIM_CCER_CC2NE;
   \   00000030   0x68CD             LDR      R5,[R1, #+12]
   \   00000032   0xF024 0x0480      BIC      R4,R4,#0x80
   4869              
   4870              /* Reset the Output Compare and Output Compare N IDLE State */
   4871              tmpcr2 &= ~TIM_CR2_OIS2;
   4872              tmpcr2 &= ~TIM_CR2_OIS2N;
   4873              /* Set the Output Idle state */
   4874              tmpcr2 |= (OC_Config->OCIdleState << 2);
   4875              /* Set the Output N Idle state */
   4876              tmpcr2 |= (OC_Config->OCNIdleState << 2);
   \   00000036   0x698E             LDR      R6,[R1, #+24]
   \   00000038   0xF422 0x6240      BIC      R2,R2,#0xC00
   \   0000003C   0xEA44 0x1405      ORR      R4,R4,R5, LSL #+4
   \   00000040   0x694D             LDR      R5,[R1, #+20]
   \   00000042   0x4335             ORRS     R5,R6,R5
   \   00000044   0xF024 0x0440      BIC      R4,R4,#0x40
   \   00000048   0xEA42 0x0285      ORR      R2,R2,R5, LSL #+2
   4877            }
   4878            /* Write to TIMx CR2 */
   4879            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \   0000004C   0x6042             STR      R2,[R0, #+4]
   4880            
   4881            /* Write to TIMx CCMR1 */
   4882            TIMx->CCMR1 = tmpccmrx;
   \   0000004E   0x6183             STR      R3,[R0, #+24]
   4883            
   4884            /* Set the Capture Compare Register value */
   4885            TIMx->CCR2 = OC_Config->Pulse;
   \   00000050   0x6849             LDR      R1,[R1, #+4]
   \   00000052   0x6381             STR      R1,[R0, #+56]
   4886            
   4887            /* Write to TIMx CCER */
   4888            TIMx->CCER = tmpccer;
   \   00000054   0x6204             STR      R4,[R0, #+32]
   4889          }
   \   00000056   0xBC70             POP      {R4-R6}
   \   00000058   0x4770             BX       LR               ;; return
   4890          
   4891          /**
   4892            * @brief  Time Output Compare 3 configuration
   4893            * @param  TIMx to select the TIM peripheral
   4894            * @param  OC_Config: The output configuration structure
   4895            * @retval None
   4896            */

   \                                 In section .text, align 2, keep-with-next
   4897          void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4898          {
   \                     TIM_OC3_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   4899            uint32_t tmpccmrx = 0;
   4900            uint32_t tmpccer = 0;
   4901            uint32_t tmpcr2 = 0;   
   4902          
   4903            /* Disable the Channel 3: Reset the CC2E Bit */
   4904            TIMx->CCER &= ~TIM_CCER_CC3E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4905            
   4906            /* Get the TIMx CCER register value */
   4907            tmpccer = TIMx->CCER;
   4908            /* Get the TIMx CR2 register value */
   4909            tmpcr2 = TIMx->CR2;
   4910            
   4911            /* Get the TIMx CCMR2 register value */
   4912            tmpccmrx = TIMx->CCMR2;
   4913              
   4914            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4915            tmpccmrx &= ~TIM_CCMR2_OC3M;
   4916            tmpccmrx &= ~TIM_CCMR2_CC3S;  
   4917            /* Select the Output Compare Mode */
   4918            tmpccmrx |= OC_Config->OCMode;
   \   00000004   0x....             LDR.N    R5,??DataTable37_11  ;; 0xfffeff8c
   \   00000006   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A04             LDR      R4,[R0, #+32]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x69C3             LDR      R3,[R0, #+28]
   4919            
   4920            /* Reset the Output Polarity level */
   4921            tmpccer &= ~TIM_CCER_CC3P;
   4922            /* Set the Output Compare Polarity */
   4923            tmpccer |= (OC_Config->OCPolarity << 8);
   \   00000012   0xF424 0x7400      BIC      R4,R4,#0x200
   \   00000016   0x402B             ANDS     R3,R5,R3
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0x432B             ORRS     R3,R5,R3
   \   0000001C   0x688D             LDR      R5,[R1, #+8]
   \   0000001E   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   4924              
   4925            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000022   0x....             LDR.N    R5,??DataTable37_12  ;; 0x40010000
   \   00000024   0x42A8             CMP      R0,R5
   \   00000026   0xBF1C             ITT      NE 
   \   00000028   0x....             LDRNE.N  R5,??DataTable37_4  ;; 0x40010400
   \   0000002A   0x42A8             CMPNE    R0,R5
   \   0000002C   0xD10D             BNE.N    ??TIM_OC3_SetConfig_0
   4926            {
   4927              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4928              
   4929              /* Reset the Output N Polarity level */
   4930              tmpccer &= ~TIM_CCER_CC3NP;
   4931              /* Set the Output N Polarity */
   4932              tmpccer |= (OC_Config->OCNPolarity << 8);
   4933              /* Reset the Output N State */
   4934              tmpccer &= ~TIM_CCER_CC3NE;
   \   0000002E   0x68CD             LDR      R5,[R1, #+12]
   \   00000030   0xF424 0x6400      BIC      R4,R4,#0x800
   4935              
   4936              /* Reset the Output Compare and Output Compare N IDLE State */
   4937              tmpcr2 &= ~TIM_CR2_OIS3;
   4938              tmpcr2 &= ~TIM_CR2_OIS3N;
   4939              /* Set the Output Idle state */
   4940              tmpcr2 |= (OC_Config->OCIdleState << 4);
   4941              /* Set the Output N Idle state */
   4942              tmpcr2 |= (OC_Config->OCNIdleState << 4);
   \   00000034   0x698E             LDR      R6,[R1, #+24]
   \   00000036   0xF422 0x5240      BIC      R2,R2,#0x3000
   \   0000003A   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   0000003E   0x694D             LDR      R5,[R1, #+20]
   \   00000040   0x4335             ORRS     R5,R6,R5
   \   00000042   0xF424 0x6480      BIC      R4,R4,#0x400
   \   00000046   0xEA42 0x1205      ORR      R2,R2,R5, LSL #+4
   4943            }
   4944            /* Write to TIMx CR2 */
   4945            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \   0000004A   0x6042             STR      R2,[R0, #+4]
   4946            
   4947            /* Write to TIMx CCMR2 */
   4948            TIMx->CCMR2 = tmpccmrx;
   \   0000004C   0x61C3             STR      R3,[R0, #+28]
   4949            
   4950            /* Set the Capture Compare Register value */
   4951            TIMx->CCR3 = OC_Config->Pulse;
   \   0000004E   0x6849             LDR      R1,[R1, #+4]
   \   00000050   0x63C1             STR      R1,[R0, #+60]
   4952            
   4953            /* Write to TIMx CCER */
   4954            TIMx->CCER = tmpccer;
   \   00000052   0x6204             STR      R4,[R0, #+32]
   4955          }
   \   00000054   0xBC70             POP      {R4-R6}
   \   00000056   0x4770             BX       LR               ;; return
   4956          
   4957          /**
   4958            * @brief  Time Output Compare 4 configuration
   4959            * @param  TIMx to select the TIM peripheral
   4960            * @param  OC_Config: The output configuration structure
   4961            * @retval None
   4962            */

   \                                 In section .text, align 2, keep-with-next
   4963          void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4964          {
   \                     TIM_OC4_SetConfig: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   4965            uint32_t tmpccmrx = 0;
   4966            uint32_t tmpccer = 0;
   4967            uint32_t tmpcr2 = 0;
   4968          
   4969            /* Disable the Channel 4: Reset the CC4E Bit */
   4970            TIMx->CCER &= ~TIM_CCER_CC4E;
   \   00000002   0x6A02             LDR      R2,[R0, #+32]
   4971            
   4972            /* Get the TIMx CCER register value */
   4973            tmpccer = TIMx->CCER;
   4974            /* Get the TIMx CR2 register value */
   4975            tmpcr2 = TIMx->CR2;
   4976            
   4977            /* Get the TIMx CCMR2 register value */
   4978            tmpccmrx = TIMx->CCMR2;
   4979              
   4980            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4981            tmpccmrx &= ~TIM_CCMR2_OC4M;
   4982            tmpccmrx &= ~TIM_CCMR2_CC4S;
   4983            
   4984            /* Select the Output Compare Mode */
   4985            tmpccmrx |= (OC_Config->OCMode << 8);
   \   00000004   0x....             LDR.N    R5,??DataTable37_13  ;; 0xfeff8cff
   \   00000006   0xF422 0x5280      BIC      R2,R2,#0x1000
   \   0000000A   0x6202             STR      R2,[R0, #+32]
   \   0000000C   0x6A02             LDR      R2,[R0, #+32]
   \   0000000E   0x6843             LDR      R3,[R0, #+4]
   \   00000010   0x69C4             LDR      R4,[R0, #+28]
   4986            
   4987            /* Reset the Output Polarity level */
   4988            tmpccer &= ~TIM_CCER_CC4P;
   4989            /* Set the Output Compare Polarity */
   4990            tmpccer |= (OC_Config->OCPolarity << 12);
   \   00000012   0xF422 0x5200      BIC      R2,R2,#0x2000
   \   00000016   0x402C             ANDS     R4,R5,R4
   \   00000018   0x680D             LDR      R5,[R1, #+0]
   \   0000001A   0xEA44 0x2405      ORR      R4,R4,R5, LSL #+8
   \   0000001E   0x688D             LDR      R5,[R1, #+8]
   \   00000020   0xEA42 0x3205      ORR      R2,R2,R5, LSL #+12
   4991             
   4992            /*if((TIMx == TIM1) || (TIMx == TIM8))*/
   4993            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   \   00000024   0x....             LDR.N    R5,??DataTable37_12  ;; 0x40010000
   \   00000026   0x42A8             CMP      R0,R5
   \   00000028   0xBF1C             ITT      NE 
   \   0000002A   0x....             LDRNE.N  R5,??DataTable37_4  ;; 0x40010400
   \   0000002C   0x42A8             CMPNE    R0,R5
   \   0000002E   0xD104             BNE.N    ??TIM_OC4_SetConfig_0
   4994            {
   4995              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4996              /* Reset the Output Compare IDLE State */
   4997              tmpcr2 &= ~TIM_CR2_OIS4;
   4998              /* Set the Output Idle state */
   4999              tmpcr2 |= (OC_Config->OCIdleState << 6);
   \   00000030   0x694D             LDR      R5,[R1, #+20]
   \   00000032   0xF423 0x4380      BIC      R3,R3,#0x4000
   \   00000036   0xEA43 0x1385      ORR      R3,R3,R5, LSL #+6
   5000            }
   5001            /* Write to TIMx CR2 */
   5002            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \   0000003A   0x6043             STR      R3,[R0, #+4]
   5003            
   5004            /* Write to TIMx CCMR2 */  
   5005            TIMx->CCMR2 = tmpccmrx;
   \   0000003C   0x61C4             STR      R4,[R0, #+28]
   5006              
   5007            /* Set the Capture Compare Register value */
   5008            TIMx->CCR4 = OC_Config->Pulse;
   \   0000003E   0x6849             LDR      R1,[R1, #+4]
   \   00000040   0x6401             STR      R1,[R0, #+64]
   5009            
   5010            /* Write to TIMx CCER */
   5011            TIMx->CCER = tmpccer;
   \   00000042   0x6202             STR      R2,[R0, #+32]
   5012          }
   \   00000044   0xBC30             POP      {R4,R5}
   \   00000046   0x4770             BX       LR               ;; return
   5013          
   5014          /**
   5015            * @brief  Time Output Compare 4 configuration
   5016            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   5017            *                the configuration information for TIM module.
   5018            * @param  sSlaveConfig: The slave configuration structure
   5019            * @retval None
   5020            */
   5021          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   5022                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   5023          {
   5024            uint32_t tmpsmcr = 0;
   5025            uint32_t tmpccmr1 = 0;
   5026            uint32_t tmpccer = 0;
   5027          
   5028           /* Get the TIMx SMCR register value */
   5029            tmpsmcr = htim->Instance->SMCR;
   5030          
   5031            /* Reset the Trigger Selection Bits */
   5032            tmpsmcr &= ~TIM_SMCR_TS;
   5033            /* Set the Input Trigger source */
   5034            tmpsmcr |= sSlaveConfig->InputTrigger;
   5035          
   5036            /* Reset the slave mode Bits */
   5037            tmpsmcr &= ~TIM_SMCR_SMS;
   5038            /* Set the slave mode */
   5039            tmpsmcr |= sSlaveConfig->SlaveMode;
   5040          
   5041            /* Write to TIMx SMCR */
   5042            htim->Instance->SMCR = tmpsmcr;
   5043           
   5044            /* Configure the trigger prescaler, filter, and polarity */
   5045            switch (sSlaveConfig->InputTrigger)
   5046            {
   5047            case TIM_TS_ETRF:
   5048              {
   5049                /* Check the parameters */
   5050                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   5051                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   5052                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5053                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5054                /* Configure the ETR Trigger source */
   5055                TIM_ETR_SetConfig(htim->Instance, 
   5056                                  sSlaveConfig->TriggerPrescaler, 
   5057                                  sSlaveConfig->TriggerPolarity, 
   5058                                  sSlaveConfig->TriggerFilter);
   5059              }
   5060              break;
   5061              
   5062            case TIM_TS_TI1F_ED:
   5063              {
   5064                /* Check the parameters */
   5065                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5066                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5067                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5068            
   5069                /* Disable the Channel 1: Reset the CC1E Bit */
   5070                tmpccer = htim->Instance->CCER;
   5071                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   5072                tmpccmr1 = htim->Instance->CCMR1;    
   5073                
   5074                /* Set the filter */
   5075                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5076                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
   5077                
   5078                /* Write to TIMx CCMR1 and CCER registers */
   5079                htim->Instance->CCMR1 = tmpccmr1;
   5080                htim->Instance->CCER = tmpccer;                               
   5081                                         
   5082              }
   5083              break;
   5084              
   5085            case TIM_TS_TI1FP1:
   5086              {
   5087                /* Check the parameters */
   5088                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5089                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5090                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5091          
   5092                /* Configure TI1 Filter and Polarity */
   5093                TIM_TI1_ConfigInputStage(htim->Instance,
   5094                                         sSlaveConfig->TriggerPolarity,
   5095                                         sSlaveConfig->TriggerFilter);
   5096              }
   5097              break;
   5098              
   5099            case TIM_TS_TI2FP2:
   5100              {
   5101                /* Check the parameters */
   5102                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5103                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5104                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5105            
   5106                /* Configure TI2 Filter and Polarity */
   5107                TIM_TI2_ConfigInputStage(htim->Instance,
   5108                                          sSlaveConfig->TriggerPolarity,
   5109                                          sSlaveConfig->TriggerFilter);
   5110              }
   5111              break;
   5112              
   5113            case TIM_TS_ITR0:
   5114              {
   5115                /* Check the parameter */
   5116                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5117              }
   5118              break;
   5119              
   5120            case TIM_TS_ITR1:
   5121              {
   5122                /* Check the parameter */
   5123                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5124              }
   5125              break;
   5126              
   5127            case TIM_TS_ITR2:
   5128              {
   5129                /* Check the parameter */
   5130                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5131              }
   5132              break;
   5133              
   5134            case TIM_TS_ITR3:
   5135              {
   5136                /* Check the parameter */
   5137                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5138              }
   5139              break;
   5140                 
   5141            default:
   5142              break;
   5143            }
   5144          }
   5145          
   5146          /**
   5147            * @brief  Configure the TI1 as Input.
   5148            * @param  TIMx to select the TIM peripheral.
   5149            * @param  TIM_ICPolarity : The Input Polarity.
   5150            *          This parameter can be one of the following values:
   5151            *            @arg TIM_ICPolarity_Rising
   5152            *            @arg TIM_ICPolarity_Falling
   5153            *            @arg TIM_ICPolarity_BothEdge  
   5154            * @param  TIM_ICSelection: specifies the input to be used.
   5155            *          This parameter can be one of the following values:
   5156            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   5157            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   5158            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   5159            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5160            *          This parameter must be a value between 0x00 and 0x0F.
   5161            * @retval None  
   5162            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   5163            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   5164            *        protected against un-initialized filter and polarity values.  
   5165            */

   \                                 In section .text, align 2, keep-with-next
   5166          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5167                                 uint32_t TIM_ICFilter)
   5168          {
   \                     TIM_TI1_SetConfig: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   5169            uint32_t tmpccmr1 = 0;
   5170            uint32_t tmpccer = 0;
   5171          
   5172            /* Disable the Channel 1: Reset the CC1E Bit */
   5173            TIMx->CCER &= ~TIM_CCER_CC1E;
   \   00000002   0x6A04             LDR      R4,[R0, #+32]
   5174            tmpccmr1 = TIMx->CCMR1;
   5175            tmpccer = TIMx->CCER;
   5176          
   5177            /* Select the Input */
   5178            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \   00000004   0x....             LDR.N    R6,??DataTable37_12  ;; 0x40010000
   \   00000006   0x0864             LSRS     R4,R4,#+1
   \   00000008   0x0064             LSLS     R4,R4,#+1
   \   0000000A   0x6204             STR      R4,[R0, #+32]
   \   0000000C   0x6985             LDR      R5,[R0, #+24]
   \   0000000E   0x42B0             CMP      R0,R6
   \   00000010   0x6A04             LDR      R4,[R0, #+32]
   \   00000012   0xBF18             IT       NE 
   \   00000014   0xF1B0 0x4F80      CMPNE    R0,#+1073741824
   \   00000018   0xD011             BEQ.N    ??TIM_TI1_SetConfig_0
   \   0000001A   0x....             LDR.N    R6,??DataTable37_14  ;; 0x40000400
   \   0000001C   0x42B0             CMP      R0,R6
   \   0000001E   0xBF1C             ITT      NE 
   \   00000020   0x....             LDRNE.N  R6,??DataTable37_15  ;; 0x40000800
   \   00000022   0x42B0             CMPNE    R0,R6
   \   00000024   0xD00B             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000026   0x....             LDR.N    R6,??DataTable37_16  ;; 0x40000c00
   \   00000028   0x42B0             CMP      R0,R6
   \   0000002A   0xBF1C             ITT      NE 
   \   0000002C   0x....             LDRNE.N  R6,??DataTable37_4  ;; 0x40010400
   \   0000002E   0x42B0             CMPNE    R0,R6
   \   00000030   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \   00000032   0x....             LDR.N    R6,??DataTable37_5  ;; 0x40014000
   \   00000034   0x42B0             CMP      R0,R6
   \   00000036   0xBF1C             ITT      NE 
   \   00000038   0x....             LDRNE.N  R6,??DataTable37_8  ;; 0x40001800
   \   0000003A   0x42B0             CMPNE    R0,R6
   \   0000003C   0xD103             BNE.N    ??TIM_TI1_SetConfig_1
   5179            {
   5180              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   5181              tmpccmr1 |= TIM_ICSelection;
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \   0000003E   0x08AD             LSRS     R5,R5,#+2
   \   00000040   0xEA42 0x0285      ORR      R2,R2,R5, LSL #+2
   \   00000044   0xE001             B.N      ??TIM_TI1_SetConfig_2
   5182            } 
   5183            else
   5184            {
   5185              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \   00000046   0xF045 0x0201      ORR      R2,R5,#0x1
   5186            }
   5187            
   5188            /* Set the filter */
   5189            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5190            tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
   5191          
   5192            /* Select the Polarity and set the CC1E Bit */
   5193            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5194            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   5195          
   5196            /* Write to TIMx CCMR1 and CCER registers */
   5197            TIMx->CCMR1 = tmpccmr1;
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \   0000004A   0x011B             LSLS     R3,R3,#+4
   \   0000004C   0xF022 0x02F0      BIC      R2,R2,#0xF0
   \   00000050   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   00000054   0x431A             ORRS     R2,R3,R2
   \   00000056   0x6182             STR      R2,[R0, #+24]
   5198            TIMx->CCER = tmpccer;
   \   00000058   0xF024 0x020A      BIC      R2,R4,#0xA
   \   0000005C   0xF001 0x010A      AND      R1,R1,#0xA
   \   00000060   0x4311             ORRS     R1,R1,R2
   \   00000062   0x6201             STR      R1,[R0, #+32]
   5199          }
   \   00000064   0xBC70             POP      {R4-R6}
   \   00000066   0x4770             BX       LR               ;; return
   5200          
   5201          /**
   5202            * @brief  Configure the Polarity and Filter for TI1.
   5203            * @param  TIMx to select the TIM peripheral.
   5204            * @param  TIM_ICPolarity : The Input Polarity.
   5205            *          This parameter can be one of the following values:
   5206            *            @arg TIM_ICPolarity_Rising
   5207            *            @arg TIM_ICPolarity_Falling
   5208            *            @arg TIM_ICPolarity_BothEdge
   5209            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5210            *          This parameter must be a value between 0x00 and 0x0F.
   5211            * @retval None
   5212            */
   5213          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5214          {
   5215            uint32_t tmpccmr1 = 0;
   5216            uint32_t tmpccer = 0;
   5217            
   5218            /* Disable the Channel 1: Reset the CC1E Bit */
   5219            tmpccer = TIMx->CCER;
   5220            TIMx->CCER &= ~TIM_CCER_CC1E;
   5221            tmpccmr1 = TIMx->CCMR1;    
   5222            
   5223            /* Set the filter */
   5224            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5225            tmpccmr1 |= (TIM_ICFilter << 4);
   5226            
   5227            /* Select the Polarity and set the CC1E Bit */
   5228            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5229            tmpccer |= TIM_ICPolarity;
   5230            
   5231            /* Write to TIMx CCMR1 and CCER registers */
   5232            TIMx->CCMR1 = tmpccmr1;
   5233            TIMx->CCER = tmpccer;
   5234          }
   5235          
   5236          /**
   5237            * @brief  Configure the TI2 as Input.
   5238            * @param  TIMx to select the TIM peripheral
   5239            * @param  TIM_ICPolarity : The Input Polarity.
   5240            *          This parameter can be one of the following values:
   5241            *            @arg TIM_ICPolarity_Rising
   5242            *            @arg TIM_ICPolarity_Falling
   5243            *            @arg TIM_ICPolarity_BothEdge   
   5244            * @param  TIM_ICSelection: specifies the input to be used.
   5245            *          This parameter can be one of the following values:
   5246            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   5247            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   5248            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   5249            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5250            *          This parameter must be a value between 0x00 and 0x0F.
   5251            * @retval None
   5252            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5253            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5254            *        protected against un-initialized filter and polarity values.  
   5255            */
   5256          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5257                                 uint32_t TIM_ICFilter)
   5258          {
   5259            uint32_t tmpccmr1 = 0;
   5260            uint32_t tmpccer = 0;
   5261          
   5262            /* Disable the Channel 2: Reset the CC2E Bit */
   5263            TIMx->CCER &= ~TIM_CCER_CC2E;
   5264            tmpccmr1 = TIMx->CCMR1;
   5265            tmpccer = TIMx->CCER;
   5266          
   5267            /* Select the Input */
   5268            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   5269            tmpccmr1 |= (TIM_ICSelection << 8);
   5270          
   5271            /* Set the filter */
   5272            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5273            tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
   5274          
   5275            /* Select the Polarity and set the CC2E Bit */
   5276            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5277            tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   5278          
   5279            /* Write to TIMx CCMR1 and CCER registers */
   5280            TIMx->CCMR1 = tmpccmr1 ;
   5281            TIMx->CCER = tmpccer;
   5282          }
   5283          
   5284          /**
   5285            * @brief  Configure the Polarity and Filter for TI2.
   5286            * @param  TIMx to select the TIM peripheral.
   5287            * @param  TIM_ICPolarity : The Input Polarity.
   5288            *          This parameter can be one of the following values:
   5289            *            @arg TIM_ICPolarity_Rising
   5290            *            @arg TIM_ICPolarity_Falling
   5291            *            @arg TIM_ICPolarity_BothEdge
   5292            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5293            *          This parameter must be a value between 0x00 and 0x0F.
   5294            * @retval None
   5295            */
   5296          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5297          {
   5298          uint32_t tmpccmr1 = 0;
   5299            uint32_t tmpccer = 0;
   5300            
   5301            /* Disable the Channel 2: Reset the CC2E Bit */
   5302            TIMx->CCER &= ~TIM_CCER_CC2E;
   5303            tmpccmr1 = TIMx->CCMR1;
   5304            tmpccer = TIMx->CCER;
   5305            
   5306            /* Set the filter */
   5307            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5308            tmpccmr1 |= (TIM_ICFilter << 12);
   5309          
   5310            /* Select the Polarity and set the CC2E Bit */
   5311            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5312            tmpccer |= (TIM_ICPolarity << 4);
   5313          
   5314            /* Write to TIMx CCMR1 and CCER registers */
   5315            TIMx->CCMR1 = tmpccmr1 ;
   5316            TIMx->CCER = tmpccer;
   5317          }
   5318          
   5319          /**
   5320            * @brief  Configure the TI3 as Input.
   5321            * @param  TIMx to select the TIM peripheral
   5322            * @param  TIM_ICPolarity : The Input Polarity.
   5323            *          This parameter can be one of the following values:
   5324            *            @arg TIM_ICPolarity_Rising
   5325            *            @arg TIM_ICPolarity_Falling
   5326            *            @arg TIM_ICPolarity_BothEdge         
   5327            * @param  TIM_ICSelection: specifies the input to be used.
   5328            *          This parameter can be one of the following values:
   5329            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   5330            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   5331            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   5332            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5333            *          This parameter must be a value between 0x00 and 0x0F.
   5334            * @retval None
   5335            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5336            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5337            *        protected against un-initialized filter and polarity values.  
   5338            */
   5339          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5340                                 uint32_t TIM_ICFilter)
   5341          {
   5342            uint32_t tmpccmr2 = 0;
   5343            uint32_t tmpccer = 0;
   5344          
   5345            /* Disable the Channel 3: Reset the CC3E Bit */
   5346            TIMx->CCER &= ~TIM_CCER_CC3E;
   5347            tmpccmr2 = TIMx->CCMR2;
   5348            tmpccer = TIMx->CCER;
   5349          
   5350            /* Select the Input */
   5351            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   5352            tmpccmr2 |= TIM_ICSelection;
   5353          
   5354            /* Set the filter */
   5355            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   5356            tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
   5357          
   5358            /* Select the Polarity and set the CC3E Bit */
   5359            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   5360            tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   5361          
   5362            /* Write to TIMx CCMR2 and CCER registers */
   5363            TIMx->CCMR2 = tmpccmr2;
   5364            TIMx->CCER = tmpccer;
   5365          }
   5366          
   5367          /**
   5368            * @brief  Configure the TI4 as Input.
   5369            * @param  TIMx to select the TIM peripheral
   5370            * @param  TIM_ICPolarity : The Input Polarity.
   5371            *          This parameter can be one of the following values:
   5372            *            @arg TIM_ICPolarity_Rising
   5373            *            @arg TIM_ICPolarity_Falling
   5374            *            @arg TIM_ICPolarity_BothEdge     
   5375            * @param  TIM_ICSelection: specifies the input to be used.
   5376            *          This parameter can be one of the following values:
   5377            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   5378            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   5379            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   5380            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   5381            *          This parameter must be a value between 0x00 and 0x0F.
   5382            * @retval None
   5383            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5384            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5385            *        protected against un-initialized filter and polarity values.  
   5386            */
   5387          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5388                                 uint32_t TIM_ICFilter)
   5389          {
   5390            uint32_t tmpccmr2 = 0;
   5391            uint32_t tmpccer = 0;
   5392          
   5393            /* Disable the Channel 4: Reset the CC4E Bit */
   5394            TIMx->CCER &= ~TIM_CCER_CC4E;
   5395            tmpccmr2 = TIMx->CCMR2;
   5396            tmpccer = TIMx->CCER;
   5397          
   5398            /* Select the Input */
   5399            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   5400            tmpccmr2 |= (TIM_ICSelection << 8);
   5401          
   5402            /* Set the filter */
   5403            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   5404            tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
   5405          
   5406            /* Select the Polarity and set the CC4E Bit */
   5407            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   5408            tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   5409          
   5410            /* Write to TIMx CCMR2 and CCER registers */
   5411            TIMx->CCMR2 = tmpccmr2;
   5412            TIMx->CCER = tmpccer ;
   5413          }
   5414          
   5415          /**
   5416            * @brief  Selects the Input Trigger source
   5417            * @param  TIMx to select the TIM peripheral
   5418            * @param  TIM_ITRx: The Input Trigger source.
   5419            *          This parameter can be one of the following values:
   5420            *            @arg TIM_TS_ITR0: Internal Trigger 0
   5421            *            @arg TIM_TS_ITR1: Internal Trigger 1
   5422            *            @arg TIM_TS_ITR2: Internal Trigger 2
   5423            *            @arg TIM_TS_ITR3: Internal Trigger 3
   5424            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   5425            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   5426            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   5427            *            @arg TIM_TS_ETRF: External Trigger input
   5428            * @retval None
   5429            */
   5430          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
   5431          {
   5432            uint32_t tmpsmcr = 0;
   5433            
   5434             /* Get the TIMx SMCR register value */
   5435             tmpsmcr = TIMx->SMCR;
   5436             /* Reset the TS Bits */
   5437             tmpsmcr &= ~TIM_SMCR_TS;
   5438             /* Set the Input Trigger source and the slave mode*/
   5439             tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
   5440             /* Write to TIMx SMCR */
   5441             TIMx->SMCR = tmpsmcr;
   5442          }
   5443          
   5444          /**
   5445            * @brief  Configures the TIMx External Trigger (ETR).
   5446            * @param  TIMx to select the TIM peripheral
   5447            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   5448            *          This parameter can be one of the following values:
   5449            *            @arg TIM_ExtTRGPSC_DIV1: ETRP Prescaler OFF.
   5450            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   5451            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   5452            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   5453            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   5454            *          This parameter can be one of the following values:
   5455            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   5456            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   5457            * @param  ExtTRGFilter: External Trigger Filter.
   5458            *          This parameter must be a value between 0x00 and 0x0F
   5459            * @retval None
   5460            */

   \                                 In section .text, align 2, keep-with-next
   5461          void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5462                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5463          {
   5464            uint32_t tmpsmcr = 0;
   5465          
   5466            tmpsmcr = TIMx->SMCR;
   5467          
   5468            /* Reset the ETR Bits */
   5469            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   5470          
   5471            /* Set the Prescaler, the Filter value and the Polarity */
   5472            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   5473          
   5474            /* Write to TIMx SMCR */
   5475            TIMx->SMCR = tmpsmcr;
   \                     TIM_ETR_SetConfig: (+1)
   \   00000000   0xF8D0 0xC008      LDR      R12,[R0, #+8]
   \   00000004   0xF42C 0x4C7F      BIC      R12,R12,#0xFF00
   \   00000008   0xEA41 0x010C      ORR      R1,R1,R12
   \   0000000C   0x4311             ORRS     R1,R2,R1
   \   0000000E   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \   00000012   0x6081             STR      R1,[R0, #+8]
   5476          } 
   \   00000014   0x4770             BX       LR               ;; return
   5477          
   5478          /**
   5479            * @brief  Enables or disables the TIM Capture Compare Channel x.
   5480            * @param  TIMx to select the TIM peripheral
   5481            * @param  Channel: specifies the TIM Channel
   5482            *          This parameter can be one of the following values:
   5483            *            @arg TIM_Channel_1: TIM Channel 1
   5484            *            @arg TIM_Channel_2: TIM Channel 2
   5485            *            @arg TIM_Channel_3: TIM Channel 3
   5486            *            @arg TIM_Channel_4: TIM Channel 4
   5487            * @param  ChannelState: specifies the TIM Channel CCxE bit new state.
   5488            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
   5489            * @retval None
   5490            */

   \                                 In section .text, align 2, keep-with-next
   5491          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   5492          {
   5493            uint32_t tmp = 0;
   5494          
   5495            /* Check the parameters */
   5496            assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
   5497            assert_param(IS_TIM_CHANNELS(Channel));
   5498          
   5499            tmp = TIM_CCER_CC1E << Channel;
   5500          
   5501            /* Reset the CCxE Bit */
   5502            TIMx->CCER &= ~tmp;
   \                     TIM_CCxChannelCmd: (+1)
   \   00000000   0x6A03             LDR      R3,[R0, #+32]
   \   00000002   0xF04F 0x0C01      MOV      R12,#+1
   \   00000006   0xFA0C 0xFC01      LSL      R12,R12,R1
   5503          
   5504            /* Set or reset the CCxE Bit */ 
   5505            TIMx->CCER |= (uint32_t)(ChannelState << Channel);
   \   0000000A   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000000E   0xEA23 0x030C      BIC      R3,R3,R12
   \   00000012   0x6203             STR      R3,[R0, #+32]
   \   00000014   0x6A03             LDR      R3,[R0, #+32]
   \   00000016   0x4319             ORRS     R1,R1,R3
   \   00000018   0x6201             STR      R1,[R0, #+32]
   5506          }
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x40002000         DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x40002000         DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0xFFFEFFF8         DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0xFFFFFCFC         DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0xFFFF0303         DC32     0xffff0303

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x........         DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x40000C00         DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0xFFFEFFF8         DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x........         DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \   00000000   0xFFFE0088         DC32     0xfffe0088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_3:
   \   00000000   0xFFFEFF88         DC32     0xfffeff88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_4:
   \   00000000   0x40010400         DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_5:
   \   00000000   0x40014000         DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_6:
   \   00000000   0x40014400         DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_7:
   \   00000000   0x40014800         DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_8:
   \   00000000   0x40001800         DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_9:
   \   00000000   0x40001C00         DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_10:
   \   00000000   0x40002000         DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_11:
   \   00000000   0xFFFEFF8C         DC32     0xfffeff8c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_12:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_13:
   \   00000000   0xFEFF8CFF         DC32     0xfeff8cff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_14:
   \   00000000   0x40000400         DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_15:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_16:
   \   00000000   0x40000C00         DC32     0x40000c00
   5507          
   5508          
   5509          /**
   5510            * @}
   5511            */
   5512          
   5513          #endif /* HAL_TIM_MODULE_ENABLED */
   5514          /**
   5515            * @}
   5516            */ 
   5517          
   5518          /**
   5519            * @}
   5520            */ 
   5521          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
      16   HAL_TIM_Base_Init
        16   -> HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
       8   HAL_TIM_Base_Start_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       0   HAL_TIM_Base_Stop_IT
       8   HAL_TIM_ConfigClockSource
      16   HAL_TIM_ConfigOCrefClear
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      16   HAL_TIM_Encoder_Init
        16   -> HAL_TIM_Encoder_MspInit
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
       0   HAL_TIM_Encoder_Start
      24   HAL_TIM_Encoder_Start_DMA
        24   -> HAL_DMA_Start_IT
       0   HAL_TIM_Encoder_Start_IT
       0   HAL_TIM_Encoder_Stop
       0   HAL_TIM_Encoder_Stop_DMA
       0   HAL_TIM_Encoder_Stop_IT
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      20   HAL_TIM_IC_ConfigChannel
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
      16   HAL_TIM_IC_Init
        16   -> HAL_TIM_IC_MspInit
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
       0   HAL_TIM_IC_Start
      16   HAL_TIM_IC_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_IC_Start_IT
       0   HAL_TIM_IC_Stop
       4   HAL_TIM_IC_Stop_DMA
       0   HAL_TIM_IC_Stop_IT
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIMEx_BreakCallback
         0   -> HAL_TIMEx_CommutationCallback
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
       8   HAL_TIM_OC_ConfigChannel
         8   -> TIM_OC1_SetConfig
         8   -> TIM_OC2_SetConfig
         8   -> TIM_OC3_SetConfig
         8   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
      16   HAL_TIM_OC_Init
        16   -> HAL_TIM_OC_MspInit
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
       0   HAL_TIM_OC_Start
      16   HAL_TIM_OC_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_OC_Start_IT
       0   HAL_TIM_OC_Stop
       4   HAL_TIM_OC_Stop_DMA
       0   HAL_TIM_OC_Stop_IT
      48   HAL_TIM_OnePulse_ConfigChannel
        48   -> TIM_OC1_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
       0   HAL_TIM_OnePulse_Start
       0   HAL_TIM_OnePulse_Start_IT
       0   HAL_TIM_OnePulse_Stop
       0   HAL_TIM_OnePulse_Stop_IT
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
      16   HAL_TIM_PWM_Init
        16   -> HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       0   HAL_TIM_PWM_Start
      16   HAL_TIM_PWM_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_PWM_Start_IT
       0   HAL_TIM_PWM_Stop
       4   HAL_TIM_PWM_Stop_DMA
       0   HAL_TIM_PWM_Stop_IT
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_ReadCapturedValue
       8   HAL_TIM_SlaveConfigSynchronization
       8   HAL_TIM_SlaveConfigSynchronization_IT
       0   HAL_TIM_TriggerCallback
       0   TIM_Base_SetConfig
       0   TIM_CCxChannelCmd
       8   TIM_DMACaptureCplt
         8   -> HAL_TIM_IC_CaptureCallback
       8   TIM_DMADelayPulseCplt
         8   -> HAL_TIM_PWM_PulseFinishedCallback
       8   TIM_DMAError
         8   -> HAL_TIM_ErrorCallback
       8   TIM_DMAPeriodElapsedCplt
         8   -> HAL_TIM_PeriodElapsedCallback
       8   TIM_DMATriggerCplt
         8   -> HAL_TIM_TriggerCallback
       0   TIM_ETR_SetConfig
       8   TIM_OC1_SetConfig
      12   TIM_OC2_SetConfig
      12   TIM_OC3_SetConfig
       8   TIM_OC4_SetConfig
      12   TIM_TI1_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable17
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable25
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable30
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_10
       4  ??DataTable37_11
       4  ??DataTable37_12
       4  ??DataTable37_13
       4  ??DataTable37_14
       4  ??DataTable37_15
       4  ??DataTable37_16
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable37_6
       4  ??DataTable37_7
       4  ??DataTable37_8
       4  ??DataTable37_9
      58  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
     222  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      26  HAL_TIM_Base_Start
      84  HAL_TIM_Base_Start_DMA
      22  HAL_TIM_Base_Start_IT
      46  HAL_TIM_Base_Stop
      50  HAL_TIM_Base_Stop_DMA
      42  HAL_TIM_Base_Stop_IT
     414  HAL_TIM_ConfigClockSource
     180  HAL_TIM_ConfigOCrefClear
      16  HAL_TIM_ConfigTI1Input
     330  HAL_TIM_DMABurst_ReadStart
      96  HAL_TIM_DMABurst_ReadStop
     330  HAL_TIM_DMABurst_WriteStart
      96  HAL_TIM_DMABurst_WriteStop
      58  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     318  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      78  HAL_TIM_Encoder_Start
     330  HAL_TIM_Encoder_Start_DMA
     118  HAL_TIM_Encoder_Start_IT
      82  HAL_TIM_Encoder_Stop
     130  HAL_TIM_Encoder_Stop_DMA
     130  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      44  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     432  HAL_TIM_IC_ConfigChannel
      58  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
     208  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      32  HAL_TIM_IC_Start
     236  HAL_TIM_IC_Start_DMA
      92  HAL_TIM_IC_Start_IT
      52  HAL_TIM_IC_Stop
     124  HAL_TIM_IC_Stop_DMA
     112  HAL_TIM_IC_Stop_IT
     356  HAL_TIM_IRQHandler
      94  HAL_TIM_OC_ConfigChannel
      58  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
     226  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      56  HAL_TIM_OC_Start
     274  HAL_TIM_OC_Start_DMA
     116  HAL_TIM_OC_Start_IT
      96  HAL_TIM_OC_Stop
     170  HAL_TIM_OC_Stop_DMA
     156  HAL_TIM_OC_Stop_IT
     266  HAL_TIM_OnePulse_ConfigChannel
      58  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
     244  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      62  HAL_TIM_OnePulse_Start
      78  HAL_TIM_OnePulse_Start_IT
     102  HAL_TIM_OnePulse_Stop
     118  HAL_TIM_OnePulse_Stop_IT
     222  HAL_TIM_PWM_ConfigChannel
      58  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
     226  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      54  HAL_TIM_PWM_Start
     270  HAL_TIM_PWM_Start_DMA
     112  HAL_TIM_PWM_Start_IT
     104  HAL_TIM_PWM_Stop
     166  HAL_TIM_PWM_Stop_DMA
     152  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      98  HAL_TIM_ReadCapturedValue
     224  HAL_TIM_SlaveConfigSynchronization
     248  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
     184  TIM_Base_SetConfig
      28  TIM_CCxChannelCmd
      62  TIM_DMACaptureCplt
      62  TIM_DMADelayPulseCplt
      20  TIM_DMAError
      20  TIM_DMAPeriodElapsedCplt
      20  TIM_DMATriggerCplt
      22  TIM_ETR_SetConfig
      82  TIM_OC1_SetConfig
      90  TIM_OC2_SetConfig
      88  TIM_OC3_SetConfig
      72  TIM_OC4_SetConfig
     104  TIM_TI1_SetConfig

 
 10 248 bytes in section .text
 
 10 248 bytes of CODE memory

Errors: none
Warnings: none
