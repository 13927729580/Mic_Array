###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       11/Oct/2016  14:17:39
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
#    Command line =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e
#        --char_is_signed --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_hcd.lst
#    Object file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_hcd.o
#
###############################################################################

D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_hcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_hcd.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   HCD HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the USB Peripheral Controller:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16            ==============================================================================
     17                              ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              (#)Declare a HCD_HandleTypeDef handle structure, for example:
     21                 HCD_HandleTypeDef  hhcd;
     22                  
     23              (#)Fill parameters of Init structure in HCD handle
     24            
     25              (#)Call HAL_HCD_Init() API to initialize the HCD peripheral (Core, Host core, ...) 
     26          
     27              (#)Initialize the HCD low level resources through the HAL_HCD_MspInit() API:
     28                  (##) Enable the HCD/USB Low Level interface clock using the following macros
     29                       (+++) __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
     30                       (+++) __HAL_RCC_USB_OTG_HS_CLK_ENABLE(); (For High Speed Mode)
     31                       (+++) __HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE(); (For High Speed Mode)
     32                     
     33                  (##) Initialize the related GPIO clocks
     34                  (##) Configure HCD pin-out
     35                  (##) Configure HCD NVIC interrupt
     36              
     37              (#)Associate the Upper USB Host stack to the HAL HCD Driver:
     38                  (##) hhcd.pData = phost;
     39          
     40              (#)Enable HCD transmission and reception:
     41                  (##) HAL_HCD_Start();
     42          
     43            @endverbatim
     44            ******************************************************************************
     45            * @attention
     46            *
     47            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     48            *
     49            * Redistribution and use in source and binary forms, with or without modification,
     50            * are permitted provided that the following conditions are met:
     51            *   1. Redistributions of source code must retain the above copyright notice,
     52            *      this list of conditions and the following disclaimer.
     53            *   2. Redistributions in binary form must reproduce the above copyright notice,
     54            *      this list of conditions and the following disclaimer in the documentation
     55            *      and/or other materials provided with the distribution.
     56            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     57            *      may be used to endorse or promote products derived from this software
     58            *      without specific prior written permission.
     59            *
     60            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     61            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     62            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     63            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     64            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     65            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     66            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     67            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     68            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     69            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     70            *
     71            ******************************************************************************
     72            */ 
     73          
     74          /* Includes ------------------------------------------------------------------*/
     75          #include "stm32f7xx_hal.h"
     76          
     77          /** @addtogroup STM32F7xx_HAL_Driver
     78            * @{
     79            */
     80          
     81          /** @defgroup HCD HCD 
     82            * @brief HCD HAL module driver
     83            * @{
     84            */
     85          
     86          #ifdef HAL_HCD_MODULE_ENABLED
     87          
     88          /* Private typedef -----------------------------------------------------------*/
     89          /* Private define ------------------------------------------------------------*/
     90          /* Private macro -------------------------------------------------------------*/
     91          /* Private variables ---------------------------------------------------------*/
     92          /* Private function ----------------------------------------------------------*/
     93          /** @defgroup HCD_Private_Functions HCD Private Functions
     94            * @{
     95            */
     96          static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum);
     97          static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum); 
     98          static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd);
     99          static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd);
    100          /**
    101            * @}
    102            */
    103          
    104          /* Exported functions --------------------------------------------------------*/
    105          /** @defgroup HCD_Exported_Functions HCD Exported Functions
    106            * @{
    107            */
    108          
    109          /** @defgroup HCD_Exported_Functions_Group1 Initialization and de-initialization functions 
    110           *  @brief    Initialization and Configuration functions 
    111           *
    112          @verbatim    
    113           ===============================================================================
    114                    ##### Initialization and de-initialization functions #####
    115           ===============================================================================
    116              [..]  This section provides functions allowing to:
    117           
    118          @endverbatim
    119            * @{
    120            */
    121          
    122          /**
    123            * @brief  Initialize the host driver.
    124            * @param  hhcd: HCD handle
    125            * @retval HAL status
    126            */

   \                                 In section .text, align 2, keep-with-next
    127          HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
    128          { 
   \                     HAL_HCD_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB08A             SUB      SP,SP,#+40
    129            /* Check the HCD handle allocation */
    130            if(hhcd == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    131            {
    132              return HAL_ERROR;
   \   0000000A   0xD024             BEQ.N    ??HAL_HCD_Init_0
    133            }
    134            
    135            /* Check the parameters */
    136            assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
    137          
    138            hhcd->State = HAL_HCD_STATE_BUSY;
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0xF884 0x028D      STRB     R0,[R4, #+653]
    139            
    140            /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    141            HAL_HCD_MspInit(hhcd);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_HCD_MspInit
    142          
    143            /* Disable the Interrupts */
    144           __HAL_HCD_DISABLE(hhcd);
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       USB_DisableGlobalInt
    145           
    146           /*Init the Core (common init.) */
    147           USB_CoreInit(hhcd->Instance, hhcd->Init);
   \   0000001E   0xB083             SUB      SP,SP,#+12
   \   00000020   0x1D21             ADDS     R1,R4,#+4
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x2230             MOVS     R2,#+48
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0xBC0E             POP      {R1-R3}
   \   0000002E   0x.... 0x....      BL       USB_CoreInit
    148           
    149           /* Force Host Mode*/
    150           USB_SetCurrentMode(hhcd->Instance , USB_OTG_HOST_MODE);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x.... 0x....      BL       USB_SetCurrentMode
    151           
    152           /* Init Host */
    153           USB_HostInit(hhcd->Instance, hhcd->Init);
   \   0000003A   0xB083             SUB      SP,SP,#+12
   \   0000003C   0x1D21             ADDS     R1,R4,#+4
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x2230             MOVS     R2,#+48
   \   00000042   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xBC0E             POP      {R1-R3}
   \   0000004A   0x.... 0x....      BL       USB_HostInit
    154           
    155           hhcd->State= HAL_HCD_STATE_READY;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xF884 0x028D      STRB     R0,[R4, #+653]
    156           
    157           return HAL_OK;
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??HAL_HCD_Init_0: (+1)
   \   00000056   0xB00A             ADD      SP,SP,#+40
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    158          }
    159          
    160          /**
    161            * @brief  Initialize a host channel.
    162            * @param  hhcd: HCD handle
    163            * @param  ch_num: Channel number.
    164            *         This parameter can be a value from 1 to 15
    165            * @param  epnum: Endpoint number.
    166            *          This parameter can be a value from 1 to 15
    167            * @param  dev_address : Current device address
    168            *          This parameter can be a value from 0 to 255
    169            * @param  speed: Current device speed.
    170            *          This parameter can be one of these values:
    171            *            HCD_SPEED_HIGH: High speed mode,
    172            *            HCD_SPEED_FULL: Full speed mode,
    173            *            HCD_SPEED_LOW: Low speed mode
    174            * @param  ep_type: Endpoint Type.
    175            *          This parameter can be one of these values:
    176            *            EP_TYPE_CTRL: Control type,
    177            *            EP_TYPE_ISOC: Isochronous type,
    178            *            EP_TYPE_BULK: Bulk type,
    179            *            EP_TYPE_INTR: Interrupt type
    180            * @param  mps: Max Packet Size.
    181            *          This parameter can be a value from 0 to32K
    182            * @retval HAL status
    183            */

   \                                 In section .text, align 2, keep-with-next
    184          HAL_StatusTypeDef HAL_HCD_HC_Init(HCD_HandleTypeDef *hhcd,  
    185                                            uint8_t ch_num,
    186                                            uint8_t epnum,
    187                                            uint8_t dev_address,
    188                                            uint8_t speed,
    189                                            uint8_t ep_type,
    190                                            uint16_t mps)
    191          {
   \                     HAL_HCD_HC_Init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0xB083             SUB      SP,SP,#+12
    192            HAL_StatusTypeDef status = HAL_OK;
    193            
    194            __HAL_LOCK(hhcd); 
   \   00000006   0xF996 0x028C      LDRSB    R0,[R6, #+652]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xD022             BEQ.N    ??HAL_HCD_HC_Init_0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF886 0x028C      STRB     R0,[R6, #+652]
    195            
    196            hhcd->hc[ch_num].dev_addr = dev_address;
   \   00000018   0xEB01 0x0081      ADD      R0,R1,R1, LSL #+2
   \   0000001C   0xEB06 0x07C0      ADD      R7,R6,R0, LSL #+3
    197            hhcd->hc[ch_num].max_packet = mps;
    198            hhcd->hc[ch_num].ch_num = ch_num;
    199            hhcd->hc[ch_num].ep_type = ep_type;
    200            hhcd->hc[ch_num].ep_num = epnum & 0x7F;
   \   00000020   0xF002 0x007F      AND      R0,R2,#0x7F
   \   00000024   0xF887 0x3034      STRB     R3,[R7, #+52]
   \   00000028   0x9C0A             LDR      R4,[SP, #+40]
   \   0000002A   0xF887 0x1035      STRB     R1,[R7, #+53]
   \   0000002E   0x87BC             STRH     R4,[R7, #+60]
   \   00000030   0x9D09             LDR      R5,[SP, #+36]
   \   00000032   0xF887 0x0036      STRB     R0,[R7, #+54]
    201            hhcd->hc[ch_num].ep_is_in = ((epnum & 0x80) == 0x80);
   \   00000036   0x09D0             LSRS     R0,R2,#+7
   \   00000038   0xF887 0x503B      STRB     R5,[R7, #+59]
   \   0000003C   0xF887 0x0037      STRB     R0,[R7, #+55]
   \   00000040   0x9808             LDR      R0,[SP, #+32]
    202            hhcd->hc[ch_num].speed = speed;
   \   00000042   0xF887 0x0038      STRB     R0,[R7, #+56]
    203          
    204            status =  USB_HC_Init(hhcd->Instance, 
    205                                  ch_num,
    206                                  epnum,
    207                                  dev_address,
    208                                  speed,
    209                                  ep_type,
    210                                  mps);
   \   00000046   0x9402             STR      R4,[SP, #+8]
   \   00000048   0x9501             STR      R5,[SP, #+4]
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0x6830             LDR      R0,[R6, #+0]
   \   0000004E   0x.... 0x....      BL       USB_HC_Init
    211            __HAL_UNLOCK(hhcd); 
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0xF886 0x128C      STRB     R1,[R6, #+652]
    212            
    213            return status;
   \                     ??HAL_HCD_HC_Init_0: (+1)
   \   00000058   0xB003             ADD      SP,SP,#+12
   \   0000005A   0xBDF0             POP      {R4-R7,PC}       ;; return
    214          }
    215          
    216          /**
    217            * @brief  Halt a host channel.
    218            * @param  hhcd: HCD handle
    219            * @param  ch_num: Channel number.
    220            *         This parameter can be a value from 1 to 15
    221            * @retval HAL status
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
    224          {
   \                     HAL_HCD_HC_Halt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    225            HAL_StatusTypeDef status = HAL_OK;
    226            
    227            __HAL_LOCK(hhcd);   
   \   00000004   0xF994 0x028C      LDRSB    R0,[R4, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_HC_Halt_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_HC_Halt_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x028C      STRB     R0,[R4, #+652]
    228            USB_HC_Halt(hhcd->Instance, ch_num);   
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_HC_Halt
    229            __HAL_UNLOCK(hhcd);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x028C      STRB     R0,[R4, #+652]
    230            
    231            return status;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    232          }
    233          
    234          /**
    235            * @brief  DeInitialize the host driver.
    236            * @param  hhcd: HCD handle
    237            * @retval HAL status
    238            */

   \                                 In section .text, align 2, keep-with-next
    239          HAL_StatusTypeDef HAL_HCD_DeInit(HCD_HandleTypeDef *hhcd)
    240          {
   \                     HAL_HCD_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    241            /* Check the HCD handle allocation */
    242            if(hhcd == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_HCD_DeInit_0
    243            {
    244              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    245            }
    246            
    247            hhcd->State = HAL_HCD_STATE_BUSY;
   \                     ??HAL_HCD_DeInit_0: (+1)
   \   0000000A   0x2003             MOVS     R0,#+3
   \   0000000C   0xF884 0x028D      STRB     R0,[R4, #+653]
    248            
    249            /* DeInit the low level hardware */
    250            HAL_HCD_MspDeInit(hhcd);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_HCD_MspDeInit
    251            
    252             __HAL_HCD_DISABLE(hhcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_DisableGlobalInt
    253            
    254            hhcd->State = HAL_HCD_STATE_RESET; 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x028D      STRB     R0,[R4, #+653]
    255            
    256            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    257          }
    258          
    259          /**
    260            * @brief  Initialize the HCD MSP.
    261            * @param  hhcd: HCD handle
    262            * @retval None
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          __weak void  HAL_HCD_MspInit(HCD_HandleTypeDef *hhcd)
    265          {
    266            /* Prevent unused argument(s) compilation warning */
    267            UNUSED(hhcd);
    268            
    269            /* NOTE : This function Should not be modified, when the callback is needed,
    270                      the HAL_HCD_MspInit could be implemented in the user file
    271             */
    272          }
   \                     HAL_HCD_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    273          
    274          /**
    275            * @brief  DeInitialize the HCD MSP.
    276            * @param  hhcd: HCD handle
    277            * @retval None
    278            */

   \                                 In section .text, align 2, keep-with-next
    279          __weak void  HAL_HCD_MspDeInit(HCD_HandleTypeDef *hhcd)
    280          {
    281            /* Prevent unused argument(s) compilation warning */
    282            UNUSED(hhcd);
    283            
    284            /* NOTE : This function Should not be modified, when the callback is needed,
    285                      the HAL_HCD_MspDeInit could be implemented in the user file
    286             */
    287          }
   \                     HAL_HCD_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    288          
    289          /**
    290            * @}
    291            */
    292          
    293          /** @defgroup HCD_Exported_Functions_Group2 Input and Output operation functions
    294            *  @brief   HCD IO operation functions
    295            *
    296          @verbatim
    297           ===============================================================================
    298                                ##### IO operation functions #####
    299           ===============================================================================
    300           [..] This subsection provides a set of functions allowing to manage the USB Host Data 
    301              Transfer
    302                 
    303          @endverbatim
    304            * @{
    305            */
    306            
    307          /**                                
    308            * @brief  Submit a new URB for processing. 
    309            * @param  hhcd: HCD handle
    310            * @param  ch_num: Channel number.
    311            *         This parameter can be a value from 1 to 15
    312            * @param  direction: Channel number.
    313            *          This parameter can be one of these values:
    314            *           0 : Output / 1 : Input
    315            * @param  ep_type: Endpoint Type.
    316            *          This parameter can be one of these values:
    317            *            EP_TYPE_CTRL: Control type/
    318            *            EP_TYPE_ISOC: Isochronous type/
    319            *            EP_TYPE_BULK: Bulk type/
    320            *            EP_TYPE_INTR: Interrupt type/
    321            * @param  token: Endpoint Type.
    322            *          This parameter can be one of these values:
    323            *            0: HC_PID_SETUP / 1: HC_PID_DATA1
    324            * @param  pbuff: pointer to URB data
    325            * @param  length: Length of URB data
    326            * @param  do_ping: activate do ping protocol (for high speed only).
    327            *          This parameter can be one of these values:
    328            *           0 : do ping inactive / 1 : do ping active 
    329            * @retval HAL status
    330            */

   \                                 In section .text, align 4, keep-with-next
    331          HAL_StatusTypeDef HAL_HCD_HC_SubmitRequest(HCD_HandleTypeDef *hhcd,
    332                                                      uint8_t ch_num, 
    333                                                      uint8_t direction ,
    334                                                      uint8_t ep_type,  
    335                                                      uint8_t token, 
    336                                                      uint8_t* pbuff, 
    337                                                      uint16_t length,
    338                                                      uint8_t do_ping) 
    339          {
   \                     HAL_HCD_HC_SubmitRequest: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    340            hhcd->hc[ch_num].ep_is_in = direction;
   \   00000002   0xEB01 0x0481      ADD      R4,R1,R1, LSL #+2
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0xEB00 0x06C4      ADD      R6,R0,R4, LSL #+3
   \   0000000C   0xF886 0x2037      STRB     R2,[R6, #+55]
    341            hhcd->hc[ch_num].ep_type  = ep_type; 
   \   00000010   0xF886 0x303B      STRB     R3,[R6, #+59]
   \   00000014   0x9D04             LDR      R5,[SP, #+16]
    342            
    343            if(token == 0)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xBF0C             ITE      EQ 
   \   0000001A   0x2403             MOVEQ    R4,#+3
   \   0000001C   0x2402             MOVNE    R4,#+2
    344            {
    345              hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    346            }
    347            else
    348            {
    349              hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    350            }
    351            
    352            /* Manage Data Toggle */
    353            switch(ep_type)
   \   0000001E   0x2B03             CMP      R3,#+3
   \   00000020   0xF886 0x403E      STRB     R4,[R6, #+62]
   \   00000024   0x9C06             LDR      R4,[SP, #+24]
   \   00000026   0xD822             BHI.N    ??HAL_HCD_HC_SubmitRequest_1
   \   00000028   0xE8DF 0xF003      TBB      [PC, R3]
   \                     ??HAL_HCD_HC_SubmitRequest_0:
   \   0000002C   0x02 0x1E          DC8      0x2,0x1E,0xB,0x1A
   \              0x0B 0x1A    
    354            {
    355            case EP_TYPE_CTRL:
    356              if((token == 1) && (direction == 0)) /*send data */
   \                     ??HAL_HCD_HC_SubmitRequest_2: (+1)
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xBF08             IT       EQ 
   \   00000034   0x2A00             CMPEQ    R2,#+0
   \   00000036   0xD11A             BNE.N    ??HAL_HCD_HC_SubmitRequest_1
    357              {
    358                if ( length == 0 )
   \   00000038   0xB924             CBNZ.N   R4,??HAL_HCD_HC_SubmitRequest_3
    359                { /* For Status OUT stage, Length==0, Status Out PID = 1 */
    360                  hhcd->hc[ch_num].toggle_out = 1;
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0xF886 0x204D      STRB     R2,[R6, #+77]
   \   00000040   0xE000             B.N      ??HAL_HCD_HC_SubmitRequest_3
    361                }
    362                
    363                /* Set the Data Toggle bit as per the Flag */
    364                if ( hhcd->hc[ch_num].toggle_out == 0)
    365                { /* Put the PID 0 */
    366                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
    367                }
    368                else
    369                { /* Put the PID 1 */
    370                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
    371                }
    372                if(hhcd->hc[ch_num].urb_state  != URB_NOTREADY)
    373                {
    374                  hhcd->hc[ch_num].do_ping = do_ping;
    375                }
    376              }
    377              break;
    378            
    379            case EP_TYPE_BULK:
    380              if(direction == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_4: (+1)
   \   00000042   0xBB42             CBNZ.N   R2,??HAL_HCD_HC_SubmitRequest_5
    381              {
    382                /* Set the Data Toggle bit as per the Flag */
    383                if ( hhcd->hc[ch_num].toggle_out == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_3: (+1)
   \   00000044   0xF896 0x204D      LDRB     R2,[R6, #+77]
   \   00000048   0xB102             CBZ.N    R2,??HAL_HCD_HC_SubmitRequest_6
    384                { /* Put the PID 0 */
    385                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
    386                }
    387                else
    388                { /* Put the PID 1 */
    389                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
   \   0000004A   0x2202             MOVS     R2,#+2
   \                     ??HAL_HCD_HC_SubmitRequest_6: (+1)
   \   0000004C   0xF886 0x203E      STRB     R2,[R6, #+62]
    390                }
    391                if(hhcd->hc[ch_num].urb_state  != URB_NOTREADY)
   \   00000050   0xF996 0x2058      LDRSB    R2,[R6, #+88]
   \   00000054   0x2A02             CMP      R2,#+2
   \   00000056   0xD00A             BEQ.N    ??HAL_HCD_HC_SubmitRequest_1
    392                {
    393                  hhcd->hc[ch_num].do_ping = do_ping;
   \   00000058   0x9A07             LDR      R2,[SP, #+28]
   \   0000005A   0xF886 0x2039      STRB     R2,[R6, #+57]
   \   0000005E   0xE006             B.N      ??HAL_HCD_HC_SubmitRequest_1
    394                }
    395              }
    396              else
    397              {
    398                if( hhcd->hc[ch_num].toggle_in == 0)
    399                {
    400                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    401                }
    402                else
    403                {
    404                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    405                }
    406              }
    407              
    408              break;
    409            case EP_TYPE_INTR:
    410              if(direction == 0)
   \                     ??HAL_HCD_HC_SubmitRequest_7: (+1)
   \   00000060   0xB9CA             CBNZ.N   R2,??HAL_HCD_HC_SubmitRequest_5
    411              {
    412                /* Set the Data Toggle bit as per the Flag */
    413                if ( hhcd->hc[ch_num].toggle_out == 0)
   \   00000062   0xF896 0x204D      LDRB     R2,[R6, #+77]
   \   00000066   0xB9D2             CBNZ.N   R2,??HAL_HCD_HC_SubmitRequest_8
    414                { /* Put the PID 0 */
    415                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;    
    416                }
    417                else
    418                { /* Put the PID 1 */
    419                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1 ;
    420                }
    421              }
    422              else
    423              {
    424                if( hhcd->hc[ch_num].toggle_in == 0)
    425                {
    426                  hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
    427                }
    428                else
    429                {
    430                  hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
    431                }
    432              }
    433              break;
    434              
    435            case EP_TYPE_ISOC: 
    436              hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
   \                     ??HAL_HCD_HC_SubmitRequest_9: (+1)
   \   00000068   0x2200             MOVS     R2,#+0
   \                     ??HAL_HCD_HC_SubmitRequest_10: (+1)
   \   0000006A   0xF886 0x203E      STRB     R2,[R6, #+62]
    437              break;      
    438            }
    439            
    440            hhcd->hc[ch_num].xfer_buff = pbuff;
   \                     ??HAL_HCD_HC_SubmitRequest_1: (+1)
   \   0000006E   0x9A05             LDR      R2,[SP, #+20]
    441            hhcd->hc[ch_num].xfer_len  = length;
   \   00000070   0x6474             STR      R4,[R6, #+68]
    442            hhcd->hc[ch_num].urb_state =   URB_IDLE;  
    443            hhcd->hc[ch_num].xfer_count = 0 ;
    444            hhcd->hc[ch_num].ch_num = ch_num;
   \   00000072   0xF886 0x1035      STRB     R1,[R6, #+53]
    445            hhcd->hc[ch_num].state = HC_IDLE;
    446            
    447            return USB_HC_StartXfer(hhcd->Instance, &(hhcd->hc[ch_num]), hhcd->Init.dma_enable);
   \   00000076   0xF106 0x0134      ADD      R1,R6,#+52
   \   0000007A   0x6432             STR      R2,[R6, #+64]
   \   0000007C   0x2200             MOVS     R2,#+0
   \   0000007E   0xF886 0x2058      STRB     R2,[R6, #+88]
   \   00000082   0x64B2             STR      R2,[R6, #+72]
   \   00000084   0xF886 0x2059      STRB     R2,[R6, #+89]
   \   00000088   0x6902             LDR      R2,[R0, #+16]
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xB001             ADD      SP,SP,#+4
   \   0000008E   0xB2D2             UXTB     R2,R2
   \   00000090   0xBC70             POP      {R4-R6}
   \   00000092   0x.... 0x....      B.W      USB_HC_StartXfer
   \                     ??HAL_HCD_HC_SubmitRequest_5: (+1)
   \   00000096   0xF896 0x204C      LDRB     R2,[R6, #+76]
   \   0000009A   0x2A00             CMP      R2,#+0
   \   0000009C   0xD0E4             BEQ.N    ??HAL_HCD_HC_SubmitRequest_9
   \                     ??HAL_HCD_HC_SubmitRequest_8: (+1)
   \   0000009E   0x2202             MOVS     R2,#+2
   \   000000A0   0xE7E3             B.N      ??HAL_HCD_HC_SubmitRequest_10
    448          }
    449          
    450          /**
    451            * @brief  Handle HCD interrupt request.
    452            * @param  hhcd: HCD handle
    453            * @retval None
    454            */

   \                                 In section .text, align 4, keep-with-next
    455          void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
    456          {
   \                     HAL_HCD_IRQHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    457            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
    458            uint32_t i = 0 , interrupt = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x6826             LDR      R6,[R4, #+0]
    459            
    460            /* ensure that we are in device mode */
    461            if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
   \   0000000A   0x4630             MOV      R0,R6
   \   0000000C   0x.... 0x....      BL       USB_GetMode
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xF040 0x8088      BNE.W    ??HAL_HCD_IRQHandler_0
    462            {
    463              /* avoid spurious interrupt */
    464              if(__HAL_HCD_IS_INVALID_INTERRUPT(hhcd)) 
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xF000 0x8082      BEQ.W    ??HAL_HCD_IRQHandler_0
    465              {
    466                return;
    467              }
    468              
    469              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000028   0x0280             LSLS     R0,R0,#+10
   \   0000002A   0xD503             BPL.N    ??HAL_HCD_IRQHandler_1
    470              {
    471               /* incorrect mode, acknowledge the interrupt */
    472                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0xF44F 0x1000      MOV      R0,#+2097152
   \   00000032   0x6148             STR      R0,[R1, #+20]
    473              }
    474              
    475              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
   \                     ??HAL_HCD_IRQHandler_1: (+1)
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000003A   0x02C0             LSLS     R0,R0,#+11
   \   0000003C   0xD503             BPL.N    ??HAL_HCD_IRQHandler_2
    476              {
    477               /* incorrect mode, acknowledge the interrupt */
    478                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0xF44F 0x1080      MOV      R0,#+1048576
   \   00000044   0x6148             STR      R0,[R1, #+20]
    479              }
    480          
    481              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
   \                     ??HAL_HCD_IRQHandler_2: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000004C   0x0140             LSLS     R0,R0,#+5
   \   0000004E   0xD503             BPL.N    ??HAL_HCD_IRQHandler_3
    482              {
    483               /* incorrect mode, acknowledge the interrupt */
    484                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000056   0x6148             STR      R0,[R1, #+20]
    485              }   
    486              
    487              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
   \                     ??HAL_HCD_IRQHandler_3: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000005E   0x0780             LSLS     R0,R0,#+30
   \   00000060   0xD502             BPL.N    ??HAL_HCD_IRQHandler_4
    488              {
    489               /* incorrect mode, acknowledge the interrupt */
    490                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x6148             STR      R0,[R1, #+20]
    491              }     
    492              
    493              /* Handle Host Disconnect Interrupts */
    494              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
   \                     ??HAL_HCD_IRQHandler_4: (+1)
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000006E   0x0080             LSLS     R0,R0,#+2
   \   00000070   0xD510             BPL.N    ??HAL_HCD_IRQHandler_5
   \   00000072   0xF506 0x6088      ADD      R0,R6,#+1088
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0xF021 0x012E      BIC      R1,R1,#0x2E
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    495              {
    496                
    497                /* Cleanup HPRT */
    498                USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
    499                  USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
    500                 
    501                /* Handle Host Port Interrupts */
    502                HAL_HCD_Disconnect_Callback(hhcd);
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       HAL_HCD_Disconnect_Callback
    503                 USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_48_MHZ );
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x2101             MOVS     R1,#+1
   \   00000088   0x.... 0x....      BL       USB_InitFSLSPClkSel
    504                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0xF04F 0x5000      MOV      R0,#+536870912
   \   00000092   0x6148             STR      R0,[R1, #+20]
    505              }
    506              
    507              /* Handle Host Port Interrupts */
    508              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
   \                     ??HAL_HCD_IRQHandler_5: (+1)
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x.... 0x....      BL       USB_ReadInterrupts
   \   0000009A   0x01C0             LSLS     R0,R0,#+7
   \   0000009C   0xBF44             ITT      MI 
    509              {
    510                HCD_Port_IRQHandler (hhcd);
   \   0000009E   0x4620             MOVMI    R0,R4
   \   000000A0   0x.... 0x....      BLMI     HCD_Port_IRQHandler
    511              }
    512              
    513              /* Handle Host SOF Interrupts */
    514              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000AA   0x0700             LSLS     R0,R0,#+28
   \   000000AC   0xD505             BPL.N    ??HAL_HCD_IRQHandler_6
    515              {
    516                HAL_HCD_SOF_Callback(hhcd);
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       HAL_HCD_SOF_Callback
    517                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
   \   000000B4   0x6821             LDR      R1,[R4, #+0]
   \   000000B6   0x2008             MOVS     R0,#+8
   \   000000B8   0x6148             STR      R0,[R1, #+20]
    518              }
    519                    
    520              /* Handle Host channel Interrupts */
    521              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
   \                     ??HAL_HCD_IRQHandler_6: (+1)
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x.... 0x....      BL       USB_ReadInterrupts
   \   000000C0   0x0180             LSLS     R0,R0,#+6
   \   000000C2   0xD51E             BPL.N    ??HAL_HCD_IRQHandler_7
    522              {
    523                interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0xF506 0x66A0      ADD      R6,R6,#+1280
   \   000000CA   0x.... 0x....      BL       USB_HC_ReadInterrupt
   \   000000CE   0x4607             MOV      R7,R0
    524                for (i = 0; i < hhcd->Init.Host_channels ; i++)
   \   000000D0   0x68A0             LDR      R0,[R4, #+8]
   \   000000D2   0xB190             CBZ.N    R0,??HAL_HCD_IRQHandler_8
    525                {
    526                  if (interrupt & (1 << i))
   \                     ??HAL_HCD_IRQHandler_9: (+1)
   \   000000D4   0xFA27 0xF005      LSR      R0,R7,R5
   \   000000D8   0x07C0             LSLS     R0,R0,#+31
   \   000000DA   0xD509             BPL.N    ??HAL_HCD_IRQHandler_10
    527                  {
    528                    if ((USBx_HC(i)->HCCHAR) &  USB_OTG_HCCHAR_EPDIR)
   \   000000DC   0x6830             LDR      R0,[R6, #+0]
   \   000000DE   0xB2E9             UXTB     R1,R5
   \   000000E0   0x0400             LSLS     R0,R0,#+16
   \   000000E2   0x4620             MOV      R0,R4
   \   000000E4   0xD502             BPL.N    ??HAL_HCD_IRQHandler_11
    529                    {
    530                      HCD_HC_IN_IRQHandler (hhcd, i);
   \   000000E6   0x.... 0x....      BL       HCD_HC_IN_IRQHandler
   \   000000EA   0xE001             B.N      ??HAL_HCD_IRQHandler_10
    531                    }
    532                    else
    533                    {
    534                      HCD_HC_OUT_IRQHandler (hhcd, i);
   \                     ??HAL_HCD_IRQHandler_11: (+1)
   \   000000EC   0x.... 0x....      BL       HCD_HC_OUT_IRQHandler
    535                    }
    536                  }
    537                }
   \                     ??HAL_HCD_IRQHandler_10: (+1)
   \   000000F0   0x68A0             LDR      R0,[R4, #+8]
   \   000000F2   0x1C6D             ADDS     R5,R5,#+1
   \   000000F4   0x3620             ADDS     R6,R6,#+32
   \   000000F6   0x4285             CMP      R5,R0
   \   000000F8   0xD3EC             BCC.N    ??HAL_HCD_IRQHandler_9
    538                __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
   \                     ??HAL_HCD_IRQHandler_8: (+1)
   \   000000FA   0x6821             LDR      R1,[R4, #+0]
   \   000000FC   0xF04F 0x7000      MOV      R0,#+33554432
   \   00000100   0x6148             STR      R0,[R1, #+20]
    539              } 
    540              
    541                  /* Handle Rx Queue Level Interrupts */
    542              if(__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL))
   \                     ??HAL_HCD_IRQHandler_7: (+1)
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x.... 0x....      BL       USB_ReadInterrupts
   \   00000108   0x06C0             LSLS     R0,R0,#+27
   \   0000010A   0xD50C             BPL.N    ??HAL_HCD_IRQHandler_0
    543              {
    544                USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6981             LDR      R1,[R0, #+24]
   \   00000110   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000114   0x6181             STR      R1,[R0, #+24]
    545                
    546                HCD_RXQLVL_IRQHandler (hhcd);
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       HCD_RXQLVL_IRQHandler
    547                
    548                USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \   0000011C   0x6820             LDR      R0,[R4, #+0]
   \   0000011E   0x6981             LDR      R1,[R0, #+24]
   \   00000120   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000124   0x6181             STR      R1,[R0, #+24]
    549              }
    550            }
    551          }
   \                     ??HAL_HCD_IRQHandler_0: (+1)
   \   00000126   0xB001             ADD      SP,SP,#+4
   \   00000128   0xBDF0             POP      {R4-R7,PC}       ;; return
    552          
    553          /**
    554            * @brief  SOF callback.
    555            * @param  hhcd: HCD handle
    556            * @retval None
    557            */

   \                                 In section .text, align 2, keep-with-next
    558          __weak void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
    559          {
    560            /* Prevent unused argument(s) compilation warning */
    561            UNUSED(hhcd);
    562            
    563            /* NOTE : This function Should not be modified, when the callback is needed,
    564                      the HAL_HCD_SOF_Callback could be implemented in the user file
    565             */
    566          }
   \                     HAL_HCD_SOF_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    567          
    568          /**
    569            * @brief Connection Event callback.
    570            * @param  hhcd: HCD handle
    571            * @retval None
    572            */

   \                                 In section .text, align 2, keep-with-next
    573          __weak void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
    574          {
    575            /* Prevent unused argument(s) compilation warning */
    576            UNUSED(hhcd);
    577            
    578            /* NOTE : This function Should not be modified, when the callback is needed,
    579                      the HAL_HCD_Connect_Callback could be implemented in the user file
    580             */
    581          }
   \                     HAL_HCD_Connect_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    582          
    583          /**
    584            * @brief  Disconnection Event callback.
    585            * @param  hhcd: HCD handle
    586            * @retval None
    587            */

   \                                 In section .text, align 2, keep-with-next
    588          __weak void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
    589          {
    590            /* Prevent unused argument(s) compilation warning */
    591            UNUSED(hhcd);
    592            
    593            /* NOTE : This function Should not be modified, when the callback is needed,
    594                      the HAL_HCD_Disconnect_Callback could be implemented in the user file
    595             */
    596          } 
   \                     HAL_HCD_Disconnect_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    597          
    598          /**
    599            * @brief  Notify URB state change callback.
    600            * @param  hhcd: HCD handle
    601            * @param  chnum: Channel number.
    602            *         This parameter can be a value from 1 to 15
    603            * @param  urb_state:
    604            *          This parameter can be one of these values:
    605            *            URB_IDLE/
    606            *            URB_DONE/
    607            *            URB_NOTREADY/
    608            *            URB_NYET/ 
    609            *            URB_ERROR/  
    610            *            URB_STALL/    
    611            * @retval None
    612            */

   \                                 In section .text, align 2, keep-with-next
    613          __weak void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
    614          {
    615            /* Prevent unused argument(s) compilation warning */
    616            UNUSED(hhcd);
    617            
    618            /* NOTE : This function Should not be modified, when the callback is needed,
    619                      the HAL_HCD_HC_NotifyURBChange_Callback could be implemented in the user file
    620             */
    621          }
   \                     HAL_HCD_HC_NotifyURBChange_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    622          
    623          /**
    624            * @}
    625            */
    626          
    627          /** @defgroup HCD_Exported_Functions_Group3 Peripheral Control functions 
    628           *  @brief   Management functions 
    629           *
    630          @verbatim   
    631           ===============================================================================
    632                                ##### Peripheral Control functions #####
    633           ===============================================================================  
    634              [..]
    635              This subsection provides a set of functions allowing to control the HCD data 
    636              transfers.
    637          
    638          @endverbatim
    639            * @{
    640            */
    641          
    642          /**
    643            * @brief  Start the host driver.
    644            * @param  hhcd: HCD handle
    645            * @retval HAL status
    646            */

   \                                 In section .text, align 2, keep-with-next
    647          HAL_StatusTypeDef HAL_HCD_Start(HCD_HandleTypeDef *hhcd)
    648          { 
   \                     HAL_HCD_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    649            __HAL_LOCK(hhcd); 
   \   00000004   0xF994 0x028C      LDRSB    R0,[R4, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_Start_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_Start_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x028C      STRB     R0,[R4, #+652]
    650            __HAL_HCD_ENABLE(hhcd);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_EnableGlobalInt
    651            USB_DriveVbus(hhcd->Instance, 1);  
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x.... 0x....      BL       USB_DriveVbus
    652            __HAL_UNLOCK(hhcd); 
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF884 0x028C      STRB     R0,[R4, #+652]
    653            return HAL_OK;
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    654          }
    655          
    656          /**
    657            * @brief  Stop the host driver.
    658            * @param  hhcd: HCD handle
    659            * @retval HAL status
    660            */
    661          

   \                                 In section .text, align 2, keep-with-next
    662          HAL_StatusTypeDef HAL_HCD_Stop(HCD_HandleTypeDef *hhcd)
    663          { 
   \                     HAL_HCD_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    664            __HAL_LOCK(hhcd); 
   \   00000004   0xF994 0x028C      LDRSB    R0,[R4, #+652]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_HCD_Stop_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD10             POP      {R4,PC}
   \                     ??HAL_HCD_Stop_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF884 0x028C      STRB     R0,[R4, #+652]
    665            USB_StopHost(hhcd->Instance);
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       USB_StopHost
    666            __HAL_UNLOCK(hhcd); 
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x028C      STRB     R0,[R4, #+652]
    667            return HAL_OK;
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    668          }
    669          
    670          /**
    671            * @brief  Reset the host port.
    672            * @param  hhcd: HCD handle
    673            * @retval HAL status
    674            */

   \                                 In section .text, align 2, keep-with-next
    675          HAL_StatusTypeDef HAL_HCD_ResetPort(HCD_HandleTypeDef *hhcd)
    676          {
    677            return (USB_ResetPort(hhcd->Instance));
   \                     HAL_HCD_ResetPort: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_ResetPort
    678          }
    679          
    680          /**
    681            * @}
    682            */
    683          
    684          /** @defgroup HCD_Exported_Functions_Group4 Peripheral State functions 
    685           *  @brief   Peripheral State functions 
    686           *
    687          @verbatim   
    688           ===============================================================================
    689                                ##### Peripheral State functions #####
    690           ===============================================================================  
    691              [..]
    692              This subsection permits to get in run-time the status of the peripheral 
    693              and the data flow.
    694          
    695          @endverbatim
    696            * @{
    697            */
    698          
    699          /**
    700            * @brief  Return the HCD handle state.
    701            * @param  hhcd: HCD handle
    702            * @retval HAL state
    703            */

   \                                 In section .text, align 2, keep-with-next
    704          HCD_StateTypeDef HAL_HCD_GetState(HCD_HandleTypeDef *hhcd)
    705          {
    706            return hhcd->State;
   \                     HAL_HCD_GetState: (+1)
   \   00000000   0xF990 0x028D      LDRSB    R0,[R0, #+653]
   \   00000004   0x4770             BX       LR               ;; return
    707          }
    708          
    709          /**
    710            * @brief  Return  URB state for a channel.
    711            * @param  hhcd: HCD handle
    712            * @param  chnum: Channel number.
    713            *         This parameter can be a value from 1 to 15
    714            * @retval URB state.
    715            *          This parameter can be one of these values:
    716            *            URB_IDLE/
    717            *            URB_DONE/
    718            *            URB_NOTREADY/
    719            *            URB_NYET/ 
    720            *            URB_ERROR/  
    721            *            URB_STALL
    722            */

   \                                 In section .text, align 2, keep-with-next
    723          HCD_URBStateTypeDef HAL_HCD_HC_GetURBState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    724          {
    725            return hhcd->hc[chnum].urb_state;
   \                     HAL_HCD_HC_GetURBState: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0xF990 0x0058      LDRSB    R0,[R0, #+88]
   \   0000000C   0x4770             BX       LR               ;; return
    726          }
    727          
    728          
    729          /**
    730            * @brief  Return the last host transfer size.
    731            * @param  hhcd: HCD handle
    732            * @param  chnum: Channel number.
    733            *         This parameter can be a value from 1 to 15
    734            * @retval last transfer size in byte
    735            */

   \                                 In section .text, align 2, keep-with-next
    736          uint32_t HAL_HCD_HC_GetXferCount(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    737          {
    738            return hhcd->hc[chnum].xfer_count; 
   \                     HAL_HCD_HC_GetXferCount: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0x6C80             LDR      R0,[R0, #+72]
   \   0000000A   0x4770             BX       LR               ;; return
    739          }
    740            
    741          /**
    742            * @brief  Return the Host Channel state.
    743            * @param  hhcd: HCD handle
    744            * @param  chnum: Channel number.
    745            *         This parameter can be a value from 1 to 15
    746            * @retval Host channel state
    747            *          This parameter can be one of these values:
    748            *            HC_IDLE/
    749            *            HC_XFRC/
    750            *            HC_HALTED/
    751            *            HC_NYET/ 
    752            *            HC_NAK/  
    753            *            HC_STALL/ 
    754            *            HC_XACTERR/  
    755            *            HC_BBLERR/  
    756            *            HC_DATATGLERR   
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          HCD_HCStateTypeDef  HAL_HCD_HC_GetState(HCD_HandleTypeDef *hhcd, uint8_t chnum)
    759          {
    760            return hhcd->hc[chnum].state;
   \                     HAL_HCD_HC_GetState: (+1)
   \   00000000   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000004   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \   00000008   0xF990 0x0059      LDRSB    R0,[R0, #+89]
   \   0000000C   0x4770             BX       LR               ;; return
    761          }
    762          
    763          /**
    764            * @brief  Return the current Host frame number.
    765            * @param  hhcd: HCD handle
    766            * @retval Current Host frame number
    767            */

   \                                 In section .text, align 2, keep-with-next
    768          uint32_t HAL_HCD_GetCurrentFrame(HCD_HandleTypeDef *hhcd)
    769          {
    770            return (USB_GetCurrentFrame(hhcd->Instance));
   \                     HAL_HCD_GetCurrentFrame: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_GetCurrentFrame
    771          }
    772          
    773          /**
    774            * @brief  Return the Host enumeration speed.
    775            * @param  hhcd: HCD handle
    776            * @retval Enumeration speed
    777            */

   \                                 In section .text, align 2, keep-with-next
    778          uint32_t HAL_HCD_GetCurrentSpeed(HCD_HandleTypeDef *hhcd)
    779          {
    780            return (USB_GetHostSpeed(hhcd->Instance));
   \                     HAL_HCD_GetCurrentSpeed: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x.... 0x....      B.W      USB_GetHostSpeed
    781          }
    782          
    783          /**
    784            * @}
    785            */
    786          
    787          /**
    788            * @}
    789            */
    790          
    791          /** @addtogroup HCD_Private_Functions
    792            * @{
    793            */
    794          /**
    795            * @brief  Handle Host Channel IN interrupt requests.
    796            * @param  hhcd: HCD handle
    797            * @param  chnum: Channel number.
    798            *         This parameter can be a value from 1 to 15
    799            * @retval none
    800            */

   \                                 In section .text, align 2, keep-with-next
    801          static void HCD_HC_IN_IRQHandler   (HCD_HandleTypeDef *hhcd, uint8_t chnum)
    802          {
   \                     HCD_HC_IN_IRQHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
    803            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000008   0x6820             LDR      R0,[R4, #+0]
    804            uint32_t tmpreg = 0;
    805            
    806            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_AHBERR)
   \   0000000A   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   0000000E   0xF500 0x66A0      ADD      R6,R0,#+1280
   \   00000012   0x68B0             LDR      R0,[R6, #+8]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD506             BPL.N    ??HCD_HC_IN_IRQHandler_0
    807            {
    808              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x60B0             STR      R0,[R6, #+8]
    809              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   0000001C   0x68F0             LDR      R0,[R6, #+12]
   \   0000001E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000022   0x60F0             STR      R0,[R6, #+12]
   \   00000024   0xE02C             B.N      ??HCD_HC_IN_IRQHandler_1
    810            }  
    811            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_ACK)
   \                     ??HCD_HC_IN_IRQHandler_0: (+1)
   \   00000026   0x68B0             LDR      R0,[R6, #+8]
   \   00000028   0x0680             LSLS     R0,R0,#+26
   \   0000002A   0xBF48             IT       MI 
   \   0000002C   0x2020             MOVMI    R0,#+32
    812            {
    813              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
   \   0000002E   0xD426             BMI.N    ??HCD_HC_IN_IRQHandler_2
    814            }
    815            
    816            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_STALL)  
   \   00000030   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000034   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   00000038   0x68B0             LDR      R0,[R6, #+8]
   \   0000003A   0x0700             LSLS     R0,R0,#+28
   \   0000003C   0xD50E             BPL.N    ??HCD_HC_IN_IRQHandler_3
    817            {
    818              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   0000003E   0x68F0             LDR      R0,[R6, #+12]
   \   00000040   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000044   0x60F0             STR      R0,[R6, #+12]
    819              hhcd->hc[chnum].state = HC_STALL;
   \   00000046   0x2005             MOVS     R0,#+5
   \   00000048   0xF887 0x0059      STRB     R0,[R7, #+89]
    820              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   0000004C   0x2010             MOVS     R0,#+16
   \   0000004E   0x60B0             STR      R0,[R6, #+8]
    821              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);    
   \   00000050   0x2008             MOVS     R0,#+8
   \   00000052   0x60B0             STR      R0,[R6, #+8]
    822              USB_HC_Halt(hhcd->Instance, chnum);    
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x.... 0x....      BL       USB_HC_Halt
   \   0000005A   0xE011             B.N      ??HCD_HC_IN_IRQHandler_1
    823            }
    824            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_DTERR)
   \                     ??HCD_HC_IN_IRQHandler_3: (+1)
   \   0000005C   0x68B0             LDR      R0,[R6, #+8]
   \   0000005E   0x0540             LSLS     R0,R0,#+21
   \   00000060   0xD50E             BPL.N    ??HCD_HC_IN_IRQHandler_1
    825            {
    826              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   00000062   0x68F0             LDR      R0,[R6, #+12]
   \   00000064   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000068   0x60F0             STR      R0,[R6, #+12]
    827              USB_HC_Halt(hhcd->Instance, chnum);  
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x.... 0x....      BL       USB_HC_Halt
    828              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);    
   \   00000070   0x2010             MOVS     R0,#+16
   \   00000072   0x60B0             STR      R0,[R6, #+8]
    829              hhcd->hc[chnum].state = HC_DATATGLERR;
   \   00000074   0x2008             MOVS     R0,#+8
   \   00000076   0xF887 0x0059      STRB     R0,[R7, #+89]
    830              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);
   \   0000007A   0xF44F 0x6080      MOV      R0,#+1024
   \                     ??HCD_HC_IN_IRQHandler_2: (+1)
   \   0000007E   0x60B0             STR      R0,[R6, #+8]
    831            }    
    832            
    833            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_FRMOR)
   \                     ??HCD_HC_IN_IRQHandler_1: (+1)
   \   00000080   0x68B0             LDR      R0,[R6, #+8]
   \   00000082   0x0580             LSLS     R0,R0,#+22
   \   00000084   0xD50A             BPL.N    ??HCD_HC_IN_IRQHandler_4
    834            {
    835              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   00000086   0x68F0             LDR      R0,[R6, #+12]
    836              USB_HC_Halt(hhcd->Instance, chnum);  
   \   00000088   0x4629             MOV      R1,R5
   \   0000008A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000008E   0x60F0             STR      R0,[R6, #+12]
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x.... 0x....      BL       USB_HC_Halt
    837              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
   \   00000096   0xF44F 0x7000      MOV      R0,#+512
   \   0000009A   0xE0AE             B.N      ??HCD_HC_IN_IRQHandler_5
    838            }
    839            
    840            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_XFRC)
   \                     ??HCD_HC_IN_IRQHandler_4: (+1)
   \   0000009C   0x68B0             LDR      R0,[R6, #+8]
   \   0000009E   0x07C0             LSLS     R0,R0,#+31
   \   000000A0   0xD540             BPL.N    ??HCD_HC_IN_IRQHandler_6
    841            {
    842              
    843              if (hhcd->Init.dma_enable)
   \   000000A2   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000000A6   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   000000AA   0x6920             LDR      R0,[R4, #+16]
   \   000000AC   0xB128             CBZ.N    R0,??HCD_HC_IN_IRQHandler_7
    844              {
    845                hhcd->hc[chnum].xfer_count = hhcd->hc[chnum].xfer_len - \
    846                                         (USBx_HC(chnum)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
   \   000000AE   0x6C78             LDR      R0,[R7, #+68]
   \   000000B0   0x6931             LDR      R1,[R6, #+16]
   \   000000B2   0x0349             LSLS     R1,R1,#+13
   \   000000B4   0xEBB0 0x3051      SUBS     R0,R0,R1, LSR #+13
   \   000000B8   0x64B8             STR      R0,[R7, #+72]
    847              }
    848              
    849              hhcd->hc[chnum].state = HC_XFRC;
   \                     ??HCD_HC_IN_IRQHandler_7: (+1)
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0xF887 0x0059      STRB     R0,[R7, #+89]
    850              hhcd->hc[chnum].ErrCnt = 0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x6578             STR      R0,[R7, #+84]
    851              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x60B0             STR      R0,[R6, #+8]
    852              
    853              
    854              if ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL)||
    855                  (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
   \   000000C8   0xF897 0x003B      LDRB     R0,[R7, #+59]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xBF18             IT       NE 
   \   000000D0   0x2802             CMPNE    R0,#+2
   \   000000D2   0xD111             BNE.N    ??HCD_HC_IN_IRQHandler_8
    856              {
    857                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   \   000000D4   0x68F0             LDR      R0,[R6, #+12]
    858                USB_HC_Halt(hhcd->Instance, chnum); 
   \   000000D6   0x4629             MOV      R1,R5
   \   000000D8   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000DC   0x60F0             STR      R0,[R6, #+12]
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x.... 0x....      BL       USB_HC_Halt
    859                __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   \   000000E4   0x2010             MOVS     R0,#+16
   \   000000E6   0x60B0             STR      R0,[R6, #+8]
    860                
    861              }
    862              else if(hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
    863              {
    864                USBx_HC(chnum)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
    865                hhcd->hc[chnum].urb_state = URB_DONE; 
    866                HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
    867              }
    868              hhcd->hc[chnum].toggle_in ^= 1;
   \   000000E8   0xF897 0x004C      LDRB     R0,[R7, #+76]
   \   000000EC   0xF080 0x0001      EOR      R0,R0,#0x1
   \   000000F0   0xF887 0x004C      STRB     R0,[R7, #+76]
    869              
    870            }
    871            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_CHH)
    872            {
    873              __HAL_HCD_MASK_HALT_HC_INT(chnum); 
    874              
    875              if(hhcd->hc[chnum].state == HC_XFRC)
    876              {
    877                hhcd->hc[chnum].urb_state  = URB_DONE;      
    878              }
    879              
    880              else if (hhcd->hc[chnum].state == HC_STALL) 
    881              {
    882                hhcd->hc[chnum].urb_state  = URB_STALL;
    883              }   
    884              
    885              else if((hhcd->hc[chnum].state == HC_XACTERR) ||
    886                      (hhcd->hc[chnum].state == HC_DATATGLERR))
    887              {
    888                if(hhcd->hc[chnum].ErrCnt++ > 3)
    889                {      
    890                  hhcd->hc[chnum].ErrCnt = 0;
    891                  hhcd->hc[chnum].urb_state = URB_ERROR;
    892                }
    893                else
    894                {
    895                  hhcd->hc[chnum].urb_state = URB_NOTREADY;
    896                }
    897                
    898                /* re-activate the channel  */
    899                tmpreg = USBx_HC(chnum)->HCCHAR;
    900                tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
    901                tmpreg |= USB_OTG_HCCHAR_CHENA;
    902                USBx_HC(chnum)->HCCHAR = tmpreg;    
    903              }
    904              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
    905              HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);
    906            }  
    907            
    908            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_TXERR)
    909            {
    910              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
    911               hhcd->hc[chnum].ErrCnt++;
    912               hhcd->hc[chnum].state = HC_XACTERR;
    913               USB_HC_Halt(hhcd->Instance, chnum);     
    914               __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
    915            }
    916            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NAK)
    917            {  
    918              if(hhcd->hc[chnum].ep_type == EP_TYPE_INTR)
    919              {
    920                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
    921                USB_HC_Halt(hhcd->Instance, chnum);  
    922              }
    923              else if  ((hhcd->hc[chnum].ep_type == EP_TYPE_CTRL)||
    924                   (hhcd->hc[chnum].ep_type == EP_TYPE_BULK))
    925              {
    926                /* re-activate the channel  */
    927                tmpreg = USBx_HC(chnum)->HCCHAR;
    928                tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
    929                tmpreg |= USB_OTG_HCCHAR_CHENA;
    930                USBx_HC(chnum)->HCCHAR = tmpreg;
    931              }
    932              hhcd->hc[chnum].state = HC_NAK;
    933              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
    934            }
    935          }
   \   000000F4   0xB001             ADD      SP,SP,#+4
   \   000000F6   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_IN_IRQHandler_8: (+1)
   \   000000F8   0x2803             CMP      R0,#+3
   \   000000FA   0xD10B             BNE.N    ??HCD_HC_IN_IRQHandler_9
   \   000000FC   0x6830             LDR      R0,[R6, #+0]
   \   000000FE   0x2201             MOVS     R2,#+1
   \   00000100   0x4629             MOV      R1,R5
   \   00000102   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \   00000106   0x6030             STR      R0,[R6, #+0]
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0xF887 0x0058      STRB     R0,[R7, #+88]
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   \                     ??HCD_HC_IN_IRQHandler_9: (+1)
   \   00000114   0xF897 0x004C      LDRB     R0,[R7, #+76]
   \   00000118   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000011C   0xF887 0x004C      STRB     R0,[R7, #+76]
   \   00000120   0xB001             ADD      SP,SP,#+4
   \   00000122   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_IN_IRQHandler_6: (+1)
   \   00000124   0x68B0             LDR      R0,[R6, #+8]
   \   00000126   0x0780             LSLS     R0,R0,#+30
   \   00000128   0xD52E             BPL.N    ??HCD_HC_IN_IRQHandler_10
   \   0000012A   0x68F0             LDR      R0,[R6, #+12]
   \   0000012C   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000130   0x60F0             STR      R0,[R6, #+12]
   \   00000132   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000136   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   0000013A   0xF997 0x0059      LDRSB    R0,[R7, #+89]
   \   0000013E   0x2801             CMP      R0,#+1
   \   00000140   0xBF14             ITE      NE 
   \   00000142   0x2805             CMPNE    R0,#+5
   \   00000144   0xF887 0x0058      STRBEQ   R0,[R7, #+88]
   \   00000148   0xD014             BEQ.N    ??HCD_HC_IN_IRQHandler_11
   \   0000014A   0x2806             CMP      R0,#+6
   \   0000014C   0xBF18             IT       NE 
   \   0000014E   0x2808             CMPNE    R0,#+8
   \   00000150   0xD110             BNE.N    ??HCD_HC_IN_IRQHandler_11
   \   00000152   0x6D78             LDR      R0,[R7, #+84]
   \   00000154   0x1C41             ADDS     R1,R0,#+1
   \   00000156   0x2804             CMP      R0,#+4
   \   00000158   0x6579             STR      R1,[R7, #+84]
   \   0000015A   0xBF23             ITTTE    CS 
   \   0000015C   0x2000             MOVCS    R0,#+0
   \   0000015E   0x6578             STRCS    R0,[R7, #+84]
   \   00000160   0x2004             MOVCS    R0,#+4
   \   00000162   0x2002             MOVCC    R0,#+2
   \   00000164   0xF887 0x0058      STRB     R0,[R7, #+88]
   \   00000168   0x6830             LDR      R0,[R6, #+0]
   \   0000016A   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   0000016E   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000172   0x6030             STR      R0,[R6, #+0]
   \                     ??HCD_HC_IN_IRQHandler_11: (+1)
   \   00000174   0x2002             MOVS     R0,#+2
   \   00000176   0x4629             MOV      R1,R5
   \   00000178   0x60B0             STR      R0,[R6, #+8]
   \   0000017A   0xF997 0x2058      LDRSB    R2,[R7, #+88]
   \   0000017E   0x4620             MOV      R0,R4
   \   00000180   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   \   00000184   0xB001             ADD      SP,SP,#+4
   \   00000186   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_IN_IRQHandler_10: (+1)
   \   00000188   0x68B0             LDR      R0,[R6, #+8]
   \   0000018A   0x0600             LSLS     R0,R0,#+24
   \   0000018C   0xD513             BPL.N    ??HCD_HC_IN_IRQHandler_12
   \   0000018E   0x68F0             LDR      R0,[R6, #+12]
   \   00000190   0x4629             MOV      R1,R5
   \   00000192   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000196   0x60F0             STR      R0,[R6, #+12]
   \   00000198   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000019C   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   000001A0   0x6D78             LDR      R0,[R7, #+84]
   \   000001A2   0x1C40             ADDS     R0,R0,#+1
   \   000001A4   0x6578             STR      R0,[R7, #+84]
   \   000001A6   0x2006             MOVS     R0,#+6
   \   000001A8   0xF887 0x0059      STRB     R0,[R7, #+89]
   \   000001AC   0x6820             LDR      R0,[R4, #+0]
   \   000001AE   0x.... 0x....      BL       USB_HC_Halt
   \   000001B2   0x2080             MOVS     R0,#+128
   \   000001B4   0xE021             B.N      ??HCD_HC_IN_IRQHandler_5
   \                     ??HCD_HC_IN_IRQHandler_12: (+1)
   \   000001B6   0x68B0             LDR      R0,[R6, #+8]
   \   000001B8   0x06C0             LSLS     R0,R0,#+27
   \   000001BA   0xD51F             BPL.N    ??HCD_HC_IN_IRQHandler_13
   \   000001BC   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000001C0   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   000001C4   0xF897 0x003B      LDRB     R0,[R7, #+59]
   \   000001C8   0x2803             CMP      R0,#+3
   \   000001CA   0xD108             BNE.N    ??HCD_HC_IN_IRQHandler_14
   \   000001CC   0x68F0             LDR      R0,[R6, #+12]
   \   000001CE   0x4629             MOV      R1,R5
   \   000001D0   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000001D4   0x60F0             STR      R0,[R6, #+12]
   \   000001D6   0x6820             LDR      R0,[R4, #+0]
   \   000001D8   0x.... 0x....      BL       USB_HC_Halt
   \   000001DC   0xE009             B.N      ??HCD_HC_IN_IRQHandler_15
   \                     ??HCD_HC_IN_IRQHandler_14: (+1)
   \   000001DE   0x2800             CMP      R0,#+0
   \   000001E0   0xBF18             IT       NE 
   \   000001E2   0x2802             CMPNE    R0,#+2
   \   000001E4   0xD105             BNE.N    ??HCD_HC_IN_IRQHandler_15
   \   000001E6   0x6830             LDR      R0,[R6, #+0]
   \   000001E8   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   000001EC   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   000001F0   0x6030             STR      R0,[R6, #+0]
   \                     ??HCD_HC_IN_IRQHandler_15: (+1)
   \   000001F2   0x2003             MOVS     R0,#+3
   \   000001F4   0xF887 0x0059      STRB     R0,[R7, #+89]
   \   000001F8   0x2010             MOVS     R0,#+16
   \                     ??HCD_HC_IN_IRQHandler_5: (+1)
   \   000001FA   0x60B0             STR      R0,[R6, #+8]
   \                     ??HCD_HC_IN_IRQHandler_13: (+1)
   \   000001FC   0xB001             ADD      SP,SP,#+4
   \   000001FE   0xBDF0             POP      {R4-R7,PC}       ;; return
    936          
    937          /**
    938            * @brief  Handle Host Channel OUT interrupt requests.
    939            * @param  hhcd: HCD handle
    940            * @param  chnum: Channel number.
    941            *         This parameter can be a value from 1 to 15
    942            * @retval none
    943            */

   \                                 In section .text, align 2, keep-with-next
    944          static void HCD_HC_OUT_IRQHandler  (HCD_HandleTypeDef *hhcd, uint8_t chnum)
    945          {
   \                     HCD_HC_OUT_IRQHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
    946            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
   \   00000008   0x6820             LDR      R0,[R4, #+0]
    947            uint32_t tmpreg = 0;
    948            
    949            if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_AHBERR)
   \   0000000A   0xEB00 0x1045      ADD      R0,R0,R5, LSL #+5
   \   0000000E   0xF500 0x66A0      ADD      R6,R0,#+1280
   \   00000012   0x68B0             LDR      R0,[R6, #+8]
   \   00000014   0x0740             LSLS     R0,R0,#+29
   \   00000016   0xD507             BPL.N    ??HCD_HC_OUT_IRQHandler_0
    950            {
    951              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_AHBERR);
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x60B0             STR      R0,[R6, #+8]
    952              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
   \   0000001C   0x68F0             LDR      R0,[R6, #+12]
   \   0000001E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000022   0x60F0             STR      R0,[R6, #+12]
    953            }  
    954            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_ACK)
    955            {
    956              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_ACK);
    957              
    958              if( hhcd->hc[chnum].do_ping == 1)
    959              {
    960                hhcd->hc[chnum].state = HC_NYET;     
    961                __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
    962                USB_HC_Halt(hhcd->Instance, chnum); 
    963                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
    964              }
    965            }
    966            
    967            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NYET)
    968            {
    969              hhcd->hc[chnum].state = HC_NYET;
    970              hhcd->hc[chnum].ErrCnt= 0;    
    971              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
    972              USB_HC_Halt(hhcd->Instance, chnum);      
    973              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NYET);
    974              
    975            }  
    976            
    977            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_FRMOR)
    978            {
    979              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
    980              USB_HC_Halt(hhcd->Instance, chnum);  
    981              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_FRMOR);
    982            }
    983            
    984            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_XFRC)
    985            {
    986                hhcd->hc[chnum].ErrCnt = 0;  
    987              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
    988              USB_HC_Halt(hhcd->Instance, chnum);   
    989              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_XFRC);
    990              hhcd->hc[chnum].state = HC_XFRC;
    991          
    992            }  
    993          
    994            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_STALL)  
    995            {
    996              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_STALL);  
    997              __HAL_HCD_UNMASK_HALT_HC_INT(chnum);
    998              USB_HC_Halt(hhcd->Instance, chnum);   
    999              hhcd->hc[chnum].state = HC_STALL;    
   1000            }
   1001          
   1002            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_NAK)
   1003            {  
   1004              hhcd->hc[chnum].ErrCnt = 0;  
   1005              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   1006              USB_HC_Halt(hhcd->Instance, chnum);   
   1007              hhcd->hc[chnum].state = HC_NAK;
   1008              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   1009            }
   1010          
   1011            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_TXERR)
   1012            {
   1013              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   1014              USB_HC_Halt(hhcd->Instance, chnum);      
   1015              hhcd->hc[chnum].state = HC_XACTERR;  
   1016               __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_TXERR);
   1017            }
   1018            
   1019            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_DTERR)
   1020            {
   1021              __HAL_HCD_UNMASK_HALT_HC_INT(chnum); 
   1022              USB_HC_Halt(hhcd->Instance, chnum);      
   1023              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_NAK);
   1024              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_DTERR);    
   1025              hhcd->hc[chnum].state = HC_DATATGLERR;
   1026            }
   1027            
   1028            
   1029            else if ((USBx_HC(chnum)->HCINT) &  USB_OTG_HCINT_CHH)
   1030            {
   1031              __HAL_HCD_MASK_HALT_HC_INT(chnum); 
   1032              
   1033              if(hhcd->hc[chnum].state == HC_XFRC)
   1034              {
   1035                hhcd->hc[chnum].urb_state  = URB_DONE;
   1036                if (hhcd->hc[chnum].ep_type == EP_TYPE_BULK)
   1037                {
   1038                  hhcd->hc[chnum].toggle_out ^= 1; 
   1039                }      
   1040              }
   1041              else if (hhcd->hc[chnum].state == HC_NAK) 
   1042              {
   1043                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   1044              }  
   1045              
   1046              else if (hhcd->hc[chnum].state == HC_NYET) 
   1047              {
   1048                hhcd->hc[chnum].urb_state  = URB_NOTREADY;
   1049                hhcd->hc[chnum].do_ping = 0;
   1050              }   
   1051              
   1052              else if (hhcd->hc[chnum].state == HC_STALL) 
   1053              {
   1054                hhcd->hc[chnum].urb_state  = URB_STALL;
   1055              } 
   1056              
   1057              else if((hhcd->hc[chnum].state == HC_XACTERR) ||
   1058                      (hhcd->hc[chnum].state == HC_DATATGLERR))
   1059              {
   1060                if(hhcd->hc[chnum].ErrCnt++ > 3)
   1061                {      
   1062                  hhcd->hc[chnum].ErrCnt = 0;
   1063                  hhcd->hc[chnum].urb_state = URB_ERROR;
   1064                }
   1065                else
   1066                {
   1067                  hhcd->hc[chnum].urb_state = URB_NOTREADY;
   1068                }
   1069                
   1070                /* re-activate the channel  */
   1071                tmpreg = USBx_HC(chnum)->HCCHAR;
   1072                tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   1073                tmpreg |= USB_OTG_HCCHAR_CHENA;
   1074                USBx_HC(chnum)->HCCHAR = tmpreg;   
   1075              }
   1076              
   1077              __HAL_HCD_CLEAR_HC_INT(chnum, USB_OTG_HCINT_CHH);
   1078              HAL_HCD_HC_NotifyURBChange_Callback(hhcd, chnum, hhcd->hc[chnum].urb_state);  
   1079            }
   1080          } 
   \   00000024   0xB001             ADD      SP,SP,#+4
   \   00000026   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_0: (+1)
   \   00000028   0x68B0             LDR      R0,[R6, #+8]
   \   0000002A   0x0680             LSLS     R0,R0,#+26
   \   0000002C   0xD519             BPL.N    ??HCD_HC_OUT_IRQHandler_1
   \   0000002E   0x2020             MOVS     R0,#+32
   \   00000030   0x60B0             STR      R0,[R6, #+8]
   \   00000032   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000036   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   0000003A   0xF897 0x0039      LDRB     R0,[R7, #+57]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xF040 0x80EF      BNE.W    ??HCD_HC_OUT_IRQHandler_2
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0xF887 0x0059      STRB     R0,[R7, #+89]
   \   0000004A   0x68F0             LDR      R0,[R6, #+12]
   \   0000004C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000050   0x60F0             STR      R0,[R6, #+12]
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       USB_HC_Halt
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0xF887 0x0058      STRB     R0,[R7, #+88]
   \   0000005E   0xB001             ADD      SP,SP,#+4
   \   00000060   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_1: (+1)
   \   00000062   0x68B0             LDR      R0,[R6, #+8]
   \   00000064   0x0640             LSLS     R0,R0,#+25
   \   00000066   0xD513             BPL.N    ??HCD_HC_OUT_IRQHandler_3
   \   00000068   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000006C   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   00000070   0x2004             MOVS     R0,#+4
   \   00000072   0xF887 0x0059      STRB     R0,[R7, #+89]
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x6578             STR      R0,[R7, #+84]
   \   0000007A   0x68F0             LDR      R0,[R6, #+12]
   \   0000007C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000080   0x60F0             STR      R0,[R6, #+12]
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x.... 0x....      BL       USB_HC_Halt
   \   00000088   0x2040             MOVS     R0,#+64
   \   0000008A   0x60B0             STR      R0,[R6, #+8]
   \   0000008C   0xB001             ADD      SP,SP,#+4
   \   0000008E   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_3: (+1)
   \   00000090   0x68B0             LDR      R0,[R6, #+8]
   \   00000092   0x0580             LSLS     R0,R0,#+22
   \   00000094   0xD50B             BPL.N    ??HCD_HC_OUT_IRQHandler_4
   \   00000096   0x68F0             LDR      R0,[R6, #+12]
   \   00000098   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000009C   0x60F0             STR      R0,[R6, #+12]
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x.... 0x....      BL       USB_HC_Halt
   \   000000A4   0xF44F 0x7000      MOV      R0,#+512
   \   000000A8   0x60B0             STR      R0,[R6, #+8]
   \   000000AA   0xB001             ADD      SP,SP,#+4
   \   000000AC   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_4: (+1)
   \   000000AE   0x68B0             LDR      R0,[R6, #+8]
   \   000000B0   0x07C0             LSLS     R0,R0,#+31
   \   000000B2   0xD512             BPL.N    ??HCD_HC_OUT_IRQHandler_5
   \   000000B4   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   000000B8   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x6578             STR      R0,[R7, #+84]
   \   000000C0   0x68F0             LDR      R0,[R6, #+12]
   \   000000C2   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000C6   0x60F0             STR      R0,[R6, #+12]
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x.... 0x....      BL       USB_HC_Halt
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x60B0             STR      R0,[R6, #+8]
   \   000000D2   0xF887 0x0059      STRB     R0,[R7, #+89]
   \   000000D6   0xB001             ADD      SP,SP,#+4
   \   000000D8   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_5: (+1)
   \   000000DA   0x68B0             LDR      R0,[R6, #+8]
   \   000000DC   0x0700             LSLS     R0,R0,#+28
   \   000000DE   0xD511             BPL.N    ??HCD_HC_OUT_IRQHandler_6
   \   000000E0   0x2008             MOVS     R0,#+8
   \   000000E2   0x60B0             STR      R0,[R6, #+8]
   \   000000E4   0x68F0             LDR      R0,[R6, #+12]
   \   000000E6   0xF040 0x0002      ORR      R0,R0,#0x2
   \   000000EA   0x60F0             STR      R0,[R6, #+12]
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x.... 0x....      BL       USB_HC_Halt
   \   000000F2   0xEB05 0x0185      ADD      R1,R5,R5, LSL #+2
   \   000000F6   0x2005             MOVS     R0,#+5
   \   000000F8   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \   000000FC   0xF881 0x0059      STRB     R0,[R1, #+89]
   \   00000100   0xB001             ADD      SP,SP,#+4
   \   00000102   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_6: (+1)
   \   00000104   0x68B0             LDR      R0,[R6, #+8]
   \   00000106   0x06C0             LSLS     R0,R0,#+27
   \   00000108   0xD513             BPL.N    ??HCD_HC_OUT_IRQHandler_7
   \   0000010A   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000010E   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0x6578             STR      R0,[R7, #+84]
   \   00000116   0x68F0             LDR      R0,[R6, #+12]
   \   00000118   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000011C   0x60F0             STR      R0,[R6, #+12]
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x.... 0x....      BL       USB_HC_Halt
   \   00000124   0x2003             MOVS     R0,#+3
   \   00000126   0xF887 0x0059      STRB     R0,[R7, #+89]
   \   0000012A   0x2010             MOVS     R0,#+16
   \   0000012C   0x60B0             STR      R0,[R6, #+8]
   \   0000012E   0xB001             ADD      SP,SP,#+4
   \   00000130   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_7: (+1)
   \   00000132   0x68B0             LDR      R0,[R6, #+8]
   \   00000134   0x0600             LSLS     R0,R0,#+24
   \   00000136   0xD511             BPL.N    ??HCD_HC_OUT_IRQHandler_8
   \   00000138   0x68F0             LDR      R0,[R6, #+12]
   \   0000013A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000013E   0x60F0             STR      R0,[R6, #+12]
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x.... 0x....      BL       USB_HC_Halt
   \   00000146   0xEB05 0x0185      ADD      R1,R5,R5, LSL #+2
   \   0000014A   0x2006             MOVS     R0,#+6
   \   0000014C   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \   00000150   0xF881 0x0059      STRB     R0,[R1, #+89]
   \   00000154   0x2080             MOVS     R0,#+128
   \   00000156   0x60B0             STR      R0,[R6, #+8]
   \   00000158   0xB001             ADD      SP,SP,#+4
   \   0000015A   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_8: (+1)
   \   0000015C   0x68B0             LDR      R0,[R6, #+8]
   \   0000015E   0x0540             LSLS     R0,R0,#+21
   \   00000160   0xD514             BPL.N    ??HCD_HC_OUT_IRQHandler_9
   \   00000162   0x68F0             LDR      R0,[R6, #+12]
   \   00000164   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000168   0x60F0             STR      R0,[R6, #+12]
   \   0000016A   0x6820             LDR      R0,[R4, #+0]
   \   0000016C   0x.... 0x....      BL       USB_HC_Halt
   \   00000170   0x2010             MOVS     R0,#+16
   \   00000172   0xEB05 0x0185      ADD      R1,R5,R5, LSL #+2
   \   00000176   0x60B0             STR      R0,[R6, #+8]
   \   00000178   0xF44F 0x6080      MOV      R0,#+1024
   \   0000017C   0x60B0             STR      R0,[R6, #+8]
   \   0000017E   0xEB04 0x01C1      ADD      R1,R4,R1, LSL #+3
   \   00000182   0x2008             MOVS     R0,#+8
   \   00000184   0xF881 0x0059      STRB     R0,[R1, #+89]
   \   00000188   0xB001             ADD      SP,SP,#+4
   \   0000018A   0xBDF0             POP      {R4-R7,PC}
   \                     ??HCD_HC_OUT_IRQHandler_9: (+1)
   \   0000018C   0x68B0             LDR      R0,[R6, #+8]
   \   0000018E   0x0780             LSLS     R0,R0,#+30
   \   00000190   0xD547             BPL.N    ??HCD_HC_OUT_IRQHandler_2
   \   00000192   0x68F0             LDR      R0,[R6, #+12]
   \   00000194   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000198   0x60F0             STR      R0,[R6, #+12]
   \   0000019A   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   0000019E   0xEB04 0x07C0      ADD      R7,R4,R0, LSL #+3
   \   000001A2   0xF997 0x0059      LDRSB    R0,[R7, #+89]
   \   000001A6   0x2801             CMP      R0,#+1
   \   000001A8   0xD10C             BNE.N    ??HCD_HC_OUT_IRQHandler_10
   \   000001AA   0xF887 0x0058      STRB     R0,[R7, #+88]
   \   000001AE   0xF897 0x003B      LDRB     R0,[R7, #+59]
   \   000001B2   0x2802             CMP      R0,#+2
   \   000001B4   0xD12D             BNE.N    ??HCD_HC_OUT_IRQHandler_11
   \   000001B6   0xF897 0x004D      LDRB     R0,[R7, #+77]
   \   000001BA   0xF080 0x0001      EOR      R0,R0,#0x1
   \   000001BE   0xF887 0x004D      STRB     R0,[R7, #+77]
   \   000001C2   0xE026             B.N      ??HCD_HC_OUT_IRQHandler_11
   \                     ??HCD_HC_OUT_IRQHandler_10: (+1)
   \   000001C4   0x2803             CMP      R0,#+3
   \   000001C6   0xBF08             IT       EQ 
   \   000001C8   0x2002             MOVEQ    R0,#+2
   \   000001CA   0xD00A             BEQ.N    ??HCD_HC_OUT_IRQHandler_12
   \   000001CC   0x2804             CMP      R0,#+4
   \   000001CE   0xD106             BNE.N    ??HCD_HC_OUT_IRQHandler_13
   \   000001D0   0x2002             MOVS     R0,#+2
   \   000001D2   0xF887 0x0058      STRB     R0,[R7, #+88]
   \   000001D6   0x2000             MOVS     R0,#+0
   \   000001D8   0xF887 0x0039      STRB     R0,[R7, #+57]
   \   000001DC   0xE019             B.N      ??HCD_HC_OUT_IRQHandler_11
   \                     ??HCD_HC_OUT_IRQHandler_13: (+1)
   \   000001DE   0x2805             CMP      R0,#+5
   \   000001E0   0xD102             BNE.N    ??HCD_HC_OUT_IRQHandler_14
   \                     ??HCD_HC_OUT_IRQHandler_12: (+1)
   \   000001E2   0xF887 0x0058      STRB     R0,[R7, #+88]
   \   000001E6   0xE014             B.N      ??HCD_HC_OUT_IRQHandler_11
   \                     ??HCD_HC_OUT_IRQHandler_14: (+1)
   \   000001E8   0x2806             CMP      R0,#+6
   \   000001EA   0xBF18             IT       NE 
   \   000001EC   0x2808             CMPNE    R0,#+8
   \   000001EE   0xD110             BNE.N    ??HCD_HC_OUT_IRQHandler_11
   \   000001F0   0x6D78             LDR      R0,[R7, #+84]
   \   000001F2   0x1C41             ADDS     R1,R0,#+1
   \   000001F4   0x2804             CMP      R0,#+4
   \   000001F6   0x6579             STR      R1,[R7, #+84]
   \   000001F8   0xBF23             ITTTE    CS 
   \   000001FA   0x2000             MOVCS    R0,#+0
   \   000001FC   0x6578             STRCS    R0,[R7, #+84]
   \   000001FE   0x2004             MOVCS    R0,#+4
   \   00000200   0x2002             MOVCC    R0,#+2
   \   00000202   0xF887 0x0058      STRB     R0,[R7, #+88]
   \   00000206   0x6830             LDR      R0,[R6, #+0]
   \   00000208   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   0000020C   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000210   0x6030             STR      R0,[R6, #+0]
   \                     ??HCD_HC_OUT_IRQHandler_11: (+1)
   \   00000212   0x2002             MOVS     R0,#+2
   \   00000214   0x4629             MOV      R1,R5
   \   00000216   0x60B0             STR      R0,[R6, #+8]
   \   00000218   0xF997 0x2058      LDRSB    R2,[R7, #+88]
   \   0000021C   0x4620             MOV      R0,R4
   \   0000021E   0x.... 0x....      BL       HAL_HCD_HC_NotifyURBChange_Callback
   \                     ??HCD_HC_OUT_IRQHandler_2: (+1)
   \   00000222   0xB001             ADD      SP,SP,#+4
   \   00000224   0xBDF0             POP      {R4-R7,PC}       ;; return
   1081          
   1082          /**
   1083            * @brief  Handle Rx Queue Level interrupt requests.
   1084            * @param  hhcd: HCD handle
   1085            * @retval none
   1086            */

   \                                 In section .text, align 2, keep-with-next
   1087          static void HCD_RXQLVL_IRQHandler  (HCD_HandleTypeDef *hhcd)
   1088          {
   \                     HCD_RXQLVL_IRQHandler: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1089            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;  
   \   00000006   0x6808             LDR      R0,[R1, #+0]
   1090            uint8_t                       channelnum =0;  
   1091            uint32_t                      pktsts;
   1092            uint32_t                      pktcnt; 
   1093            uint32_t                      temp = 0;
   1094            uint32_t tmpreg = 0;
   1095            
   1096            temp = hhcd->Instance->GRXSTSP ;
   \   00000008   0x6A02             LDR      R2,[R0, #+32]
   1097            channelnum = temp &  USB_OTG_GRXSTSP_EPNUM;  
   \   0000000A   0xF002 0x050F      AND      R5,R2,#0xF
   \   0000000E   0x4604             MOV      R4,R0
   1098            pktsts = (temp &  USB_OTG_GRXSTSP_PKTSTS) >> 17;
   1099            pktcnt = (temp &  USB_OTG_GRXSTSP_BCNT) >> 4;
   \   00000010   0xF3C2 0x160A      UBFX     R6,R2,#+4,#+11
   1100              
   1101            switch (pktsts)
   \   00000014   0xF3C2 0x4243      UBFX     R2,R2,#+17,#+4
   \   00000018   0x2A02             CMP      R2,#+2
   \   0000001A   0xD125             BNE.N    ??HCD_RXQLVL_IRQHandler_0
   1102            {
   1103            case GRXSTS_PKTSTS_IN:
   1104              /* Read the data into the host buffer. */
   1105              if ((pktcnt > 0) && (hhcd->hc[channelnum].xfer_buff != (void  *)0))
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xBF1F             ITTTT    NE 
   \   00000020   0xEB05 0x0285      ADDNE    R2,R5,R5, LSL #+2
   \   00000024   0xEB01 0x07C2      ADDNE    R7,R1,R2, LSL #+3
   \   00000028   0x6C39             LDRNE    R1,[R7, #+64]
   \   0000002A   0x2900             CMPNE    R1,#+0
   \   0000002C   0xD01C             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   1106              {  
   1107                
   1108                USB_ReadPacket(hhcd->Instance, hhcd->hc[channelnum].xfer_buff, pktcnt);
   \   0000002E   0x4632             MOV      R2,R6
   \   00000030   0x.... 0x....      BL       USB_ReadPacket
   1109               
   1110                /*manage multiple Xfer */
   1111                hhcd->hc[channelnum].xfer_buff += pktcnt;           
   \   00000034   0x6C38             LDR      R0,[R7, #+64]
   1112                hhcd->hc[channelnum].xfer_count  += pktcnt;
   1113                  
   1114                if((USBx_HC(channelnum)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0)
   \   00000036   0x....             LDR.N    R2,??DataTable0  ;; 0x1ff80000
   \   00000038   0x1830             ADDS     R0,R6,R0
   \   0000003A   0x6438             STR      R0,[R7, #+64]
   \   0000003C   0x6CB8             LDR      R0,[R7, #+72]
   \   0000003E   0x1830             ADDS     R0,R6,R0
   \   00000040   0x64B8             STR      R0,[R7, #+72]
   \   00000042   0xEB04 0x1045      ADD      R0,R4,R5, LSL #+5
   \   00000046   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   0000004A   0x6901             LDR      R1,[R0, #+16]
   \   0000004C   0x4211             TST      R1,R2
   \   0000004E   0xD00B             BEQ.N    ??HCD_RXQLVL_IRQHandler_0
   1115                {
   1116                  /* re-activate the channel when more packets are expected */
   1117                  tmpreg = USBx_HC(channelnum)->HCCHAR;
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   1118                  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   1119                  tmpreg |= USB_OTG_HCCHAR_CHENA;
   1120                  USBx_HC(channelnum)->HCCHAR = tmpreg;
   \   00000052   0xF021 0x4180      BIC      R1,R1,#0x40000000
   \   00000056   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   1121                  hhcd->hc[channelnum].toggle_in ^= 1;
   \   0000005C   0xF897 0x004C      LDRB     R0,[R7, #+76]
   \   00000060   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000064   0xF887 0x004C      STRB     R0,[R7, #+76]
   1122                }
   1123              }
   1124              break;
   1125          
   1126            case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
   1127              break;
   1128            case GRXSTS_PKTSTS_IN_XFER_COMP:
   1129            case GRXSTS_PKTSTS_CH_HALTED:
   1130            default:
   1131              break;
   1132            }
   1133          }
   \                     ??HCD_RXQLVL_IRQHandler_0: (+1)
   \   00000068   0xB001             ADD      SP,SP,#+4
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1134          
   1135          /**
   1136            * @brief  Handle Host Port interrupt requests.
   1137            * @param  hhcd: HCD handle
   1138            * @retval None
   1139            */

   \                                 In section .text, align 2, keep-with-next
   1140          static void HCD_Port_IRQHandler  (HCD_HandleTypeDef *hhcd)
   1141          {
   \                     HCD_Port_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
   1142            USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;  
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   1143            __IO uint32_t hprt0, hprt0_dup;
   1144            
   1145            /* Handle Host Port Interrupts */
   1146            hprt0 = USBx_HPRT0;
   \   00000008   0x4606             MOV      R6,R0
   \   0000000A   0xF506 0x6488      ADD      R4,R6,#+1088
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x9101             STR      R1,[SP, #+4]
   1147            hprt0_dup = USBx_HPRT0;
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x9100             STR      R1,[SP, #+0]
   1148            
   1149            hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
   1150                           USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0xF021 0x012E      BIC      R1,R1,#0x2E
   \   0000001C   0x9100             STR      R1,[SP, #+0]
   1151            
   1152            /* Check whether Port Connect detected */
   1153            if((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
   \   0000001E   0x9901             LDR      R1,[SP, #+4]
   \   00000020   0x0789             LSLS     R1,R1,#+30
   \   00000022   0xD50D             BPL.N    ??HCD_Port_IRQHandler_0
   1154            {  
   1155              if((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
   \   00000024   0x9901             LDR      R1,[SP, #+4]
   \   00000026   0x07C9             LSLS     R1,R1,#+31
   \   00000028   0xD506             BPL.N    ??HCD_Port_IRQHandler_1
   1156              {
   1157                USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT);
   \   0000002A   0x6981             LDR      R1,[R0, #+24]
   \   0000002C   0xF021 0x5100      BIC      R1,R1,#0x20000000
   \   00000030   0x6181             STR      R1,[R0, #+24]
   1158                HAL_HCD_Connect_Callback(hhcd);
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       HAL_HCD_Connect_Callback
   1159              }
   1160              hprt0_dup  |= USB_OTG_HPRT_PCDET;
   \                     ??HCD_Port_IRQHandler_1: (+1)
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   1161              
   1162            }
   1163            
   1164            /* Check whether Port Enable Changed */
   1165            if((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
   \                     ??HCD_Port_IRQHandler_0: (+1)
   \   00000040   0x9801             LDR      R0,[SP, #+4]
   \   00000042   0x0700             LSLS     R0,R0,#+28
   \   00000044   0xD52C             BPL.N    ??HCD_Port_IRQHandler_2
   1166            {
   1167              hprt0_dup |= USB_OTG_HPRT_PENCHNG;
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   1168              
   1169              if((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
   \   0000004E   0x9801             LDR      R0,[SP, #+4]
   \   00000050   0x0740             LSLS     R0,R0,#+29
   \   00000052   0xD51C             BPL.N    ??HCD_Port_IRQHandler_3
   1170              {    
   1171                if(hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
   \   00000054   0x69A8             LDR      R0,[R5, #+24]
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD10B             BNE.N    ??HCD_Port_IRQHandler_4
   1172                {
   1173                  if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
   \   0000005A   0x6828             LDR      R0,[R5, #+0]
   \   0000005C   0x9901             LDR      R1,[SP, #+4]
   \   0000005E   0xF401 0x21C0      AND      R1,R1,#0x60000
   \   00000062   0xF5B1 0x2F80      CMP      R1,#+262144
   \   00000066   0xBF0C             ITE      EQ 
   \   00000068   0x2102             MOVEQ    R1,#+2
   \   0000006A   0x2101             MOVNE    R1,#+1
   1174                  {
   1175                    USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_6_MHZ );
   1176                  }
   1177                  else
   1178                  {
   1179                    USB_InitFSLSPClkSel(hhcd->Instance ,HCFG_48_MHZ );
   \   0000006C   0x.... 0x....      BL       USB_InitFSLSPClkSel
   \   00000070   0xE007             B.N      ??HCD_Port_IRQHandler_5
   1180                  }
   1181                }
   1182                else
   1183                {
   1184                  if(hhcd->Init.speed == HCD_SPEED_FULL)
   \                     ??HCD_Port_IRQHandler_4: (+1)
   \   00000072   0x68E8             LDR      R0,[R5, #+12]
   \   00000074   0x2803             CMP      R0,#+3
   \   00000076   0xD104             BNE.N    ??HCD_Port_IRQHandler_5
   1185                  {
   1186                    USBx_HOST->HFIR = (uint32_t)60000;
   \   00000078   0xF64E 0x2060      MOVW     R0,#+60000
   \   0000007C   0xF506 0x6180      ADD      R1,R6,#+1024
   \   00000080   0x6048             STR      R0,[R1, #+4]
   1187                  }
   1188                }
   1189                HAL_HCD_Connect_Callback(hhcd);
   \                     ??HCD_Port_IRQHandler_5: (+1)
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       HAL_HCD_Connect_Callback
   1190                
   1191                if(hhcd->Init.speed == HCD_SPEED_HIGH)
   \   00000088   0x68E8             LDR      R0,[R5, #+12]
   \   0000008A   0xB948             CBNZ.N   R0,??HCD_Port_IRQHandler_2
   1192                {
   1193                  USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT); 
   \   0000008C   0xE003             B.N      ??HCD_Port_IRQHandler_6
   1194                }
   1195              }
   1196              else
   1197              {
   1198                /* Cleanup HPRT */
   1199                USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |\
   1200                  USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \                     ??HCD_Port_IRQHandler_3: (+1)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0xF020 0x002E      BIC      R0,R0,#0x2E
   \   00000094   0x6020             STR      R0,[R4, #+0]
   1201                
   1202                USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT); 
   \                     ??HCD_Port_IRQHandler_6: (+1)
   \   00000096   0x6828             LDR      R0,[R5, #+0]
   \   00000098   0x6981             LDR      R1,[R0, #+24]
   \   0000009A   0xF041 0x5100      ORR      R1,R1,#0x20000000
   \   0000009E   0x6181             STR      R1,[R0, #+24]
   1203              }    
   1204            }
   1205            
   1206            /* Check For an overcurrent */
   1207            if((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
   \                     ??HCD_Port_IRQHandler_2: (+1)
   \   000000A0   0x9801             LDR      R0,[SP, #+4]
   \   000000A2   0x0680             LSLS     R0,R0,#+26
   \   000000A4   0xD503             BPL.N    ??HCD_Port_IRQHandler_7
   1208            {
   1209              hprt0_dup |= USB_OTG_HPRT_POCCHNG;
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   1210            }
   1211          
   1212            /* Clear Port Interrupts */
   1213            USBx_HPRT0 = hprt0_dup;
   \                     ??HCD_Port_IRQHandler_7: (+1)
   \   000000AE   0x9800             LDR      R0,[SP, #+0]
   \   000000B0   0x6020             STR      R0,[R4, #+0]
   1214          }
   \   000000B2   0xB002             ADD      SP,SP,#+8
   \   000000B4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x1FF80000         DC32     0x1ff80000
   1215          
   1216          /**
   1217            * @}
   1218            */
   1219          
   1220          /**
   1221            * @}
   1222            */
   1223            
   1224          #endif /* HAL_HCD_MODULE_ENABLED */
   1225          /**
   1226            * @}
   1227            */
   1228          
   1229          /**
   1230            * @}
   1231            */
   1232          
   1233          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HCD_Connect_Callback
       8   HAL_HCD_DeInit
         8   -> HAL_HCD_MspDeInit
         8   -> USB_DisableGlobalInt
       0   HAL_HCD_Disconnect_Callback
       0   HAL_HCD_GetCurrentFrame
         0   -> USB_GetCurrentFrame
       0   HAL_HCD_GetCurrentSpeed
         0   -> USB_GetHostSpeed
       0   HAL_HCD_GetState
       0   HAL_HCD_HC_GetState
       0   HAL_HCD_HC_GetURBState
       0   HAL_HCD_HC_GetXferCount
       8   HAL_HCD_HC_Halt
         8   -> USB_HC_Halt
      32   HAL_HCD_HC_Init
        32   -> USB_HC_Init
       0   HAL_HCD_HC_NotifyURBChange_Callback
      16   HAL_HCD_HC_SubmitRequest
         0   -> USB_HC_StartXfer
      24   HAL_HCD_IRQHandler
        24   -> HAL_HCD_Disconnect_Callback
        24   -> HAL_HCD_SOF_Callback
        24   -> HCD_HC_IN_IRQHandler
        24   -> HCD_HC_OUT_IRQHandler
        24   -> HCD_Port_IRQHandler
        24   -> HCD_RXQLVL_IRQHandler
        24   -> USB_GetMode
        24   -> USB_HC_ReadInterrupt
        24   -> USB_InitFSLSPClkSel
        24   -> USB_ReadInterrupts
      60   HAL_HCD_Init
        48   -> HAL_HCD_MspInit
        48   -> USB_CoreInit
        48   -> USB_DisableGlobalInt
        48   -> USB_HostInit
        48   -> USB_SetCurrentMode
        60   -> __aeabi_memcpy4
       0   HAL_HCD_MspDeInit
       0   HAL_HCD_MspInit
       0   HAL_HCD_ResetPort
         0   -> USB_ResetPort
       0   HAL_HCD_SOF_Callback
       8   HAL_HCD_Start
         8   -> USB_DriveVbus
         8   -> USB_EnableGlobalInt
       8   HAL_HCD_Stop
         8   -> USB_StopHost
      24   HCD_HC_IN_IRQHandler
        24   -> HAL_HCD_HC_NotifyURBChange_Callback
        24   -> USB_HC_Halt
      24   HCD_HC_OUT_IRQHandler
        24   -> HAL_HCD_HC_NotifyURBChange_Callback
        24   -> USB_HC_Halt
      24   HCD_Port_IRQHandler
        24   -> HAL_HCD_Connect_Callback
        24   -> USB_InitFSLSPClkSel
      24   HCD_RXQLVL_IRQHandler
        24   -> USB_ReadPacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       2  HAL_HCD_Connect_Callback
      36  HAL_HCD_DeInit
       2  HAL_HCD_Disconnect_Callback
       6  HAL_HCD_GetCurrentFrame
       6  HAL_HCD_GetCurrentSpeed
       6  HAL_HCD_GetState
      14  HAL_HCD_HC_GetState
      14  HAL_HCD_HC_GetURBState
      12  HAL_HCD_HC_GetXferCount
      36  HAL_HCD_HC_Halt
      92  HAL_HCD_HC_Init
       2  HAL_HCD_HC_NotifyURBChange_Callback
     162  HAL_HCD_HC_SubmitRequest
     298  HAL_HCD_IRQHandler
      90  HAL_HCD_Init
       2  HAL_HCD_MspDeInit
       2  HAL_HCD_MspInit
       6  HAL_HCD_ResetPort
       2  HAL_HCD_SOF_Callback
      44  HAL_HCD_Start
      36  HAL_HCD_Stop
     512  HCD_HC_IN_IRQHandler
     550  HCD_HC_OUT_IRQHandler
     182  HCD_Port_IRQHandler
     108  HCD_RXQLVL_IRQHandler

 
 2 226 bytes in section .text
 
 2 226 bytes of CODE memory

Errors: none
Warnings: none
