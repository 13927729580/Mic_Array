###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       08/Nov/2016  10:26:36
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_usb.c
#    Command line =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_usb.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e
#        --char_is_signed --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_ll_usb.lst
#    Object file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_ll_usb.o
#
###############################################################################

D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_usb.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_ll_usb.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   USB Low Layer HAL module driver.
      8            *    
      9            *          This file provides firmware functions to manage the following 
     10            *          functionalities of the USB Peripheral Controller:
     11            *           + Initialization/de-initialization functions
     12            *           + I/O operation functions
     13            *           + Peripheral Control functions 
     14            *           + Peripheral State functions
     15            *         
     16            @verbatim
     17            ==============================================================================
     18                              ##### How to use this driver #####
     19            ==============================================================================
     20              [..]
     21                (#) Fill parameters of Init structure in USB_OTG_CfgTypeDef structure.
     22            
     23                (#) Call USB_CoreInit() API to initialize the USB Core peripheral.
     24          
     25                (#) The upper HAL HCD/PCD driver will call the right routines for its internal processes.
     26          
     27            @endverbatim
     28            ******************************************************************************
     29            * @attention
     30            *
     31            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     32            *
     33            * Redistribution and use in source and binary forms, with or without modification,
     34            * are permitted provided that the following conditions are met:
     35            *   1. Redistributions of source code must retain the above copyright notice,
     36            *      this list of conditions and the following disclaimer.
     37            *   2. Redistributions in binary form must reproduce the above copyright notice,
     38            *      this list of conditions and the following disclaimer in the documentation
     39            *      and/or other materials provided with the distribution.
     40            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     41            *      may be used to endorse or promote products derived from this software
     42            *      without specific prior written permission.
     43            *
     44            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     45            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     46            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     47            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     48            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     49            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     50            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     51            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     52            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     53            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     54            *
     55            ******************************************************************************
     56            */ 
     57          
     58          /* Includes ------------------------------------------------------------------*/
     59          #include "stm32f7xx_hal.h"
     60          
     61          /** @addtogroup STM32F7xx_LL_USB_DRIVER
     62            * @{
     63            */
     64          
     65          #if defined (HAL_PCD_MODULE_ENABLED) || defined (HAL_HCD_MODULE_ENABLED)
     66          
     67          /* Private typedef -----------------------------------------------------------*/
     68          /* Private define ------------------------------------------------------------*/
     69          /* Private macro -------------------------------------------------------------*/
     70          /* Private variables ---------------------------------------------------------*/
     71          /* Private function prototypes -----------------------------------------------*/
     72          /* Private functions ---------------------------------------------------------*/
     73          static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx);
     74          
     75          /* Exported functions --------------------------------------------------------*/
     76          /** @defgroup LL_USB_Exported_Functions USB Low Layer Exported Functions
     77            * @{
     78            */
     79          
     80          /** @defgroup LL_USB_Group1 Initialization/de-initialization functions 
     81           *  @brief    Initialization and Configuration functions 
     82           *
     83          @verbatim    
     84           ===============================================================================
     85                        ##### Initialization/de-initialization functions #####
     86           ===============================================================================
     87              [..]  This section provides functions allowing to:
     88           
     89          @endverbatim
     90            * @{
     91            */
     92          
     93          /**
     94            * @brief  Initializes the USB Core
     95            * @param  USBx: USB Instance
     96            * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
     97            *         the configuration information for the specified USBx peripheral.
     98            * @retval HAL status
     99            */

   \                                 In section .text, align 2, keep-with-next
    100          HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
    101          {
   \                     USB_CoreInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
    102            if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   \   00000002   0x9905             LDR      R1,[SP, #+20]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD125             BNE.N    ??USB_CoreInit_0
    103            {
    104              
    105              USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   \   00000008   0x6B81             LDR      R1,[R0, #+56]
    106          
    107              /* Init The ULPI Interface */
    108              USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0xffbdffbf
   \   0000000E   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   00000012   0x6381             STR      R1,[R0, #+56]
   \   00000014   0x68C1             LDR      R1,[R0, #+12]
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x60C1             STR      R1,[R0, #+12]
    109             
    110              /* Select vbus source */
    111              USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
   \   0000001A   0x68C1             LDR      R1,[R0, #+12]
   \   0000001C   0xF421 0x1140      BIC      R1,R1,#0x300000
   \   00000020   0x60C1             STR      R1,[R0, #+12]
    112              if(cfg.use_external_vbus == 1)
   \   00000022   0x990B             LDR      R1,[SP, #+44]
   \   00000024   0x2901             CMP      R1,#+1
   \   00000026   0xD103             BNE.N    ??USB_CoreInit_1
    113              {
    114                USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
   \   00000028   0x68C1             LDR      R1,[R0, #+12]
   \   0000002A   0xF441 0x1180      ORR      R1,R1,#0x100000
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
    115              }
    116              /* Reset after a PHY select  */
    117              USB_CoreReset(USBx); 
   \                     ??USB_CoreInit_1: (+1)
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable8_1  ;; 0x30d41
   \   00000034   0x460A             MOV      R2,R1
   \                     ??USB_CoreInit_2: (+1)
   \   00000036   0x1E52             SUBS     R2,R2,#+1
   \   00000038   0xD024             BEQ.N    ??USB_CoreInit_3
   \   0000003A   0x6903             LDR      R3,[R0, #+16]
   \   0000003C   0x2B00             CMP      R3,#+0
   \   0000003E   0xD5FA             BPL.N    ??USB_CoreInit_2
   \   00000040   0x6902             LDR      R2,[R0, #+16]
   \   00000042   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000046   0x6102             STR      R2,[R0, #+16]
   \                     ??USB_CoreInit_4: (+1)
   \   00000048   0x1E49             SUBS     R1,R1,#+1
   \   0000004A   0xD01B             BEQ.N    ??USB_CoreInit_3
   \   0000004C   0x6902             LDR      R2,[R0, #+16]
   \   0000004E   0x07D2             LSLS     R2,R2,#+31
   \   00000050   0xD4FA             BMI.N    ??USB_CoreInit_4
   \   00000052   0xE017             B.N      ??USB_CoreInit_3
    118            }
    119            else /* FS interface (embedded Phy) */
    120            {
    121              /* Select FS Embedded PHY */
    122              USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
   \                     ??USB_CoreInit_0: (+1)
   \   00000054   0x68C1             LDR      R1,[R0, #+12]
   \   00000056   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000005A   0x60C1             STR      R1,[R0, #+12]
    123              
    124              /* Reset after a PHY select and set Host mode */
    125              USB_CoreReset(USBx);
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable8_1  ;; 0x30d41
   \   00000060   0x460A             MOV      R2,R1
   \                     ??USB_CoreInit_5: (+1)
   \   00000062   0x1E52             SUBS     R2,R2,#+1
   \   00000064   0xD00B             BEQ.N    ??USB_CoreInit_6
   \   00000066   0x6903             LDR      R3,[R0, #+16]
   \   00000068   0x2B00             CMP      R3,#+0
   \   0000006A   0xD5FA             BPL.N    ??USB_CoreInit_5
   \   0000006C   0x6902             LDR      R2,[R0, #+16]
   \   0000006E   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000072   0x6102             STR      R2,[R0, #+16]
   \                     ??USB_CoreInit_7: (+1)
   \   00000074   0x1E49             SUBS     R1,R1,#+1
   \   00000076   0xD002             BEQ.N    ??USB_CoreInit_6
   \   00000078   0x6902             LDR      R2,[R0, #+16]
   \   0000007A   0x07D2             LSLS     R2,R2,#+31
   \   0000007C   0xD4FA             BMI.N    ??USB_CoreInit_7
    126              
    127              /* Deactivate the power down*/
    128              USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
   \                     ??USB_CoreInit_6: (+1)
   \   0000007E   0xF44F 0x3180      MOV      R1,#+65536
   \   00000082   0x6381             STR      R1,[R0, #+56]
    129            }
    130           
    131            if(cfg.dma_enable == ENABLE)
   \                     ??USB_CoreInit_3: (+1)
   \   00000084   0x9903             LDR      R1,[SP, #+12]
   \   00000086   0x2901             CMP      R1,#+1
   \   00000088   0xD107             BNE.N    ??USB_CoreInit_8
    132            {
    133              USBx->GAHBCFG |= (USB_OTG_GAHBCFG_HBSTLEN_1 | USB_OTG_GAHBCFG_HBSTLEN_2);
   \   0000008A   0x6881             LDR      R1,[R0, #+8]
   \   0000008C   0xF041 0x010C      ORR      R1,R1,#0xC
   \   00000090   0x6081             STR      R1,[R0, #+8]
    134              USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
   \   00000092   0x6881             LDR      R1,[R0, #+8]
   \   00000094   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000098   0x6081             STR      R1,[R0, #+8]
    135            }  
    136          
    137            return HAL_OK;
   \                     ??USB_CoreInit_8: (+1)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xB003             ADD      SP,SP,#+12
   \   0000009E   0x4770             BX       LR               ;; return
    138          }
    139          
    140          /**
    141            * @brief  USB_EnableGlobalInt
    142            *         Enables the controller's Global Int in the AHB Config reg
    143            * @param  USBx : Selected device
    144            * @retval HAL status
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
    147          {
    148            USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   \                     USB_EnableGlobalInt: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000006   0x6081             STR      R1,[R0, #+8]
    149            return HAL_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    150          }
    151          
    152          
    153          /**
    154            * @brief  USB_DisableGlobalInt
    155            *         Disable the controller's Global Int in the AHB Config reg
    156            * @param  USBx : Selected device
    157            * @retval HAL status
    158          */

   \                                 In section .text, align 2, keep-with-next
    159          HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
    160          {
    161            USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   \                     USB_DisableGlobalInt: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
   \   00000002   0x0849             LSRS     R1,R1,#+1
   \   00000004   0x0049             LSLS     R1,R1,#+1
   \   00000006   0x6081             STR      R1,[R0, #+8]
    162            return HAL_OK;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
    163          }
    164             
    165          /**
    166            * @brief  USB_SetCurrentMode : Set functional mode
    167            * @param  USBx : Selected device
    168            * @param  mode :  current core mode
    169            *          This parameter can be one of these values:
    170            *            @arg USB_OTG_DEVICE_MODE: Peripheral mode
    171            *            @arg USB_OTG_HOST_MODE: Host mode
    172            *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
    173            * @retval HAL status
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
    176          {
   \                     USB_SetCurrentMode: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    177            USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
   \   00000004   0x68C2             LDR      R2,[R0, #+12]
    178            
    179            if ( mode == USB_OTG_HOST_MODE)
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xF022 0x42C0      BIC      R2,R2,#0x60000000
   \   0000000C   0x60C2             STR      R2,[R0, #+12]
   \   0000000E   0xD103             BNE.N    ??USB_SetCurrentMode_0
    180            {
    181              USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF041 0x5100      ORR      R1,R1,#0x20000000
   \   00000016   0xE003             B.N      ??USB_SetCurrentMode_1
    182            }
    183            else if ( mode == USB_OTG_DEVICE_MODE)
   \                     ??USB_SetCurrentMode_0: (+1)
   \   00000018   0xB919             CBNZ.N   R1,??USB_SetCurrentMode_2
    184            {
    185              USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
   \   0000001A   0x68C1             LDR      R1,[R0, #+12]
   \   0000001C   0xF041 0x4180      ORR      R1,R1,#0x40000000
   \                     ??USB_SetCurrentMode_1: (+1)
   \   00000020   0x60C1             STR      R1,[R0, #+12]
    186            }
    187            HAL_Delay(50);
   \                     ??USB_SetCurrentMode_2: (+1)
   \   00000022   0x2032             MOVS     R0,#+50
   \   00000024   0x.... 0x....      BL       HAL_Delay
    188            
    189            return HAL_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xB001             ADD      SP,SP,#+4
   \   0000002C   0xBD00             POP      {PC}             ;; return
    190          }
    191          
    192          /**
    193            * @brief  USB_DevInit : Initializes the USB_OTG controller registers 
    194            *         for device mode
    195            * @param  USBx : Selected device
    196            * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
    197            *         the configuration information for the specified USBx peripheral.
    198            * @retval HAL status
    199            */

   \                                 In section .text, align 4, keep-with-next
    200          HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
    201          {
   \                     USB_DevInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB5F0             PUSH     {R4-R7,LR}
    202            uint32_t i = 0;
    203          
    204            /*Activate VBUS Sensing B */
    205            USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
   \   00000004   0x6B81             LDR      R1,[R0, #+56]
   \   00000006   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   0000000A   0x6381             STR      R1,[R0, #+56]
    206            
    207            if (cfg.vbus_sensing_enable == 0)
   \   0000000C   0x990E             LDR      R1,[SP, #+56]
   \   0000000E   0xB959             CBNZ.N   R1,??USB_DevInit_0
    208            {
    209              /* Deactivate VBUS Sensing B */
    210              USBx->GCCFG &= ~ USB_OTG_GCCFG_VBDEN;
   \   00000010   0x6B82             LDR      R2,[R0, #+56]
   \   00000012   0xF422 0x1200      BIC      R2,R2,#0x200000
   \   00000016   0x6382             STR      R2,[R0, #+56]
    211              
    212              /* B-peripheral session valid override enable*/ 
    213              USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0xF042 0x0240      ORR      R2,R2,#0x40
   \   0000001E   0x6002             STR      R2,[R0, #+0]
    214              USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000026   0x6002             STR      R2,[R0, #+0]
    215            }
    216             
    217            /* Restart the Phy Clock */
    218            USBx_PCGCCTL = 0;
   \                     ??USB_DevInit_0: (+1)
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0xF500 0x6460      ADD      R4,R0,#+3584
   \   0000002E   0x6022             STR      R2,[R4, #+0]
    219          
    220            /* Device mode configuration */
    221            USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
   \   00000030   0xF500 0x6200      ADD      R2,R0,#+2048
   \   00000034   0x6814             LDR      R4,[R2, #+0]
   \   00000036   0x6014             STR      R4,[R2, #+0]
    222            
    223            if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
   \   00000038   0x9C0A             LDR      R4,[SP, #+40]
   \   0000003A   0x2C01             CMP      R4,#+1
   \   0000003C   0xD106             BNE.N    ??USB_DevInit_1
    224            {
    225              if(cfg.speed == USB_OTG_SPEED_HIGH)
   \   0000003E   0x9C07             LDR      R4,[SP, #+28]
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0x6814             LDR      R4,[R2, #+0]
   \   00000044   0xD005             BEQ.N    ??USB_DevInit_2
    226              {      
    227                /* Set High speed phy */
    228                USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    229              }
    230              else 
    231              {
    232                /* set High speed phy in Full speed mode */
    233                USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
   \   00000046   0xF044 0x0401      ORR      R4,R4,#0x1
   \   0000004A   0xE002             B.N      ??USB_DevInit_2
    234              }
    235            }
    236            else
    237            {
    238              /* Set Full speed phy */
    239              USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
   \                     ??USB_DevInit_1: (+1)
   \   0000004C   0x6814             LDR      R4,[R2, #+0]
   \   0000004E   0xF044 0x0403      ORR      R4,R4,#0x3
   \                     ??USB_DevInit_2: (+1)
   \   00000052   0x6014             STR      R4,[R2, #+0]
    240            }
    241          
    242            /* Flush the FIFOs */
    243            USB_FlushTxFifo(USBx , 0x10); /* all Tx FIFOs */
   \   00000054   0xF44F 0x6484      MOV      R4,#+1056
   \   00000058   0x6104             STR      R4,[R0, #+16]
   \   0000005A   0x.... 0x....      LDR.W    R4,??DataTable8_1  ;; 0x30d41
   \   0000005E   0x4625             MOV      R5,R4
   \                     ??USB_DevInit_3: (+1)
   \   00000060   0x1E6D             SUBS     R5,R5,#+1
   \   00000062   0xD002             BEQ.N    ??USB_DevInit_4
   \   00000064   0x6906             LDR      R6,[R0, #+16]
   \   00000066   0x06B6             LSLS     R6,R6,#+26
   \   00000068   0xD4FA             BMI.N    ??USB_DevInit_3
    244            USB_FlushRxFifo(USBx);
   \                     ??USB_DevInit_4: (+1)
   \   0000006A   0x2510             MOVS     R5,#+16
   \   0000006C   0x6105             STR      R5,[R0, #+16]
   \                     ??USB_DevInit_5: (+1)
   \   0000006E   0x1E64             SUBS     R4,R4,#+1
   \   00000070   0xD002             BEQ.N    ??USB_DevInit_6
   \   00000072   0x6905             LDR      R5,[R0, #+16]
   \   00000074   0x06ED             LSLS     R5,R5,#+27
   \   00000076   0xD4FA             BMI.N    ??USB_DevInit_5
    245            
    246            /* Clear all pending Device Interrupts */
    247            USBx_DEVICE->DIEPMSK = 0;
   \                     ??USB_DevInit_6: (+1)
   \   00000078   0x2400             MOVS     R4,#+0
   \   0000007A   0x6114             STR      R4,[R2, #+16]
    248            USBx_DEVICE->DOEPMSK = 0;
   \   0000007C   0x6154             STR      R4,[R2, #+20]
    249            USBx_DEVICE->DAINT = 0xFFFFFFFF;
   \   0000007E   0xF04F 0x34FF      MOV      R4,#-1
   \   00000082   0x6194             STR      R4,[R2, #+24]
    250            USBx_DEVICE->DAINTMSK = 0;
   \   00000084   0x2400             MOVS     R4,#+0
   \   00000086   0x61D4             STR      R4,[R2, #+28]
    251            
    252            for (i = 0; i < cfg.dev_endpoints; i++)
   \   00000088   0x9C05             LDR      R4,[SP, #+20]
   \   0000008A   0xB34C             CBZ.N    R4,??USB_DevInit_7
   \   0000008C   0x4627             MOV      R7,R4
   \   0000008E   0xF500 0x6610      ADD      R6,R0,#+2304
   \   00000092   0x24FF             MOVS     R4,#+255
   \   00000094   0xF04F 0x4590      MOV      R5,#+1207959552
    253            {
    254              if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
   \                     ??USB_DevInit_8: (+1)
   \   00000098   0xF8D6 0xE000      LDR      LR,[R6, #+0]
   \   0000009C   0xF1BE 0x0F00      CMP      LR,#+0
   \   000000A0   0xBF4E             ITEE     MI 
   \   000000A2   0x6035             STRMI    R5,[R6, #+0]
   \   000000A4   0xF04F 0x0E00      MOVPL    LR,#+0
   \   000000A8   0xF8C6 0xE000      STRPL    LR,[R6, #+0]
    255              {
    256                USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
    257              }
    258              else
    259              {
    260                USBx_INEP(i)->DIEPCTL = 0;
    261              }
    262              
    263              USBx_INEP(i)->DIEPTSIZ = 0;
   \   000000AC   0xF04F 0x0E00      MOV      LR,#+0
   \   000000B0   0xF8C6 0xE010      STR      LR,[R6, #+16]
    264              USBx_INEP(i)->DIEPINT  = 0xFF;
   \   000000B4   0x60B4             STR      R4,[R6, #+8]
    265            }
   \   000000B6   0x3620             ADDS     R6,R6,#+32
   \   000000B8   0x1E7F             SUBS     R7,R7,#+1
   \   000000BA   0xD1ED             BNE.N    ??USB_DevInit_8
   \   000000BC   0xF500 0x6330      ADD      R3,R0,#+2816
   \   000000C0   0xF8DD 0x6014      LDR.W    R6,[SP, #+20]
    266            
    267            for (i = 0; i < cfg.dev_endpoints; i++)
    268            {
    269              if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
   \                     ??USB_DevInit_9: (+1)
   \   000000C4   0xF8D3 0xC000      LDR      R12,[R3, #+0]
   \   000000C8   0xF1BC 0x0F00      CMP      R12,#+0
   \   000000CC   0xBF4C             ITE      MI 
   \   000000CE   0x601D             STRMI    R5,[R3, #+0]
   \   000000D0   0xF8C3 0xE000      STRPL    LR,[R3, #+0]
    270              {
    271                USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
    272              }
    273              else
    274              {
    275                USBx_OUTEP(i)->DOEPCTL = 0;
    276              }
    277              
    278              USBx_OUTEP(i)->DOEPTSIZ = 0;
   \   000000D4   0xF8C3 0xE010      STR      LR,[R3, #+16]
    279              USBx_OUTEP(i)->DOEPINT  = 0xFF;
   \   000000D8   0x609C             STR      R4,[R3, #+8]
    280            }
   \   000000DA   0x3320             ADDS     R3,R3,#+32
   \   000000DC   0x1E76             SUBS     R6,R6,#+1
   \   000000DE   0xD1F1             BNE.N    ??USB_DevInit_9
    281            
    282            USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
   \                     ??USB_DevInit_7: (+1)
   \   000000E0   0x6913             LDR      R3,[R2, #+16]
   \   000000E2   0xF423 0x7380      BIC      R3,R3,#0x100
   \   000000E6   0x6113             STR      R3,[R2, #+16]
    283            
    284            if (cfg.dma_enable == 1)
   \   000000E8   0x9B08             LDR      R3,[SP, #+32]
   \   000000EA   0x2B01             CMP      R3,#+1
   \   000000EC   0xD109             BNE.N    ??USB_DevInit_10
    285            {
    286              /*Set threshold parameters */
    287              USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
   \   000000EE   0x.... 0x....      LDR.W    R4,??DataTable10  ;; 0x800100
   \   000000F2   0x6314             STR      R4,[R2, #+48]
    288              USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
   \   000000F4   0x6B14             LDR      R4,[R2, #+48]
   \   000000F6   0xF444 0x3480      ORR      R4,R4,#0x10000
   \   000000FA   0xF044 0x0403      ORR      R4,R4,#0x3
   \   000000FE   0x6314             STR      R4,[R2, #+48]
    289              
    290              i= USBx_DEVICE->DTHRCTL;
   \   00000100   0x6B12             LDR      R2,[R2, #+48]
    291            }
    292            
    293            /* Disable all interrupts. */
    294            USBx->GINTMSK = 0;
   \                     ??USB_DevInit_10: (+1)
   \   00000102   0x2200             MOVS     R2,#+0
   \   00000104   0x6182             STR      R2,[R0, #+24]
    295            
    296            /* Clear any pending interrupts */
    297            USBx->GINTSTS = 0xBFFFFFFF;
   \   00000106   0xF06F 0x4280      MVN      R2,#+1073741824
   \   0000010A   0x6142             STR      R2,[R0, #+20]
    298          
    299            /* Enable the common interrupts */
    300            if (cfg.dma_enable == DISABLE)
   \   0000010C   0xB91B             CBNZ.N   R3,??USB_DevInit_11
    301            {
    302              USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
   \   0000010E   0x6982             LDR      R2,[R0, #+24]
   \   00000110   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000114   0x6182             STR      R2,[R0, #+24]
    303            }
    304            
    305            /* Enable interrupts matching to the Device mode ONLY */
    306            USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
    307                              USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
    308                              USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
    309                              USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
   \                     ??USB_DevInit_11: (+1)
   \   00000116   0x6982             LDR      R2,[R0, #+24]
   \   00000118   0x.... 0x....      LDR.W    R3,??DataTable11  ;; 0x803c3800
   \   0000011C   0x431A             ORRS     R2,R3,R2
   \   0000011E   0x6182             STR      R2,[R0, #+24]
    310            
    311            if(cfg.Sof_enable)
   \   00000120   0x9A0B             LDR      R2,[SP, #+44]
   \   00000122   0xB11A             CBZ.N    R2,??USB_DevInit_12
    312            {
    313              USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
   \   00000124   0x6982             LDR      R2,[R0, #+24]
   \   00000126   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000012A   0x6182             STR      R2,[R0, #+24]
    314            }
    315          
    316            if (cfg.vbus_sensing_enable == ENABLE)
   \                     ??USB_DevInit_12: (+1)
   \   0000012C   0x2901             CMP      R1,#+1
   \   0000012E   0xD105             BNE.N    ??USB_DevInit_13
    317            {
    318              USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
   \   00000130   0x6981             LDR      R1,[R0, #+24]
   \   00000132   0xF041 0x4180      ORR      R1,R1,#0x40000000
   \   00000136   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000013A   0x6181             STR      R1,[R0, #+24]
    319            }
    320            
    321            return HAL_OK;
   \                     ??USB_DevInit_13: (+1)
   \   0000013C   0xBCF0             POP      {R4-R7}
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    322          }
    323          
    324          
    325          /**
    326            * @brief  USB_OTG_FlushTxFifo : Flush a Tx FIFO
    327            * @param  USBx : Selected device
    328            * @param  num : FIFO number
    329            *         This parameter can be a value from 1 to 15
    330                      15 means Flush all Tx FIFOs
    331            * @retval HAL status
    332            */

   \                                 In section .text, align 2, keep-with-next
    333          HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
    334          {
    335            uint32_t count = 0;
    336           
    337            USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
   \                     USB_FlushTxFifo: (+1)
   \   00000000   0x0189             LSLS     R1,R1,#+6
   \   00000002   0xF041 0x0120      ORR      R1,R1,#0x20
   \   00000006   0x6101             STR      R1,[R0, #+16]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x30d41
    338           
    339            do
    340            {
    341              if (++count > 200000)
   \                     ??USB_FlushTxFifo_0: (+1)
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   \   0000000E   0xD101             BNE.N    ??USB_FlushTxFifo_1
    342              {
    343                return HAL_TIMEOUT;
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0x4770             BX       LR
    344              }
    345            }
    346            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   \                     ??USB_FlushTxFifo_1: (+1)
   \   00000014   0x6902             LDR      R2,[R0, #+16]
   \   00000016   0x0692             LSLS     R2,R2,#+26
   \   00000018   0xD4F8             BMI.N    ??USB_FlushTxFifo_0
    347            
    348            return HAL_OK;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
    349          }
    350          
    351          
    352          /**
    353            * @brief  USB_FlushRxFifo : Flush Rx FIFO
    354            * @param  USBx : Selected device
    355            * @retval HAL status
    356            */

   \                                 In section .text, align 2, keep-with-next
    357          HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
    358          {
    359            uint32_t count = 0;
    360            
    361            USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   \                     USB_FlushRxFifo: (+1)
   \   00000000   0x2110             MOVS     R1,#+16
   \   00000002   0x6101             STR      R1,[R0, #+16]
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x30d41
    362            
    363            do
    364            {
    365              if (++count > 200000)
   \                     ??USB_FlushRxFifo_0: (+1)
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \   0000000A   0xD101             BNE.N    ??USB_FlushRxFifo_1
    366              {
    367                return HAL_TIMEOUT;
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x4770             BX       LR
    368              }
    369            }
    370            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   \                     ??USB_FlushRxFifo_1: (+1)
   \   00000010   0x6902             LDR      R2,[R0, #+16]
   \   00000012   0x06D2             LSLS     R2,R2,#+27
   \   00000014   0xD4F8             BMI.N    ??USB_FlushRxFifo_0
    371            
    372            return HAL_OK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4770             BX       LR               ;; return
    373          }
    374          
    375          /**
    376            * @brief  USB_SetDevSpeed :Initializes the DevSpd field of DCFG register 
    377            *         depending the PHY type and the enumeration speed of the device.
    378            * @param  USBx : Selected device
    379            * @param  speed : device speed
    380            *          This parameter can be one of these values:
    381            *            @arg USB_OTG_SPEED_HIGH: High speed mode
    382            *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
    383            *            @arg USB_OTG_SPEED_FULL: Full speed mode
    384            *            @arg USB_OTG_SPEED_LOW: Low speed mode
    385            * @retval  Hal status
    386            */

   \                                 In section .text, align 2, keep-with-next
    387          HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
    388          {
    389            USBx_DEVICE->DCFG |= speed;
   \                     USB_SetDevSpeed: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000004   0x6802             LDR      R2,[R0, #+0]
   \   00000006   0x4311             ORRS     R1,R1,R2
   \   00000008   0x6001             STR      R1,[R0, #+0]
    390            return HAL_OK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR               ;; return
    391          }
    392          
    393          /**
    394            * @brief  USB_GetDevSpeed :Return the  Dev Speed 
    395            * @param  USBx : Selected device
    396            * @retval speed : device speed
    397            *          This parameter can be one of these values:
    398            *            @arg USB_OTG_SPEED_HIGH: High speed mode
    399            *            @arg USB_OTG_SPEED_FULL: Full speed mode
    400            *            @arg USB_OTG_SPEED_LOW: Low speed mode
    401            */

   \                                 In section .text, align 2, keep-with-next
    402          uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
    403          {
    404            uint8_t speed = 0;
    405            
    406            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
   \                     USB_GetDevSpeed: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6882             LDR      R2,[R0, #+8]
   \   00000008   0xF012 0x0F06      TST      R2,#0x6
   \   0000000C   0xD010             BEQ.N    ??USB_GetDevSpeed_0
    407            {
    408              speed = USB_OTG_SPEED_HIGH;
    409            }
    410            else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
    411                     ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
   \   0000000E   0x6882             LDR      R2,[R0, #+8]
   \   00000010   0xF002 0x0206      AND      R2,R2,#0x6
   \   00000014   0x2A02             CMP      R2,#+2
   \   00000016   0xBF1D             ITTTE    NE 
   \   00000018   0x6882             LDRNE    R2,[R0, #+8]
   \   0000001A   0xF002 0x0206      ANDNE    R2,R2,#0x6
   \   0000001E   0x2A06             CMPNE    R2,#+6
   \   00000020   0x2103             MOVEQ    R1,#+3
    412            {
    413              speed = USB_OTG_SPEED_FULL;
   \   00000022   0xD005             BEQ.N    ??USB_GetDevSpeed_0
    414            }
    415            else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \   00000026   0xF000 0x0006      AND      R0,R0,#0x6
   \   0000002A   0x2804             CMP      R0,#+4
   \   0000002C   0xBF08             IT       EQ 
   \   0000002E   0x2102             MOVEQ    R1,#+2
    416            {
    417              speed = USB_OTG_SPEED_LOW;
    418            }
    419            
    420            return speed;
   \                     ??USB_GetDevSpeed_0: (+1)
   \   00000030   0x4608             MOV      R0,R1
   \   00000032   0x4770             BX       LR               ;; return
    421          }
    422          
    423          /**
    424            * @brief  Activate and configure an endpoint
    425            * @param  USBx : Selected device
    426            * @param  ep: pointer to endpoint structure
    427            * @retval HAL status
    428            */

   \                                 In section .text, align 2, keep-with-next
    429          HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    430          {
    431            if (ep->is_in == 1)
   \                     USB_ActivateEndpoint: (+1)
   \   00000000   0xF991 0xC000      LDRSB    R12,[R1, #+0]
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0xF500 0x6200      ADD      R2,R0,#+2048
   \   0000000A   0xFA03 0xF30C      LSL      R3,R3,R12
   \   0000000E   0xF891 0xC001      LDRB     R12,[R1, #+1]
   \   00000012   0xF1BC 0x0F01      CMP      R12,#+1
   \   00000016   0xF8D2 0xC01C      LDR      R12,[R2, #+28]
   \   0000001A   0xD11D             BNE.N    ??USB_ActivateEndpoint_0
    432            {
    433             USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
   \   0000001C   0xB29B             UXTH     R3,R3
   \   0000001E   0xEA43 0x030C      ORR      R3,R3,R12
   \   00000022   0x61D3             STR      R3,[R2, #+28]
    434             
    435              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
   \   00000024   0x780A             LDRB     R2,[R1, #+0]
   \   00000026   0xEB00 0x1042      ADD      R0,R0,R2, LSL #+5
   \   0000002A   0xF500 0x6010      ADD      R0,R0,#+2304
   \   0000002E   0x6803             LDR      R3,[R0, #+0]
   \   00000030   0x041B             LSLS     R3,R3,#+16
   \   00000032   0xD429             BMI.N    ??USB_ActivateEndpoint_1
    436              {
    437                USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    438                  ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \   00000034   0x6803             LDR      R3,[R0, #+0]
   \   00000036   0xF8D1 0xC008      LDR      R12,[R1, #+8]
   \   0000003A   0x78C9             LDRB     R1,[R1, #+3]
   \   0000003C   0xEA4F 0x5C4C      LSL      R12,R12,#+21
   \   00000040   0xEA4F 0x5C5C      LSR      R12,R12,#+21
   \   00000044   0xEA4C 0x4181      ORR      R1,R12,R1, LSL #+18
   \   00000048   0xEA41 0x5182      ORR      R1,R1,R2, LSL #+22
   \   0000004C   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000050   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000054   0x4319             ORRS     R1,R1,R3
   \   00000056   0xE016             B.N      ??USB_ActivateEndpoint_2
    439              } 
    440          
    441            }
    442            else
    443            {
    444               USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
   \                     ??USB_ActivateEndpoint_0: (+1)
   \   00000058   0xEA4C 0x4303      ORR      R3,R12,R3, LSL #+16
   \   0000005C   0x61D3             STR      R3,[R2, #+28]
    445               
    446              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
   \   0000005E   0x780A             LDRB     R2,[R1, #+0]
   \   00000060   0xEB00 0x1042      ADD      R0,R0,R2, LSL #+5
   \   00000064   0xF500 0x6030      ADD      R0,R0,#+2816
   \   00000068   0x6802             LDR      R2,[R0, #+0]
   \   0000006A   0x0412             LSLS     R2,R2,#+16
   \   0000006C   0xD40C             BMI.N    ??USB_ActivateEndpoint_1
    447              {
    448                USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    449                 (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
   \   0000006E   0x6802             LDR      R2,[R0, #+0]
   \   00000070   0x688B             LDR      R3,[R1, #+8]
   \   00000072   0x78C9             LDRB     R1,[R1, #+3]
   \   00000074   0x055B             LSLS     R3,R3,#+21
   \   00000076   0x0D5B             LSRS     R3,R3,#+21
   \   00000078   0xEA43 0x4181      ORR      R1,R3,R1, LSL #+18
   \   0000007C   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000080   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   00000084   0x4311             ORRS     R1,R1,R2
   \                     ??USB_ActivateEndpoint_2: (+1)
   \   00000086   0x6001             STR      R1,[R0, #+0]
    450              } 
    451            }
    452            return HAL_OK;
   \                     ??USB_ActivateEndpoint_1: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x4770             BX       LR               ;; return
    453          }
    454          /**
    455            * @brief  Activate and configure a dedicated endpoint
    456            * @param  USBx : Selected device
    457            * @param  ep: pointer to endpoint structure
    458            * @retval HAL status
    459            */

   \                                 In section .text, align 2, keep-with-next
    460          HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    461          {
   \                     USB_ActivateDedicatedEndpoint: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    462            static __IO uint32_t debug = 0;
    463            
    464            /* Read DEPCTLn register */
    465            if (ep->is_in == 1)
   \   00000002   0x784C             LDRB     R4,[R1, #+1]
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xEB00 0x1342      ADD      R3,R0,R2, LSL #+5
   \   0000000C   0xD12F             BNE.N    ??USB_ActivateDedicatedEndpoint_0
   \   0000000E   0xF503 0x6410      ADD      R4,R3,#+2304
   \   00000012   0x.... 0x....      LDR.W    R3,??DataTable11_1  ;; 0x10008000
   \   00000016   0x6825             LDR      R5,[R4, #+0]
   \   00000018   0x042D             LSLS     R5,R5,#+16
   \   0000001A   0xD40B             BMI.N    ??USB_ActivateDedicatedEndpoint_1
    466            {
    467              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0)
    468              {
    469                USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    470                  ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \   0000001C   0x6825             LDR      R5,[R4, #+0]
   \   0000001E   0x688E             LDR      R6,[R1, #+8]
   \   00000020   0x78CF             LDRB     R7,[R1, #+3]
   \   00000022   0x0576             LSLS     R6,R6,#+21
   \   00000024   0x0D76             LSRS     R6,R6,#+21
   \   00000026   0xEA46 0x4687      ORR      R6,R6,R7, LSL #+18
   \   0000002A   0xEA46 0x5282      ORR      R2,R6,R2, LSL #+22
   \   0000002E   0x431A             ORRS     R2,R3,R2
   \   00000030   0x432A             ORRS     R2,R2,R5
   \   00000032   0x6022             STR      R2,[R4, #+0]
    471              } 
    472              
    473              
    474              debug  |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    475                  ((ep->num) << 22 ) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
   \                     ??USB_ActivateDedicatedEndpoint_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable11_2
    476              
    477             USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num)));
   \   00000038   0xF500 0x6000      ADD      R0,R0,#+2048
   \   0000003C   0x6814             LDR      R4,[R2, #+0]
   \   0000003E   0x688D             LDR      R5,[R1, #+8]
   \   00000040   0x78CE             LDRB     R6,[R1, #+3]
   \   00000042   0x056D             LSLS     R5,R5,#+21
   \   00000044   0x0D6D             LSRS     R5,R5,#+21
   \   00000046   0xEA45 0x4586      ORR      R5,R5,R6, LSL #+18
   \   0000004A   0x780E             LDRB     R6,[R1, #+0]
   \   0000004C   0xEA45 0x5586      ORR      R5,R5,R6, LSL #+22
   \   00000050   0x432B             ORRS     R3,R3,R5
   \   00000052   0x4323             ORRS     R3,R3,R4
   \   00000054   0x6013             STR      R3,[R2, #+0]
   \   00000056   0x6BC2             LDR      R2,[R0, #+60]
   \   00000058   0xF991 0x1000      LDRSB    R1,[R1, #+0]
   \   0000005C   0x2301             MOVS     R3,#+1
   \   0000005E   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000062   0xB289             UXTH     R1,R1
   \   00000064   0x4311             ORRS     R1,R1,R2
   \   00000066   0x63C1             STR      R1,[R0, #+60]
    478            }
    479            else
    480            {
    481              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0)
    482              {
    483                USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    484                  ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP));
    485                
    486                debug = (uint32_t)(((uint32_t )USBx) + USB_OTG_OUT_ENDPOINT_BASE + (0)*USB_OTG_EP_REG_SIZE);
    487                debug = (uint32_t )&USBx_OUTEP(ep->num)->DOEPCTL;
    488                debug |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18 ) |\
    489                  ((ep->num) << 22 ) | (USB_OTG_DOEPCTL_USBAEP)); 
    490              } 
    491              
    492               USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16);
    493            }
    494          
    495            return HAL_OK;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBCF0             POP      {R4-R7}
   \   0000006C   0x4770             BX       LR
   \                     ??USB_ActivateDedicatedEndpoint_0: (+1)
   \   0000006E   0xF503 0x6330      ADD      R3,R3,#+2816
   \   00000072   0x681C             LDR      R4,[R3, #+0]
   \   00000074   0x0424             LSLS     R4,R4,#+16
   \   00000076   0xD425             BMI.N    ??USB_ActivateDedicatedEndpoint_2
   \   00000078   0x681C             LDR      R4,[R3, #+0]
   \   0000007A   0x688D             LDR      R5,[R1, #+8]
   \   0000007C   0x78CE             LDRB     R6,[R1, #+3]
   \   0000007E   0x056D             LSLS     R5,R5,#+21
   \   00000080   0x0D6D             LSRS     R5,R5,#+21
   \   00000082   0xEA45 0x4586      ORR      R5,R5,R6, LSL #+18
   \   00000086   0xEA45 0x5282      ORR      R2,R5,R2, LSL #+22
   \   0000008A   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   0000008E   0x4322             ORRS     R2,R2,R4
   \   00000090   0x601A             STR      R2,[R3, #+0]
   \   00000092   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   00000096   0xF500 0x6330      ADD      R3,R0,#+2816
   \   0000009A   0x6013             STR      R3,[R2, #+0]
   \   0000009C   0x780B             LDRB     R3,[R1, #+0]
   \   0000009E   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   000000A2   0xF503 0x6330      ADD      R3,R3,#+2816
   \   000000A6   0x6013             STR      R3,[R2, #+0]
   \   000000A8   0x6813             LDR      R3,[R2, #+0]
   \   000000AA   0x688C             LDR      R4,[R1, #+8]
   \   000000AC   0x78CD             LDRB     R5,[R1, #+3]
   \   000000AE   0x0564             LSLS     R4,R4,#+21
   \   000000B0   0x0D64             LSRS     R4,R4,#+21
   \   000000B2   0xEA44 0x4485      ORR      R4,R4,R5, LSL #+18
   \   000000B6   0x780D             LDRB     R5,[R1, #+0]
   \   000000B8   0xEA44 0x5485      ORR      R4,R4,R5, LSL #+22
   \   000000BC   0xF444 0x4400      ORR      R4,R4,#0x8000
   \   000000C0   0x4323             ORRS     R3,R4,R3
   \   000000C2   0x6013             STR      R3,[R2, #+0]
   \                     ??USB_ActivateDedicatedEndpoint_2: (+1)
   \   000000C4   0xF500 0x6000      ADD      R0,R0,#+2048
   \   000000C8   0x2301             MOVS     R3,#+1
   \   000000CA   0x6BC2             LDR      R2,[R0, #+60]
   \   000000CC   0xF991 0x1000      LDRSB    R1,[R1, #+0]
   \   000000D0   0xFA03 0xF101      LSL      R1,R3,R1
   \   000000D4   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   000000D8   0x63C1             STR      R1,[R0, #+60]
   \   000000DA   0x2000             MOVS     R0,#+0
   \   000000DC   0xBCF0             POP      {R4-R7}
   \   000000DE   0x4770             BX       LR               ;; return
    496          }

   \                                 In section .bss, align 4
   \                     ??debug:
   \   00000000                      DS8 4
    497          /**
    498            * @brief  De-activate and de-initialize an endpoint
    499            * @param  USBx : Selected device
    500            * @param  ep: pointer to endpoint structure
    501            * @retval HAL status
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    504          {
   \                     USB_DeactivateEndpoint: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    505            /* Read DEPCTLn register */
    506            if (ep->is_in == 1)
   \   00000002   0x784D             LDRB     R5,[R1, #+1]
   \   00000004   0xF991 0x4000      LDRSB    R4,[R1, #+0]
   \   00000008   0xF500 0x6200      ADD      R2,R0,#+2048
   \   0000000C   0x2301             MOVS     R3,#+1
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xFA03 0xF404      LSL      R4,R3,R4
   \   00000014   0x6BD5             LDR      R5,[R2, #+60]
   \   00000016   0xD111             BNE.N    ??USB_DeactivateEndpoint_0
    507            {
    508             USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
   \   00000018   0xB2A4             UXTH     R4,R4
   \   0000001A   0xEA25 0x0404      BIC      R4,R5,R4
   \   0000001E   0x63D4             STR      R4,[R2, #+60]
    509             USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));   
   \   00000020   0x69D4             LDR      R4,[R2, #+28]
   \   00000022   0xF991 0x5000      LDRSB    R5,[R1, #+0]
   \   00000026   0x40AB             LSLS     R3,R3,R5
   \   00000028   0xB29B             UXTH     R3,R3
   \   0000002A   0xEA24 0x0303      BIC      R3,R4,R3
   \   0000002E   0x61D3             STR      R3,[R2, #+28]
    510             USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000036   0xF500 0x6010      ADD      R0,R0,#+2304
   \   0000003A   0xE00E             B.N      ??USB_DeactivateEndpoint_1
    511            }
    512            else
    513            {
    514               USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
   \                     ??USB_DeactivateEndpoint_0: (+1)
   \   0000003C   0xEA25 0x4404      BIC      R4,R5,R4, LSL #+16
   \   00000040   0x63D4             STR      R4,[R2, #+60]
    515               USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));     
   \   00000042   0x69D4             LDR      R4,[R2, #+28]
   \   00000044   0xF991 0x5000      LDRSB    R5,[R1, #+0]
   \   00000048   0x40AB             LSLS     R3,R3,R5
   \   0000004A   0xEA24 0x4303      BIC      R3,R4,R3, LSL #+16
   \   0000004E   0x61D3             STR      R3,[R2, #+28]
    516               USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
   \   00000050   0x7809             LDRB     R1,[R1, #+0]
   \   00000052   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000056   0xF500 0x6030      ADD      R0,R0,#+2816
   \                     ??USB_DeactivateEndpoint_1: (+1)
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000060   0x6001             STR      R1,[R0, #+0]
    517            }
    518            return HAL_OK;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xBC30             POP      {R4,R5}
   \   00000066   0x4770             BX       LR               ;; return
    519          }
    520          
    521          /**
    522            * @brief  De-activate and de-initialize a dedicated endpoint
    523            * @param  USBx : Selected device
    524            * @param  ep: pointer to endpoint structure
    525            * @retval HAL status
    526            */

   \                                 In section .text, align 2, keep-with-next
    527          HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    528          {
    529            /* Read DEPCTLn register */
    530            if (ep->is_in == 1)
   \                     USB_DeactivateDedicatedEndpoint: (+1)
   \   00000000   0xF891 0xC001      LDRB     R12,[R1, #+1]
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0xEB00 0x1342      ADD      R3,R0,R2, LSL #+5
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000010   0xF1BC 0x0F01      CMP      R12,#+1
   \   00000014   0xD112             BNE.N    ??USB_DeactivateDedicatedEndpoint_0
   \   00000016   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000001A   0xF8D3 0xC000      LDR      R12,[R3, #+0]
   \   0000001E   0xF42C 0x4C00      BIC      R12,R12,#0x8000
   \   00000022   0xF8C3 0xC000      STR      R12,[R3, #+0]
    531            {
    532             USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
    533             USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1 << (ep->num))));
   \   00000026   0x69C3             LDR      R3,[R0, #+28]
   \   00000028   0xF991 0x1000      LDRSB    R1,[R1, #+0]
   \   0000002C   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000030   0xB289             UXTH     R1,R1
   \   00000032   0xEA23 0x0101      BIC      R1,R3,R1
   \   00000036   0x61C1             STR      R1,[R0, #+28]
    534            }
    535            else
    536            {
    537               USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP; 
    538               USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1 << (ep->num)) << 16));
    539            }
    540            return HAL_OK;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x4770             BX       LR
   \                     ??USB_DeactivateDedicatedEndpoint_0: (+1)
   \   0000003C   0xF503 0x6330      ADD      R3,R3,#+2816
   \   00000040   0xF8D3 0xC000      LDR      R12,[R3, #+0]
   \   00000044   0xF42C 0x4C00      BIC      R12,R12,#0x8000
   \   00000048   0xF8C3 0xC000      STR      R12,[R3, #+0]
   \   0000004C   0x69C3             LDR      R3,[R0, #+28]
   \   0000004E   0xF991 0x1000      LDRSB    R1,[R1, #+0]
   \   00000052   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000056   0xEA23 0x4101      BIC      R1,R3,R1, LSL #+16
   \   0000005A   0x61C1             STR      R1,[R0, #+28]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x4770             BX       LR               ;; return
    541          }
    542          
    543          /**
    544            * @brief  USB_EPStartXfer : setup and starts a transfer over an EP
    545            * @param  USBx : Selected device
    546            * @param  ep: pointer to endpoint structure
    547            * @param  dma: USB dma enabled or disabled 
    548            *          This parameter can be one of these values:
    549            *           0 : DMA feature not used 
    550            *           1 : DMA feature used  
    551            * @retval HAL status
    552            */

   \                                 In section .text, align 4, keep-with-next
    553          HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
    554          {
   \                     USB_EPStartXfer: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    555            uint16_t pktcnt = 0;
    556            
    557            /* IN endpoint */
    558            if (ep->is_in == 1)
   \   00000002   0x784D             LDRB     R5,[R1, #+1]
   \   00000004   0x780B             LDRB     R3,[R1, #+0]
   \   00000006   0x2D01             CMP      R5,#+1
   \   00000008   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable11_3  ;; 0xe007ffff
   \   00000010   0xF040 0x80A6      BNE.W    ??USB_EPStartXfer_0
   \   00000014   0x694D             LDR      R5,[R1, #+20]
   \   00000016   0xF504 0x6410      ADD      R4,R4,#+2304
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0x6925             LDR      R5,[R4, #+16]
   \   0000001E   0xD113             BNE.N    ??USB_EPStartXfer_1
    559            {
    560              /* Zero Length Packet? */
    561              if (ep->xfer_len == 0)
    562              {
    563                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   00000020   0x402B             ANDS     R3,R3,R5
   \   00000022   0x6123             STR      R3,[R4, #+16]
    564                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
   \   00000024   0x780B             LDRB     R3,[R1, #+0]
   \   00000026   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000002A   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000002E   0x691C             LDR      R4,[R3, #+16]
   \   00000030   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   00000034   0x611C             STR      R4,[R3, #+16]
    565                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
   \   00000036   0x780B             LDRB     R3,[R1, #+0]
   \   00000038   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000003C   0xF503 0x6310      ADD      R3,R3,#+2304
   \   00000040   0x691C             LDR      R4,[R3, #+16]
   \   00000042   0x0CE4             LSRS     R4,R4,#+19
   \   00000044   0x04E4             LSLS     R4,R4,#+19
   \   00000046   0xE03B             B.N      ??USB_EPStartXfer_2
    566              }
    567              else
    568              {
    569                /* Program the transfer size and packet count
    570                * as follows: xfersize = N * maxpacket +
    571                * short_packet pktcnt = N + (short_packet
    572                * exist ? 1 : 0)
    573                */
    574                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \                     ??USB_EPStartXfer_1: (+1)
   \   00000048   0x0CED             LSRS     R5,R5,#+19
   \   0000004A   0x04ED             LSLS     R5,R5,#+19
   \   0000004C   0x6125             STR      R5,[R4, #+16]
    575                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   0000004E   0x780C             LDRB     R4,[R1, #+0]
   \   00000050   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   00000054   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000058   0x6925             LDR      R5,[R4, #+16]
   \   0000005A   0x402B             ANDS     R3,R3,R5
   \   0000005C   0x6123             STR      R3,[R4, #+16]
    576                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket) << 19)) ;
   \   0000005E   0x780B             LDRB     R3,[R1, #+0]
   \   00000060   0x688C             LDR      R4,[R1, #+8]
   \   00000062   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000066   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000006A   0x691D             LDR      R5,[R3, #+16]
   \   0000006C   0x694E             LDR      R6,[R1, #+20]
   \   0000006E   0x19A6             ADDS     R6,R4,R6
   \   00000070   0x1E76             SUBS     R6,R6,#+1
   \   00000072   0xFBB6 0xF4F4      UDIV     R4,R6,R4
   \   00000076   0x.... 0x....      LDR.W    R6,??DataTable11_4  ;; 0x1ff80000
   \   0000007A   0xEA06 0x44C4      AND      R4,R6,R4, LSL #+19
   \   0000007E   0x432C             ORRS     R4,R4,R5
   \   00000080   0x611C             STR      R4,[R3, #+16]
    577                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
   \   00000082   0x780B             LDRB     R3,[R1, #+0]
   \   00000084   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000088   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000008C   0x691C             LDR      R4,[R3, #+16]
   \   0000008E   0x694D             LDR      R5,[R1, #+20]
   \   00000090   0x036D             LSLS     R5,R5,#+13
   \   00000092   0xEA54 0x3455      ORRS     R4,R4,R5, LSR #+13
   \   00000096   0x611C             STR      R4,[R3, #+16]
    578                
    579                if (ep->type == EP_TYPE_ISOC)
   \   00000098   0x78CB             LDRB     R3,[R1, #+3]
   \   0000009A   0x2B01             CMP      R3,#+1
   \   0000009C   0xD111             BNE.N    ??USB_EPStartXfer_3
    580                {
    581                  USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
   \   0000009E   0x780B             LDRB     R3,[R1, #+0]
   \   000000A0   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   000000A4   0xF503 0x6310      ADD      R3,R3,#+2304
   \   000000A8   0x691C             LDR      R4,[R3, #+16]
   \   000000AA   0xF024 0x44C0      BIC      R4,R4,#0x60000000
   \   000000AE   0x611C             STR      R4,[R3, #+16]
    582                  USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1 << 29)); 
   \   000000B0   0x780B             LDRB     R3,[R1, #+0]
   \   000000B2   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   000000B6   0xF503 0x6310      ADD      R3,R3,#+2304
   \   000000BA   0x691C             LDR      R4,[R3, #+16]
   \   000000BC   0xF044 0x5400      ORR      R4,R4,#0x20000000
   \                     ??USB_EPStartXfer_2: (+1)
   \   000000C0   0x611C             STR      R4,[R3, #+16]
    583                }       
    584              }
    585          
    586              if (dma == 1)
   \                     ??USB_EPStartXfer_3: (+1)
   \   000000C2   0x2A01             CMP      R2,#+1
   \   000000C4   0xD107             BNE.N    ??USB_EPStartXfer_4
    587              {
    588                USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
   \   000000C6   0x780B             LDRB     R3,[R1, #+0]
   \   000000C8   0x690C             LDR      R4,[R1, #+16]
   \   000000CA   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   000000CE   0xF503 0x6310      ADD      R3,R3,#+2304
   \   000000D2   0x615C             STR      R4,[R3, #+20]
   \   000000D4   0xE00D             B.N      ??USB_EPStartXfer_5
    589              }
    590              else
    591              {
    592                if (ep->type != EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_4: (+1)
   \   000000D6   0x78CB             LDRB     R3,[R1, #+3]
   \   000000D8   0x2B01             CMP      R3,#+1
   \   000000DA   0xD00D             BEQ.N    ??USB_EPStartXfer_6
    593                {
    594                  /* Enable the Tx FIFO Empty Interrupt for this EP */
    595                  if (ep->xfer_len > 0)
   \   000000DC   0x694B             LDR      R3,[R1, #+20]
   \   000000DE   0xB143             CBZ.N    R3,??USB_EPStartXfer_5
    596                  {
    597                    USBx_DEVICE->DIEPEMPMSK |= 1 << ep->num;
   \   000000E0   0xF500 0x6300      ADD      R3,R0,#+2048
   \   000000E4   0x2501             MOVS     R5,#+1
   \   000000E6   0x6B5C             LDR      R4,[R3, #+52]
   \   000000E8   0xF991 0x6000      LDRSB    R6,[R1, #+0]
   \   000000EC   0x40B5             LSLS     R5,R5,R6
   \   000000EE   0x432C             ORRS     R4,R5,R4
   \   000000F0   0x635C             STR      R4,[R3, #+52]
    598                  }
    599                }
    600              }
    601          
    602              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_5: (+1)
   \   000000F2   0x78CB             LDRB     R3,[R1, #+3]
   \   000000F4   0x2B01             CMP      R3,#+1
   \   000000F6   0xD10F             BNE.N    ??USB_EPStartXfer_7
    603              {
    604                if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
   \                     ??USB_EPStartXfer_6: (+1)
   \   000000F8   0x780B             LDRB     R3,[R1, #+0]
   \   000000FA   0xF500 0x6400      ADD      R4,R0,#+2048
   \   000000FE   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000102   0x68A4             LDR      R4,[R4, #+8]
   \   00000104   0xF503 0x6310      ADD      R3,R3,#+2304
   \   00000108   0x05E4             LSLS     R4,R4,#+23
   \   0000010A   0x681C             LDR      R4,[R3, #+0]
   \   0000010C   0xBF54             ITE      PL 
   \   0000010E   0xF044 0x5400      ORRPL    R4,R4,#0x20000000
   \   00000112   0xF044 0x5480      ORRMI    R4,R4,#0x10000000
    605                {
    606                  USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
    607                }
    608                else
    609                {
    610                  USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
   \   00000116   0x601C             STR      R4,[R3, #+0]
    611                }
    612              } 
    613              
    614              /* EP enable, IN data in FIFO */
    615              USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
   \                     ??USB_EPStartXfer_7: (+1)
   \   00000118   0x780B             LDRB     R3,[R1, #+0]
   \   0000011A   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000011E   0xF503 0x6310      ADD      R3,R3,#+2304
   \   00000122   0x681C             LDR      R4,[R3, #+0]
   \   00000124   0xF044 0x4404      ORR      R4,R4,#0x84000000
   \   00000128   0x601C             STR      R4,[R3, #+0]
    616              
    617              if (ep->type == EP_TYPE_ISOC)
   \   0000012A   0x78CB             LDRB     R3,[R1, #+3]
   \   0000012C   0x2B01             CMP      R3,#+1
   \   0000012E   0xBF02             ITTT     EQ 
   \   00000130   0x780B             LDRBEQ   R3,[R1, #+0]
   \   00000132   0x68CC             LDREQ    R4,[R1, #+12]
   \   00000134   0x2A00             CMPEQ    R2,#+0
    618              {
    619                USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
   \   00000136   0xD174             BNE.N    ??USB_EPStartXfer_8
   \   00000138   0x8A89             LDRH     R1,[R1, #+20]
   \   0000013A   0x1CC9             ADDS     R1,R1,#+3
   \   0000013C   0x104A             ASRS     R2,R1,#+1
   \   0000013E   0xEB01 0x7192      ADD      R1,R1,R2, LSR #+30
   \   00000142   0x1089             ASRS     R1,R1,#+2
   \   00000144   0xF000 0x806D      BEQ.W    ??USB_EPStartXfer_8
   \   00000148   0xEB00 0x3003      ADD      R0,R0,R3, LSL #+12
   \   0000014C   0xF500 0x5080      ADD      R0,R0,#+4096
   \                     ??USB_EPStartXfer_9: (+1)
   \   00000150   0xF854 0x2B04      LDR      R2,[R4], #+4
   \   00000154   0x1E49             SUBS     R1,R1,#+1
   \   00000156   0x6002             STR      R2,[R0, #+0]
   \   00000158   0xD1FA             BNE.N    ??USB_EPStartXfer_9
    620              }    
    621            }
    622            else /* OUT endpoint */
    623            {
    624              /* Program the transfer size and packet count as follows:
    625              * pktcnt = N
    626              * xfersize = N * maxpacket
    627              */  
    628              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
    629              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
    630                
    631              if (ep->xfer_len == 0)
    632              {
    633                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
    634                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;      
    635              }
    636              else
    637              {
    638                pktcnt = (ep->xfer_len + ep->maxpacket -1)/ ep->maxpacket; 
    639                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19));
    640                USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt)); 
    641              }
    642          
    643              if (dma == 1)
    644              {
    645                USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
    646              }
    647              
    648              if (ep->type == EP_TYPE_ISOC)
    649              {
    650                if ((USBx_DEVICE->DSTS & ( 1 << 8 )) == 0)
    651                {
    652                  USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
    653                }
    654                else
    655                {
    656                  USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
    657                }
    658              }
    659              /* EP enable */
    660              USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
    661            }
    662            return HAL_OK;
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0xBC70             POP      {R4-R6}
   \   0000015E   0x4770             BX       LR
   \                     ??USB_EPStartXfer_0: (+1)
   \   00000160   0xF504 0x6430      ADD      R4,R4,#+2816
   \   00000164   0x6925             LDR      R5,[R4, #+16]
   \   00000166   0x0CED             LSRS     R5,R5,#+19
   \   00000168   0x04ED             LSLS     R5,R5,#+19
   \   0000016A   0x6125             STR      R5,[R4, #+16]
   \   0000016C   0x780C             LDRB     R4,[R1, #+0]
   \   0000016E   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   00000172   0xF504 0x6430      ADD      R4,R4,#+2816
   \   00000176   0x6925             LDR      R5,[R4, #+16]
   \   00000178   0x402B             ANDS     R3,R3,R5
   \   0000017A   0x6123             STR      R3,[R4, #+16]
   \   0000017C   0x780B             LDRB     R3,[R1, #+0]
   \   0000017E   0x694D             LDR      R5,[R1, #+20]
   \   00000180   0x688C             LDR      R4,[R1, #+8]
   \   00000182   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000186   0xF503 0x6330      ADD      R3,R3,#+2816
   \   0000018A   0xB96D             CBNZ.N   R5,??USB_EPStartXfer_10
   \   0000018C   0x691D             LDR      R5,[R3, #+16]
   \   0000018E   0x0364             LSLS     R4,R4,#+13
   \   00000190   0xEA55 0x3454      ORRS     R4,R5,R4, LSR #+13
   \   00000194   0x611C             STR      R4,[R3, #+16]
   \   00000196   0x780B             LDRB     R3,[R1, #+0]
   \   00000198   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000019C   0xF503 0x6330      ADD      R3,R3,#+2816
   \   000001A0   0x691C             LDR      R4,[R3, #+16]
   \   000001A2   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   000001A6   0xE016             B.N      ??USB_EPStartXfer_11
   \                     ??USB_EPStartXfer_10: (+1)
   \   000001A8   0x1965             ADDS     R5,R4,R5
   \   000001AA   0x1E6D             SUBS     R5,R5,#+1
   \   000001AC   0xFBB5 0xF4F4      UDIV     R4,R5,R4
   \   000001B0   0xB2A4             UXTH     R4,R4
   \   000001B2   0x.... 0x....      LDR.W    R6,??DataTable11_4  ;; 0x1ff80000
   \   000001B6   0x691D             LDR      R5,[R3, #+16]
   \   000001B8   0xEA06 0x46C4      AND      R6,R6,R4, LSL #+19
   \   000001BC   0x4335             ORRS     R5,R6,R5
   \   000001BE   0x611D             STR      R5,[R3, #+16]
   \   000001C0   0x780B             LDRB     R3,[R1, #+0]
   \   000001C2   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   000001C6   0xF503 0x6330      ADD      R3,R3,#+2816
   \   000001CA   0x691D             LDR      R5,[R3, #+16]
   \   000001CC   0x688E             LDR      R6,[R1, #+8]
   \   000001CE   0x4374             MULS     R4,R4,R6
   \   000001D0   0x0364             LSLS     R4,R4,#+13
   \   000001D2   0xEA55 0x3454      ORRS     R4,R5,R4, LSR #+13
   \                     ??USB_EPStartXfer_11: (+1)
   \   000001D6   0x2A01             CMP      R2,#+1
   \   000001D8   0x611C             STR      R4,[R3, #+16]
   \   000001DA   0xD106             BNE.N    ??USB_EPStartXfer_12
   \   000001DC   0x780A             LDRB     R2,[R1, #+0]
   \   000001DE   0x68CB             LDR      R3,[R1, #+12]
   \   000001E0   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   000001E4   0xF502 0x6230      ADD      R2,R2,#+2816
   \   000001E8   0x6153             STR      R3,[R2, #+20]
   \                     ??USB_EPStartXfer_12: (+1)
   \   000001EA   0x78CA             LDRB     R2,[R1, #+3]
   \   000001EC   0x2A01             CMP      R2,#+1
   \   000001EE   0xD10F             BNE.N    ??USB_EPStartXfer_13
   \   000001F0   0x780A             LDRB     R2,[R1, #+0]
   \   000001F2   0xF500 0x6300      ADD      R3,R0,#+2048
   \   000001F6   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   000001FA   0x689B             LDR      R3,[R3, #+8]
   \   000001FC   0xF502 0x6230      ADD      R2,R2,#+2816
   \   00000200   0x05DB             LSLS     R3,R3,#+23
   \   00000202   0x6813             LDR      R3,[R2, #+0]
   \   00000204   0xBF54             ITE      PL 
   \   00000206   0xF043 0x5300      ORRPL    R3,R3,#0x20000000
   \   0000020A   0xF043 0x5380      ORRMI    R3,R3,#0x10000000
   \   0000020E   0x6013             STR      R3,[R2, #+0]
   \                     ??USB_EPStartXfer_13: (+1)
   \   00000210   0x7809             LDRB     R1,[R1, #+0]
   \   00000212   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000216   0xF500 0x6030      ADD      R0,R0,#+2816
   \   0000021A   0x6801             LDR      R1,[R0, #+0]
   \   0000021C   0xF041 0x4104      ORR      R1,R1,#0x84000000
   \   00000220   0x6001             STR      R1,[R0, #+0]
   \                     ??USB_EPStartXfer_8: (+1)
   \   00000222   0x2000             MOVS     R0,#+0
   \   00000224   0xBC70             POP      {R4-R6}
   \   00000226   0x4770             BX       LR               ;; return
    663          }
    664          
    665          /**
    666            * @brief  USB_EP0StartXfer : setup and starts a transfer over the EP  0
    667            * @param  USBx : Selected device
    668            * @param  ep: pointer to endpoint structure
    669            * @param  dma: USB dma enabled or disabled 
    670            *          This parameter can be one of these values:
    671            *           0 : DMA feature not used 
    672            *           1 : DMA feature used  
    673            * @retval HAL status
    674            */

   \                                 In section .text, align 2, keep-with-next
    675          HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
    676          {
   \                     USB_EP0StartXfer: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    677            /* IN endpoint */
    678            if (ep->is_in == 1)
   \   00000002   0x784D             LDRB     R5,[R1, #+1]
   \   00000004   0x780B             LDRB     R3,[R1, #+0]
   \   00000006   0x2D01             CMP      R5,#+1
   \   00000008   0xEB00 0x1443      ADD      R4,R0,R3, LSL #+5
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable11_3  ;; 0xe007ffff
   \   00000010   0xD15E             BNE.N    ??USB_EP0StartXfer_0
   \   00000012   0x694D             LDR      R5,[R1, #+20]
   \   00000014   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0x6925             LDR      R5,[R4, #+16]
   \   0000001C   0xD113             BNE.N    ??USB_EP0StartXfer_1
    679            {
    680              /* Zero Length Packet? */
    681              if (ep->xfer_len == 0)
    682              {
    683                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   0000001E   0x402B             ANDS     R3,R3,R5
   \   00000020   0x6123             STR      R3,[R4, #+16]
    684                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
   \   00000022   0x780B             LDRB     R3,[R1, #+0]
   \   00000024   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000028   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000002C   0x691C             LDR      R4,[R3, #+16]
   \   0000002E   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   00000032   0x611C             STR      R4,[R3, #+16]
    685                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
   \   00000034   0x780B             LDRB     R3,[R1, #+0]
   \   00000036   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000003A   0xF503 0x6310      ADD      R3,R3,#+2304
   \   0000003E   0x691C             LDR      R4,[R3, #+16]
   \   00000040   0x0CE4             LSRS     R4,R4,#+19
   \   00000042   0x04E4             LSLS     R4,R4,#+19
   \   00000044   0xE023             B.N      ??USB_EP0StartXfer_2
    686              }
    687              else
    688              {
    689                /* Program the transfer size and packet count
    690                * as follows: xfersize = N * maxpacket +
    691                * short_packet pktcnt = N + (short_packet
    692                * exist ? 1 : 0)
    693                */
    694                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \                     ??USB_EP0StartXfer_1: (+1)
   \   00000046   0x0CED             LSRS     R5,R5,#+19
   \   00000048   0x04ED             LSLS     R5,R5,#+19
   \   0000004A   0x6125             STR      R5,[R4, #+16]
    695                USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
   \   0000004C   0x780C             LDRB     R4,[R1, #+0]
   \   0000004E   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   00000052   0xF504 0x6410      ADD      R4,R4,#+2304
   \   00000056   0x6925             LDR      R5,[R4, #+16]
   \   00000058   0x402B             ANDS     R3,R3,R5
   \   0000005A   0x6123             STR      R3,[R4, #+16]
    696                
    697                if(ep->xfer_len > ep->maxpacket)
   \   0000005C   0x688B             LDR      R3,[R1, #+8]
   \   0000005E   0x694C             LDR      R4,[R1, #+20]
   \   00000060   0x42A3             CMP      R3,R4
   \   00000062   0xBF88             IT       HI 
   \   00000064   0x4623             MOVHI    R3,R4
   \   00000066   0x614B             STR      R3,[R1, #+20]
    698                {
    699                  ep->xfer_len = ep->maxpacket;
    700                }
    701                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1 << 19)) ;
   \   00000068   0x780B             LDRB     R3,[R1, #+0]
   \   0000006A   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000006E   0xF503 0x6310      ADD      R3,R3,#+2304
   \   00000072   0x691C             LDR      R4,[R3, #+16]
   \   00000074   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   00000078   0x611C             STR      R4,[R3, #+16]
    702                USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
   \   0000007A   0x780B             LDRB     R3,[R1, #+0]
   \   0000007C   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   00000080   0xF503 0x6310      ADD      R3,R3,#+2304
   \   00000084   0x691C             LDR      R4,[R3, #+16]
   \   00000086   0x694D             LDR      R5,[R1, #+20]
   \   00000088   0x036D             LSLS     R5,R5,#+13
   \   0000008A   0xEA54 0x3455      ORRS     R4,R4,R5, LSR #+13
    703              
    704              }
    705              
    706              if (dma == 1)
   \                     ??USB_EP0StartXfer_2: (+1)
   \   0000008E   0x2A01             CMP      R2,#+1
   \   00000090   0x611C             STR      R4,[R3, #+16]
   \   00000092   0xD10C             BNE.N    ??USB_EP0StartXfer_3
    707              {
    708                USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
   \   00000094   0x780A             LDRB     R2,[R1, #+0]
   \   00000096   0x690B             LDR      R3,[R1, #+16]
   \   00000098   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   0000009C   0xF502 0x6210      ADD      R2,R2,#+2304
   \   000000A0   0x6153             STR      R3,[R2, #+20]
    709              }
    710              else
    711              {
    712                /* Enable the Tx FIFO Empty Interrupt for this EP */
    713                if (ep->xfer_len > 0)
    714                {
    715                  USBx_DEVICE->DIEPEMPMSK |= 1 << (ep->num);
    716                }
    717              }
    718              
    719              /* EP enable, IN data in FIFO */
    720              USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
   \   000000A2   0x7809             LDRB     R1,[R1, #+0]
   \   000000A4   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   000000A8   0xF500 0x6010      ADD      R0,R0,#+2304
   \   000000AC   0xE044             B.N      ??USB_EP0StartXfer_4
   \                     ??USB_EP0StartXfer_3: (+1)
   \   000000AE   0x694A             LDR      R2,[R1, #+20]
   \   000000B0   0xB142             CBZ.N    R2,??USB_EP0StartXfer_5
   \   000000B2   0xF500 0x6200      ADD      R2,R0,#+2048
   \   000000B6   0x2401             MOVS     R4,#+1
   \   000000B8   0x6B53             LDR      R3,[R2, #+52]
   \   000000BA   0xF991 0x5000      LDRSB    R5,[R1, #+0]
   \   000000BE   0x40AC             LSLS     R4,R4,R5
   \   000000C0   0x4323             ORRS     R3,R4,R3
   \   000000C2   0x6353             STR      R3,[R2, #+52]
   \                     ??USB_EP0StartXfer_5: (+1)
   \   000000C4   0x7809             LDRB     R1,[R1, #+0]
   \   000000C6   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   000000CA   0xF500 0x6010      ADD      R0,R0,#+2304
   \   000000CE   0xE033             B.N      ??USB_EP0StartXfer_4
    721            }
   \                     ??USB_EP0StartXfer_0: (+1)
   \   000000D0   0xF504 0x6430      ADD      R4,R4,#+2816
   \   000000D4   0x6925             LDR      R5,[R4, #+16]
   \   000000D6   0x0CED             LSRS     R5,R5,#+19
   \   000000D8   0x04ED             LSLS     R5,R5,#+19
   \   000000DA   0x6125             STR      R5,[R4, #+16]
    722            else /* OUT endpoint */
    723            {
    724              /* Program the transfer size and packet count as follows:
    725              * pktcnt = N
    726              * xfersize = N * maxpacket
    727              */
    728              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
    729              USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
   \   000000DC   0x780C             LDRB     R4,[R1, #+0]
   \   000000DE   0xEB00 0x1444      ADD      R4,R0,R4, LSL #+5
   \   000000E2   0xF504 0x6430      ADD      R4,R4,#+2816
   \   000000E6   0x6925             LDR      R5,[R4, #+16]
   \   000000E8   0x402B             ANDS     R3,R3,R5
   \   000000EA   0x6123             STR      R3,[R4, #+16]
    730                
    731              if (ep->xfer_len > 0)
   \   000000EC   0x694B             LDR      R3,[R1, #+20]
   \   000000EE   0xB10B             CBZ.N    R3,??USB_EP0StartXfer_6
    732              {
    733                ep->xfer_len = ep->maxpacket;
   \   000000F0   0x688B             LDR      R3,[R1, #+8]
   \   000000F2   0x614B             STR      R3,[R1, #+20]
    734              }
    735              
    736              USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19));
   \                     ??USB_EP0StartXfer_6: (+1)
   \   000000F4   0x780B             LDRB     R3,[R1, #+0]
   \   000000F6   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   000000FA   0xF503 0x6330      ADD      R3,R3,#+2816
   \   000000FE   0x691C             LDR      R4,[R3, #+16]
   \   00000100   0xF444 0x2400      ORR      R4,R4,#0x80000
   \   00000104   0x611C             STR      R4,[R3, #+16]
    737              USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
   \   00000106   0x780B             LDRB     R3,[R1, #+0]
   \   00000108   0xEB00 0x1343      ADD      R3,R0,R3, LSL #+5
   \   0000010C   0xF503 0x6330      ADD      R3,R3,#+2816
   \   00000110   0x691C             LDR      R4,[R3, #+16]
   \   00000112   0x688D             LDR      R5,[R1, #+8]
   \   00000114   0x036D             LSLS     R5,R5,#+13
   \   00000116   0xEA54 0x3455      ORRS     R4,R4,R5, LSR #+13
    738              
    739          
    740              if (dma == 1)
   \   0000011A   0x2A01             CMP      R2,#+1
   \   0000011C   0x611C             STR      R4,[R3, #+16]
   \   0000011E   0xD106             BNE.N    ??USB_EP0StartXfer_7
    741              {
    742                USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
   \   00000120   0x780A             LDRB     R2,[R1, #+0]
   \   00000122   0x68CB             LDR      R3,[R1, #+12]
   \   00000124   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   00000128   0xF502 0x6230      ADD      R2,R2,#+2816
   \   0000012C   0x6153             STR      R3,[R2, #+20]
    743              }
    744              
    745              /* EP enable */
    746              USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
   \                     ??USB_EP0StartXfer_7: (+1)
   \   0000012E   0x7809             LDRB     R1,[R1, #+0]
   \   00000130   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000134   0xF500 0x6030      ADD      R0,R0,#+2816
   \                     ??USB_EP0StartXfer_4: (+1)
   \   00000138   0x6801             LDR      R1,[R0, #+0]
   \   0000013A   0xF041 0x4104      ORR      R1,R1,#0x84000000
   \   0000013E   0x6001             STR      R1,[R0, #+0]
    747            }
    748            return HAL_OK;
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xBC30             POP      {R4,R5}
   \   00000144   0x4770             BX       LR               ;; return
    749          }
    750          
    751          /**
    752            * @brief  USB_WritePacket : Writes a packet into the Tx FIFO associated 
    753            *         with the EP/channel
    754            * @param  USBx : Selected device           
    755            * @param  src :  pointer to source buffer
    756            * @param  ch_ep_num : endpoint or host channel number
    757            * @param  len : Number of bytes to write
    758            * @param  dma: USB dma enabled or disabled 
    759            *          This parameter can be one of these values:
    760            *           0 : DMA feature not used 
    761            *           1 : DMA feature used  
    762            * @retval HAL status
    763            */

   \                                 In section .text, align 4, keep-with-next
    764          HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
    765          {
   \                     USB_WritePacket: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    766            uint32_t count32b= 0 , i= 0;
    767            
    768            if (dma == 0)
   \   00000002   0xF8DD 0xC004      LDR      R12,[SP, #+4]
   \   00000006   0xF1BC 0x0F00      CMP      R12,#+0
   \   0000000A   0xD110             BNE.N    ??USB_WritePacket_0
    769            {
    770              count32b =  (len + 3) / 4;
   \   0000000C   0x1CDB             ADDS     R3,R3,#+3
   \   0000000E   0xEA4F 0x0C63      ASR      R12,R3,#+1
   \   00000012   0xEB03 0x739C      ADD      R3,R3,R12, LSR #+30
   \   00000016   0x109B             ASRS     R3,R3,#+2
    771              for (i = 0; i < count32b; i++, src += 4)
   \   00000018   0xF000 0x8009      BEQ.W    ??USB_WritePacket_0
   \   0000001C   0xEB00 0x3002      ADD      R0,R0,R2, LSL #+12
   \   00000020   0xF500 0x5080      ADD      R0,R0,#+4096
    772              {
    773                USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
   \                     ??USB_WritePacket_1: (+1)
   \   00000024   0xF851 0x2B04      LDR      R2,[R1], #+4
    774              }
   \   00000028   0x1E5B             SUBS     R3,R3,#+1
   \   0000002A   0x6002             STR      R2,[R0, #+0]
   \   0000002C   0xD1FA             BNE.N    ??USB_WritePacket_1
    775            }
    776            return HAL_OK;
   \                     ??USB_WritePacket_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xB001             ADD      SP,SP,#+4
   \   00000032   0x4770             BX       LR               ;; return
    777          }
    778          
    779          /**
    780            * @brief  USB_ReadPacket : read a packet from the Tx FIFO associated 
    781            *         with the EP/channel
    782            * @param  USBx : Selected device  
    783            * @param  src : source pointer
    784            * @param  ch_ep_num : endpoint or host channel number
    785            * @param  len : Number of bytes to read
    786            * @param  dma: USB dma enabled or disabled 
    787            *          This parameter can be one of these values:
    788            *           0 : DMA feature not used 
    789            *           1 : DMA feature used  
    790            * @retval pointer to destination buffer
    791            */

   \                                 In section .text, align 2, keep-with-next
    792          void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
    793          {
    794            uint32_t i=0;
    795            uint32_t count32b = (len + 3) / 4;
   \                     USB_ReadPacket: (+1)
   \   00000000   0x1CD2             ADDS     R2,R2,#+3
   \   00000002   0x1053             ASRS     R3,R2,#+1
   \   00000004   0xEB02 0x7293      ADD      R2,R2,R3, LSR #+30
   \   00000008   0x1092             ASRS     R2,R2,#+2
    796            
    797            for ( i = 0; i < count32b; i++, dest += 4 )
   \   0000000A   0xD006             BEQ.N    ??USB_ReadPacket_0
   \   0000000C   0xF500 0x5080      ADD      R0,R0,#+4096
    798            {
    799              *(__packed uint32_t *)dest = USBx_DFIFO(0);
   \                     ??USB_ReadPacket_1: (+1)
   \   00000010   0x6803             LDR      R3,[R0, #+0]
    800              
    801            }
   \   00000012   0x1E52             SUBS     R2,R2,#+1
   \   00000014   0xF841 0x3B04      STR      R3,[R1], #+4
   \   00000018   0xD1FA             BNE.N    ??USB_ReadPacket_1
    802            return ((void *)dest);
   \                     ??USB_ReadPacket_0: (+1)
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
    803          }
    804          
    805          /**
    806            * @brief  USB_EPSetStall : set a stall condition over an EP
    807            * @param  USBx : Selected device
    808            * @param  ep: pointer to endpoint structure   
    809            * @retval HAL status
    810            */

   \                                 In section .text, align 2, keep-with-next
    811          HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
    812          {
    813            if (ep->is_in == 1)
   \                     USB_EPSetStall: (+1)
   \   00000000   0x784B             LDRB     R3,[R1, #+1]
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   0000000A   0xD10E             BNE.N    ??USB_EPSetStall_0
   \   0000000C   0xF502 0x6210      ADD      R2,R2,#+2304
   \   00000010   0x6813             LDR      R3,[R2, #+0]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD403             BMI.N    ??USB_EPSetStall_1
    814            {
    815              if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0)
    816              {
    817                USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0xF023 0x4380      BIC      R3,R3,#0x40000000
   \   0000001C   0x6013             STR      R3,[R2, #+0]
    818              } 
    819              USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
   \                     ??USB_EPSetStall_1: (+1)
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000024   0xF500 0x6010      ADD      R0,R0,#+2304
   \   00000028   0xE00D             B.N      ??USB_EPSetStall_2
    820            }
   \                     ??USB_EPSetStall_0: (+1)
   \   0000002A   0xF502 0x6230      ADD      R2,R2,#+2816
   \   0000002E   0x6813             LDR      R3,[R2, #+0]
   \   00000030   0x2B00             CMP      R3,#+0
   \   00000032   0xD403             BMI.N    ??USB_EPSetStall_3
    821            else
    822            {
    823              if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0)
    824              {
    825                USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
   \   00000034   0x6813             LDR      R3,[R2, #+0]
   \   00000036   0xF023 0x4380      BIC      R3,R3,#0x40000000
   \   0000003A   0x6013             STR      R3,[R2, #+0]
    826              } 
    827              USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
   \                     ??USB_EPSetStall_3: (+1)
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000042   0xF500 0x6030      ADD      R0,R0,#+2816
   \                     ??USB_EPSetStall_2: (+1)
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    828            }
    829            return HAL_OK;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x4770             BX       LR               ;; return
    830          }
    831          
    832          
    833          /**
    834            * @brief  USB_EPClearStall : Clear a stall condition over an EP
    835            * @param  USBx : Selected device
    836            * @param  ep: pointer to endpoint structure   
    837            * @retval HAL status
    838            */

   \                                 In section .text, align 2, keep-with-next
    839          HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    840          {
    841            if (ep->is_in == 1)
   \                     USB_EPClearStall: (+1)
   \   00000000   0x784B             LDRB     R3,[R1, #+1]
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x2B01             CMP      R3,#+1
   \   00000006   0xEB00 0x1242      ADD      R2,R0,R2, LSL #+5
   \   0000000A   0xD110             BNE.N    ??USB_EPClearStall_0
   \   0000000C   0xF502 0x6210      ADD      R2,R2,#+2304
   \   00000010   0x6813             LDR      R3,[R2, #+0]
   \   00000012   0xF423 0x1300      BIC      R3,R3,#0x200000
   \   00000016   0x6013             STR      R3,[R2, #+0]
    842            {
    843              USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
    844              if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   \   00000018   0x78CA             LDRB     R2,[R1, #+3]
   \   0000001A   0x2A03             CMP      R2,#+3
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x2A02             CMPNE    R2,#+2
   \   00000020   0xD119             BNE.N    ??USB_EPClearStall_1
    845              {
    846                 USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000028   0xF500 0x6010      ADD      R0,R0,#+2304
   \   0000002C   0xE00F             B.N      ??USB_EPClearStall_2
    847              }    
    848            }
   \                     ??USB_EPClearStall_0: (+1)
   \   0000002E   0xF502 0x6230      ADD      R2,R2,#+2816
   \   00000032   0x6813             LDR      R3,[R2, #+0]
   \   00000034   0xF423 0x1300      BIC      R3,R3,#0x200000
   \   00000038   0x6013             STR      R3,[R2, #+0]
    849            else
    850            {
    851              USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
    852              if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
   \   0000003A   0x78CA             LDRB     R2,[R1, #+3]
   \   0000003C   0x2A03             CMP      R2,#+3
   \   0000003E   0xBF18             IT       NE 
   \   00000040   0x2A02             CMPNE    R2,#+2
   \   00000042   0xD108             BNE.N    ??USB_EPClearStall_1
    853              {
    854                USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   0000004A   0xF500 0x6030      ADD      R0,R0,#+2816
   \                     ??USB_EPClearStall_2: (+1)
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000054   0x6001             STR      R1,[R0, #+0]
    855              }    
    856            }
    857            return HAL_OK;
   \                     ??USB_EPClearStall_1: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4770             BX       LR               ;; return
    858          }
    859          
    860          /**
    861            * @brief  USB_StopDevice : Stop the usb device mode
    862            * @param  USBx : Selected device
    863            * @retval HAL status
    864            */

   \                                 In section .text, align 2, keep-with-next
    865          HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
    866          {
   \                     USB_StopDevice: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    867            uint32_t i;
    868            
    869            /* Clear Pending interrupt */
    870            for (i = 0; i < 15 ; i++)
   \   00000002   0xF500 0x6210      ADD      R2,R0,#+2304
   \   00000006   0x230F             MOVS     R3,#+15
   \   00000008   0x24FF             MOVS     R4,#+255
    871            {
    872              USBx_INEP(i)->DIEPINT  = 0xFF;
   \                     ??USB_StopDevice_0: (+1)
   \   0000000A   0x6094             STR      R4,[R2, #+8]
    873              USBx_OUTEP(i)->DOEPINT  = 0xFF;
   \   0000000C   0xF502 0x7500      ADD      R5,R2,#+512
    874            }
   \   00000010   0x3220             ADDS     R2,R2,#+32
   \   00000012   0x1E5B             SUBS     R3,R3,#+1
   \   00000014   0x60AC             STR      R4,[R5, #+8]
   \   00000016   0xD1F8             BNE.N    ??USB_StopDevice_0
    875            USBx_DEVICE->DAINT = 0xFFFFFFFF;
   \   00000018   0xF500 0x6100      ADD      R1,R0,#+2048
   \   0000001C   0xF04F 0x32FF      MOV      R2,#-1
   \   00000020   0x618A             STR      R2,[R1, #+24]
    876            
    877            /* Clear interrupt masks */
    878            USBx_DEVICE->DIEPMSK  = 0;
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x610A             STR      R2,[R1, #+16]
    879            USBx_DEVICE->DOEPMSK  = 0;
   \   00000026   0x614A             STR      R2,[R1, #+20]
    880            USBx_DEVICE->DAINTMSK = 0;
   \   00000028   0x61CA             STR      R2,[R1, #+28]
    881            
    882            /* Flush the FIFO */
    883            USB_FlushRxFifo(USBx);
   \   0000002A   0x2110             MOVS     R1,#+16
   \   0000002C   0x6101             STR      R1,[R0, #+16]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0x30d41
   \   00000032   0x460A             MOV      R2,R1
   \                     ??USB_StopDevice_1: (+1)
   \   00000034   0x1E52             SUBS     R2,R2,#+1
   \   00000036   0xD002             BEQ.N    ??USB_StopDevice_2
   \   00000038   0x6903             LDR      R3,[R0, #+16]
   \   0000003A   0x06DB             LSLS     R3,R3,#+27
   \   0000003C   0xD4FA             BMI.N    ??USB_StopDevice_1
    884            USB_FlushTxFifo(USBx ,  0x10 );  
   \                     ??USB_StopDevice_2: (+1)
   \   0000003E   0xF44F 0x6284      MOV      R2,#+1056
   \   00000042   0x6102             STR      R2,[R0, #+16]
   \                     ??USB_StopDevice_3: (+1)
   \   00000044   0x1E49             SUBS     R1,R1,#+1
   \   00000046   0xD002             BEQ.N    ??USB_StopDevice_4
   \   00000048   0x6902             LDR      R2,[R0, #+16]
   \   0000004A   0x0692             LSLS     R2,R2,#+26
   \   0000004C   0xD4FA             BMI.N    ??USB_StopDevice_3
    885            
    886            return HAL_OK;
   \                     ??USB_StopDevice_4: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBC30             POP      {R4,R5}
   \   00000052   0x4770             BX       LR               ;; return
    887          }
    888          
    889          /**
    890            * @brief  USB_SetDevAddress : Stop the usb device mode
    891            * @param  USBx : Selected device
    892            * @param  address : new device address to be assigned
    893            *          This parameter can be a value from 0 to 255
    894            * @retval HAL status
    895            */

   \                                 In section .text, align 2, keep-with-next
    896          HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
    897          {
    898            USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
   \                     USB_SetDevAddress: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
    899            USBx_DEVICE->DCFG |= (address << 4) & USB_OTG_DCFG_DAD ;
   \   00000004   0x0109             LSLS     R1,R1,#+4
   \   00000006   0xF401 0x61FE      AND      R1,R1,#0x7F0
   \   0000000A   0x6802             LDR      R2,[R0, #+0]
   \   0000000C   0xF422 0x62FE      BIC      R2,R2,#0x7F0
   \   00000010   0x6002             STR      R2,[R0, #+0]
   \   00000012   0x6802             LDR      R2,[R0, #+0]
   \   00000014   0x4311             ORRS     R1,R1,R2
   \   00000016   0x6001             STR      R1,[R0, #+0]
    900            
    901            return HAL_OK;  
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
    902          }
    903          
    904          /**
    905            * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
    906            * @param  USBx : Selected device
    907            * @retval HAL status
    908            */

   \                                 In section .text, align 2, keep-with-next
    909          HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
    910          {
   \                     USB_DevConnect: (+1)
   \   00000000   0xB500             PUSH     {LR}
    911            USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0xF021 0x0102      BIC      R1,R1,#0x2
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    912            HAL_Delay(3);
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0x.... 0x....      BL       HAL_Delay
    913            
    914            return HAL_OK;  
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    915          }
    916          
    917          /**
    918            * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
    919            * @param  USBx : Selected device
    920            * @retval HAL status
    921            */

   \                                 In section .text, align 2, keep-with-next
    922          HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
    923          {
   \                     USB_DevDisconnect: (+1)
   \   00000000   0xB500             PUSH     {LR}
    924            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
   \   00000002   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000006   0xB081             SUB      SP,SP,#+4
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    925            HAL_Delay(3);
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0x.... 0x....      BL       HAL_Delay
    926            
    927            return HAL_OK;  
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xBD00             POP      {PC}             ;; return
    928          }
    929          
    930          /**
    931            * @brief  USB_ReadInterrupts: return the global USB interrupt status
    932            * @param  USBx : Selected device
    933            * @retval HAL status
    934            */

   \                                 In section .text, align 2, keep-with-next
    935          uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
    936          {
    937            uint32_t v = 0;
    938            
    939            v = USBx->GINTSTS;
   \                     USB_ReadInterrupts: (+1)
   \   00000000   0x6941             LDR      R1,[R0, #+20]
    940            v &= USBx->GINTMSK;
   \   00000002   0x6980             LDR      R0,[R0, #+24]
    941            return v;  
   \   00000004   0x4008             ANDS     R0,R0,R1
   \   00000006   0x4770             BX       LR               ;; return
    942          }
    943          
    944          /**
    945            * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
    946            * @param  USBx : Selected device
    947            * @retval HAL status
    948            */

   \                                 In section .text, align 2, keep-with-next
    949          uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
    950          {
    951            uint32_t v;
    952            v  = USBx_DEVICE->DAINT;
   \                     USB_ReadDevAllOutEpInterrupt: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000004   0x6981             LDR      R1,[R0, #+24]
    953            v &= USBx_DEVICE->DAINTMSK;
   \   00000006   0x69C0             LDR      R0,[R0, #+28]
    954            return ((v & 0xffff0000) >> 16);
   \   00000008   0x4008             ANDS     R0,R0,R1
   \   0000000A   0x0C00             LSRS     R0,R0,#+16
   \   0000000C   0x4770             BX       LR               ;; return
    955          }
    956          
    957          /**
    958            * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
    959            * @param  USBx : Selected device
    960            * @retval HAL status
    961            */

   \                                 In section .text, align 2, keep-with-next
    962          uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
    963          {
    964            uint32_t v;
    965            v  = USBx_DEVICE->DAINT;
   \                     USB_ReadDevAllInEpInterrupt: (+1)
   \   00000000   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000004   0x6981             LDR      R1,[R0, #+24]
    966            v &= USBx_DEVICE->DAINTMSK;
   \   00000006   0x69C0             LDR      R0,[R0, #+28]
    967            return ((v & 0xFFFF));
   \   00000008   0x4008             ANDS     R0,R0,R1
   \   0000000A   0xB280             UXTH     R0,R0
   \   0000000C   0x4770             BX       LR               ;; return
    968          }
    969          
    970          /**
    971            * @brief  Returns Device OUT EP Interrupt register
    972            * @param  USBx : Selected device
    973            * @param  epnum : endpoint number
    974            *          This parameter can be a value from 0 to 15
    975            * @retval Device OUT EP Interrupt register
    976            */

   \                                 In section .text, align 2, keep-with-next
    977          uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
    978          {
    979            uint32_t v;
    980            v  = USBx_OUTEP(epnum)->DOEPINT;
   \                     USB_ReadDevOutEPInterrupt: (+1)
   \   00000000   0xEB00 0x1141      ADD      R1,R0,R1, LSL #+5
    981            v &= USBx_DEVICE->DOEPMSK;
   \   00000004   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000008   0xF501 0x6130      ADD      R1,R1,#+2816
   \   0000000C   0x6889             LDR      R1,[R1, #+8]
   \   0000000E   0x6940             LDR      R0,[R0, #+20]
    982            return v;
   \   00000010   0x4008             ANDS     R0,R0,R1
   \   00000012   0x4770             BX       LR               ;; return
    983          }
    984          
    985          /**
    986            * @brief  Returns Device IN EP Interrupt register
    987            * @param  USBx : Selected device
    988            * @param  epnum : endpoint number
    989            *          This parameter can be a value from 0 to 15
    990            * @retval Device IN EP Interrupt register
    991            */

   \                                 In section .text, align 2, keep-with-next
    992          uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
    993          {
    994            uint32_t v, msk, emp;
    995            
    996            msk = USBx_DEVICE->DIEPMSK;
   \                     USB_ReadDevInEPInterrupt: (+1)
   \   00000000   0xF500 0x6200      ADD      R2,R0,#+2048
    997            emp = USBx_DEVICE->DIEPEMPMSK;
    998            msk |= ((emp >> epnum) & 0x1) << 7;
    999            v = USBx_INEP(epnum)->DIEPINT & msk;
   \   00000004   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000008   0x6913             LDR      R3,[R2, #+16]
   \   0000000A   0x6B52             LDR      R2,[R2, #+52]
   \   0000000C   0xF500 0x6010      ADD      R0,R0,#+2304
   1000            return v;
   \   00000010   0x40CA             LSRS     R2,R2,R1
   \   00000012   0xF002 0x0101      AND      R1,R2,#0x1
   \   00000016   0x6880             LDR      R0,[R0, #+8]
   \   00000018   0xEA43 0x11C1      ORR      R1,R3,R1, LSL #+7
   \   0000001C   0x4008             ANDS     R0,R1,R0
   \   0000001E   0x4770             BX       LR               ;; return
   1001          }
   1002          
   1003          /**
   1004            * @brief  USB_ClearInterrupts: clear a USB interrupt
   1005            * @param  USBx : Selected device
   1006            * @param  interrupt : interrupt flag
   1007            * @retval None
   1008            */

   \                                 In section .text, align 2, keep-with-next
   1009          void  USB_ClearInterrupts (USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)
   1010          {
   1011            USBx->GINTSTS |= interrupt; 
   \                     USB_ClearInterrupts: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x6141             STR      R1,[R0, #+20]
   1012          }
   \   00000006   0x4770             BX       LR               ;; return
   1013          
   1014          /**
   1015            * @brief  Returns USB core mode
   1016            * @param  USBx : Selected device
   1017            * @retval return core mode : Host or Device
   1018            *          This parameter can be one of these values:
   1019            *           0 : Host 
   1020            *           1 : Device
   1021            */

   \                                 In section .text, align 2, keep-with-next
   1022          uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
   1023          {
   1024            return ((USBx->GINTSTS ) & 0x1);
   \                     USB_GetMode: (+1)
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000006   0x4770             BX       LR               ;; return
   1025          }
   1026          
   1027          
   1028          /**
   1029            * @brief  Activate EP0 for Setup transactions
   1030            * @param  USBx : Selected device
   1031            * @retval HAL status
   1032            */

   \                                 In section .text, align 2, keep-with-next
   1033          HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
   1034          {
   1035            /* Set the MPS of the IN EP based on the enumeration speed */
   1036            USBx_INEP(0)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
   \                     USB_ActivateSetup: (+1)
   \   00000000   0xF500 0x6110      ADD      R1,R0,#+2304
   1037            
   1038            if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
   \   00000004   0xF500 0x6000      ADD      R0,R0,#+2048
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0x0AD2             LSRS     R2,R2,#+11
   \   0000000C   0x02D2             LSLS     R2,R2,#+11
   \   0000000E   0x600A             STR      R2,[R1, #+0]
   \   00000010   0x6882             LDR      R2,[R0, #+8]
   \   00000012   0xF002 0x0206      AND      R2,R2,#0x6
   \   00000016   0x2A04             CMP      R2,#+4
   \   00000018   0xD103             BNE.N    ??USB_ActivateSetup_0
   1039            {
   1040              USBx_INEP(0)->DIEPCTL |= 3;
   \   0000001A   0x680A             LDR      R2,[R1, #+0]
   \   0000001C   0xF042 0x0203      ORR      R2,R2,#0x3
   \   00000020   0x600A             STR      R2,[R1, #+0]
   1041            }
   1042            USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
   \                     ??USB_ActivateSetup_0: (+1)
   \   00000022   0x6841             LDR      R1,[R0, #+4]
   \   00000024   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000028   0x6041             STR      R1,[R0, #+4]
   1043          
   1044            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
   1045          }
   1046          
   1047          
   1048          /**
   1049            * @brief  Prepare the EP0 to start the first control setup
   1050            * @param  USBx : Selected device
   1051            * @param  dma: USB dma enabled or disabled 
   1052            *          This parameter can be one of these values:
   1053            *           0 : DMA feature not used 
   1054            *           1 : DMA feature used  
   1055            * @param  psetup : pointer to setup packet
   1056            * @retval HAL status
   1057            */

   \                                 In section .text, align 2, keep-with-next
   1058          HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
   1059          {
   1060            USBx_OUTEP(0)->DOEPTSIZ = 0;
   \                     USB_EP0_OutStart: (+1)
   \   00000000   0xF500 0x6030      ADD      R0,R0,#+2816
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x6103             STR      R3,[R0, #+16]
   1061            USBx_OUTEP(0)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1 << 19)) ;
   1062            USBx_OUTEP(0)->DOEPTSIZ |= (3 * 8);
   1063            USBx_OUTEP(0)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
   1064            
   1065            if (dma == 1)
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0x6903             LDR      R3,[R0, #+16]
   \   0000000C   0xF443 0x2300      ORR      R3,R3,#0x80000
   \   00000010   0x6103             STR      R3,[R0, #+16]
   \   00000012   0x6903             LDR      R3,[R0, #+16]
   \   00000014   0xF043 0x0318      ORR      R3,R3,#0x18
   \   00000018   0x6103             STR      R3,[R0, #+16]
   \   0000001A   0x6903             LDR      R3,[R0, #+16]
   \   0000001C   0xF043 0x43C0      ORR      R3,R3,#0x60000000
   \   00000020   0x6103             STR      R3,[R0, #+16]
   \   00000022   0xD103             BNE.N    ??USB_EP0_OutStart_0
   1066            {
   1067              USBx_OUTEP(0)->DOEPDMA = (uint32_t)psetup;
   \   00000024   0x6142             STR      R2,[R0, #+20]
   1068              /* EP enable */
   1069              USBx_OUTEP(0)->DOEPCTL = 0x80008000;
   \   00000026   0xF04F 0x2180      MOV      R1,#-2147450880
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   1070            }
   1071            
   1072            return HAL_OK;  
   \                     ??USB_EP0_OutStart_0: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR               ;; return
   1073          }
   1074          
   1075          
   1076          /**
   1077            * @brief  Reset the USB Core (needed after USB clock settings change)
   1078            * @param  USBx : Selected device
   1079            * @retval HAL status
   1080            */
   1081          static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
   1082          {
   1083            uint32_t count = 0;
   1084          
   1085            /* Wait for AHB master IDLE state. */
   1086            do
   1087            {
   1088              if (++count > 200000)
   1089              {
   1090                return HAL_TIMEOUT;
   1091              }
   1092            }
   1093            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0);
   1094            
   1095            /* Core Soft Reset */
   1096            count = 0;
   1097            USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   1098          
   1099            do
   1100            {
   1101              if (++count > 200000)
   1102              {
   1103                return HAL_TIMEOUT;
   1104              }
   1105            }
   1106            while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   1107            
   1108            return HAL_OK;
   1109          }
   1110          
   1111          
   1112          /**
   1113            * @brief  USB_HostInit : Initializes the USB OTG controller registers 
   1114            *         for Host mode 
   1115            * @param  USBx : Selected device
   1116            * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
   1117            *         the configuration information for the specified USBx peripheral.
   1118            * @retval HAL status
   1119            */

   \                                 In section .text, align 2, keep-with-next
   1120          HAL_StatusTypeDef USB_HostInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
   1121          {
   \                     USB_HostInit: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4604             MOV      R4,R0
   1122            uint32_t i;
   1123            
   1124            /* Restart the Phy Clock */
   1125            USBx_PCGCCTL = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF500 0x6260      ADD      R2,R0,#+3584
   \   0000000E   0x6011             STR      R1,[R2, #+0]
   1126            
   1127            /*Activate VBUS Sensing B */
   1128            USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
   \   00000010   0x6BA1             LDR      R1,[R4, #+56]
   \   00000012   0xF441 0x1100      ORR      R1,R1,#0x200000
   \   00000016   0x63A1             STR      R1,[R4, #+56]
   1129            
   1130            /* Disable the FS/LS support mode only */
   1131            if((cfg.speed == USB_OTG_SPEED_FULL)&&
   1132               (USBx != USB_OTG_FS))
   \   00000018   0x9907             LDR      R1,[SP, #+28]
   \   0000001A   0x2903             CMP      R1,#+3
   \   0000001C   0xD108             BNE.N    ??USB_HostInit_0
   \   0000001E   0xF1B4 0x4FA0      CMP      R4,#+1342177280
   \   00000022   0xD005             BEQ.N    ??USB_HostInit_0
   1133            {
   1134              USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS; 
   \   00000024   0xF500 0x6180      ADD      R1,R0,#+1024
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0xF042 0x0204      ORR      R2,R2,#0x4
   \   0000002E   0xE004             B.N      ??USB_HostInit_1
   1135            }
   1136            else
   1137            {
   1138              USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);  
   \                     ??USB_HostInit_0: (+1)
   \   00000030   0xF500 0x6180      ADD      R1,R0,#+1024
   \   00000034   0x680A             LDR      R2,[R1, #+0]
   \   00000036   0xF022 0x0204      BIC      R2,R2,#0x4
   \                     ??USB_HostInit_1: (+1)
   \   0000003A   0x600A             STR      R2,[R1, #+0]
   1139            }
   1140          
   1141            /* Make sure the FIFOs are flushed. */
   1142            USB_FlushTxFifo(USBx, 0x10 ); /* all Tx FIFOs */
   \   0000003C   0xF44F 0x6184      MOV      R1,#+1056
   \   00000040   0x6121             STR      R1,[R4, #+16]
   \   00000042   0x....             LDR.N    R1,??DataTable8_1  ;; 0x30d41
   \   00000044   0x460A             MOV      R2,R1
   \                     ??USB_HostInit_2: (+1)
   \   00000046   0x1E52             SUBS     R2,R2,#+1
   \   00000048   0xD002             BEQ.N    ??USB_HostInit_3
   \   0000004A   0x6923             LDR      R3,[R4, #+16]
   \   0000004C   0x069B             LSLS     R3,R3,#+26
   \   0000004E   0xD4FA             BMI.N    ??USB_HostInit_2
   1143            USB_FlushRxFifo(USBx);
   \                     ??USB_HostInit_3: (+1)
   \   00000050   0x2210             MOVS     R2,#+16
   \   00000052   0x6122             STR      R2,[R4, #+16]
   \                     ??USB_HostInit_4: (+1)
   \   00000054   0x1E49             SUBS     R1,R1,#+1
   \   00000056   0xD002             BEQ.N    ??USB_HostInit_5
   \   00000058   0x6922             LDR      R2,[R4, #+16]
   \   0000005A   0x06D2             LSLS     R2,R2,#+27
   \   0000005C   0xD4FA             BMI.N    ??USB_HostInit_4
   1144          
   1145            /* Clear all pending HC Interrupts */
   1146            for (i = 0; i < cfg.Host_channels; i++)
   \                     ??USB_HostInit_5: (+1)
   \   0000005E   0x9906             LDR      R1,[SP, #+24]
   \   00000060   0xB149             CBZ.N    R1,??USB_HostInit_6
   \   00000062   0xF500 0x62A0      ADD      R2,R0,#+1280
   \   00000066   0xF04F 0x33FF      MOV      R3,#-1
   \   0000006A   0x2500             MOVS     R5,#+0
   1147            {
   1148              USBx_HC(i)->HCINT = 0xFFFFFFFF;
   \                     ??USB_HostInit_7: (+1)
   \   0000006C   0x6093             STR      R3,[R2, #+8]
   1149              USBx_HC(i)->HCINTMSK = 0;
   \   0000006E   0x60D5             STR      R5,[R2, #+12]
   1150            }
   \   00000070   0x3220             ADDS     R2,R2,#+32
   \   00000072   0x1E49             SUBS     R1,R1,#+1
   \   00000074   0xD1FA             BNE.N    ??USB_HostInit_7
   1151            
   1152            /* Enable VBUS driving */
   1153            USB_DriveVbus(USBx, 1);
   \                     ??USB_HostInit_6: (+1)
   \   00000076   0xF500 0x6088      ADD      R0,R0,#+1088
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0x9100             STR      R1,[SP, #+0]
   \   0000007E   0x9900             LDR      R1,[SP, #+0]
   \   00000080   0xF021 0x012E      BIC      R1,R1,#0x2E
   \   00000084   0x9100             STR      R1,[SP, #+0]
   \   00000086   0x9900             LDR      R1,[SP, #+0]
   \   00000088   0x04C9             LSLS     R1,R1,#+19
   \   0000008A   0xD403             BMI.N    ??USB_HostInit_8
   \   0000008C   0x9900             LDR      R1,[SP, #+0]
   \   0000008E   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000092   0x6001             STR      R1,[R0, #+0]
   \                     ??USB_HostInit_8: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   1154            
   1155            HAL_Delay(200);
   \   00000096   0x20C8             MOVS     R0,#+200
   \   00000098   0x.... 0x....      BL       HAL_Delay
   1156            
   1157            /* Disable all interrupts. */
   1158            USBx->GINTMSK = 0;
   \   0000009C   0x2000             MOVS     R0,#+0
   1159            
   1160            /* Clear any pending interrupts */
   1161            USBx->GINTSTS = 0xFFFFFFFF;
   1162            
   1163            if(USBx == USB_OTG_FS)
   \   0000009E   0xF1B4 0x4FA0      CMP      R4,#+1342177280
   \   000000A2   0x61A0             STR      R0,[R4, #+24]
   \   000000A4   0xF04F 0x30FF      MOV      R0,#-1
   \   000000A8   0x6160             STR      R0,[R4, #+20]
   \   000000AA   0xD10B             BNE.N    ??USB_HostInit_9
   1164            {
   1165              /* set Rx FIFO size */
   1166              USBx->GRXFSIZ  = (uint32_t )0x80; 
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable11_5  ;; 0x50000024
   \   000000B0   0x2180             MOVS     R1,#+128
   \   000000B2   0x6001             STR      R1,[R0, #+0]
   1167              USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x60 << 16)& USB_OTG_NPTXFD) | 0x80);
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable11_6  ;; 0x600080
   \   000000B8   0x6041             STR      R1,[R0, #+4]
   1168              USBx->HPTXFSIZ = (uint32_t )(((0x40 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0);
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable11_7  ;; 0x4000e0
   \   000000BE   0xF8C0 0x10DC      STR      R1,[R0, #+220]
   \   000000C2   0xE009             B.N      ??USB_HostInit_10
   1169            }
   1170            else
   1171            {
   1172              /* set Rx FIFO size */
   1173              USBx->GRXFSIZ  = (uint32_t )0x200; 
   \                     ??USB_HostInit_9: (+1)
   \   000000C4   0xF44F 0x7000      MOV      R0,#+512
   \   000000C8   0x6260             STR      R0,[R4, #+36]
   1174              USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t )(((0x100 << 16)& USB_OTG_NPTXFD) | 0x200);
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable11_8  ;; 0x1000200
   \   000000CE   0x62A0             STR      R0,[R4, #+40]
   1175              USBx->HPTXFSIZ = (uint32_t )(((0xE0 << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0x300);
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable11_9  ;; 0xe00300
   \   000000D4   0xF8C4 0x0100      STR      R0,[R4, #+256]
   1176            }
   1177            
   1178            /* Enable the common interrupts */
   1179            if (cfg.dma_enable == DISABLE)
   \                     ??USB_HostInit_10: (+1)
   \   000000D8   0x9808             LDR      R0,[SP, #+32]
   \   000000DA   0xB918             CBNZ.N   R0,??USB_HostInit_11
   1180            {
   1181              USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
   \   000000DC   0x69A0             LDR      R0,[R4, #+24]
   \   000000DE   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000E2   0x61A0             STR      R0,[R4, #+24]
   1182            }
   1183            
   1184            /* Enable interrupts matching to the Host mode ONLY */
   1185            USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM |\
   1186                              USB_OTG_GINTMSK_SOFM             |USB_OTG_GINTSTS_DISCINT|\
   1187                              USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);
   \                     ??USB_HostInit_11: (+1)
   \   000000E4   0x69A0             LDR      R0,[R4, #+24]
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable11_10  ;; 0xa3200008
   \   000000EA   0x4308             ORRS     R0,R1,R0
   \   000000EC   0x61A0             STR      R0,[R4, #+24]
   1188          
   1189            return HAL_OK;
   \   000000EE   0xB002             ADD      SP,SP,#+8
   \   000000F0   0xBC30             POP      {R4,R5}
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   1190          }
   1191          
   1192          /**
   1193            * @brief  USB_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the 
   1194            *         HCFG register on the PHY type and set the right frame interval
   1195            * @param  USBx : Selected device
   1196            * @param  freq : clock frequency
   1197            *          This parameter can be one of these values:
   1198            *           HCFG_48_MHZ : Full Speed 48 MHz Clock 
   1199            *           HCFG_6_MHZ : Low Speed 6 MHz Clock 
   1200            * @retval HAL status
   1201            */

   \                                 In section .text, align 2, keep-with-next
   1202          HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq)
   1203          {
   1204            USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
   \                     USB_InitFSLSPClkSel: (+1)
   \   00000000   0xF500 0x6080      ADD      R0,R0,#+1024
   1205            USBx_HOST->HCFG |= (freq & USB_OTG_HCFG_FSLSPCS);
   \   00000004   0xF001 0x0303      AND      R3,R1,#0x3
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x0892             LSRS     R2,R2,#+2
   \   0000000C   0x0092             LSLS     R2,R2,#+2
   \   0000000E   0x6002             STR      R2,[R0, #+0]
   \   00000010   0x6802             LDR      R2,[R0, #+0]
   \   00000012   0x431A             ORRS     R2,R3,R2
   1206            
   1207            if (freq ==  HCFG_48_MHZ)
   \   00000014   0x2901             CMP      R1,#+1
   \   00000016   0x6002             STR      R2,[R0, #+0]
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0xF64B 0x3180      MOVWEQ   R1,#+48000
   1208            {
   1209              USBx_HOST->HFIR = (uint32_t)48000;
   \   0000001E   0xD003             BEQ.N    ??USB_InitFSLSPClkSel_0
   1210            }
   1211            else if (freq ==  HCFG_6_MHZ)
   \   00000020   0x2902             CMP      R1,#+2
   \   00000022   0xD102             BNE.N    ??USB_InitFSLSPClkSel_1
   1212            {
   1213              USBx_HOST->HFIR = (uint32_t)6000;
   \   00000024   0xF241 0x7170      MOVW     R1,#+6000
   \                     ??USB_InitFSLSPClkSel_0: (+1)
   \   00000028   0x6041             STR      R1,[R0, #+4]
   1214            } 
   1215            return HAL_OK;  
   \                     ??USB_InitFSLSPClkSel_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4770             BX       LR               ;; return
   1216          }
   1217          
   1218          /**
   1219          * @brief  USB_OTG_ResetPort : Reset Host Port
   1220            * @param  USBx : Selected device
   1221            * @retval HAL status
   1222            * @note : (1)The application must wait at least 10 ms
   1223            *   before clearing the reset bit.
   1224            */

   \                                 In section .text, align 2, keep-with-next
   1225          HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
   1226          {
   \                     USB_ResetPort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1227            __IO uint32_t hprt0;
   1228            
   1229            hprt0 = USBx_HPRT0;
   \   00000002   0xF500 0x6488      ADD      R4,R0,#+1088
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   1230            
   1231            hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
   1232              USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0xF020 0x002E      BIC      R0,R0,#0x2E
   \   00000012   0x9000             STR      R0,[SP, #+0]
   1233            
   1234            USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);  
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0xF440 0x7080      ORR      R0,R0,#0x100
   \   0000001A   0x6020             STR      R0,[R4, #+0]
   1235            HAL_Delay (10);                                /* See Note #1 */
   \   0000001C   0x200A             MOVS     R0,#+10
   \   0000001E   0x.... 0x....      BL       HAL_Delay
   1236            USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0); 
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000028   0x6020             STR      R0,[R4, #+0]
   1237            return HAL_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xB002             ADD      SP,SP,#+8
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1238          }
   1239          
   1240          /**
   1241            * @brief  USB_DriveVbus : activate or de-activate vbus
   1242            * @param  state : VBUS state
   1243            *          This parameter can be one of these values:
   1244            *           0 : VBUS Active 
   1245            *           1 : VBUS Inactive
   1246            * @retval HAL status
   1247          */

   \                                 In section .text, align 2, keep-with-next
   1248          HAL_StatusTypeDef USB_DriveVbus (USB_OTG_GlobalTypeDef *USBx, uint8_t state)
   1249          {
   1250            __IO uint32_t hprt0;
   1251          
   1252            hprt0 = USBx_HPRT0;
   \                     USB_DriveVbus: (+1)
   \   00000000   0xF500 0x6088      ADD      R0,R0,#+1088
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x9200             STR      R2,[SP, #+0]
   1253            hprt0 &= ~(USB_OTG_HPRT_PENA    | USB_OTG_HPRT_PCDET |\
   1254                                   USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG );
   \   0000000A   0x9A00             LDR      R2,[SP, #+0]
   \   0000000C   0xF022 0x022E      BIC      R2,R2,#0x2E
   \   00000010   0x9200             STR      R2,[SP, #+0]
   1255            
   1256            if (((hprt0 & USB_OTG_HPRT_PPWR) == 0 ) && (state == 1 ))
   \   00000012   0x9A00             LDR      R2,[SP, #+0]
   \   00000014   0x04D2             LSLS     R2,R2,#+19
   \   00000016   0xD409             BMI.N    ??USB_DriveVbus_0
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD107             BNE.N    ??USB_DriveVbus_0
   1257            {
   1258              USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0); 
   \   0000001C   0x9900             LDR      R1,[SP, #+0]
   \   0000001E   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000022   0x6001             STR      R1,[R0, #+0]
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   1259            }
   1260            if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0 ))
   1261            {
   1262              USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0); 
   1263            }
   1264            return HAL_OK; 
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xB001             ADD      SP,SP,#+4
   \   0000002A   0x4770             BX       LR
   \                     ??USB_DriveVbus_0: (+1)
   \   0000002C   0x9A00             LDR      R2,[SP, #+0]
   \   0000002E   0x04D2             LSLS     R2,R2,#+19
   \   00000030   0xD504             BPL.N    ??USB_DriveVbus_1
   \   00000032   0xB919             CBNZ.N   R1,??USB_DriveVbus_1
   \   00000034   0x9900             LDR      R1,[SP, #+0]
   \   00000036   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   \                     ??USB_DriveVbus_1: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xB001             ADD      SP,SP,#+4
   \   00000040   0x4770             BX       LR               ;; return
   1265          }
   1266          
   1267          /**
   1268            * @brief  Return Host Core speed
   1269            * @param  USBx : Selected device
   1270            * @retval speed : Host speed
   1271            *          This parameter can be one of these values:
   1272            *            @arg USB_OTG_SPEED_HIGH: High speed mode
   1273            *            @arg USB_OTG_SPEED_FULL: Full speed mode
   1274            *            @arg USB_OTG_SPEED_LOW: Low speed mode
   1275            */

   \                                 In section .text, align 2, keep-with-next
   1276          uint32_t USB_GetHostSpeed (USB_OTG_GlobalTypeDef *USBx)
   1277          {
   1278            __IO uint32_t hprt0;
   1279            
   1280            hprt0 = USBx_HPRT0;
   \                     USB_GetHostSpeed: (+1)
   \   00000000   0xF500 0x6088      ADD      R0,R0,#+1088
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1281            return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
   \   0000000A   0x9800             LDR      R0,[SP, #+0]
   \   0000000C   0xB001             ADD      SP,SP,#+4
   \   0000000E   0xF3C0 0x4041      UBFX     R0,R0,#+17,#+2
   \   00000012   0x4770             BX       LR               ;; return
   1282          }
   1283          
   1284          /**
   1285            * @brief  Return Host Current Frame number
   1286            * @param  USBx : Selected device
   1287            * @retval current frame number
   1288          */

   \                                 In section .text, align 2, keep-with-next
   1289          uint32_t USB_GetCurrentFrame (USB_OTG_GlobalTypeDef *USBx)
   1290          {
   1291            return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
   \                     USB_GetCurrentFrame: (+1)
   \   00000000   0xF500 0x6080      ADD      R0,R0,#+1024
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
   1292          }
   1293          
   1294          /**
   1295            * @brief  Initialize a host channel
   1296            * @param  USBx : Selected device
   1297            * @param  ch_num : Channel number
   1298            *         This parameter can be a value from 1 to 15
   1299            * @param  epnum : Endpoint number
   1300            *          This parameter can be a value from 1 to 15
   1301            * @param  dev_address : Current device address
   1302            *          This parameter can be a value from 0 to 255
   1303            * @param  speed : Current device speed
   1304            *          This parameter can be one of these values:
   1305            *            @arg USB_OTG_SPEED_HIGH: High speed mode
   1306            *            @arg USB_OTG_SPEED_FULL: Full speed mode
   1307            *            @arg USB_OTG_SPEED_LOW: Low speed mode
   1308            * @param  ep_type : Endpoint Type
   1309            *          This parameter can be one of these values:
   1310            *            @arg EP_TYPE_CTRL: Control type
   1311            *            @arg EP_TYPE_ISOC: Isochronous type
   1312            *            @arg EP_TYPE_BULK: Bulk type
   1313            *            @arg EP_TYPE_INTR: Interrupt type
   1314            * @param  mps : Max Packet Size
   1315            *          This parameter can be a value from 0 to32K
   1316            * @retval HAL state
   1317            */

   \                                 In section .text, align 4, keep-with-next
   1318          HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx,  
   1319                                        uint8_t ch_num,
   1320                                        uint8_t epnum,
   1321                                        uint8_t dev_address,
   1322                                        uint8_t speed,
   1323                                        uint8_t ep_type,
   1324                                        uint16_t mps)
   1325          {
   \                     USB_HC_Init: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1326              
   1327            /* Clear old interrupt conditions for this host channel. */
   1328            USBx_HC(ch_num)->HCINT = 0xFFFFFFFF;
   \   00000002   0xEB00 0x1441      ADD      R4,R0,R1, LSL #+5
   \   00000006   0xF504 0x65A0      ADD      R5,R4,#+1280
   \   0000000A   0xF04F 0x34FF      MOV      R4,#-1
   \   0000000E   0x60AC             STR      R4,[R5, #+8]
   \   00000010   0x9C05             LDR      R4,[SP, #+20]
   1329            
   1330            /* Enable channel interrupts required for this transfer. */
   1331            switch (ep_type) 
   \   00000012   0x2C03             CMP      R4,#+3
   \   00000014   0xD825             BHI.N    ??USB_HC_Init_1
   \   00000016   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??USB_HC_Init_0:
   \   0000001A   0x02 0x1B          DC8      0x2,0x1B,0x2,0x12
   \              0x02 0x12    
   1332            {
   1333            case EP_TYPE_CTRL:
   1334            case EP_TYPE_BULK:
   1335              
   1336              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1337                                          USB_OTG_HCINTMSK_STALLM |\
   1338                                          USB_OTG_HCINTMSK_TXERRM |\
   1339                                          USB_OTG_HCINTMSK_DTERRM |\
   1340                                          USB_OTG_HCINTMSK_AHBERR |\
   1341                                          USB_OTG_HCINTMSK_NAKM ;
   \                     ??USB_HC_Init_2: (+1)
   \   0000001E   0xF240 0x479D      MOVW     R7,#+1181
   \   00000022   0x60EF             STR      R7,[R5, #+12]
   1342           
   1343              if (epnum & 0x80) 
   \   00000024   0x0617             LSLS     R7,R2,#+24
   \   00000026   0xD503             BPL.N    ??USB_HC_Init_3
   1344              {
   1345                USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   \   00000028   0x68EF             LDR      R7,[R5, #+12]
   \   0000002A   0xF447 0x7780      ORR      R7,R7,#0x100
   \   0000002E   0xE017             B.N      ??USB_HC_Init_4
   1346              } 
   1347              else 
   1348              {
   1349                if(USBx != USB_OTG_FS)
   \                     ??USB_HC_Init_3: (+1)
   \   00000030   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   00000034   0xD015             BEQ.N    ??USB_HC_Init_1
   1350                {
   1351                  USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   \   00000036   0x68EF             LDR      R7,[R5, #+12]
   \   00000038   0xF047 0x0760      ORR      R7,R7,#0x60
   \   0000003C   0xE010             B.N      ??USB_HC_Init_4
   1352                }
   1353              }
   1354              break;
   1355              
   1356            case EP_TYPE_INTR:
   1357              
   1358              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1359                                          USB_OTG_HCINTMSK_STALLM |\
   1360                                          USB_OTG_HCINTMSK_TXERRM |\
   1361                                          USB_OTG_HCINTMSK_DTERRM |\
   1362                                          USB_OTG_HCINTMSK_NAKM   |\
   1363                                          USB_OTG_HCINTMSK_AHBERR |\
   1364                                          USB_OTG_HCINTMSK_FRMORM ;    
   \                     ??USB_HC_Init_5: (+1)
   \   0000003E   0xF240 0x679D      MOVW     R7,#+1693
   \   00000042   0x60EF             STR      R7,[R5, #+12]
   1365              
   1366              if (epnum & 0x80) 
   \   00000044   0x0617             LSLS     R7,R2,#+24
   \   00000046   0xD50C             BPL.N    ??USB_HC_Init_1
   1367              {
   1368                USBx_HC(ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   \   00000048   0x68EF             LDR      R7,[R5, #+12]
   \   0000004A   0xF447 0x7780      ORR      R7,R7,#0x100
   \   0000004E   0xE007             B.N      ??USB_HC_Init_4
   1369              }
   1370              
   1371              break;
   1372            case EP_TYPE_ISOC:
   1373              
   1374              USBx_HC(ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |\
   1375                                          USB_OTG_HCINTMSK_ACKM   |\
   1376                                          USB_OTG_HCINTMSK_AHBERR |\
   1377                                          USB_OTG_HCINTMSK_FRMORM ;   
   \                     ??USB_HC_Init_6: (+1)
   \   00000050   0xF240 0x2725      MOVW     R7,#+549
   \   00000054   0x60EF             STR      R7,[R5, #+12]
   1378              
   1379              if (epnum & 0x80) 
   \   00000056   0x0617             LSLS     R7,R2,#+24
   \   00000058   0xD503             BPL.N    ??USB_HC_Init_1
   1380              {
   1381                USBx_HC(ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);      
   \   0000005A   0x68EF             LDR      R7,[R5, #+12]
   \   0000005C   0xF447 0x77C0      ORR      R7,R7,#0x180
   \                     ??USB_HC_Init_4: (+1)
   \   00000060   0x60EF             STR      R7,[R5, #+12]
   1382              }
   1383              break;
   1384            }
   1385            
   1386            /* Enable the top level host channel interrupt. */
   1387            USBx_HOST->HAINTMSK |= (1 << ch_num);
   \                     ??USB_HC_Init_1: (+1)
   \   00000062   0xF500 0x6680      ADD      R6,R0,#+1024
   \   00000066   0xF04F 0x0C01      MOV      R12,#+1
   \   0000006A   0xFA0C 0xF101      LSL      R1,R12,R1
   \   0000006E   0x69B7             LDR      R7,[R6, #+24]
   \   00000070   0x4339             ORRS     R1,R1,R7
   \   00000072   0x61B1             STR      R1,[R6, #+24]
   1388            
   1389            /* Make sure host channel interrupts are enabled. */
   1390            USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   \   00000074   0x6981             LDR      R1,[R0, #+24]
   \   00000076   0xF041 0x7100      ORR      R1,R1,#0x2000000
   \   0000007A   0x6181             STR      R1,[R0, #+24]
   1391            
   1392            /* Program the HCCHAR register */
   1393            USBx_HC(ch_num)->HCCHAR = (((dev_address << 22) & USB_OTG_HCCHAR_DAD)  |\
   1394                                       (((epnum & 0x7F)<< 11) & USB_OTG_HCCHAR_EPNUM)|\
   1395                                       ((((epnum & 0x80) == 0x80)<< 15) & USB_OTG_HCCHAR_EPDIR)|\
   1396                                       (((speed == HPRT0_PRTSPD_LOW_SPEED)<< 17) & USB_OTG_HCCHAR_LSDEV)|\
   1397                                       ((ep_type << 18) & USB_OTG_HCCHAR_EPTYP)|\
   1398                                       (mps & USB_OTG_HCCHAR_MPSIZ));
   \   0000007C   0x9804             LDR      R0,[SP, #+16]
   \   0000007E   0x09D1             LSRS     R1,R2,#+7
   \   00000080   0x2802             CMP      R0,#+2
   \   00000082   0xBF0C             ITE      EQ 
   \   00000084   0x2001             MOVEQ    R0,#+1
   \   00000086   0x2000             MOVNE    R0,#+0
   \   00000088   0x059B             LSLS     R3,R3,#+22
   \   0000008A   0x02D2             LSLS     R2,R2,#+11
   \   0000008C   0xF003 0x53FE      AND      R3,R3,#0x1FC00000
   \   00000090   0xF402 0x42F0      AND      R2,R2,#0x7800
   \   00000094   0x431A             ORRS     R2,R2,R3
   \   00000096   0xEA42 0x31C1      ORR      R1,R2,R1, LSL #+15
   \   0000009A   0xEA41 0x4040      ORR      R0,R1,R0, LSL #+17
   \   0000009E   0x04A1             LSLS     R1,R4,#+18
   \   000000A0   0xF401 0x2140      AND      R1,R1,#0xC0000
   \   000000A4   0x4301             ORRS     R1,R1,R0
   \   000000A6   0x9806             LDR      R0,[SP, #+24]
   \   000000A8   0x0540             LSLS     R0,R0,#+21
   \   000000AA   0xEA51 0x5050      ORRS     R0,R1,R0, LSR #+21
   1399              
   1400            if (ep_type == EP_TYPE_INTR)
   \   000000AE   0x2C03             CMP      R4,#+3
   \   000000B0   0x6028             STR      R0,[R5, #+0]
   \   000000B2   0xD103             BNE.N    ??USB_HC_Init_7
   1401            {
   1402              USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
   \   000000B4   0x6828             LDR      R0,[R5, #+0]
   \   000000B6   0xF040 0x5000      ORR      R0,R0,#0x20000000
   \   000000BA   0x6028             STR      R0,[R5, #+0]
   1403            }
   1404          
   1405            return HAL_OK; 
   \                     ??USB_HC_Init_7: (+1)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xBCF0             POP      {R4-R7}
   \   000000C0   0x4770             BX       LR               ;; return
   1406          }
   1407          
   1408          /**
   1409            * @brief  Start a transfer over a host channel
   1410            * @param  USBx : Selected device
   1411            * @param  hc : pointer to host channel structure
   1412            * @param  dma: USB dma enabled or disabled 
   1413            *          This parameter can be one of these values:
   1414            *           0 : DMA feature not used 
   1415            *           1 : DMA feature used  
   1416            * @retval HAL state
   1417            */
   1418          #if defined   (__CC_ARM) /*!< ARM Compiler */
   1419          #pragma O0
   1420          #elif defined (__GNUC__) /*!< GNU Compiler */
   1421          #pragma GCC optimize ("O0")
   1422          #endif /* __CC_ARM */

   \                                 In section .text, align 4, keep-with-next
   1423          HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
   1424          {
   1425            uint8_t  is_oddframe = 0; 
   1426            uint16_t len_words = 0;   
   1427            uint16_t num_packets = 0;
   1428            uint16_t max_hc_pkt_count = 256;
   1429            uint32_t tmpreg = 0;
   1430              
   1431            if((USBx != USB_OTG_FS) && (hc->speed == USB_OTG_SPEED_HIGH))
   \                     USB_HC_StartXfer: (+1)
   \   00000000   0xF1B0 0x4FA0      CMP      R0,#+1342177280
   \   00000004   0x4603             MOV      R3,R0
   \   00000006   0xB4F0             PUSH     {R4-R7}
   \   00000008   0xD023             BEQ.N    ??USB_HC_StartXfer_1
   \   0000000A   0x790C             LDRB     R4,[R1, #+4]
   \   0000000C   0xBB0C             CBNZ.N   R4,??USB_HC_StartXfer_1
   1432            {
   1433              if((dma == 0) && (hc->do_ping == 1))
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xBF04             ITT      EQ 
   \   00000012   0x794C             LDRBEQ   R4,[R1, #+5]
   \   00000014   0x2C01             CMPEQ    R4,#+1
   \   00000016   0xD10F             BNE.N    ??USB_HC_StartXfer_2
   1434              {
   1435                USB_DoPing(USBx, hc->ch_num);
   \   00000018   0x7848             LDRB     R0,[R1, #+1]
   \   0000001A   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   0000001E   0xF500 0x64A0      ADD      R4,R0,#+1280
   \   00000022   0x....             LDR.N    R0,??DataTable11_11  ;; 0x80080000
   \   00000024   0x6120             STR      R0,[R4, #+16]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0xF020 0x4080      BIC      R0,R0,#0x40000000
   \   0000002C   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000030   0x6020             STR      R0,[R4, #+0]
   1436                return HAL_OK;
   1437              }
   1438              else if(dma == 1)
   1439              {
   1440                USBx_HC(hc->ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   1441                hc->do_ping = 0;
   1442              }
   1443            }
   1444            
   1445            /* Compute the expected number of packets associated to the transfer */
   1446            if (hc->xfer_len > 0)
   1447            {
   1448              num_packets = (hc->xfer_len + hc->max_packet - 1) / hc->max_packet;
   1449              
   1450              if (num_packets > max_hc_pkt_count)
   1451              {
   1452                num_packets = max_hc_pkt_count;
   1453                hc->xfer_len = num_packets * hc->max_packet;
   1454              }
   1455            }
   1456            else
   1457            {
   1458              num_packets = 1;
   1459            }
   1460            if (hc->ep_is_in)
   1461            {
   1462              hc->xfer_len = num_packets * hc->max_packet;
   1463            }
   1464            
   1465            /* Initialize the HCTSIZn register */
   1466            USBx_HC(hc->ch_num)->HCTSIZ = (((hc->xfer_len) & USB_OTG_HCTSIZ_XFRSIZ)) |\
   1467              ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
   1468                (((hc->data_pid) << 29) & USB_OTG_HCTSIZ_DPID);
   1469            
   1470            if (dma)
   1471            {
   1472              /* xfer_buff MUST be 32-bits aligned */
   1473              USBx_HC(hc->ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
   1474            }
   1475            
   1476            is_oddframe = (USBx_HOST->HFNUM & 0x01) ? 0 : 1;
   1477            USBx_HC(hc->ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   1478            USBx_HC(hc->ch_num)->HCCHAR |= (is_oddframe << 29);
   1479            
   1480            /* Set host channel enable */
   1481            tmpreg = USBx_HC(hc->ch_num)->HCCHAR;
   1482            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   1483            tmpreg |= USB_OTG_HCCHAR_CHENA;
   1484            USBx_HC(hc->ch_num)->HCCHAR = tmpreg;
   1485            
   1486            if (dma == 0) /* Slave mode */
   1487            {  
   1488              if((hc->ep_is_in == 0) && (hc->xfer_len > 0))
   1489              {
   1490                switch(hc->ep_type) 
   1491                {
   1492                  /* Non periodic transfer */
   1493                case EP_TYPE_CTRL:
   1494                case EP_TYPE_BULK:
   1495                  
   1496                  len_words = (hc->xfer_len + 3) / 4;
   1497                  
   1498                  /* check if there is enough space in FIFO space */
   1499                  if(len_words > (USBx->HNPTXSTS & 0xFFFF))
   1500                  {
   1501                    /* need to process data in nptxfempty interrupt */
   1502                    USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
   1503                  }
   1504                  break;
   1505                  /* Periodic transfer */
   1506                case EP_TYPE_INTR:
   1507                case EP_TYPE_ISOC:
   1508                  len_words = (hc->xfer_len + 3) / 4;
   1509                  /* check if there is enough space in FIFO space */
   1510                  if(len_words > (USBx_HOST->HPTXSTS & 0xFFFF)) /* split the transfer */
   1511                  {
   1512                    /* need to process data in ptxfempty interrupt */
   1513                    USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;          
   1514                  }
   1515                  break;
   1516                  
   1517                default:
   1518                  break;
   1519                }
   1520                
   1521                /* Write packet into the Tx FIFO. */
   1522                USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, hc->xfer_len, 0);
   1523              }
   1524            }
   1525            
   1526            return HAL_OK;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xBCF0             POP      {R4-R7}
   \   00000036   0x4770             BX       LR
   \                     ??USB_HC_StartXfer_2: (+1)
   \   00000038   0x2A01             CMP      R2,#+1
   \   0000003A   0xD10A             BNE.N    ??USB_HC_StartXfer_1
   \   0000003C   0x784C             LDRB     R4,[R1, #+1]
   \   0000003E   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   00000042   0xF504 0x64A0      ADD      R4,R4,#+1280
   \   00000046   0x68E5             LDR      R5,[R4, #+12]
   \   00000048   0xF025 0x0560      BIC      R5,R5,#0x60
   \   0000004C   0x60E5             STR      R5,[R4, #+12]
   \   0000004E   0x2400             MOVS     R4,#+0
   \   00000050   0x714C             STRB     R4,[R1, #+5]
   \                     ??USB_HC_StartXfer_1: (+1)
   \   00000052   0x690C             LDR      R4,[R1, #+16]
   \   00000054   0xB16C             CBZ.N    R4,??USB_HC_StartXfer_3
   \   00000056   0x890D             LDRH     R5,[R1, #+8]
   \   00000058   0x192C             ADDS     R4,R5,R4
   \   0000005A   0x1E64             SUBS     R4,R4,#+1
   \   0000005C   0xFBB4 0xF4F5      UDIV     R4,R4,R5
   \   00000060   0xB2A4             UXTH     R4,R4
   \   00000062   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000066   0xDD05             BLE.N    ??USB_HC_StartXfer_4
   \   00000068   0x022D             LSLS     R5,R5,#+8
   \   0000006A   0xF44F 0x7480      MOV      R4,#+256
   \   0000006E   0x610D             STR      R5,[R1, #+16]
   \   00000070   0xE000             B.N      ??USB_HC_StartXfer_4
   \                     ??USB_HC_StartXfer_3: (+1)
   \   00000072   0x2401             MOVS     R4,#+1
   \                     ??USB_HC_StartXfer_4: (+1)
   \   00000074   0x78CD             LDRB     R5,[R1, #+3]
   \   00000076   0xB115             CBZ.N    R5,??USB_HC_StartXfer_5
   \   00000078   0x890D             LDRH     R5,[R1, #+8]
   \   0000007A   0x4365             MULS     R5,R5,R4
   \   0000007C   0x610D             STR      R5,[R1, #+16]
   \                     ??USB_HC_StartXfer_5: (+1)
   \   0000007E   0x690E             LDR      R6,[R1, #+16]
   \   00000080   0x....             LDR.N    R7,??DataTable11_4  ;; 0x1ff80000
   \   00000082   0xEA07 0x44C4      AND      R4,R7,R4, LSL #+19
   \   00000086   0x784D             LDRB     R5,[R1, #+1]
   \   00000088   0x0376             LSLS     R6,R6,#+13
   \   0000008A   0xEA54 0x3456      ORRS     R4,R4,R6, LSR #+13
   \   0000008E   0x7A8E             LDRB     R6,[R1, #+10]
   \   00000090   0xEB03 0x1545      ADD      R5,R3,R5, LSL #+5
   \   00000094   0x0776             LSLS     R6,R6,#+29
   \   00000096   0xF006 0x46C0      AND      R6,R6,#0x60000000
   \   0000009A   0xF505 0x65A0      ADD      R5,R5,#+1280
   \   0000009E   0x4334             ORRS     R4,R6,R4
   \   000000A0   0x2A00             CMP      R2,#+0
   \   000000A2   0x612C             STR      R4,[R5, #+16]
   \   000000A4   0xD006             BEQ.N    ??USB_HC_StartXfer_6
   \   000000A6   0x784C             LDRB     R4,[R1, #+1]
   \   000000A8   0x68CD             LDR      R5,[R1, #+12]
   \   000000AA   0xEB03 0x1444      ADD      R4,R3,R4, LSL #+5
   \   000000AE   0xF504 0x64A0      ADD      R4,R4,#+1280
   \   000000B2   0x6165             STR      R5,[R4, #+20]
   \                     ??USB_HC_StartXfer_6: (+1)
   \   000000B4   0xF503 0x6480      ADD      R4,R3,#+1024
   \   000000B8   0x68A5             LDR      R5,[R4, #+8]
   \   000000BA   0x784E             LDRB     R6,[R1, #+1]
   \   000000BC   0xEB03 0x1646      ADD      R6,R3,R6, LSL #+5
   \   000000C0   0xF005 0x0501      AND      R5,R5,#0x1
   \   000000C4   0xF085 0x0501      EOR      R5,R5,#0x1
   \   000000C8   0xF506 0x66A0      ADD      R6,R6,#+1280
   \   000000CC   0x6837             LDR      R7,[R6, #+0]
   \   000000CE   0xF027 0x5700      BIC      R7,R7,#0x20000000
   \   000000D2   0x6037             STR      R7,[R6, #+0]
   \   000000D4   0x784E             LDRB     R6,[R1, #+1]
   \   000000D6   0xEB03 0x1646      ADD      R6,R3,R6, LSL #+5
   \   000000DA   0xF506 0x66A0      ADD      R6,R6,#+1280
   \   000000DE   0x6837             LDR      R7,[R6, #+0]
   \   000000E0   0xEA47 0x7545      ORR      R5,R7,R5, LSL #+29
   \   000000E4   0x6035             STR      R5,[R6, #+0]
   \   000000E6   0x784D             LDRB     R5,[R1, #+1]
   \   000000E8   0xEB03 0x1545      ADD      R5,R3,R5, LSL #+5
   \   000000EC   0xF505 0x65A0      ADD      R5,R5,#+1280
   \   000000F0   0x682E             LDR      R6,[R5, #+0]
   \   000000F2   0xF026 0x4680      BIC      R6,R6,#0x40000000
   \   000000F6   0xF046 0x4600      ORR      R6,R6,#0x80000000
   \   000000FA   0x602E             STR      R6,[R5, #+0]
   \   000000FC   0xBF04             ITT      EQ 
   \   000000FE   0x78CA             LDRBEQ   R2,[R1, #+3]
   \   00000100   0x2A00             CMPEQ    R2,#+0
   \   00000102   0xD130             BNE.N    ??USB_HC_StartXfer_7
   \   00000104   0x690A             LDR      R2,[R1, #+16]
   \   00000106   0xB372             CBZ.N    R2,??USB_HC_StartXfer_7
   \   00000108   0x79CD             LDRB     R5,[R1, #+7]
   \   0000010A   0x2D03             CMP      R5,#+3
   \   0000010C   0xD819             BHI.N    ??USB_HC_StartXfer_8
   \   0000010E   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??USB_HC_StartXfer_0:
   \   00000112   0x02 0x0D          DC8      0x2,0xD,0x2,0xD
   \              0x02 0x0D    
   \                     ??USB_HC_StartXfer_9: (+1)
   \   00000116   0x6AC4             LDR      R4,[R0, #+44]
   \   00000118   0x1CD2             ADDS     R2,R2,#+3
   \   0000011A   0x0392             LSLS     R2,R2,#+14
   \   0000011C   0xB2A4             UXTH     R4,R4
   \   0000011E   0xEBB4 0x4F12      CMP      R4,R2, LSR #+16
   \   00000122   0xD20E             BCS.N    ??USB_HC_StartXfer_8
   \   00000124   0x6982             LDR      R2,[R0, #+24]
   \   00000126   0xF042 0x0220      ORR      R2,R2,#0x20
   \   0000012A   0xE009             B.N      ??USB_HC_StartXfer_10
   \                     ??USB_HC_StartXfer_11: (+1)
   \   0000012C   0x6924             LDR      R4,[R4, #+16]
   \   0000012E   0x1CD2             ADDS     R2,R2,#+3
   \   00000130   0x0392             LSLS     R2,R2,#+14
   \   00000132   0xB2A4             UXTH     R4,R4
   \   00000134   0xEBB4 0x4F12      CMP      R4,R2, LSR #+16
   \   00000138   0xD203             BCS.N    ??USB_HC_StartXfer_8
   \   0000013A   0x6982             LDR      R2,[R0, #+24]
   \   0000013C   0xF042 0x6280      ORR      R2,R2,#0x4000000
   \                     ??USB_HC_StartXfer_10: (+1)
   \   00000140   0x6182             STR      R2,[R0, #+24]
   \                     ??USB_HC_StartXfer_8: (+1)
   \   00000142   0x7848             LDRB     R0,[R1, #+1]
   \   00000144   0x68CA             LDR      R2,[R1, #+12]
   \   00000146   0x8A09             LDRH     R1,[R1, #+16]
   \   00000148   0x1CC9             ADDS     R1,R1,#+3
   \   0000014A   0x104C             ASRS     R4,R1,#+1
   \   0000014C   0xEB01 0x7194      ADD      R1,R1,R4, LSR #+30
   \   00000150   0x1089             ASRS     R1,R1,#+2
   \   00000152   0xD008             BEQ.N    ??USB_HC_StartXfer_7
   \   00000154   0xEB03 0x3000      ADD      R0,R3,R0, LSL #+12
   \   00000158   0xF500 0x5080      ADD      R0,R0,#+4096
   \                     ??USB_HC_StartXfer_12: (+1)
   \   0000015C   0xF852 0x3B04      LDR      R3,[R2], #+4
   \   00000160   0x1E49             SUBS     R1,R1,#+1
   \   00000162   0x6003             STR      R3,[R0, #+0]
   \   00000164   0xD1FA             BNE.N    ??USB_HC_StartXfer_12
   \                     ??USB_HC_StartXfer_7: (+1)
   \   00000166   0x2000             MOVS     R0,#+0
   \   00000168   0xBCF0             POP      {R4-R7}
   \   0000016A   0x4770             BX       LR               ;; return
   1527          }
   1528          
   1529          /**
   1530            * @brief Read all host channel interrupts status
   1531            * @param  USBx : Selected device
   1532            * @retval HAL state
   1533            */

   \                                 In section .text, align 2, keep-with-next
   1534          uint32_t USB_HC_ReadInterrupt (USB_OTG_GlobalTypeDef *USBx)
   1535          {
   1536            return ((USBx_HOST->HAINT) & 0xFFFF);
   \                     USB_HC_ReadInterrupt: (+1)
   \   00000000   0xF500 0x6080      ADD      R0,R0,#+1024
   \   00000004   0x6940             LDR      R0,[R0, #+20]
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
   1537          }
   1538          
   1539          /**
   1540            * @brief  Halt a host channel
   1541            * @param  USBx : Selected device
   1542            * @param  hc_num : Host Channel number
   1543            *         This parameter can be a value from 1 to 15
   1544            * @retval HAL state
   1545            */

   \                                 In section .text, align 2, keep-with-next
   1546          HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num)
   1547          {
   1548            uint32_t count = 0;
   1549            
   1550            /* Check for space in the request queue to issue the halt. */
   1551            if (((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_CTRL << 18)) || ((USBx_HC(hc_num)->HCCHAR) & (HCCHAR_BULK << 18)))
   \                     USB_HC_Halt: (+1)
   \   00000000   0xEB00 0x1141      ADD      R1,R0,R1, LSL #+5
   \   00000004   0xF501 0x61A0      ADD      R1,R1,#+1280
   \   00000008   0x680A             LDR      R2,[R1, #+0]
   \   0000000A   0x680A             LDR      R2,[R1, #+0]
   \   0000000C   0x0312             LSLS     R2,R2,#+12
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0xF042 0x4280      ORR      R2,R2,#0x40000000
   \   00000014   0x600A             STR      R2,[R1, #+0]
   \   00000016   0xBF4E             ITEE     MI 
   \   00000018   0x6AC0             LDRMI    R0,[R0, #+44]
   \   0000001A   0xF500 0x6080      ADDPL    R0,R0,#+1024
   \   0000001E   0x6900             LDRPL    R0,[R0, #+16]
   1552            {
   1553              USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   1554              
   1555              if ((USBx->HNPTXSTS & 0xFFFF) == 0)
   1556              {
   1557                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   1558                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
   1559                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   1560                do 
   1561                {
   1562                  if (++count > 1000) 
   1563                  {
   1564                    break;
   1565                  }
   1566                } 
   1567                while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
   1568              }
   1569              else
   1570              {
   1571                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
   1572              }
   1573            }
   1574            else
   1575            {
   1576              USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   1577              
   1578              if ((USBx_HOST->HPTXSTS & 0xFFFF) == 0)
   \   00000020   0x0400             LSLS     R0,R0,#+16
   \   00000022   0x6808             LDR      R0,[R1, #+0]
   \   00000024   0xD113             BNE.N    ??USB_HC_Halt_0
   1579              {
   1580                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   \   00000026   0x0040             LSLS     R0,R0,#+1
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1581                USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA;  
   \   0000002C   0x6808             LDR      R0,[R1, #+0]
   \   0000002E   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1582                USBx_HC(hc_num)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   \   00000034   0x6808             LDR      R0,[R1, #+0]
   \   00000036   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   \   0000003C   0xF240 0x30E9      MOVW     R0,#+1001
   1583                do 
   1584                {
   1585                  if (++count > 1000) 
   \                     ??USB_HC_Halt_1: (+1)
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0xD007             BEQ.N    ??USB_HC_Halt_2
   1586                  {
   1587                    break;
   1588                  }
   1589                } 
   1590                while ((USBx_HC(hc_num)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);     
   \   00000044   0x680A             LDR      R2,[R1, #+0]
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD4FA             BMI.N    ??USB_HC_Halt_1
   1591              }
   1592              else
   1593              {
   1594                 USBx_HC(hc_num)->HCCHAR |= USB_OTG_HCCHAR_CHENA; 
   1595              }
   1596            }
   1597            
   1598            return HAL_OK;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x4770             BX       LR
   \                     ??USB_HC_Halt_0: (+1)
   \   0000004E   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \                     ??USB_HC_Halt_2: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x4770             BX       LR               ;; return
   1599          }
   1600          
   1601          /**
   1602            * @brief  Initiate Do Ping protocol
   1603            * @param  USBx : Selected device
   1604            * @param  hc_num : Host Channel number
   1605            *         This parameter can be a value from 1 to 15
   1606            * @retval HAL state
   1607            */

   \                                 In section .text, align 2, keep-with-next
   1608          HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx , uint8_t ch_num)
   1609          {
   1610            uint8_t  num_packets = 1;
   1611            uint32_t tmpreg = 0;
   1612          
   1613            USBx_HC(ch_num)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |\
   1614                                          USB_OTG_HCTSIZ_DOPING;
   \                     USB_DoPing: (+1)
   \   00000000   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000004   0x....             LDR.N    R1,??DataTable11_11  ;; 0x80080000
   \   00000006   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   0000000A   0x6101             STR      R1,[R0, #+16]
   1615            
   1616            /* Set host channel enable */
   1617            tmpreg = USBx_HC(ch_num)->HCCHAR;
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   1618            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   1619            tmpreg |= USB_OTG_HCCHAR_CHENA;
   1620            USBx_HC(ch_num)->HCCHAR = tmpreg;
   \   0000000E   0xF021 0x4180      BIC      R1,R1,#0x40000000
   \   00000012   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000016   0x6001             STR      R1,[R0, #+0]
   1621            
   1622            return HAL_OK;  
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x4770             BX       LR               ;; return
   1623          }
   1624          
   1625          /**
   1626            * @brief  Stop Host Core
   1627            * @param  USBx : Selected device
   1628            * @retval HAL state
   1629            */

   \                                 In section .text, align 2, keep-with-next
   1630          HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
   1631          {
   \                     USB_StopHost: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1632            uint8_t i;
   1633            uint32_t count = 0;
   1634            uint32_t value;
   1635            
   1636            USB_DisableGlobalInt(USBx);
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x6082             STR      R2,[R0, #+8]
   1637            
   1638              /* Flush FIFO */
   1639            USB_FlushTxFifo(USBx, 0x10);
   \   0000000C   0xF44F 0x6284      MOV      R2,#+1056
   \   00000010   0x6102             STR      R2,[R0, #+16]
   \   00000012   0x....             LDR.N    R2,??DataTable11_12  ;; 0x30d41
   \   00000014   0x4613             MOV      R3,R2
   \                     ??USB_StopHost_0: (+1)
   \   00000016   0x1E5B             SUBS     R3,R3,#+1
   \   00000018   0xD002             BEQ.N    ??USB_StopHost_1
   \   0000001A   0x6904             LDR      R4,[R0, #+16]
   \   0000001C   0x06A4             LSLS     R4,R4,#+26
   \   0000001E   0xD4FA             BMI.N    ??USB_StopHost_0
   1640            USB_FlushRxFifo(USBx);
   \                     ??USB_StopHost_1: (+1)
   \   00000020   0x2310             MOVS     R3,#+16
   \   00000022   0x6103             STR      R3,[R0, #+16]
   \                     ??USB_StopHost_2: (+1)
   \   00000024   0x1E52             SUBS     R2,R2,#+1
   \   00000026   0xD002             BEQ.N    ??USB_StopHost_3
   \   00000028   0x6903             LDR      R3,[R0, #+16]
   \   0000002A   0x06DB             LSLS     R3,R3,#+27
   \   0000002C   0xD4FA             BMI.N    ??USB_StopHost_2
   1641            
   1642            /* Flush out any leftover queued requests. */
   1643            for (i = 0; i <= 15; i++)
   \                     ??USB_StopHost_3: (+1)
   \   0000002E   0xF500 0x63A0      ADD      R3,R0,#+1280
   \   00000032   0x461C             MOV      R4,R3
   \   00000034   0x2510             MOVS     R5,#+16
   \   00000036   0xF06F 0x2780      MVN      R7,#-2147450880
   1644            {   
   1645          
   1646              value = USBx_HC(i)->HCCHAR ;
   \                     ??USB_StopHost_4: (+1)
   \   0000003A   0x6826             LDR      R6,[R4, #+0]
   1647              value |=  USB_OTG_HCCHAR_CHDIS;
   1648              value &= ~USB_OTG_HCCHAR_CHENA;  
   1649              value &= ~USB_OTG_HCCHAR_EPDIR;
   1650              USBx_HC(i)->HCCHAR = value;
   \   0000003C   0x403E             ANDS     R6,R7,R6
   \   0000003E   0xF046 0x4680      ORR      R6,R6,#0x40000000
   1651            }
   \   00000042   0x1E6D             SUBS     R5,R5,#+1
   \   00000044   0xF844 0x6B20      STR      R6,[R4], #+32
   \   00000048   0xD1F7             BNE.N    ??USB_StopHost_4
   1652            
   1653            /* Halt all channels to put them into a known state. */  
   1654            for (i = 0; i <= 15; i++)
   \   0000004A   0x2410             MOVS     R4,#+16
   \   0000004C   0xF240 0x35E9      MOVW     R5,#+1001
   1655            {
   1656              value = USBx_HC(i)->HCCHAR ;
   \                     ??USB_StopHost_5: (+1)
   \   00000050   0x681F             LDR      R7,[R3, #+0]
   1657              
   1658              value |= USB_OTG_HCCHAR_CHDIS;
   1659              value |= USB_OTG_HCCHAR_CHENA;  
   1660              value &= ~USB_OTG_HCCHAR_EPDIR;
   1661              
   1662              USBx_HC(i)->HCCHAR = value;
   \   00000052   0xF427 0x4700      BIC      R7,R7,#0x8000
   \   00000056   0xF047 0x4740      ORR      R7,R7,#0xC0000000
   \   0000005A   0x601F             STR      R7,[R3, #+0]
   1663              do 
   1664              {
   1665                if (++count > 1000) 
   \                     ??USB_StopHost_6: (+1)
   \   0000005C   0x1C49             ADDS     R1,R1,#+1
   \   0000005E   0x42A9             CMP      R1,R5
   \   00000060   0xD202             BCS.N    ??USB_StopHost_7
   1666                {
   1667                  break;
   1668                }
   1669              } 
   1670              while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   \   00000062   0x681F             LDR      R7,[R3, #+0]
   \   00000064   0x2F00             CMP      R7,#+0
   \   00000066   0xD4F9             BMI.N    ??USB_StopHost_6
   1671            }
   \                     ??USB_StopHost_7: (+1)
   \   00000068   0x3320             ADDS     R3,R3,#+32
   \   0000006A   0x1E64             SUBS     R4,R4,#+1
   \   0000006C   0xD1F0             BNE.N    ??USB_StopHost_5
   1672          
   1673            /* Clear any pending Host interrupts */
   1674            USBx_HOST->HAINT = 0xFFFFFFFF;
   \   0000006E   0xF04F 0x31FF      MOV      R1,#-1
   \   00000072   0xF500 0x6280      ADD      R2,R0,#+1024
   \   00000076   0x6151             STR      R1,[R2, #+20]
   1675            USBx->GINTSTS = 0xFFFFFFFF;
   \   00000078   0x6141             STR      R1,[R0, #+20]
   1676            USB_EnableGlobalInt(USBx);
   \   0000007A   0x6881             LDR      R1,[R0, #+8]
   \   0000007C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000080   0x6081             STR      R1,[R0, #+8]
   1677            return HAL_OK;  
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xBCF0             POP      {R4-R7}
   \   00000086   0x4770             BX       LR               ;; return
   1678          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xFFBDFFBF         DC32     0xffbdffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x00030D41         DC32     0x30d41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x00030D41         DC32     0x30d41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x00800100         DC32     0x800100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x803C3800         DC32     0x803c3800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x10008000         DC32     0x10008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     ??debug

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0xE007FFFF         DC32     0xe007ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x1FF80000         DC32     0x1ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x50000024         DC32     0x50000024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x00600080         DC32     0x600080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x004000E0         DC32     0x4000e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x01000200         DC32     0x1000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x00E00300         DC32     0xe00300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0xA3200008         DC32     0xa3200008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x80080000         DC32     0x80080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x00030D41         DC32     0x30d41
   1679          /**
   1680            * @}
   1681            */
   1682          
   1683          #endif /* defined (HAL_PCD_MODULE_ENABLED) || defined (HAL_HCD_MODULE_ENABLED) */
   1684          
   1685          /**
   1686            * @}
   1687            */
   1688          
   1689          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB_ActivateDedicatedEndpoint
       0   USB_ActivateEndpoint
       0   USB_ActivateSetup
       0   USB_ClearInterrupts
      12   USB_CoreInit
       0   USB_DeactivateDedicatedEndpoint
       8   USB_DeactivateEndpoint
       8   USB_DevConnect
         8   -> HAL_Delay
       8   USB_DevDisconnect
         8   -> HAL_Delay
      32   USB_DevInit
       0   USB_DisableGlobalInt
       0   USB_DoPing
       4   USB_DriveVbus
       8   USB_EP0StartXfer
       0   USB_EP0_OutStart
       0   USB_EPClearStall
       0   USB_EPSetStall
      12   USB_EPStartXfer
       0   USB_EnableGlobalInt
       0   USB_FlushRxFifo
       0   USB_FlushTxFifo
       0   USB_GetCurrentFrame
       0   USB_GetDevSpeed
       4   USB_GetHostSpeed
       0   USB_GetMode
       0   USB_HC_Halt
      16   USB_HC_Init
       0   USB_HC_ReadInterrupt
      16   USB_HC_StartXfer
      32   USB_HostInit
        32   -> HAL_Delay
       0   USB_InitFSLSPClkSel
       0   USB_ReadDevAllInEpInterrupt
       0   USB_ReadDevAllOutEpInterrupt
       0   USB_ReadDevInEPInterrupt
       0   USB_ReadDevOutEPInterrupt
       0   USB_ReadInterrupts
       0   USB_ReadPacket
      16   USB_ResetPort
        16   -> HAL_Delay
       8   USB_SetCurrentMode
         8   -> HAL_Delay
       0   USB_SetDevAddress
       0   USB_SetDevSpeed
       8   USB_StopDevice
      16   USB_StopHost
       4   USB_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
     224  USB_ActivateDedicatedEndpoint
     140  USB_ActivateEndpoint
      46  USB_ActivateSetup
       8  USB_ClearInterrupts
     160  USB_CoreInit
      96  USB_DeactivateDedicatedEndpoint
     104  USB_DeactivateEndpoint
      28  USB_DevConnect
      28  USB_DevDisconnect
     324  USB_DevInit
      12  USB_DisableGlobalInt
      28  USB_DoPing
      66  USB_DriveVbus
     326  USB_EP0StartXfer
      48  USB_EP0_OutStart
      90  USB_EPClearStall
      82  USB_EPSetStall
     552  USB_EPStartXfer
      12  USB_EnableGlobalInt
      26  USB_FlushRxFifo
      30  USB_FlushTxFifo
      10  USB_GetCurrentFrame
      52  USB_GetDevSpeed
      20  USB_GetHostSpeed
       8  USB_GetMode
      88  USB_HC_Halt
     194  USB_HC_Init
      10  USB_HC_ReadInterrupt
     364  USB_HC_StartXfer
     248  USB_HostInit
      46  USB_InitFSLSPClkSel
      14  USB_ReadDevAllInEpInterrupt
      14  USB_ReadDevAllOutEpInterrupt
      32  USB_ReadDevInEPInterrupt
      20  USB_ReadDevOutEPInterrupt
       8  USB_ReadInterrupts
      30  USB_ReadPacket
      48  USB_ResetPort
      46  USB_SetCurrentMode
      28  USB_SetDevAddress
      14  USB_SetDevSpeed
      84  USB_StopDevice
     136  USB_StopHost
      52  USB_WritePacket
       4  debug

 
     4 bytes in section .bss
 4 064 bytes in section .text
 
 4 064 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
