###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       10/Oct/2016  13:58:59
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sai.c
#    Command line =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sai.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e
#        --char_is_signed --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_sai.lst
#    Object file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_sai.o
#
###############################################################################

D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sai.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_sai.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   SAI HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Serial Audio Interface (SAI) peripheral:
     10            *           + Initialization/de-initialization functions
     11            *           + I/O operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State functions
     14            *         
     15            @verbatim
     16           ==============================================================================
     17                            ##### How to use this driver #####
     18            ==============================================================================
     19                     
     20            [..]
     21              The SAI HAL driver can be used as follows:
     22              
     23              (#) Declare a SAI_HandleTypeDef handle structure.
     24              (#) Initialize the SAI low level resources by implementing the HAL_SAI_MspInit() API:
     25                  (##) Enable the SAI interface clock.                      
     26                  (##) SAI pins configuration:
     27                      (+++) Enable the clock for the SAI GPIOs.
     28                      (+++) Configure these SAI pins as alternate function pull-up.
     29                  (##) NVIC configuration if you need to use interrupt process (HAL_SAI_Transmit_IT()
     30                       and HAL_SAI_Receive_IT() APIs):
     31                      (+++) Configure the SAI interrupt priority.
     32                      (+++) Enable the NVIC SAI IRQ handle.
     33          
     34                  (##) DMA Configuration if you need to use DMA process (HAL_SAI_Transmit_DMA()
     35                       and HAL_SAI_Receive_DMA() APIs):
     36                      (+++) Declare a DMA handle structure for the Tx/Rx stream.
     37                      (+++) Enable the DMAx interface clock.
     38                      (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.                
     39                      (+++) Configure the DMA Tx/Rx Stream.
     40                      (+++) Associate the initialized DMA handle to the SAI DMA Tx/Rx handle.
     41                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the 
     42                          DMA Tx/Rx Stream.
     43            
     44             (#) Program the SAI Mode, Standard, Data Format, MCLK Output, Audio frequency and Polarity
     45                 using HAL_SAI_Init() function.
     46             
     47             -@- The specific SAI interrupts (FIFO request and Overrun underrun interrupt)
     48                 will be managed using the macros __SAI_ENABLE_IT() and __SAI_DISABLE_IT()
     49                 inside the transmit and receive process.   
     50          
     51            [..]           
     52             (@) SAI Clock Source, the configuration is managed through RCCEx_PeriphCLKConfig()
     53                      function in the HAL RCC drivers        
     54            [..]           
     55             (@) Make sure that either:
     56                 (+@) I2S PLL is configured or 
     57                 (+@) SAI PLL is configured or 
     58                 (+@) External clock source is configured after setting correctly 
     59                      the define constant EXTERNAL_CLOCK_VALUE in the stm32f7xx_hal_conf.h file. 
     60                                  
     61            [..]           
     62              (@) In master Tx mode: enabling the audio block immediately generates the bit clock 
     63                  for the external slaves even if there is no data in the FIFO, However FS signal 
     64                  generation is conditioned by the presence of data in the FIFO.
     65                           
     66            [..]           
     67              (@) In master Rx mode: enabling the audio block immediately generates the bit clock 
     68                  and FS signal for the external slaves. 
     69                          
     70            [..]           
     71              (@) It is mandatory to respect the following conditions in order to avoid bad SAI behavior: 
     72                  (+@)  First bit Offset <= (SLOT size - Data size)
     73                  (+@)  Data size <= SLOT size
     74                  (+@)  Number of SLOT x SLOT size = Frame length
     75                  (+@)  The number of slots should be even when SAI_FS_CHANNEL_IDENTIFICATION is selected.  
     76          
     77            [..]         
     78               Three operation modes are available within this driver :     
     79            
     80             *** Polling mode IO operation ***
     81             =================================
     82             [..]    
     83               (+) Send an amount of data in blocking mode using HAL_SAI_Transmit() 
     84               (+) Receive an amount of data in blocking mode using HAL_SAI_Receive()
     85             
     86             *** Interrupt mode IO operation ***    
     87             ===================================
     88             [..]    
     89               (+) Send an amount of data in non blocking mode using HAL_SAI_Transmit_IT() 
     90               (+) At transmission end of transfer HAL_SAI_TxCpltCallback is executed and user can 
     91                   add his own code by customization of function pointer HAL_SAI_TxCpltCallback
     92               (+) Receive an amount of data in non blocking mode using HAL_SAI_Receive_IT() 
     93               (+) At reception end of transfer HAL_SAI_RxCpltCallback is executed and user can 
     94                   add his own code by customization of function pointer HAL_SAI_RxCpltCallback                                      
     95               (+) In case of transfer Error, HAL_SAI_ErrorCallback() function is executed and user can 
     96                   add his own code by customization of function pointer HAL_SAI_ErrorCallback
     97          
     98             *** DMA mode IO operation ***    
     99             ==============================
    100             [..] 
    101               (+) Send an amount of data in non blocking mode (DMA) using HAL_SAI_Transmit_DMA() 
    102               (+) At transmission end of transfer HAL_SAI_TxCpltCallback is executed and user can 
    103                   add his own code by customization of function pointer HAL_SAI_TxCpltCallback
    104               (+) Receive an amount of data in non blocking mode (DMA) using HAL_SAI_Receive_DMA() 
    105               (+) At reception end of transfer HAL_SAI_RxCpltCallback is executed and user can 
    106                   add his own code by customization of function pointer HAL_SAI_RxCpltCallback                                  
    107               (+) In case of transfer Error, HAL_SAI_ErrorCallback() function is executed and user can 
    108                   add his own code by customization of function pointer HAL_SAI_ErrorCallback
    109               (+) Pause the DMA Transfer using HAL_SAI_DMAPause()      
    110               (+) Resume the DMA Transfer using HAL_SAI_DMAResume()  
    111               (+) Stop the DMA Transfer using HAL_SAI_DMAStop()      
    112             
    113             *** SAI HAL driver macros list ***
    114             ============================================= 
    115             [..]
    116               Below the list of most used macros in USART HAL driver :
    117                 
    118                (+) __HAL_SAI_ENABLE: Enable the SAI peripheral
    119                (+) __HAL_SAI_DISABLE: Disable the SAI peripheral
    120                (+) __HAL_SAI_ENABLE_IT : Enable the specified SAI interrupts
    121                (+) __HAL_SAI_DISABLE_IT : Disable the specified SAI interrupts
    122                (+) __HAL_SAI_GET_IT_SOURCE: Check if the specified SAI interrupt source is 
    123                    enabled or disabled
    124                (+) __HAL_SAI_GET_FLAG: Check whether the specified SAI flag is set or not
    125            
    126            @endverbatim
    127            ******************************************************************************
    128            * @attention
    129            *
    130            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
    131            *
    132            * Redistribution and use in source and binary forms, with or without modification,
    133            * are permitted provided that the following conditions are met:
    134            *   1. Redistributions of source code must retain the above copyright notice,
    135            *      this list of conditions and the following disclaimer.
    136            *   2. Redistributions in binary form must reproduce the above copyright notice,
    137            *      this list of conditions and the following disclaimer in the documentation
    138            *      and/or other materials provided with the distribution.
    139            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    140            *      may be used to endorse or promote products derived from this software
    141            *      without specific prior written permission.
    142            *
    143            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    144            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    145            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    146            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    147            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    148            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    149            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    150            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    151            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    152            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    153            *
    154            ******************************************************************************
    155            */ 
    156          
    157          /* Includes ------------------------------------------------------------------*/
    158          #include "stm32f7xx_hal.h"
    159          
    160          /** @addtogroup STM32F7xx_HAL_Driver
    161            * @{
    162            */
    163          
    164          /** @defgroup SAI SAI
    165            * @brief SAI HAL module driver
    166            * @{
    167            */
    168          
    169          #ifdef HAL_SAI_MODULE_ENABLED
    170          
    171          /* Private typedef -----------------------------------------------------------*/
    172          /** @defgroup SAI_Private_Typedefs  SAI Private Typedefs
    173            * @{
    174            */
    175          typedef enum {
    176            SAI_MODE_DMA,
    177            SAI_MODE_IT
    178          }SAI_ModeTypedef;
    179          /**
    180            * @}
    181            */
    182          /* Private define ------------------------------------------------------------*/
    183          /** @defgroup SAI_Private_Constants  SAI Private Constants
    184            * @{
    185            */
    186          #define SAI_FIFO_SIZE       8
    187          #define SAI_DEFAULT_TIMEOUT 4
    188          #define SAI_xCR2_MUTECNT_OFFSET POSITION_VAL(SAI_xCR2_MUTECNT)
    189          /**
    190            * @}
    191            */
    192          
    193          /* SAI registers Masks */
    194          #define CR1_CLEAR_MASK            ((uint32_t)0xFF04C010)
    195          #define FRCR_CLEAR_MASK           ((uint32_t)0xFFF88000)
    196          #define SLOTR_CLEAR_MASK          ((uint32_t)0x0000F020)
    197          
    198          #define SAI_TIMEOUT_VALUE         10
    199          /* Private macro -------------------------------------------------------------*/
    200          /* Private variables ---------------------------------------------------------*/
    201          /* Private function prototypes -----------------------------------------------*/
    202          static void SAI_FillFifo(SAI_HandleTypeDef *hsai);
    203          static uint32_t SAI_InterruptFlag(SAI_HandleTypeDef *hsai, uint32_t mode);
    204          static HAL_StatusTypeDef SAI_InitI2S(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot);
    205          static HAL_StatusTypeDef SAI_InitPCM(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot);
    206          
    207          static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai);
    208          static void SAI_Transmit_IT8Bit(SAI_HandleTypeDef *hsai);
    209          static void SAI_Transmit_IT16Bit(SAI_HandleTypeDef *hsai);
    210          static void SAI_Transmit_IT32Bit(SAI_HandleTypeDef *hsai);
    211          static void SAI_Receive_IT8Bit(SAI_HandleTypeDef *hsai);
    212          static void SAI_Receive_IT16Bit(SAI_HandleTypeDef *hsai);
    213          static void SAI_Receive_IT32Bit(SAI_HandleTypeDef *hsai);
    214          
    215          static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma);
    216          static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    217          static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma);
    218          static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    219          static void SAI_DMAError(DMA_HandleTypeDef *hdma);
    220          
    221          /* Exported functions ---------------------------------------------------------*/
    222          
    223          /** @defgroup SAI_Exported_Functions  SAI Exported Functions
    224            * @{
    225            */
    226          
    227          /** @defgroup SAI_Exported_Functions_Group1 Initialization and de-initialization functions 
    228           *  @brief    Initialization and Configuration functions 
    229           *
    230          @verbatim    
    231           ===============================================================================
    232                        ##### Initialization and de-initialization functions #####
    233           ===============================================================================
    234              [..]  This subsection provides a set of functions allowing to initialize and 
    235                    de-initialize the SAIx peripheral:
    236          
    237                (+) User must implement HAL_SAI_MspInit() function in which he configures 
    238                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    239          
    240                (+) Call the function HAL_SAI_Init() to configure the selected device with 
    241                    the selected configuration:
    242                  (++) Mode (Master/slave TX/RX)
    243                  (++) Protocol 
    244                  (++) Data Size
    245                  (++) MCLK Output
    246                  (++) Audio frequency
    247                  (++) FIFO Threshold
    248                  (++) Frame Config
    249                  (++) Slot Config
    250          
    251                (+) Call the function HAL_SAI_DeInit() to restore the default configuration 
    252                    of the selected SAI peripheral.     
    253          
    254          @endverbatim
    255            * @{
    256            */
    257          
    258          /**
    259            * @brief  Initializes the structure FrameInit, SlotInit and the low part of 
    260            *         Init according to the specified parameters and call the function
    261            *         HAL_SAI_Init to initialize the SAI block.
    262            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains 
    263            *               the configuration information for SAI module.
    264            * @param  protocol : one of the supported protocol @ref SAI_Protocol
    265            * @param  datasize : one of the supported datasize @ref SAI_Protocol_DataSize
    266            *                the configuration information for SAI module.
    267            * @param  nbslot   : Number of slot.
    268            * @retval HAL status
    269            */

   \                                 In section .text, align 4, keep-with-next
    270          HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
    271          {
    272            HAL_StatusTypeDef status = HAL_OK;
    273            
    274            /* Check the parameters */
    275            assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
    276            assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
    277            
    278            switch(protocol)
   \                     HAL_SAI_InitProtocol: (+1)
   \   00000000   0x2908             CMP      R1,#+8
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xD842             BHI.N    ??HAL_SAI_InitProtocol_2
   \   00000008   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_SAI_InitProtocol_0:
   \   0000000C   0x05 0x05          DC8      0x5,0x5,0x5,0x41
   \              0x05 0x41    
   \   00000010   0x0D 0x41          DC8      0xD,0x41,0x41,0x41
   \              0x41 0x41    
   \   00000014   0x0D 0x00          DC8      0xD,0x0
    279            {
    280            case SAI_I2S_STANDARD :
    281            case SAI_I2S_MSBJUSTIFIED :
    282            case SAI_I2S_LSBJUSTIFIED :
    283              status = SAI_InitI2S(hsai, protocol, datasize, nbslot);
   \                     ??HAL_SAI_InitProtocol_3: (+1)
   \   00000016   0x.... 0x....      BL       SAI_InitI2S
    284              break;  
    285            case SAI_PCM_LONG :
    286            case SAI_PCM_SHORT :
    287              status = SAI_InitPCM(hsai, protocol, datasize, nbslot);
    288              break;
    289            default :
    290              status = HAL_ERROR;
    291              break;
    292            }
    293            
    294            if(status == HAL_OK)
   \   0000001A   0xB918             CBNZ.N   R0,??HAL_SAI_InitProtocol_4
    295            {
    296              status = HAL_SAI_Init(hsai);
   \                     ??HAL_SAI_InitProtocol_5: (+1)
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x....             B.N      HAL_SAI_Init
    297            }
    298          
    299            return status;
   \                     ??HAL_SAI_InitProtocol_4: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   \                     ??HAL_SAI_InitProtocol_6: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x65E3             STR      R3,[R4, #+92]
   \   0000002A   0x6320             STR      R0,[R4, #+48]
   \   0000002C   0x63A0             STR      R0,[R4, #+56]
   \   0000002E   0x63E0             STR      R0,[R4, #+60]
   \   00000030   0x64A0             STR      R0,[R4, #+72]
   \   00000032   0xF44F 0x3000      MOV      R0,#+131072
   \   00000036   0x64E0             STR      R0,[R4, #+76]
   \   00000038   0xF44F 0x2080      MOV      R0,#+262144
   \   0000003C   0x6520             STR      R0,[R4, #+80]
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6560             STR      R0,[R4, #+84]
   \   00000042   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000046   0x2904             CMP      R1,#+4
   \   00000048   0x6620             STR      R0,[R4, #+96]
   \   0000004A   0xD003             BEQ.N    ??HAL_SAI_InitProtocol_7
   \   0000004C   0x2908             CMP      R1,#+8
   \   0000004E   0xD003             BEQ.N    ??HAL_SAI_InitProtocol_8
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xBD10             POP      {R4,PC}
   \                     ??HAL_SAI_InitProtocol_7: (+1)
   \   00000054   0x200D             MOVS     R0,#+13
   \   00000056   0xE000             B.N      ??HAL_SAI_InitProtocol_9
   \                     ??HAL_SAI_InitProtocol_8: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \                     ??HAL_SAI_InitProtocol_9: (+1)
   \   0000005A   0x2A04             CMP      R2,#+4
   \   0000005C   0x6460             STR      R0,[R4, #+68]
   \   0000005E   0xD816             BHI.N    ??HAL_SAI_InitProtocol_2
   \   00000060   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_SAI_InitProtocol_1:
   \   00000064   0x0E 0x0C          DC8      0xE,0xC,0xA,0x15
   \              0x0A 0x15    
   \   00000068   0x03 0x00          DC8      0x3,0x0
   \                     ??HAL_SAI_InitProtocol_10: (+1)
   \   0000006A   0x20E0             MOVS     R0,#+224
   \                     ??HAL_SAI_InitProtocol_11: (+1)
   \   0000006C   0x6360             STR      R0,[R4, #+52]
   \   0000006E   0x0158             LSLS     R0,R3,#+5
   \   00000070   0x6420             STR      R0,[R4, #+64]
   \   00000072   0x2080             MOVS     R0,#+128
   \   00000074   0x65A0             STR      R0,[R4, #+88]
   \   00000076   0xE7D1             B.N      ??HAL_SAI_InitProtocol_5
   \                     ??HAL_SAI_InitProtocol_12: (+1)
   \   00000078   0x20C0             MOVS     R0,#+192
   \   0000007A   0xE7F7             B.N      ??HAL_SAI_InitProtocol_11
   \                     ??HAL_SAI_InitProtocol_13: (+1)
   \   0000007C   0x2080             MOVS     R0,#+128
   \   0000007E   0xE7F5             B.N      ??HAL_SAI_InitProtocol_11
   \                     ??HAL_SAI_InitProtocol_14: (+1)
   \   00000080   0x2080             MOVS     R0,#+128
   \   00000082   0x6360             STR      R0,[R4, #+52]
   \   00000084   0x0118             LSLS     R0,R3,#+4
   \   00000086   0x6420             STR      R0,[R4, #+64]
   \   00000088   0x2040             MOVS     R0,#+64
   \   0000008A   0x65A0             STR      R0,[R4, #+88]
   \   0000008C   0xE7C6             B.N      ??HAL_SAI_InitProtocol_5
   \                     ??HAL_SAI_InitProtocol_2: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xBD10             POP      {R4,PC}
    300          }
    301          
    302          /**
    303            * @brief  Initializes the SAI according to the specified parameters 
    304            *         in the SAI_InitTypeDef and create the associated handle.
    305            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    306            *                the configuration information for SAI module.
    307            * @retval HAL status
    308            */

   \                                 In section .text, align 2, keep-with-next
    309          HAL_StatusTypeDef HAL_SAI_Init(SAI_HandleTypeDef *hsai)
    310          { 
   \                     HAL_SAI_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    311            uint32_t tmpclock = 0;
    312          
    313            /* This variable used to store the SAI_CK_x (value in Hz) */
    314            uint32_t freq = 0;
    315            
    316            uint32_t syncen_bits = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    317            
    318            /* Check the SAI handle allocation */
    319            if(hsai == NULL)
   \   00000006   0xB90C             CBNZ.N   R4,??HAL_SAI_Init_0
    320            {
    321              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD70             POP      {R4-R6,PC}
    322            }
    323            
    324            /* Check the SAI Block parameters */
    325            assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));  
    326            assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
    327            assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
    328            assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
    329            assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
    330            assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
    331            assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
    332            assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
    333            assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
    334            assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
    335            assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
    336            assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
    337            assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
    338            assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
    339            
    340            /* Check the SAI Block Frame parameters */
    341            assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
    342            assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
    343            assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
    344            assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
    345            assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
    346            
    347            /* Check the SAI Block Slot parameters */
    348            assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
    349            assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
    350            assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
    351            assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
    352            
    353            if(hsai->State == HAL_SAI_STATE_RESET)
   \                     ??HAL_SAI_Init_0: (+1)
   \   0000000C   0xF994 0x007D      LDRSB    R0,[R4, #+125]
   \   00000010   0xB920             CBNZ.N   R0,??HAL_SAI_Init_1
    354            {
    355              /* Allocate lock resource and initialize it */
    356              hsai->Lock = HAL_UNLOCKED;
   \   00000012   0xF884 0x007C      STRB     R0,[R4, #+124]
    357              
    358              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    359              HAL_SAI_MspInit(hsai);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_SAI_MspInit
    360            }
    361            
    362            hsai->State = HAL_SAI_STATE_BUSY;
   \                     ??HAL_SAI_Init_1: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xF884 0x007D      STRB     R0,[R4, #+125]
    363            
    364            /* Disable the selected SAI peripheral */
    365            SAI_Disable(hsai);
   \   00000022   0x.... 0x....      BL       HAL_GetTick
   \   00000026   0x4606             MOV      R6,R0
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SAI_Init_2: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x03C0             LSLS     R0,R0,#+15
   \   00000038   0xD50A             BPL.N    ??HAL_SAI_Init_3
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0x1B80             SUBS     R0,R0,R6
   \   00000040   0x280B             CMP      R0,#+11
   \   00000042   0xD3F6             BCC.N    ??HAL_SAI_Init_2
   \   00000044   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   00000048   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000004C   0xF8C4 0x0080      STR      R0,[R4, #+128]
    366            
    367            /* SAI Block Synchro Configuration -----------------------------------------*/
    368            SAI_BlockSynchroConfig(hsai);
   \                     ??HAL_SAI_Init_3: (+1)
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       SAI_BlockSynchroConfig
    369              
    370            /* Configure Master Clock using the following formula :
    371               MCLK_x = SAI_CK_x / (MCKDIV[3:0] * 2) with MCLK_x = 256 * FS
    372               FS = SAI_CK_x / (MCKDIV[3:0] * 2) * 256
    373               MCKDIV[3:0] = SAI_CK_x / FS * 512 */
    374            if(hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
   \   00000056   0x69E0             LDR      R0,[R4, #+28]
   \   00000058   0xB1A8             CBZ.N    R0,??HAL_SAI_Init_4
    375            { 
    376            /* Get SAI clock source based on Source clock selection from RCC */
    377            freq = SAI_GetInputClock(hsai);
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       SAI_GetInputClock
    378            
    379              /* (saiclocksource x 10) to keep Significant digits */
    380              tmpclock = (((freq * 10) / ((hsai->Init.AudioFrequency) * 512)));
   \   00000060   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   00000064   0x0048             LSLS     R0,R1,#+1
   \   00000066   0x69E1             LDR      R1,[R4, #+28]
   \   00000068   0x0249             LSLS     R1,R1,#+9
   \   0000006A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    381              
    382              hsai->Init.Mckdiv = tmpclock / 10;
   \   0000006E   0x210A             MOVS     R1,#+10
   \   00000070   0xFBB0 0xF1F1      UDIV     R1,R0,R1
    383              
    384                  /* Round result to the nearest integer */
    385              if((tmpclock % 10) > 8) 
   \   00000074   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000078   0x6221             STR      R1,[R4, #+32]
   \   0000007A   0xEBA0 0x0042      SUB      R0,R0,R2, LSL #+1
   \   0000007E   0x2809             CMP      R0,#+9
   \   00000080   0xBF24             ITT      CS 
   \   00000082   0x1C48             ADDCS    R0,R1,#+1
   \   00000084   0x6220             STRCS    R0,[R4, #+32]
    386              {
    387                hsai->Init.Mckdiv+= 1;
    388              }
    389            }
    390            
    391            /* SAI Block Configuration ------------------------------------------------------------*/
    392            switch(hsai->Init.Synchro)
   \                     ??HAL_SAI_Init_4: (+1)
   \   00000086   0x68A0             LDR      R0,[R4, #+8]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0xD005             BEQ.N    ??HAL_SAI_Init_5
   \   0000008C   0x1E40             SUBS     R0,R0,#+1
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xBF98             IT       LS 
   \   00000092   0xF44F 0x6500      MOVLS    R5,#+2048
    393            {
    394              case SAI_ASYNCHRONOUS :
    395                {
    396                  syncen_bits = 0;
    397                }
    398                break;
    399              case SAI_SYNCHRONOUS :
    400                {
    401                  syncen_bits = SAI_xCR1_SYNCEN_0;
    402                }
    403                break;
    404              case SAI_SYNCHRONOUS_EXT_SAI1 :
    405              case SAI_SYNCHRONOUS_EXT_SAI2 :  
    406                {
    407                  syncen_bits = SAI_xCR1_SYNCEN_1;
   \   00000096   0xE001             B.N      ??HAL_SAI_Init_6
    408                }
   \                     ??HAL_SAI_Init_5: (+1)
   \   00000098   0xF44F 0x6580      MOV      R5,#+1024
    409                break;
    410            }  
    411            /* SAI CR1 Configuration */
    412            hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
    413                                   SAI_xCR1_LSBFIRST | SAI_xCR1_CKSTR | SAI_xCR1_SYNCEN |\
    414                                   SAI_xCR1_MONO | SAI_xCR1_OUTDRIV  | SAI_xCR1_DMAEN |  \
    415                                   SAI_xCR1_NODIV | SAI_xCR1_MCKDIV);
   \                     ??HAL_SAI_Init_6: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x....             LDR.N    R2,??DataTable0  ;; 0xff05c010
   \   000000A0   0x6801             LDR      R1,[R0, #+0]
   \   000000A2   0x4011             ANDS     R1,R2,R1
   \   000000A4   0x6001             STR      R1,[R0, #+0]
    416          
    417            hsai->Instance->CR1|= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
    418                                  hsai->Init.DataSize | hsai->Init.FirstBit  |           \
    419                                  hsai->Init.ClockStrobing | syncen_bits |        \
    420                                  hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
    421                                  hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));  
   \   000000A6   0x6820             LDR      R0,[R4, #+0]
   \   000000A8   0x6801             LDR      R1,[R0, #+0]
   \   000000AA   0x6862             LDR      R2,[R4, #+4]
   \   000000AC   0x6B23             LDR      R3,[R4, #+48]
   \   000000AE   0x431A             ORRS     R2,R3,R2
   \   000000B0   0x6B63             LDR      R3,[R4, #+52]
   \   000000B2   0x431A             ORRS     R2,R3,R2
   \   000000B4   0x6BA3             LDR      R3,[R4, #+56]
   \   000000B6   0x431A             ORRS     R2,R3,R2
   \   000000B8   0x6BE3             LDR      R3,[R4, #+60]
   \   000000BA   0x431A             ORRS     R2,R3,R2
   \   000000BC   0x6A63             LDR      R3,[R4, #+36]
   \   000000BE   0x432A             ORRS     R2,R5,R2
   \   000000C0   0x431A             ORRS     R2,R3,R2
   \   000000C2   0x6923             LDR      R3,[R4, #+16]
   \   000000C4   0x431A             ORRS     R2,R3,R2
   \   000000C6   0x6963             LDR      R3,[R4, #+20]
   \   000000C8   0x431A             ORRS     R2,R3,R2
   \   000000CA   0x6A23             LDR      R3,[R4, #+32]
   \   000000CC   0xEA42 0x5203      ORR      R2,R2,R3, LSL #+20
   \   000000D0   0x4311             ORRS     R1,R2,R1
    422            
    423            /* SAI CR2 Configuration */
    424            hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
   \   000000D2   0x....             LDR.N    R2,??DataTable0_1  ;; 0xffff1ff0
   \   000000D4   0x6001             STR      R1,[R0, #+0]
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x6841             LDR      R1,[R0, #+4]
   \   000000DA   0x4011             ANDS     R1,R2,R1
   \   000000DC   0x6041             STR      R1,[R0, #+4]
    425            hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
   \   000000DE   0x6820             LDR      R0,[R4, #+0]
   \   000000E0   0x6841             LDR      R1,[R0, #+4]
   \   000000E2   0x69A2             LDR      R2,[R4, #+24]
   \   000000E4   0x6AA3             LDR      R3,[R4, #+40]
   \   000000E6   0x431A             ORRS     R2,R3,R2
   \   000000E8   0x6AE3             LDR      R3,[R4, #+44]
   \   000000EA   0x431A             ORRS     R2,R3,R2
   \   000000EC   0x4311             ORRS     R1,R2,R1
   \   000000EE   0x6041             STR      R1,[R0, #+4]
    426          
    427            /* SAI Frame Configuration -----------------------------------------*/
    428            hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
    429                                     SAI_xFRCR_FSPO | SAI_xFRCR_FSOFF));
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x....             LDR.N    R2,??DataTable0_2  ;; 0xfff88000
   \   000000F4   0x6881             LDR      R1,[R0, #+8]
   \   000000F6   0x4011             ANDS     R1,R2,R1
   \   000000F8   0x6081             STR      R1,[R0, #+8]
    430            hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1)  | 
    431                                      hsai->FrameInit.FSOffset | 
    432                                      hsai->FrameInit.FSDefinition | 
    433                                      hsai->FrameInit.FSPolarity   | 
    434                                      ((hsai->FrameInit.ActiveFrameLength - 1) << 8));  
   \   000000FA   0x6820             LDR      R0,[R4, #+0]
   \   000000FC   0x6881             LDR      R1,[R0, #+8]
   \   000000FE   0x6C22             LDR      R2,[R4, #+64]
   \   00000100   0x6D23             LDR      R3,[R4, #+80]
   \   00000102   0x1E52             SUBS     R2,R2,#+1
   \   00000104   0x431A             ORRS     R2,R3,R2
   \   00000106   0x6CA3             LDR      R3,[R4, #+72]
   \   00000108   0x431A             ORRS     R2,R3,R2
   \   0000010A   0x6CE3             LDR      R3,[R4, #+76]
   \   0000010C   0x431A             ORRS     R2,R3,R2
   \   0000010E   0x6C63             LDR      R3,[R4, #+68]
   \   00000110   0x1E5B             SUBS     R3,R3,#+1
   \   00000112   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   00000116   0x4311             ORRS     R1,R2,R1
    435            
    436            /* SAI Block_x SLOT Configuration ------------------------------------------*/
    437            /* This register has no meaning in AC 97 and SPDIF audio protocol */
    438            hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
    439                                       SAI_xSLOTR_NBSLOT | SAI_xSLOTR_SLOTEN ));
   \   00000118   0xF24F 0x0220      MOVW     R2,#+61472
   \   0000011C   0x6081             STR      R1,[R0, #+8]
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x68C1             LDR      R1,[R0, #+12]
   \   00000122   0x4011             ANDS     R1,R2,R1
   \   00000124   0x60C1             STR      R1,[R0, #+12]
    440            
    441            hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
    442                                    | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);           
   \   00000126   0x6820             LDR      R0,[R4, #+0]
   \   00000128   0x68C1             LDR      R1,[R0, #+12]
   \   0000012A   0x6D62             LDR      R2,[R4, #+84]
   \   0000012C   0x6DA3             LDR      R3,[R4, #+88]
   \   0000012E   0x431A             ORRS     R2,R3,R2
   \   00000130   0x6E23             LDR      R3,[R4, #+96]
   \   00000132   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \   00000136   0x6DE3             LDR      R3,[R4, #+92]
   \   00000138   0x1E5B             SUBS     R3,R3,#+1
   \   0000013A   0xEA42 0x2203      ORR      R2,R2,R3, LSL #+8
   \   0000013E   0x4311             ORRS     R1,R2,R1
   \   00000140   0x60C1             STR      R1,[R0, #+12]
    443            
    444            /* Initialize the error code */
    445            hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xF8C4 0x0080      STR      R0,[R4, #+128]
    446            
    447            /* Initialize the SAI state */
    448            hsai->State= HAL_SAI_STATE_READY;
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xF884 0x007D      STRB     R0,[R4, #+125]
    449            
    450            /* Release Lock */
    451            __HAL_UNLOCK(hsai);
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x007C      STRB     R0,[R4, #+124]
    452            
    453            return HAL_OK;
   \   00000154   0xBD70             POP      {R4-R6,PC}       ;; return
    454          }
    455          
    456          /**
    457            * @brief  DeInitializes the SAI peripheral. 
    458            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    459            *                the configuration information for SAI module.
    460            * @retval HAL status
    461            */

   \                                 In section .text, align 2, keep-with-next
    462          HAL_StatusTypeDef HAL_SAI_DeInit(SAI_HandleTypeDef *hsai)
    463          {
   \                     HAL_SAI_DeInit: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    464            /* Check the SAI handle allocation */
    465            if(hsai == NULL)
   \   00000006   0xBF08             IT       EQ 
   \   00000008   0x2001             MOVEQ    R0,#+1
    466            {
    467              return HAL_ERROR;
   \   0000000A   0xD02F             BEQ.N    ??HAL_SAI_DeInit_0
    468            }
    469          
    470            hsai->State = HAL_SAI_STATE_BUSY;
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x007D      STRB     R0,[R4, #+125]
    471          
    472            /* Disabled All interrupt and clear all the flag */
    473            hsai->Instance->IMR = 0;
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6108             STR      R0,[R1, #+16]
    474            hsai->Instance->CLRFR = 0xFFFFFFFF;
   \   00000018   0x6821             LDR      R1,[R4, #+0]
   \   0000001A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000001E   0x6188             STR      R0,[R1, #+24]
    475            
    476            /* Disable the SAI */
    477            SAI_Disable(hsai);
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x4605             MOV      R5,R0
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SAI_DeInit_1: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x03C0             LSLS     R0,R0,#+15
   \   00000036   0xD50A             BPL.N    ??HAL_SAI_DeInit_2
   \   00000038   0x.... 0x....      BL       HAL_GetTick
   \   0000003C   0x1B40             SUBS     R0,R0,R5
   \   0000003E   0x280B             CMP      R0,#+11
   \   00000040   0xD3F6             BCC.N    ??HAL_SAI_DeInit_1
   \   00000042   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   00000046   0xF040 0x0040      ORR      R0,R0,#0x40
   \   0000004A   0xF8C4 0x0080      STR      R0,[R4, #+128]
    478          
    479            /* Flush the fifo */
    480            SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
   \                     ??HAL_SAI_DeInit_2: (+1)
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6841             LDR      R1,[R0, #+4]
   \   00000052   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000056   0x6041             STR      R1,[R0, #+4]
    481            
    482            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    483            HAL_SAI_MspDeInit(hsai);
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       HAL_SAI_MspDeInit
    484          
    485            /* Initialize the error code */
    486            hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF8C4 0x0080      STR      R0,[R4, #+128]
    487            
    488            /* Initialize the SAI state */
    489            hsai->State = HAL_SAI_STATE_RESET;
   \   00000064   0xF884 0x007D      STRB     R0,[R4, #+125]
    490          
    491            /* Release Lock */
    492            __HAL_UNLOCK(hsai);
   \   00000068   0xF884 0x007C      STRB     R0,[R4, #+124]
    493          
    494            return HAL_OK;
   \                     ??HAL_SAI_DeInit_0: (+1)
   \   0000006C   0xB001             ADD      SP,SP,#+4
   \   0000006E   0xBD30             POP      {R4,R5,PC}       ;; return
    495          }
    496          
    497          /**
    498            * @brief SAI MSP Init.
    499            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    500            *                the configuration information for SAI module.
    501            * @retval None
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          __weak void HAL_SAI_MspInit(SAI_HandleTypeDef *hsai)
    504          {
    505            /* Prevent unused argument(s) compilation warning */
    506            UNUSED(hsai);
    507            
    508            /* NOTE : This function should not be modified, when the callback is needed,
    509                      the HAL_SAI_MspInit could be implemented in the user file
    510             */ 
    511          }
   \                     HAL_SAI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    512          
    513          /**
    514            * @brief SAI MSP DeInit.
    515            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    516            *                the configuration information for SAI module.
    517            * @retval None
    518            */

   \                                 In section .text, align 2, keep-with-next
    519          __weak void HAL_SAI_MspDeInit(SAI_HandleTypeDef *hsai)
    520          {
    521            /* Prevent unused argument(s) compilation warning */
    522            UNUSED(hsai);
    523            
    524            /* NOTE : This function should not be modified, when the callback is needed,
    525                      the HAL_SAI_MspDeInit could be implemented in the user file
    526             */ 
    527          }
   \                     HAL_SAI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    528          
    529          /**
    530            * @}
    531            */
    532          
    533          /** @defgroup SAI_Exported_Functions_Group2 IO operation functions 
    534           *  @brief   Data transfers functions 
    535           *
    536          @verbatim   
    537            ===============================================================================
    538                                ##### IO operation functions #####
    539           ===============================================================================  
    540              [..]
    541              This subsection provides a set of functions allowing to manage the SAI data 
    542              transfers.
    543          
    544              (+) There are two modes of transfer:
    545                 (++) Blocking mode : The communication is performed in the polling mode. 
    546                      The status of all data processing is returned by the same function 
    547                      after finishing transfer.  
    548                 (++) No-Blocking mode : The communication is performed using Interrupts 
    549                      or DMA. These functions return the status of the transfer startup.
    550                      The end of the data processing will be indicated through the 
    551                      dedicated SAI IRQ when using Interrupt mode or the DMA IRQ when 
    552                      using DMA mode.
    553          
    554              (+) Blocking mode functions are :
    555                  (++) HAL_SAI_Transmit()
    556                  (++) HAL_SAI_Receive()
    557                  (++) HAL_SAI_TransmitReceive()
    558                  
    559              (+) Non Blocking mode functions with Interrupt are :
    560                  (++) HAL_SAI_Transmit_IT()
    561                  (++) HAL_SAI_Receive_IT()
    562                  (++) HAL_SAI_TransmitReceive_IT()
    563          
    564              (+) Non Blocking mode functions with DMA are :
    565                  (++) HAL_SAI_Transmit_DMA()
    566                  (++) HAL_SAI_Receive_DMA()
    567                  (++) HAL_SAI_TransmitReceive_DMA()
    568          
    569              (+) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    570                  (++) HAL_SAI_TxCpltCallback()
    571                  (++) HAL_SAI_RxCpltCallback()
    572                  (++) HAL_SAI_ErrorCallback()
    573          
    574          @endverbatim
    575            * @{
    576            */
    577          
    578          /**
    579            * @brief  Transmits an amount of data in blocking mode.
    580            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    581            *                the configuration information for SAI module.
    582            * @param  pData: Pointer to data buffer
    583            * @param  Size: Amount of data to be sent
    584            * @param  Timeout: Timeout duration
    585            * @retval HAL status
    586            */

   \                                 In section .text, align 2, keep-with-next
    587          HAL_StatusTypeDef HAL_SAI_Transmit(SAI_HandleTypeDef *hsai, uint8_t* pData, uint16_t Size, uint32_t Timeout)
    588          {
   \                     HAL_SAI_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461D             MOV      R5,R3
    589            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
    590            
    591            if((pData == NULL ) || (Size == 0)) 
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0x4606             MOV      R6,R0
   \   00000014   0xBF14             ITE      NE 
   \   00000016   0xF1B8 0x0F00      CMPNE    R8,#+0
   \   0000001A   0x2001             MOVEQ    R0,#+1
    592            {
    593              return  HAL_ERROR;
   \   0000001C   0xD067             BEQ.N    ??HAL_SAI_Transmit_0
    594            }
    595            
    596            if(hsai->State == HAL_SAI_STATE_READY)
   \   0000001E   0xF994 0x007D      LDRSB    R0,[R4, #+125]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD162             BNE.N    ??HAL_SAI_Transmit_1
    597            {  
    598              /* Process Locked */
    599              __HAL_LOCK(hsai);
   \   00000026   0xF994 0x007C      LDRSB    R0,[R4, #+124]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD05E             BEQ.N    ??HAL_SAI_Transmit_1
   \   0000002E   0x2001             MOVS     R0,#+1
    600              
    601              hsai->XferSize = Size;
   \   00000030   0xF8A4 0x8068      STRH     R8,[R4, #+104]
   \   00000034   0xF884 0x007C      STRB     R0,[R4, #+124]
    602              hsai->XferCount = Size;
    603              hsai->pBuffPtr = pData;
    604              hsai->State = HAL_SAI_STATE_BUSY_TX;
   \   00000038   0x2012             MOVS     R0,#+18
   \   0000003A   0xF8A4 0x806A      STRH     R8,[R4, #+106]
   \   0000003E   0x6667             STR      R7,[R4, #+100]
   \   00000040   0xF884 0x007D      STRB     R0,[R4, #+125]
    605              hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8C4 0x0080      STR      R0,[R4, #+128]
    606              
    607              /* Check if the SAI is already enabled */ 
    608              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x03C0             LSLS     R0,R0,#+15
   \   00000050   0xD413             BMI.N    ??HAL_SAI_Transmit_2
    609              {
    610                /* fill the fifo with data before to enabled the SAI */
    611                SAI_FillFifo(hsai);      
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       SAI_FillFifo
    612                /* Enable SAI peripheral */    
    613                __HAL_SAI_ENABLE(hsai);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000060   0x6001             STR      R1,[R0, #+0]
   \   00000062   0xE00A             B.N      ??HAL_SAI_Transmit_2
    614              }
    615              
    616              while(hsai->XferCount > 0)
    617              { 
    618                /* Write data if the FIFO is not full */
    619                if((hsai->Instance->SR & SAI_xSR_FLVL) != SAI_FIFOSTATUS_FULL)
    620                {
    621                  if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
    622                  {      
    623                    hsai->Instance->DR = (*hsai->pBuffPtr++);
    624                  }
    625                  else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
    626                  {
    627                    hsai->Instance->DR = *((uint16_t *)hsai->pBuffPtr);
    628                    hsai->pBuffPtr+= 2;        
    629                  }
    630                  else
    631                  {
    632                    hsai->Instance->DR = *((uint32_t *)hsai->pBuffPtr);
   \                     ??HAL_SAI_Transmit_3: (+1)
   \   00000064   0x6E61             LDR      R1,[R4, #+100]
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x61C1             STR      R1,[R0, #+28]
    633                    hsai->pBuffPtr+= 4;
   \   0000006A   0x6E60             LDR      R0,[R4, #+100]
   \   0000006C   0x1D00             ADDS     R0,R0,#+4
   \                     ??HAL_SAI_Transmit_4: (+1)
   \   0000006E   0x6660             STR      R0,[R4, #+100]
    634                  }       
    635                  hsai->XferCount--; 
   \                     ??HAL_SAI_Transmit_5: (+1)
   \   00000070   0xF8B4 0x006A      LDRH     R0,[R4, #+106]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0xF8A4 0x006A      STRH     R0,[R4, #+106]
   \                     ??HAL_SAI_Transmit_2: (+1)
   \   0000007A   0xF8B4 0x006A      LDRH     R0,[R4, #+106]
   \   0000007E   0xB368             CBZ.N    R0,??HAL_SAI_Transmit_6
   \                     ??HAL_SAI_Transmit_7: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6941             LDR      R1,[R0, #+20]
   \   00000084   0xF401 0x21E0      AND      R1,R1,#0x70000
   \   00000088   0xF5B1 0x2FA0      CMP      R1,#+327680
   \   0000008C   0xD012             BEQ.N    ??HAL_SAI_Transmit_8
   \   0000008E   0x6B61             LDR      R1,[R4, #+52]
   \   00000090   0x2940             CMP      R1,#+64
   \   00000092   0xD107             BNE.N    ??HAL_SAI_Transmit_9
   \   00000094   0x6AA1             LDR      R1,[R4, #+40]
   \   00000096   0xB939             CBNZ.N   R1,??HAL_SAI_Transmit_10
   \   00000098   0x6E61             LDR      R1,[R4, #+100]
   \   0000009A   0x1C4A             ADDS     R2,R1,#+1
   \   0000009C   0x6662             STR      R2,[R4, #+100]
   \   0000009E   0x7809             LDRB     R1,[R1, #+0]
   \   000000A0   0x61C1             STR      R1,[R0, #+28]
   \   000000A2   0xE7E5             B.N      ??HAL_SAI_Transmit_5
   \                     ??HAL_SAI_Transmit_9: (+1)
   \   000000A4   0x2981             CMP      R1,#+129
   \   000000A6   0xD2DD             BCS.N    ??HAL_SAI_Transmit_3
   \                     ??HAL_SAI_Transmit_10: (+1)
   \   000000A8   0x6E61             LDR      R1,[R4, #+100]
   \   000000AA   0x8809             LDRH     R1,[R1, #+0]
   \   000000AC   0x61C1             STR      R1,[R0, #+28]
   \   000000AE   0x6E60             LDR      R0,[R4, #+100]
   \   000000B0   0x1C80             ADDS     R0,R0,#+2
   \   000000B2   0xE7DC             B.N      ??HAL_SAI_Transmit_4
    636                }
    637                else
    638                {
    639                  /* Check for the Timeout */
    640                  if((Timeout != HAL_MAX_DELAY) && ((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout)))
   \                     ??HAL_SAI_Transmit_8: (+1)
   \   000000B4   0xF115 0x0F01      CMN      R5,#+1
   \   000000B8   0xD0E2             BEQ.N    ??HAL_SAI_Transmit_7
   \   000000BA   0xB125             CBZ.N    R5,??HAL_SAI_Transmit_11
   \   000000BC   0x.... 0x....      BL       HAL_GetTick
   \   000000C0   0x1B80             SUBS     R0,R0,R6
   \   000000C2   0x4285             CMP      R5,R0
   \   000000C4   0xD2D9             BCS.N    ??HAL_SAI_Transmit_2
    641                  {
    642                    /* Update error code */
    643                    hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   \                     ??HAL_SAI_Transmit_11: (+1)
   \   000000C6   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   000000CA   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000CE   0xF8C4 0x0080      STR      R0,[R4, #+128]
    644                    /* Change the SAI state */
    645                    hsai->State = HAL_SAI_STATE_TIMEOUT;
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0xF884 0x007D      STRB     R0,[R4, #+125]
    646                    
    647                    return HAL_TIMEOUT;
   \   000000D8   0xE8BD 0x81F0      POP      {R4-R8,PC}
    648                  }
    649                }
    650              }      
    651              
    652              hsai->State = HAL_SAI_STATE_READY; 
   \                     ??HAL_SAI_Transmit_6: (+1)
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xF884 0x007D      STRB     R0,[R4, #+125]
    653              
    654              /* Process Unlocked */
    655              __HAL_UNLOCK(hsai);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF884 0x007C      STRB     R0,[R4, #+124]
    656              
    657              return HAL_OK;
   \   000000E8   0xE8BD 0x81F0      POP      {R4-R8,PC}
    658            }
    659            else
    660            {
    661              return HAL_BUSY;
   \                     ??HAL_SAI_Transmit_1: (+1)
   \   000000EC   0x2002             MOVS     R0,#+2
   \                     ??HAL_SAI_Transmit_0: (+1)
   \   000000EE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    662            }
    663          }
    664          
    665          /**
    666            * @brief  Receives an amount of data in blocking mode. 
    667            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    668            *                the configuration information for SAI module.
    669            * @param  pData: Pointer to data buffer
    670            * @param  Size: Amount of data to be received
    671            * @param  Timeout: Timeout duration
    672            * @retval HAL status
    673            */

   \                                 In section .text, align 2, keep-with-next
    674          HAL_StatusTypeDef HAL_SAI_Receive(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    675          {
   \                     HAL_SAI_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461D             MOV      R5,R3
    676            uint32_t tickstart = HAL_GetTick();
   \   0000000C   0x.... 0x....      BL       HAL_GetTick
    677            
    678            if((pData == NULL ) || (Size == 0)) 
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0x4606             MOV      R6,R0
   \   00000014   0xBF14             ITE      NE 
   \   00000016   0xF1B8 0x0F00      CMPNE    R8,#+0
   \   0000001A   0x2001             MOVEQ    R0,#+1
    679            {
    680              return  HAL_ERROR;
   \   0000001C   0xD062             BEQ.N    ??HAL_SAI_Receive_0
    681            }
    682            
    683            if(hsai->State == HAL_SAI_STATE_READY)
   \   0000001E   0xF994 0x007D      LDRSB    R0,[R4, #+125]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD15D             BNE.N    ??HAL_SAI_Receive_1
    684            { 
    685              /* Process Locked */
    686              __HAL_LOCK(hsai);
   \   00000026   0xF994 0x007C      LDRSB    R0,[R4, #+124]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD059             BEQ.N    ??HAL_SAI_Receive_1
   \   0000002E   0x2001             MOVS     R0,#+1
    687              
    688              hsai->pBuffPtr = pData;
   \   00000030   0x6667             STR      R7,[R4, #+100]
   \   00000032   0xF884 0x007C      STRB     R0,[R4, #+124]
    689              hsai->XferSize = Size;
    690              hsai->XferCount = Size;
    691              hsai->State = HAL_SAI_STATE_BUSY_RX;
   \   00000036   0x2022             MOVS     R0,#+34
   \   00000038   0xF8A4 0x8068      STRH     R8,[R4, #+104]
   \   0000003C   0xF8A4 0x806A      STRH     R8,[R4, #+106]
   \   00000040   0xF884 0x007D      STRB     R0,[R4, #+125]
    692              hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8C4 0x0080      STR      R0,[R4, #+128]
    693              
    694              /* Check if the SAI is already enabled */ 
    695              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0x03C9             LSLS     R1,R1,#+15
   \   00000050   0xD40F             BMI.N    ??HAL_SAI_Receive_2
    696              {
    697                /* Enable SAI peripheral */    
    698                __HAL_SAI_ENABLE(hsai);
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000058   0x6001             STR      R1,[R0, #+0]
   \   0000005A   0xE00A             B.N      ??HAL_SAI_Receive_2
    699              }
    700              
    701              /* Receive data */
    702              while(hsai->XferCount > 0)
    703              {      
    704                if((hsai->Instance->SR & SAI_xSR_FLVL) != SAI_FIFOSTATUS_EMPTY)
    705                {
    706                  if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
    707                  {
    708                    (*hsai->pBuffPtr++) = hsai->Instance->DR;
    709                  }
    710                  else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
    711                  {
    712                    *((uint16_t*)hsai->pBuffPtr) = hsai->Instance->DR;
    713                    hsai->pBuffPtr+= 2;
    714                  }
    715                  else
    716                  {
    717                    *((uint32_t*)hsai->pBuffPtr) = hsai->Instance->DR;
   \                     ??HAL_SAI_Receive_3: (+1)
   \   0000005C   0x69C0             LDR      R0,[R0, #+28]
   \   0000005E   0x6E61             LDR      R1,[R4, #+100]
   \   00000060   0x6008             STR      R0,[R1, #+0]
    718                    hsai->pBuffPtr+= 4;
   \   00000062   0x6E60             LDR      R0,[R4, #+100]
   \   00000064   0x1D00             ADDS     R0,R0,#+4
   \                     ??HAL_SAI_Receive_4: (+1)
   \   00000066   0x6660             STR      R0,[R4, #+100]
    719                  }  
    720                  hsai->XferCount--; 
   \                     ??HAL_SAI_Receive_5: (+1)
   \   00000068   0xF8B4 0x006A      LDRH     R0,[R4, #+106]
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0xF8A4 0x006A      STRH     R0,[R4, #+106]
   \                     ??HAL_SAI_Receive_2: (+1)
   \   00000072   0xF8B4 0x006A      LDRH     R0,[R4, #+106]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0xD02A             BEQ.N    ??HAL_SAI_Receive_6
   \                     ??HAL_SAI_Receive_7: (+1)
   \   0000007C   0x6941             LDR      R1,[R0, #+20]
   \   0000007E   0xF411 0x2FE0      TST      R1,#0x70000
   \   00000082   0xD012             BEQ.N    ??HAL_SAI_Receive_8
   \   00000084   0x6B61             LDR      R1,[R4, #+52]
   \   00000086   0x2940             CMP      R1,#+64
   \   00000088   0xD107             BNE.N    ??HAL_SAI_Receive_9
   \   0000008A   0x6AA1             LDR      R1,[R4, #+40]
   \   0000008C   0xB939             CBNZ.N   R1,??HAL_SAI_Receive_10
   \   0000008E   0x6E61             LDR      R1,[R4, #+100]
   \   00000090   0x1C4A             ADDS     R2,R1,#+1
   \   00000092   0x6662             STR      R2,[R4, #+100]
   \   00000094   0x69C0             LDR      R0,[R0, #+28]
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   \   00000098   0xE7E6             B.N      ??HAL_SAI_Receive_5
   \                     ??HAL_SAI_Receive_9: (+1)
   \   0000009A   0x2981             CMP      R1,#+129
   \   0000009C   0xD2DE             BCS.N    ??HAL_SAI_Receive_3
   \                     ??HAL_SAI_Receive_10: (+1)
   \   0000009E   0x69C0             LDR      R0,[R0, #+28]
   \   000000A0   0x6E61             LDR      R1,[R4, #+100]
   \   000000A2   0x8008             STRH     R0,[R1, #+0]
   \   000000A4   0x6E60             LDR      R0,[R4, #+100]
   \   000000A6   0x1C80             ADDS     R0,R0,#+2
   \   000000A8   0xE7DD             B.N      ??HAL_SAI_Receive_4
    721                }
    722                else
    723                {
    724                  /* Check for the Timeout */
    725                  if((Timeout != HAL_MAX_DELAY) && ((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout)))
   \                     ??HAL_SAI_Receive_8: (+1)
   \   000000AA   0xF115 0x0F01      CMN      R5,#+1
   \   000000AE   0xD0E5             BEQ.N    ??HAL_SAI_Receive_7
   \   000000B0   0xB125             CBZ.N    R5,??HAL_SAI_Receive_11
   \   000000B2   0x.... 0x....      BL       HAL_GetTick
   \   000000B6   0x1B80             SUBS     R0,R0,R6
   \   000000B8   0x4285             CMP      R5,R0
   \   000000BA   0xD2DA             BCS.N    ??HAL_SAI_Receive_2
    726                  {
    727                    /* Update error code */
    728                    hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   \                     ??HAL_SAI_Receive_11: (+1)
   \   000000BC   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   000000C0   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000C4   0xF8C4 0x0080      STR      R0,[R4, #+128]
    729                    /* Change the SAI state */
    730                    hsai->State = HAL_SAI_STATE_TIMEOUT;
   \   000000C8   0x2003             MOVS     R0,#+3
   \   000000CA   0xF884 0x007D      STRB     R0,[R4, #+125]
    731                    
    732                    return HAL_TIMEOUT;
   \   000000CE   0xE8BD 0x81F0      POP      {R4-R8,PC}
    733                  }
    734                }
    735              }      
    736              
    737              hsai->State = HAL_SAI_STATE_READY; 
   \                     ??HAL_SAI_Receive_6: (+1)
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF884 0x007D      STRB     R0,[R4, #+125]
    738              
    739              /* Process Unlocked */
    740              __HAL_UNLOCK(hsai);
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x007C      STRB     R0,[R4, #+124]
    741              
    742              return HAL_OK;
   \   000000DE   0xE8BD 0x81F0      POP      {R4-R8,PC}
    743            }
    744            else
    745            {
    746              return HAL_BUSY;
   \                     ??HAL_SAI_Receive_1: (+1)
   \   000000E2   0x2002             MOVS     R0,#+2
   \                     ??HAL_SAI_Receive_0: (+1)
   \   000000E4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    747            }
    748          }
    749          
    750          /**
    751            * @brief  Transmits an amount of data in no-blocking mode with Interrupt.
    752            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    753            *                the configuration information for SAI module.
    754            * @param  pData: Pointer to data buffer
    755            * @param  Size: Amount of data to be sent
    756            * @retval HAL status
    757            */

   \                                 In section .text, align 2, keep-with-next
    758          HAL_StatusTypeDef HAL_SAI_Transmit_IT(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
    759          {
    760              if((pData == NULL) || (Size == 0)) 
   \                     HAL_SAI_Transmit_IT: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2A00             CMPNE    R2,#+0
   \   00000006   0xD101             BNE.N    ??HAL_SAI_Transmit_IT_0
    761              {
    762                return  HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
    763              }
    764              
    765            if(hsai->State == HAL_SAI_STATE_READY)
   \                     ??HAL_SAI_Transmit_IT_0: (+1)
   \   0000000C   0xF990 0x307D      LDRSB    R3,[R0, #+125]
   \   00000010   0x2B01             CMP      R3,#+1
   \   00000012   0xD173             BNE.N    ??HAL_SAI_Transmit_IT_1
    766            {    
    767              /* Process Locked */
    768              __HAL_LOCK(hsai);
   \   00000014   0xF990 0x307C      LDRSB    R3,[R0, #+124]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD06F             BEQ.N    ??HAL_SAI_Transmit_IT_1
   \   0000001C   0x2301             MOVS     R3,#+1
    769              
    770              hsai->pBuffPtr = pData;
   \   0000001E   0x6641             STR      R1,[R0, #+100]
   \   00000020   0xF880 0x307C      STRB     R3,[R0, #+124]
    771              hsai->XferSize = Size;
    772              hsai->XferCount = Size;
    773              hsai->ErrorCode = HAL_SAI_ERROR_NONE;    
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xF8A0 0x2068      STRH     R2,[R0, #+104]
   \   0000002A   0xF8A0 0x206A      STRH     R2,[R0, #+106]
   \   0000002E   0xF8C0 0x1080      STR      R1,[R0, #+128]
    774              hsai->State = HAL_SAI_STATE_BUSY_TX;
   \   00000032   0x2112             MOVS     R1,#+18
   \   00000034   0xF880 0x107D      STRB     R1,[R0, #+125]
    775              
    776              if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
   \   00000038   0x6B41             LDR      R1,[R0, #+52]
   \   0000003A   0x2940             CMP      R1,#+64
   \   0000003C   0xD105             BNE.N    ??HAL_SAI_Transmit_IT_2
   \   0000003E   0x6A81             LDR      R1,[R0, #+40]
   \   00000040   0xB929             CBNZ.N   R1,??HAL_SAI_Transmit_IT_3
    777              {
    778                hsai->InterruptServiceRoutine = SAI_Transmit_IT8Bit;
   \   00000042   0x.... 0x....      ADR.W    R1,SAI_Transmit_IT8Bit
   \   00000046   0x6781             STR      R1,[R0, #+120]
   \   00000048   0xE014             B.N      ??HAL_SAI_Transmit_IT_4
    779              }
    780              else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
   \                     ??HAL_SAI_Transmit_IT_2: (+1)
   \   0000004A   0x2981             CMP      R1,#+129
   \   0000004C   0xD203             BCS.N    ??HAL_SAI_Transmit_IT_5
    781              {
    782                hsai->InterruptServiceRoutine = SAI_Transmit_IT16Bit;
   \                     ??HAL_SAI_Transmit_IT_3: (+1)
   \   0000004E   0x.... 0x....      ADR.W    R1,SAI_Transmit_IT16Bit
   \   00000052   0x6781             STR      R1,[R0, #+120]
   \   00000054   0xE00E             B.N      ??HAL_SAI_Transmit_IT_4
    783              }
    784              else
    785              {
    786                hsai->InterruptServiceRoutine = SAI_Transmit_IT32Bit;
   \                     ??HAL_SAI_Transmit_IT_5: (+1)
   \   00000056   0x.... 0x....      ADR.W    R1,SAI_Transmit_IT32Bit
   \   0000005A   0x6781             STR      R1,[R0, #+120]
   \   0000005C   0xE00A             B.N      ??HAL_SAI_Transmit_IT_4
   \                     ??HAL_SAI_Transmit_IT_6: (+1)
   \   0000005E   0x6E42             LDR      R2,[R0, #+100]
   \   00000060   0x6812             LDR      R2,[R2, #+0]
   \   00000062   0x61CA             STR      R2,[R1, #+28]
   \   00000064   0x6E41             LDR      R1,[R0, #+100]
   \   00000066   0x1D09             ADDS     R1,R1,#+4
   \                     ??HAL_SAI_Transmit_IT_7: (+1)
   \   00000068   0x6641             STR      R1,[R0, #+100]
   \                     ??HAL_SAI_Transmit_IT_8: (+1)
   \   0000006A   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   0000006E   0x1E49             SUBS     R1,R1,#+1
   \   00000070   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   \                     ??HAL_SAI_Transmit_IT_4: (+1)
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x694A             LDR      R2,[R1, #+20]
   \   00000078   0xF402 0x22E0      AND      R2,R2,#0x70000
   \   0000007C   0xF5B2 0x2FA0      CMP      R2,#+327680
   \   00000080   0xBF1C             ITT      NE 
   \   00000082   0xF8B0 0x206A      LDRHNE   R2,[R0, #+106]
   \   00000086   0x2A00             CMPNE    R2,#+0
   \   00000088   0xD012             BEQ.N    ??HAL_SAI_Transmit_IT_9
   \   0000008A   0x6B42             LDR      R2,[R0, #+52]
   \   0000008C   0x2A40             CMP      R2,#+64
   \   0000008E   0xD107             BNE.N    ??HAL_SAI_Transmit_IT_10
   \   00000090   0x6A82             LDR      R2,[R0, #+40]
   \   00000092   0xB93A             CBNZ.N   R2,??HAL_SAI_Transmit_IT_11
   \   00000094   0x6E42             LDR      R2,[R0, #+100]
   \   00000096   0x1C53             ADDS     R3,R2,#+1
   \   00000098   0x6643             STR      R3,[R0, #+100]
   \   0000009A   0x7812             LDRB     R2,[R2, #+0]
   \   0000009C   0x61CA             STR      R2,[R1, #+28]
   \   0000009E   0xE7E4             B.N      ??HAL_SAI_Transmit_IT_8
   \                     ??HAL_SAI_Transmit_IT_10: (+1)
   \   000000A0   0x2A81             CMP      R2,#+129
   \   000000A2   0xD2DC             BCS.N    ??HAL_SAI_Transmit_IT_6
   \                     ??HAL_SAI_Transmit_IT_11: (+1)
   \   000000A4   0x6E42             LDR      R2,[R0, #+100]
   \   000000A6   0x6812             LDR      R2,[R2, #+0]
   \   000000A8   0x61CA             STR      R2,[R1, #+28]
   \   000000AA   0x6E41             LDR      R1,[R0, #+100]
   \   000000AC   0x1C89             ADDS     R1,R1,#+2
   \   000000AE   0xE7DB             B.N      ??HAL_SAI_Transmit_IT_7
    787              }
    788              
    789              /* Fill the fifo before starting the communication */
    790              SAI_FillFifo(hsai);
    791              
    792              /* Enable FRQ and OVRUDR interrupts */
    793              __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \                     ??HAL_SAI_Transmit_IT_9: (+1)
   \   000000B0   0x6B03             LDR      R3,[R0, #+48]
   \   000000B2   0x2209             MOVS     R2,#+9
   \   000000B4   0x2B08             CMP      R3,#+8
   \   000000B6   0xD119             BNE.N    ??HAL_SAI_Transmit_IT_12
   \   000000B8   0x6843             LDR      R3,[R0, #+4]
   \   000000BA   0x2B03             CMP      R3,#+3
   \   000000BC   0xD112             BNE.N    ??HAL_SAI_Transmit_IT_13
   \   000000BE   0x2219             MOVS     R2,#+25
   \                     ??HAL_SAI_Transmit_IT_14: (+1)
   \   000000C0   0xF042 0x0260      ORR      R2,R2,#0x60
   \                     ??HAL_SAI_Transmit_IT_15: (+1)
   \   000000C4   0x690B             LDR      R3,[R1, #+16]
   \   000000C6   0x431A             ORRS     R2,R2,R3
   \   000000C8   0x610A             STR      R2,[R1, #+16]
    794              
    795              /* Check if the SAI is already enabled */ 
    796              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   000000CA   0x6801             LDR      R1,[R0, #+0]
   \   000000CC   0x680A             LDR      R2,[R1, #+0]
   \   000000CE   0x03D2             LSLS     R2,R2,#+15
   \   000000D0   0xD403             BMI.N    ??HAL_SAI_Transmit_IT_16
    797              {      
    798                /* Enable SAI peripheral */    
    799                __HAL_SAI_ENABLE(hsai);
   \   000000D2   0x680A             LDR      R2,[R1, #+0]
   \   000000D4   0xF442 0x3280      ORR      R2,R2,#0x10000
   \   000000D8   0x600A             STR      R2,[R1, #+0]
    800              }
    801              /* Process Unlocked */
    802              __HAL_UNLOCK(hsai);
   \                     ??HAL_SAI_Transmit_IT_16: (+1)
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0xF880 0x107C      STRB     R1,[R0, #+124]
    803              
    804              return HAL_OK;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x4770             BX       LR
   \                     ??HAL_SAI_Transmit_IT_13: (+1)
   \   000000E4   0x2B01             CMP      R3,#+1
   \   000000E6   0xBF08             IT       EQ 
   \   000000E8   0x2219             MOVEQ    R2,#+25
   \   000000EA   0xD004             BEQ.N    ??HAL_SAI_Transmit_IT_17
   \                     ??HAL_SAI_Transmit_IT_12: (+1)
   \   000000EC   0x6843             LDR      R3,[R0, #+4]
   \   000000EE   0x2B03             CMP      R3,#+3
   \   000000F0   0xBF18             IT       NE 
   \   000000F2   0x2B02             CMPNE    R3,#+2
   \   000000F4   0xD0E4             BEQ.N    ??HAL_SAI_Transmit_IT_14
   \                     ??HAL_SAI_Transmit_IT_17: (+1)
   \   000000F6   0xF042 0x0204      ORR      R2,R2,#0x4
   \   000000FA   0xE7E3             B.N      ??HAL_SAI_Transmit_IT_15
    805            }
    806            else
    807            {
    808              return HAL_BUSY;
   \                     ??HAL_SAI_Transmit_IT_1: (+1)
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0x4770             BX       LR               ;; return
    809            }
    810          }
    811          
    812          /**
    813            * @brief  Receives an amount of data in no-blocking mode with Interrupt.
    814            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    815            *                the configuration information for SAI module.
    816            * @param  pData: Pointer to data buffer
    817            * @param  Size: Amount of data to be received
    818            * @retval HAL status
    819            */

   \                                 In section .text, align 2, keep-with-next
    820          HAL_StatusTypeDef HAL_SAI_Receive_IT(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
    821          {
    822              if((pData == NULL) || (Size == 0)) 
   \                     HAL_SAI_Receive_IT: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2A00             CMPNE    R2,#+0
   \   00000006   0xD101             BNE.N    ??HAL_SAI_Receive_IT_0
    823              {
    824                return  HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
    825              }
    826              
    827            if(hsai->State == HAL_SAI_STATE_READY)
   \                     ??HAL_SAI_Receive_IT_0: (+1)
   \   0000000C   0xF990 0x307D      LDRSB    R3,[R0, #+125]
   \   00000010   0x2B01             CMP      R3,#+1
   \   00000012   0xD148             BNE.N    ??HAL_SAI_Receive_IT_1
    828            {   
    829              /* Process Locked */
    830              __HAL_LOCK(hsai);
   \   00000014   0xF990 0x307C      LDRSB    R3,[R0, #+124]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD044             BEQ.N    ??HAL_SAI_Receive_IT_1
   \   0000001C   0x2301             MOVS     R3,#+1
    831              
    832              hsai->pBuffPtr = pData;
   \   0000001E   0x6641             STR      R1,[R0, #+100]
   \   00000020   0xF880 0x307C      STRB     R3,[R0, #+124]
    833              hsai->XferSize = Size;
    834              hsai->XferCount = Size;
    835              hsai->ErrorCode = HAL_SAI_ERROR_NONE;    
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xF8A0 0x2068      STRH     R2,[R0, #+104]
   \   0000002A   0xF8A0 0x206A      STRH     R2,[R0, #+106]
   \   0000002E   0xF8C0 0x1080      STR      R1,[R0, #+128]
    836              hsai->State = HAL_SAI_STATE_BUSY_RX;
   \   00000032   0x2122             MOVS     R1,#+34
   \   00000034   0xF880 0x107D      STRB     R1,[R0, #+125]
    837              
    838              if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
   \   00000038   0x6B41             LDR      R1,[R0, #+52]
   \   0000003A   0x2940             CMP      R1,#+64
   \   0000003C   0xD104             BNE.N    ??HAL_SAI_Receive_IT_2
   \   0000003E   0x6A81             LDR      R1,[R0, #+40]
   \   00000040   0xB921             CBNZ.N   R1,??HAL_SAI_Receive_IT_3
    839              {
    840                hsai->InterruptServiceRoutine = SAI_Receive_IT8Bit;
   \   00000042   0x.... 0x....      ADR.W    R1,SAI_Receive_IT8Bit
   \   00000046   0xE006             B.N      ??HAL_SAI_Receive_IT_4
    841              }
    842              else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
   \                     ??HAL_SAI_Receive_IT_2: (+1)
   \   00000048   0x2981             CMP      R1,#+129
   \   0000004A   0xD202             BCS.N    ??HAL_SAI_Receive_IT_5
    843              {
    844                hsai->InterruptServiceRoutine = SAI_Receive_IT16Bit;
   \                     ??HAL_SAI_Receive_IT_3: (+1)
   \   0000004C   0x.... 0x....      ADR.W    R1,SAI_Receive_IT16Bit
   \   00000050   0xE001             B.N      ??HAL_SAI_Receive_IT_4
    845              }
    846              else
    847              {
    848                hsai->InterruptServiceRoutine = SAI_Receive_IT32Bit;
   \                     ??HAL_SAI_Receive_IT_5: (+1)
   \   00000052   0x.... 0x....      ADR.W    R1,SAI_Receive_IT32Bit
   \                     ??HAL_SAI_Receive_IT_4: (+1)
   \   00000056   0x6781             STR      R1,[R0, #+120]
    849              }
    850              
    851              /* Enable TXE and OVRUDR interrupts */
    852              __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \   00000058   0x6B02             LDR      R2,[R0, #+48]
   \   0000005A   0x2109             MOVS     R1,#+9
   \   0000005C   0x2A08             CMP      R2,#+8
   \   0000005E   0xD11A             BNE.N    ??HAL_SAI_Receive_IT_6
   \   00000060   0x6842             LDR      R2,[R0, #+4]
   \   00000062   0x2A03             CMP      R2,#+3
   \   00000064   0xD113             BNE.N    ??HAL_SAI_Receive_IT_7
   \   00000066   0x2119             MOVS     R1,#+25
   \                     ??HAL_SAI_Receive_IT_8: (+1)
   \   00000068   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??HAL_SAI_Receive_IT_9: (+1)
   \   0000006C   0x6802             LDR      R2,[R0, #+0]
   \   0000006E   0x6913             LDR      R3,[R2, #+16]
   \   00000070   0x4319             ORRS     R1,R1,R3
   \   00000072   0x6111             STR      R1,[R2, #+16]
    853              
    854              /* Check if the SAI is already enabled */ 
    855              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x680A             LDR      R2,[R1, #+0]
   \   00000078   0x03D2             LSLS     R2,R2,#+15
   \   0000007A   0xD403             BMI.N    ??HAL_SAI_Receive_IT_10
    856              {
    857                /* Enable SAI peripheral */    
    858                __HAL_SAI_ENABLE(hsai);
   \   0000007C   0x680A             LDR      R2,[R1, #+0]
   \   0000007E   0xF442 0x3280      ORR      R2,R2,#0x10000
   \   00000082   0x600A             STR      R2,[R1, #+0]
    859              }
    860              
    861              /* Process Unlocked */
    862              __HAL_UNLOCK(hsai);
   \                     ??HAL_SAI_Receive_IT_10: (+1)
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0xF880 0x107C      STRB     R1,[R0, #+124]
    863              
    864              return HAL_OK;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x4770             BX       LR
   \                     ??HAL_SAI_Receive_IT_7: (+1)
   \   0000008E   0x2A01             CMP      R2,#+1
   \   00000090   0xBF08             IT       EQ 
   \   00000092   0x2119             MOVEQ    R1,#+25
   \   00000094   0xD004             BEQ.N    ??HAL_SAI_Receive_IT_11
   \                     ??HAL_SAI_Receive_IT_6: (+1)
   \   00000096   0x6842             LDR      R2,[R0, #+4]
   \   00000098   0x2A03             CMP      R2,#+3
   \   0000009A   0xBF18             IT       NE 
   \   0000009C   0x2A02             CMPNE    R2,#+2
   \   0000009E   0xD0E3             BEQ.N    ??HAL_SAI_Receive_IT_8
   \                     ??HAL_SAI_Receive_IT_11: (+1)
   \   000000A0   0xF041 0x0104      ORR      R1,R1,#0x4
   \   000000A4   0xE7E2             B.N      ??HAL_SAI_Receive_IT_9
    865            }
    866            else
    867            {
    868              return HAL_BUSY; 
   \                     ??HAL_SAI_Receive_IT_1: (+1)
   \   000000A6   0x2002             MOVS     R0,#+2
   \   000000A8   0x4770             BX       LR               ;; return
    869            } 
    870          }
    871          
    872          /**
    873            * @brief Pauses the audio stream playing from the Media.
    874            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    875            *                the configuration information for SAI module.
    876            * @retval HAL status
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          HAL_StatusTypeDef HAL_SAI_DMAPause(SAI_HandleTypeDef *hsai)
    879          {
    880            /* Process Locked */
    881            __HAL_LOCK(hsai);
   \                     HAL_SAI_DMAPause: (+1)
   \   00000000   0xF990 0x107C      LDRSB    R1,[R0, #+124]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SAI_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SAI_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x107C      STRB     R1,[R0, #+124]
    882            
    883            /* Pause the audio file playing by disabling the SAI DMA requests */
    884            hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0xF422 0x3200      BIC      R2,R2,#0x20000
   \   0000001A   0x600A             STR      R2,[R1, #+0]
    885          
    886            /* Process Unlocked */
    887            __HAL_UNLOCK(hsai);
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xF880 0x107C      STRB     R1,[R0, #+124]
    888            
    889            return HAL_OK; 
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
    890          }
    891          
    892          /**
    893            * @brief Resumes the audio stream playing from the Media.
    894            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
    895            *                the configuration information for SAI module.
    896            * @retval HAL status
    897            */

   \                                 In section .text, align 2, keep-with-next
    898          HAL_StatusTypeDef HAL_SAI_DMAResume(SAI_HandleTypeDef *hsai)
    899          {
    900            /* Process Locked */
    901            __HAL_LOCK(hsai);
   \                     HAL_SAI_DMAResume: (+1)
   \   00000000   0xF990 0x107C      LDRSB    R1,[R0, #+124]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SAI_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SAI_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x107C      STRB     R1,[R0, #+124]
    902            
    903            /* Enable the SAI DMA requests */
    904            hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0xF442 0x3200      ORR      R2,R2,#0x20000
   \   0000001A   0x600A             STR      R2,[R1, #+0]
    905          
    906            /* If the SAI peripheral is still not enabled, enable it */
    907            if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   0000001C   0x680A             LDR      R2,[R1, #+0]
   \   0000001E   0x03D2             LSLS     R2,R2,#+15
   \   00000020   0xD403             BMI.N    ??HAL_SAI_DMAResume_1
    908            {
    909              /* Enable SAI peripheral */    
    910              __HAL_SAI_ENABLE(hsai);
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0xF442 0x3280      ORR      R2,R2,#0x10000
   \   00000028   0x600A             STR      R2,[R1, #+0]
    911            }
    912          
    913            /* Process Unlocked */
    914            __HAL_UNLOCK(hsai);
   \                     ??HAL_SAI_DMAResume_1: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xF880 0x107C      STRB     R1,[R0, #+124]
    915            
    916            return HAL_OK;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x4770             BX       LR               ;; return
    917          }
    918          
    919          /**
    920            * @brief Stops the audio stream playing from the Media.
    921            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
    922            *                the configuration information for SAI module.
    923            * @retval HAL status
    924            */

   \                                 In section .text, align 2, keep-with-next
    925          HAL_StatusTypeDef HAL_SAI_DMAStop(SAI_HandleTypeDef *hsai)
    926          {
   \                     HAL_SAI_DMAStop: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    927            /* Process Locked */
    928            __HAL_LOCK(hsai);
   \   00000006   0xF994 0x007C      LDRSB    R0,[R4, #+124]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xBF08             IT       EQ 
   \   0000000E   0x2002             MOVEQ    R0,#+2
   \   00000010   0xD031             BEQ.N    ??HAL_SAI_DMAStop_0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x007C      STRB     R0,[R4, #+124]
    929            
    930            /* Disable the SAI DMA request */
    931            hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF421 0x3100      BIC      R1,R1,#0x20000
   \   00000020   0x6001             STR      R1,[R0, #+0]
    932            
    933            /* Abort the SAI DMA Tx Stream */
    934            if(hsai->hdmatx != NULL)
   \   00000022   0x6EE0             LDR      R0,[R4, #+108]
   \   00000024   0xB110             CBZ.N    R0,??HAL_SAI_DMAStop_1
    935            {
    936              if(HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
   \   00000026   0x.... 0x....      BL       HAL_DMA_Abort
   \   0000002A   0xB920             CBNZ.N   R0,??HAL_SAI_DMAStop_2
    937              {
    938                return HAL_ERROR;
    939              }
    940            }
    941            /* Abort the SAI DMA Rx Stream */
    942            if(hsai->hdmarx != NULL)
   \                     ??HAL_SAI_DMAStop_1: (+1)
   \   0000002C   0x6F20             LDR      R0,[R4, #+112]
   \   0000002E   0xB128             CBZ.N    R0,??HAL_SAI_DMAStop_3
    943            {  
    944              if(HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
   \   00000030   0x.... 0x....      BL       HAL_DMA_Abort
   \   00000034   0xB110             CBZ.N    R0,??HAL_SAI_DMAStop_3
    945              {
    946                return HAL_ERROR;
   \                     ??HAL_SAI_DMAStop_2: (+1)
   \   00000036   0x2001             MOVS     R0,#+1
    947              }
    948            }
    949            
    950            /* Disable SAI peripheral */
    951            SAI_Disable(hsai);
    952            
    953            hsai->State = HAL_SAI_STATE_READY;
    954            
    955            /* Process Unlocked */
    956            __HAL_UNLOCK(hsai);
    957            
    958            return HAL_OK;
   \   00000038   0xB001             ADD      SP,SP,#+4
   \   0000003A   0xBD30             POP      {R4,R5,PC}
   \                     ??HAL_SAI_DMAStop_3: (+1)
   \   0000003C   0x.... 0x....      BL       HAL_GetTick
   \   00000040   0x4605             MOV      R5,R0
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   0000004A   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SAI_DMAStop_4: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x03C0             LSLS     R0,R0,#+15
   \   00000052   0xD50A             BPL.N    ??HAL_SAI_DMAStop_5
   \   00000054   0x.... 0x....      BL       HAL_GetTick
   \   00000058   0x1B40             SUBS     R0,R0,R5
   \   0000005A   0x280B             CMP      R0,#+11
   \   0000005C   0xD3F6             BCC.N    ??HAL_SAI_DMAStop_4
   \   0000005E   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   00000062   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000066   0xF8C4 0x0080      STR      R0,[R4, #+128]
   \                     ??HAL_SAI_DMAStop_5: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xF884 0x007D      STRB     R0,[R4, #+125]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF884 0x007C      STRB     R0,[R4, #+124]
   \                     ??HAL_SAI_DMAStop_0: (+1)
   \   00000076   0xB001             ADD      SP,SP,#+4
   \   00000078   0xBD30             POP      {R4,R5,PC}       ;; return
    959          }
    960          
    961          /**
    962            * @brief Abort the current transfer and disbaled the SAI.
    963            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
    964            *                the configuration information for SAI module.
    965            * @retval HAL status
    966            */

   \                                 In section .text, align 2, keep-with-next
    967          HAL_StatusTypeDef HAL_SAI_Abort(SAI_HandleTypeDef *hsai)
    968          {
   \                     HAL_SAI_Abort: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    969            /* Disable the SAI DMA request */
    970            hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0xF421 0x3100      BIC      R1,R1,#0x20000
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    971            
    972            /* Abort the SAI DMA Tx Stream */
    973            if(hsai->hdmatx != NULL)
   \   00000010   0x6EE0             LDR      R0,[R4, #+108]
   \   00000012   0xB110             CBZ.N    R0,??HAL_SAI_Abort_0
    974            {
    975              if(HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
   \   00000014   0x.... 0x....      BL       HAL_DMA_Abort
   \   00000018   0xB920             CBNZ.N   R0,??HAL_SAI_Abort_1
    976              {
    977                return HAL_ERROR;
    978              }
    979            }
    980            /* Abort the SAI DMA Rx Stream */
    981            if(hsai->hdmarx != NULL)
   \                     ??HAL_SAI_Abort_0: (+1)
   \   0000001A   0x6F20             LDR      R0,[R4, #+112]
   \   0000001C   0xB128             CBZ.N    R0,??HAL_SAI_Abort_2
    982            {  
    983              if(HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
   \   0000001E   0x.... 0x....      BL       HAL_DMA_Abort
   \   00000022   0xB110             CBZ.N    R0,??HAL_SAI_Abort_2
    984              {
    985                return HAL_ERROR;
   \                     ??HAL_SAI_Abort_1: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
    986              }
    987            }
    988          
    989            /* Disabled All interrupt and clear all the flag */
    990            hsai->Instance->IMR = 0;
    991            hsai->Instance->CLRFR = 0xFFFFFFFF;
    992            
    993            /* Disable SAI peripheral */
    994            SAI_Disable(hsai);
    995            
    996            /* Flush the fifo */
    997            SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
    998            
    999            hsai->State = HAL_SAI_STATE_READY;
   1000            
   1001            /* Process Unlocked */
   1002            __HAL_UNLOCK(hsai);
   1003            
   1004            return HAL_OK;
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0xBD30             POP      {R4,R5,PC}
   \                     ??HAL_SAI_Abort_2: (+1)
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6108             STR      R0,[R1, #+16]
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0xF04F 0x30FF      MOV      R0,#-1
   \   00000036   0x6188             STR      R0,[R1, #+24]
   \   00000038   0x.... 0x....      BL       HAL_GetTick
   \   0000003C   0x4605             MOV      R5,R0
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   00000046   0x6001             STR      R1,[R0, #+0]
   \                     ??HAL_SAI_Abort_3: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x03C0             LSLS     R0,R0,#+15
   \   0000004E   0xD50A             BPL.N    ??HAL_SAI_Abort_4
   \   00000050   0x.... 0x....      BL       HAL_GetTick
   \   00000054   0x1B40             SUBS     R0,R0,R5
   \   00000056   0x280B             CMP      R0,#+11
   \   00000058   0xD3F6             BCC.N    ??HAL_SAI_Abort_3
   \   0000005A   0xF8D4 0x0080      LDR      R0,[R4, #+128]
   \   0000005E   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000062   0xF8C4 0x0080      STR      R0,[R4, #+128]
   \                     ??HAL_SAI_Abort_4: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6841             LDR      R1,[R0, #+4]
   \   0000006A   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000006E   0x6041             STR      R1,[R0, #+4]
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xF884 0x007D      STRB     R0,[R4, #+125]
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x007C      STRB     R0,[R4, #+124]
   \   0000007C   0xB001             ADD      SP,SP,#+4
   \   0000007E   0xBD30             POP      {R4,R5,PC}       ;; return
   1005          }
   1006          
   1007          /**
   1008            * @brief  Transmits an amount of data in no-blocking mode with DMA.
   1009            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1010            *                the configuration information for SAI module.
   1011            * @param  pData: Pointer to data buffer
   1012            * @param  Size: Amount of data to be sent
   1013            * @retval HAL status
   1014            */

   \                                 In section .text, align 2, keep-with-next
   1015          HAL_StatusTypeDef HAL_SAI_Transmit_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
   1016          {
   1017            uint32_t *tmp;
   1018            
   1019            if((pData == NULL) || (Size == 0)) 
   \                     HAL_SAI_Transmit_DMA: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_SAI_Transmit_DMA_0
   1020            {
   1021              return  HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD10             POP      {R4,PC}
   1022            }
   1023            
   1024            if(hsai->State == HAL_SAI_STATE_READY)
   \                     ??HAL_SAI_Transmit_DMA_0: (+1)
   \   00000010   0xF994 0x007D      LDRSB    R0,[R4, #+125]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD150             BNE.N    ??HAL_SAI_Transmit_DMA_1
   1025            {  
   1026              /* Process Locked */
   1027              __HAL_LOCK(hsai);
   \   00000018   0xF994 0x007C      LDRSB    R0,[R4, #+124]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD04C             BEQ.N    ??HAL_SAI_Transmit_DMA_1
   \   00000020   0x2001             MOVS     R0,#+1
   1028              
   1029              hsai->pBuffPtr = pData;
   \   00000022   0x6661             STR      R1,[R4, #+100]
   \   00000024   0xF884 0x007C      STRB     R0,[R4, #+124]
   1030              hsai->XferSize = Size;
   1031              hsai->XferCount = Size;
   1032              hsai->ErrorCode = HAL_SAI_ERROR_NONE;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF8A4 0x2068      STRH     R2,[R4, #+104]
   \   0000002E   0xF8A4 0x206A      STRH     R2,[R4, #+106]
   \   00000032   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1033              hsai->State = HAL_SAI_STATE_BUSY_TX;
   \   00000036   0x2012             MOVS     R0,#+18
   \   00000038   0xF884 0x007D      STRB     R0,[R4, #+125]
   1034              
   1035              /* Set the SAI Tx DMA Half transfer complete callback */
   1036              hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
   \   0000003C   0x6EE2             LDR      R2,[R4, #+108]
   \   0000003E   0x.... 0x....      ADR.W    R0,SAI_DMATxHalfCplt
   \   00000042   0x6410             STR      R0,[R2, #+64]
   1037              
   1038              /* Set the SAI TxDMA transfer complete callback */
   1039              hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
   \   00000044   0x6EE2             LDR      R2,[R4, #+108]
   \   00000046   0x.... 0x....      ADR.W    R0,SAI_DMATxCplt
   \   0000004A   0x63D0             STR      R0,[R2, #+60]
   1040              
   1041              /* Set the DMA error callback */
   1042              hsai->hdmatx->XferErrorCallback = SAI_DMAError;
   \   0000004C   0x6EE2             LDR      R2,[R4, #+108]
   \   0000004E   0x.... 0x....      ADR.W    R0,SAI_DMAError
   \   00000052   0x6490             STR      R0,[R2, #+72]
   1043              
   1044              /* Enable the Tx DMA Stream */
   1045              tmp = (uint32_t*)&pData;
   1046              HAL_DMA_Start_IT(hsai->hdmatx, *(uint32_t*)tmp, (uint32_t)&hsai->Instance->DR, hsai->XferSize);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0xF8B4 0x3068      LDRH     R3,[R4, #+104]
   \   0000005A   0xF100 0x021C      ADD      R2,R0,#+28
   \   0000005E   0x6EE0             LDR      R0,[R4, #+108]
   \   00000060   0x.... 0x....      BL       HAL_DMA_Start_IT
   1047              
   1048              /* Check if the SAI is already enabled */ 
   1049              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0x03C9             LSLS     R1,R1,#+15
   \   0000006A   0xD403             BMI.N    ??HAL_SAI_Transmit_DMA_2
   1050              {
   1051                /* Enable SAI peripheral */
   1052                __HAL_SAI_ENABLE(hsai);
   \   0000006C   0x6801             LDR      R1,[R0, #+0]
   \   0000006E   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000072   0x6001             STR      R1,[R0, #+0]
   1053              }
   1054              
   1055              /* Enable the interrupts for error handling */
   1056              __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   \                     ??HAL_SAI_Transmit_DMA_2: (+1)
   \   00000074   0x6B21             LDR      R1,[R4, #+48]
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x2908             CMP      R1,#+8
   \   0000007A   0xD116             BNE.N    ??HAL_SAI_Transmit_DMA_3
   \   0000007C   0x6861             LDR      R1,[R4, #+4]
   \   0000007E   0x2903             CMP      R1,#+3
   \   00000080   0xD10F             BNE.N    ??HAL_SAI_Transmit_DMA_4
   \   00000082   0x2011             MOVS     R0,#+17
   \                     ??HAL_SAI_Transmit_DMA_5: (+1)
   \   00000084   0xF040 0x0060      ORR      R0,R0,#0x60
   \                     ??HAL_SAI_Transmit_DMA_6: (+1)
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x690A             LDR      R2,[R1, #+16]
   \   0000008C   0x4310             ORRS     R0,R0,R2
   \   0000008E   0x6108             STR      R0,[R1, #+16]
   1057              
   1058              /* Enable SAI Tx DMA Request */  
   1059              hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0xF441 0x3100      ORR      R1,R1,#0x20000
   \   00000098   0x6001             STR      R1,[R0, #+0]
   1060              
   1061              /* Process Unlocked */
   1062              __HAL_UNLOCK(hsai);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF884 0x007C      STRB     R0,[R4, #+124]
   1063              
   1064              return HAL_OK;
   \   000000A0   0xBD10             POP      {R4,PC}
   \                     ??HAL_SAI_Transmit_DMA_4: (+1)
   \   000000A2   0x2901             CMP      R1,#+1
   \   000000A4   0xBF08             IT       EQ 
   \   000000A6   0x2011             MOVEQ    R0,#+17
   \   000000A8   0xD004             BEQ.N    ??HAL_SAI_Transmit_DMA_7
   \                     ??HAL_SAI_Transmit_DMA_3: (+1)
   \   000000AA   0x6861             LDR      R1,[R4, #+4]
   \   000000AC   0x2903             CMP      R1,#+3
   \   000000AE   0xBF18             IT       NE 
   \   000000B0   0x2902             CMPNE    R1,#+2
   \   000000B2   0xD0E7             BEQ.N    ??HAL_SAI_Transmit_DMA_5
   \                     ??HAL_SAI_Transmit_DMA_7: (+1)
   \   000000B4   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000B8   0xE7E6             B.N      ??HAL_SAI_Transmit_DMA_6
   1065            }
   1066            else
   1067            {
   1068              return HAL_BUSY;
   \                     ??HAL_SAI_Transmit_DMA_1: (+1)
   \   000000BA   0x2002             MOVS     R0,#+2
   \   000000BC   0xBD10             POP      {R4,PC}          ;; return
   1069            }
   1070          }
   1071          
   1072          /**
   1073            * @brief  Receives an amount of data in no-blocking mode with DMA. 
   1074            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1075            *                the configuration information for SAI module.
   1076            * @param  pData: Pointer to data buffer
   1077            * @param  Size: Amount of data to be received
   1078            * @retval HAL status
   1079            */

   \                                 In section .text, align 2, keep-with-next
   1080          HAL_StatusTypeDef HAL_SAI_Receive_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
   1081          {
   1082            uint32_t *tmp;
   1083            
   1084            if((pData == NULL) || (Size == 0))
   \                     HAL_SAI_Receive_DMA: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2A00             CMPNE    R2,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_SAI_Receive_DMA_0
   1085            {
   1086              return  HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD10             POP      {R4,PC}
   1087            } 
   1088            
   1089            if(hsai->State == HAL_SAI_STATE_READY)
   \                     ??HAL_SAI_Receive_DMA_0: (+1)
   \   00000010   0xF994 0x007D      LDRSB    R0,[R4, #+125]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD151             BNE.N    ??HAL_SAI_Receive_DMA_1
   1090            {   
   1091              /* Process Locked */
   1092              __HAL_LOCK(hsai);
   \   00000018   0xF994 0x007C      LDRSB    R0,[R4, #+124]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD04D             BEQ.N    ??HAL_SAI_Receive_DMA_1
   \   00000020   0x2001             MOVS     R0,#+1
   1093              
   1094              hsai->pBuffPtr = pData;
   \   00000022   0x6661             STR      R1,[R4, #+100]
   \   00000024   0xF884 0x007C      STRB     R0,[R4, #+124]
   1095              hsai->XferSize = Size;
   1096              hsai->XferCount = Size;
   1097              hsai->ErrorCode = HAL_SAI_ERROR_NONE;    
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF8A4 0x2068      STRH     R2,[R4, #+104]
   \   0000002E   0xF8A4 0x206A      STRH     R2,[R4, #+106]
   \   00000032   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1098              hsai->State = HAL_SAI_STATE_BUSY_RX;
   \   00000036   0x2022             MOVS     R0,#+34
   \   00000038   0xF884 0x007D      STRB     R0,[R4, #+125]
   1099              
   1100              /* Set the SAI Rx DMA Half transfer complete callback */
   1101              hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
   \   0000003C   0x6F22             LDR      R2,[R4, #+112]
   \   0000003E   0x.... 0x....      ADR.W    R0,SAI_DMARxHalfCplt
   \   00000042   0x6410             STR      R0,[R2, #+64]
   1102              
   1103              /* Set the SAI Rx DMA transfer complete callback */
   1104              hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
   \   00000044   0x6F22             LDR      R2,[R4, #+112]
   \   00000046   0x.... 0x....      ADR.W    R0,SAI_DMARxCplt
   \   0000004A   0x63D0             STR      R0,[R2, #+60]
   1105              
   1106              /* Set the DMA error callback */
   1107              hsai->hdmarx->XferErrorCallback = SAI_DMAError;
   \   0000004C   0x6F22             LDR      R2,[R4, #+112]
   \   0000004E   0x.... 0x....      ADR.W    R0,SAI_DMAError
   \   00000052   0x6490             STR      R0,[R2, #+72]
   1108              
   1109              /* Enable the Rx DMA Stream */
   1110              tmp = (uint32_t*)&pData;
   1111              HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, *(uint32_t*)tmp, hsai->XferSize);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x460A             MOV      R2,R1
   \   00000058   0xF8B4 0x3068      LDRH     R3,[R4, #+104]
   \   0000005C   0xF100 0x011C      ADD      R1,R0,#+28
   \   00000060   0x6F20             LDR      R0,[R4, #+112]
   \   00000062   0x.... 0x....      BL       HAL_DMA_Start_IT
   1112              
   1113              /* Check if the SAI is already enabled */
   1114              if((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == RESET)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x03C9             LSLS     R1,R1,#+15
   \   0000006C   0xD403             BMI.N    ??HAL_SAI_Receive_DMA_2
   1115              {
   1116                /* Enable SAI peripheral */
   1117                __HAL_SAI_ENABLE(hsai);
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000074   0x6001             STR      R1,[R0, #+0]
   1118              }
   1119              
   1120              /* Enable the interrupts for error handling */
   1121              __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   \                     ??HAL_SAI_Receive_DMA_2: (+1)
   \   00000076   0x6B21             LDR      R1,[R4, #+48]
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x2908             CMP      R1,#+8
   \   0000007C   0xD116             BNE.N    ??HAL_SAI_Receive_DMA_3
   \   0000007E   0x6861             LDR      R1,[R4, #+4]
   \   00000080   0x2903             CMP      R1,#+3
   \   00000082   0xD10F             BNE.N    ??HAL_SAI_Receive_DMA_4
   \   00000084   0x2011             MOVS     R0,#+17
   \                     ??HAL_SAI_Receive_DMA_5: (+1)
   \   00000086   0xF040 0x0060      ORR      R0,R0,#0x60
   \                     ??HAL_SAI_Receive_DMA_6: (+1)
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x690A             LDR      R2,[R1, #+16]
   \   0000008E   0x4310             ORRS     R0,R0,R2
   \   00000090   0x6108             STR      R0,[R1, #+16]
   1122              
   1123              /* Enable SAI Rx DMA Request */
   1124              hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0xF441 0x3100      ORR      R1,R1,#0x20000
   \   0000009A   0x6001             STR      R1,[R0, #+0]
   1125              
   1126              /* Process Unlocked */
   1127              __HAL_UNLOCK(hsai);
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xF884 0x007C      STRB     R0,[R4, #+124]
   1128              
   1129              return HAL_OK;
   \   000000A2   0xBD10             POP      {R4,PC}
   \                     ??HAL_SAI_Receive_DMA_4: (+1)
   \   000000A4   0x2901             CMP      R1,#+1
   \   000000A6   0xBF08             IT       EQ 
   \   000000A8   0x2011             MOVEQ    R0,#+17
   \   000000AA   0xD004             BEQ.N    ??HAL_SAI_Receive_DMA_7
   \                     ??HAL_SAI_Receive_DMA_3: (+1)
   \   000000AC   0x6861             LDR      R1,[R4, #+4]
   \   000000AE   0x2903             CMP      R1,#+3
   \   000000B0   0xBF18             IT       NE 
   \   000000B2   0x2902             CMPNE    R1,#+2
   \   000000B4   0xD0E7             BEQ.N    ??HAL_SAI_Receive_DMA_5
   \                     ??HAL_SAI_Receive_DMA_7: (+1)
   \   000000B6   0xF040 0x0004      ORR      R0,R0,#0x4
   \   000000BA   0xE7E6             B.N      ??HAL_SAI_Receive_DMA_6
   1130            }
   1131            else
   1132            {
   1133              return HAL_BUSY;
   \                     ??HAL_SAI_Receive_DMA_1: (+1)
   \   000000BC   0x2002             MOVS     R0,#+2
   \   000000BE   0xBD10             POP      {R4,PC}          ;; return
   1134            }
   1135          }
   1136          
   1137          /**
   1138            * @brief  Enable the tx mute mode.
   1139            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1140            *                the configuration information for SAI module.
   1141            * @param  val :  value sent during the mute @ref SAI_Block_Mute_Value
   1142            * @retval HAL status
   1143            */

   \                                 In section .text, align 2, keep-with-next
   1144          HAL_StatusTypeDef HAL_SAI_EnableTxMuteMode(SAI_HandleTypeDef *hsai, uint16_t val)
   1145          {
   1146            assert_param(IS_SAI_BLOCK_MUTE_VALUE(val));
   1147            
   1148            if(hsai->State != HAL_SAI_STATE_RESET)
   \                     HAL_SAI_EnableTxMuteMode: (+1)
   \   00000000   0xF990 0x207D      LDRSB    R2,[R0, #+125]
   \   00000004   0xB162             CBZ.N    R2,??HAL_SAI_EnableTxMuteMode_0
   1149            {
   1150              CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTEVAL | SAI_xCR2_MUTE);
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   1151              SET_BIT(hsai->Instance->CR2, SAI_xCR2_MUTE | val);
   \   00000008   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000C   0x6853             LDR      R3,[R2, #+4]
   \   0000000E   0xF023 0x0360      BIC      R3,R3,#0x60
   \   00000012   0x6053             STR      R3,[R2, #+4]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x6842             LDR      R2,[R0, #+4]
   \   00000018   0x4311             ORRS     R1,R1,R2
   \   0000001A   0x6041             STR      R1,[R0, #+4]
   1152              return HAL_OK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x4770             BX       LR
   1153            }
   1154            return HAL_ERROR;
   \                     ??HAL_SAI_EnableTxMuteMode_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4770             BX       LR               ;; return
   1155          }
   1156          
   1157          /**
   1158            * @brief  Disable the tx mute mode.
   1159            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1160            *                the configuration information for SAI module.
   1161            * @retval HAL status
   1162            */

   \                                 In section .text, align 2, keep-with-next
   1163          HAL_StatusTypeDef HAL_SAI_DisableTxMuteMode(SAI_HandleTypeDef *hsai)
   1164          {
   1165            if(hsai->State != HAL_SAI_STATE_RESET)
   \                     HAL_SAI_DisableTxMuteMode: (+1)
   \   00000000   0xF990 0x107D      LDRSB    R1,[R0, #+125]
   \   00000004   0xB131             CBZ.N    R1,??HAL_SAI_DisableTxMuteMode_0
   1166            {
   1167              CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTEVAL | SAI_xCR2_MUTE);
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6841             LDR      R1,[R0, #+4]
   \   0000000A   0xF021 0x0160      BIC      R1,R1,#0x60
   \   0000000E   0x6041             STR      R1,[R0, #+4]
   1168              return HAL_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   1169            }
   1170            return HAL_ERROR;
   \                     ??HAL_SAI_DisableTxMuteMode_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
   1171          }
   1172          
   1173          /**
   1174            * @brief  Enable the rx mute detection.
   1175            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1176            *                the configuration information for SAI module.
   1177            * @param  callback : function called when the mute is detected
   1178            * @param  counter : number a data before mute detection max 63.
   1179            * @retval HAL status
   1180            */

   \                                 In section .text, align 2, keep-with-next
   1181          HAL_StatusTypeDef HAL_SAI_EnableRxMuteMode(SAI_HandleTypeDef *hsai, SAIcallback callback, uint16_t counter)
   1182          {
   1183            assert_param(IS_SAI_BLOCK_MUTE_COUNTER(counter));
   1184            
   1185            if(hsai->State != HAL_SAI_STATE_RESET)
   \                     HAL_SAI_EnableRxMuteMode: (+1)
   \   00000000   0xF990 0x307D      LDRSB    R3,[R0, #+125]
   \   00000004   0xB1A3             CBZ.N    R3,??HAL_SAI_EnableRxMuteMode_0
   1186            {
   1187              /* set the mute counter */
   1188              CLEAR_BIT(hsai->Instance->CR2, SAI_xCR2_MUTECNT);
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0xF8D3 0xC004      LDR      R12,[R3, #+4]
   \   0000000C   0xF42C 0x5CFC      BIC      R12,R12,#0x1F80
   \   00000010   0xF8C3 0xC004      STR      R12,[R3, #+4]
   1189              SET_BIT(hsai->Instance->CR2, (uint32_t)((uint32_t)counter << SAI_xCR2_MUTECNT_OFFSET));
   \   00000014   0x6803             LDR      R3,[R0, #+0]
   \   00000016   0xF8D3 0xC004      LDR      R12,[R3, #+4]
   \   0000001A   0xEA4C 0x12C2      ORR      R2,R12,R2, LSL #+7
   \   0000001E   0x605A             STR      R2,[R3, #+4]
   1190              hsai->mutecallback = callback;
   \   00000020   0x6741             STR      R1,[R0, #+116]
   1191              /* enable the IT interrupt */
   1192              __HAL_SAI_ENABLE_IT(hsai, SAI_IT_MUTEDET);
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x6901             LDR      R1,[R0, #+16]
   \   00000026   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000002A   0x6101             STR      R1,[R0, #+16]
   1193              return HAL_OK;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4770             BX       LR
   1194            }
   1195            return HAL_ERROR;
   \                     ??HAL_SAI_EnableRxMuteMode_0: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x4770             BX       LR               ;; return
   1196          }
   1197          
   1198          /**
   1199            * @brief  Disable the rx mute detection.
   1200            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1201            *                the configuration information for SAI module.
   1202            * @retval HAL status
   1203            */

   \                                 In section .text, align 2, keep-with-next
   1204          HAL_StatusTypeDef HAL_SAI_DisableRxMuteMode(SAI_HandleTypeDef *hsai)
   1205          {
   1206            if(hsai->State != HAL_SAI_STATE_RESET)
   \                     HAL_SAI_DisableRxMuteMode: (+1)
   \   00000000   0xF990 0x107D      LDRSB    R1,[R0, #+125]
   \   00000004   0xB141             CBZ.N    R1,??HAL_SAI_DisableRxMuteMode_0
   1207            {
   1208              /* set the mutecallback to NULL */
   1209              hsai->mutecallback = (SAIcallback)NULL;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6741             STR      R1,[R0, #+116]
   1210              /* enable the IT interrupt */
   1211              __HAL_SAI_DISABLE_IT(hsai, SAI_IT_MUTEDET);
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x6901             LDR      R1,[R0, #+16]
   \   0000000E   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000012   0x6101             STR      R1,[R0, #+16]
   1212              return HAL_OK;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR
   1213            }
   1214            return HAL_ERROR;
   \                     ??HAL_SAI_DisableRxMuteMode_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4770             BX       LR               ;; return
   1215          }
   1216          
   1217          /**
   1218            * @brief  This function handles SAI interrupt request.
   1219            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1220            *                the configuration information for SAI module.
   1221            * @retval HAL status
   1222            */

   \                                 In section .text, align 2, keep-with-next
   1223          void HAL_SAI_IRQHandler(SAI_HandleTypeDef *hsai)
   1224          { 
   \                     HAL_SAI_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1225            if(hsai->State != HAL_SAI_STATE_RESET)
   \   00000004   0xF994 0x007D      LDRSB    R0,[R4, #+125]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD05D             BEQ.N    ??HAL_SAI_IRQHandler_0
   1226            {
   1227              uint32_t tmpFlag = hsai->Instance->SR;
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x6945             LDR      R5,[R0, #+20]
   1228              uint32_t tmpItSource = hsai->Instance->IMR; 
   \   00000010   0x6906             LDR      R6,[R0, #+16]
   1229              
   1230              if(((tmpFlag & SAI_xSR_FREQ) == SAI_xSR_FREQ) && ((tmpItSource & SAI_IT_FREQ) == SAI_IT_FREQ))
   \   00000012   0x0728             LSLS     R0,R5,#+28
   \   00000014   0xD504             BPL.N    ??HAL_SAI_IRQHandler_1
   \   00000016   0x0730             LSLS     R0,R6,#+28
   \   00000018   0xD502             BPL.N    ??HAL_SAI_IRQHandler_1
   1231              {
   1232                hsai->InterruptServiceRoutine(hsai);
   \   0000001A   0x6FA1             LDR      R1,[R4, #+120]
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x4788             BLX      R1
   1233              }
   1234              
   1235              /* check the flag only if one of them is set */
   1236              if(tmpFlag != 0x00000000)
   \                     ??HAL_SAI_IRQHandler_1: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD051             BEQ.N    ??HAL_SAI_IRQHandler_0
   1237              {
   1238                /* SAI Overrun error interrupt occurred ----------------------------------*/
   1239                if(((tmpFlag & SAI_FLAG_OVRUDR) == SAI_FLAG_OVRUDR) && ((tmpItSource & SAI_IT_OVRUDR) == SAI_IT_OVRUDR))
   \   00000024   0xF005 0x0001      AND      R0,R5,#0x1
   \   00000028   0xF006 0x0101      AND      R1,R6,#0x1
   \   0000002C   0x4208             TST      R0,R1
   \   0000002E   0xD00D             BEQ.N    ??HAL_SAI_IRQHandler_2
   1240                {
   1241                  /* Clear the SAI Overrun flag */
   1242                  __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x6188             STR      R0,[R1, #+24]
   1243                  /* Change the SAI error code */
   1244                  hsai->ErrorCode = ((hsai->State == HAL_SAI_STATE_BUSY_RX) ? HAL_SAI_ERROR_OVR : HAL_SAI_ERROR_UDR);
   \   00000036   0xF994 0x007D      LDRSB    R0,[R4, #+125]
   \   0000003A   0x2822             CMP      R0,#+34
   \   0000003C   0xBF0C             ITE      EQ 
   \   0000003E   0x2001             MOVEQ    R0,#+1
   \   00000040   0x2002             MOVNE    R0,#+2
   \   00000042   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1245                  /* the transfer is not stopped, we will forward the information to the user and we let the user decide what needs to be done */
   1246                  HAL_SAI_ErrorCallback(hsai);
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1247                }
   1248                
   1249                /* SAI mutedet interrupt occurred ----------------------------------*/
   1250                if(((tmpFlag & SAI_FLAG_MUTEDET) == SAI_FLAG_MUTEDET) && ((tmpItSource & SAI_IT_MUTEDET) == SAI_IT_MUTEDET))
   \                     ??HAL_SAI_IRQHandler_2: (+1)
   \   0000004C   0x07A8             LSLS     R0,R5,#+30
   \   0000004E   0xD508             BPL.N    ??HAL_SAI_IRQHandler_3
   \   00000050   0x07B0             LSLS     R0,R6,#+30
   \   00000052   0xD506             BPL.N    ??HAL_SAI_IRQHandler_3
   1251                {
   1252                  /* Clear the SAI mutedet flag */
   1253                  __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_MUTEDET);
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0x6188             STR      R0,[R1, #+24]
   1254                  /* call the call back function */
   1255                  if(hsai->mutecallback != (SAIcallback)NULL)
   \   0000005A   0x6F60             LDR      R0,[R4, #+116]
   \   0000005C   0x0001             MOVS     R1,R0
   \   0000005E   0xBF18             IT       NE 
   1256                  {
   1257                    /* inform the user that an RX mute event has been detected */
   1258                    hsai->mutecallback();
   \   00000060   0x4780             BLXNE    R0
   1259                  }
   1260                }
   1261                
   1262                /* SAI AFSDET interrupt occurred ----------------------------------*/
   1263                if(((tmpFlag & SAI_FLAG_AFSDET) == SAI_FLAG_AFSDET) && ((tmpItSource & SAI_IT_AFSDET) == SAI_IT_AFSDET))
   \                     ??HAL_SAI_IRQHandler_3: (+1)
   \   00000062   0x06A8             LSLS     R0,R5,#+26
   \   00000064   0xD50A             BPL.N    ??HAL_SAI_IRQHandler_4
   \   00000066   0x06B0             LSLS     R0,R6,#+26
   \   00000068   0xD508             BPL.N    ??HAL_SAI_IRQHandler_4
   1264                {
   1265                  /* Change the SAI error code */
   1266                  hsai->ErrorCode = HAL_SAI_ERROR_AFSDET;
   \   0000006A   0x2004             MOVS     R0,#+4
   \   0000006C   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1267                  HAL_SAI_Abort(hsai);
   \   00000070   0x4620             MOV      R0,R4
   \   00000072   0x.... 0x....      BL       HAL_SAI_Abort
   1268                  HAL_SAI_ErrorCallback(hsai);
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1269                }
   1270                
   1271                /* SAI LFSDET interrupt occurred ----------------------------------*/
   1272                if(((tmpFlag & SAI_FLAG_LFSDET) == SAI_FLAG_LFSDET) && ((tmpItSource & SAI_IT_LFSDET) == SAI_IT_LFSDET))
   \                     ??HAL_SAI_IRQHandler_4: (+1)
   \   0000007C   0x0668             LSLS     R0,R5,#+25
   \   0000007E   0xD50A             BPL.N    ??HAL_SAI_IRQHandler_5
   \   00000080   0x0670             LSLS     R0,R6,#+25
   \   00000082   0xD508             BPL.N    ??HAL_SAI_IRQHandler_5
   1273                {
   1274                  /* Change the SAI error code */
   1275                  hsai->ErrorCode = HAL_SAI_ERROR_LFSDET;
   \   00000084   0x2008             MOVS     R0,#+8
   \   00000086   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1276                  HAL_SAI_Abort(hsai);
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       HAL_SAI_Abort
   1277                  HAL_SAI_ErrorCallback(hsai);
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1278                }
   1279          
   1280                /* SAI WCKCFG interrupt occurred ----------------------------------*/
   1281                if(((tmpFlag & SAI_FLAG_WCKCFG) == SAI_FLAG_WCKCFG) && ((tmpItSource & SAI_IT_WCKCFG) == SAI_IT_WCKCFG))
   \                     ??HAL_SAI_IRQHandler_5: (+1)
   \   00000096   0x0768             LSLS     R0,R5,#+29
   \   00000098   0xD50A             BPL.N    ??HAL_SAI_IRQHandler_6
   \   0000009A   0x0770             LSLS     R0,R6,#+29
   \   0000009C   0xD508             BPL.N    ??HAL_SAI_IRQHandler_6
   1282                {
   1283                  /* Change the SAI error code */
   1284                  hsai->ErrorCode = HAL_SAI_ERROR_WCKCFG;
   \   0000009E   0x2020             MOVS     R0,#+32
   \   000000A0   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1285                  HAL_SAI_Abort(hsai);
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       HAL_SAI_Abort
   1286                  HAL_SAI_ErrorCallback(hsai);
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1287                }
   1288                /* SAI CNRDY interrupt occurred ----------------------------------*/
   1289                if(((tmpFlag & SAI_FLAG_CNRDY) == SAI_FLAG_CNRDY) && ((tmpItSource & SAI_IT_CNRDY) == SAI_IT_CNRDY))
   \                     ??HAL_SAI_IRQHandler_6: (+1)
   \   000000B0   0x06E8             LSLS     R0,R5,#+27
   \   000000B2   0xD509             BPL.N    ??HAL_SAI_IRQHandler_0
   \   000000B4   0x06F0             LSLS     R0,R6,#+27
   \   000000B6   0xD507             BPL.N    ??HAL_SAI_IRQHandler_0
   1290                {
   1291                  /* Clear the SAI CNRDY flag */
   1292                  __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_CNRDY);
   \   000000B8   0x6821             LDR      R1,[R4, #+0]
   \   000000BA   0x2010             MOVS     R0,#+16
   \   000000BC   0x6188             STR      R0,[R1, #+24]
   1293                  /* Change the SAI error code */
   1294                  hsai->ErrorCode = HAL_SAI_ERROR_CNREADY;
   \   000000BE   0xF8C4 0x0080      STR      R0,[R4, #+128]
   1295                  /* the transfer is not stopped, we will forward the information to the user and we let the user decide what needs to be done */
   1296                  HAL_SAI_ErrorCallback(hsai);
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1297                }      
   1298              }
   1299            }
   1300          }
   \                     ??HAL_SAI_IRQHandler_0: (+1)
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return
   1301          
   1302          /**
   1303            * @brief Tx Transfer completed callbacks.
   1304            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1305            *                the configuration information for SAI module.
   1306            * @retval None
   1307            */

   \                                 In section .text, align 2, keep-with-next
   1308           __weak void HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai)
   1309          {
   1310            /* Prevent unused argument(s) compilation warning */
   1311            UNUSED(hsai);
   1312            
   1313            /* NOTE : This function Should not be modified, when the callback is needed,
   1314                      the HAL_SAI_TxCpltCallback could be implemented in the user file
   1315             */ 
   1316          }
   \                     HAL_SAI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1317          
   1318          /**
   1319            * @brief Tx Transfer Half completed callbacks
   1320            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1321            *                the configuration information for SAI module.
   1322            * @retval None
   1323            */

   \                                 In section .text, align 2, keep-with-next
   1324           __weak void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
   1325          {
   1326            /* Prevent unused argument(s) compilation warning */
   1327            UNUSED(hsai);
   1328            
   1329            /* NOTE : This function Should not be modified, when the callback is needed,
   1330                      the HAL_SAI_TxHalfCpltCallback could be implemented in the user file
   1331             */ 
   1332          }
   \                     HAL_SAI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1333          
   1334          /**
   1335            * @brief Rx Transfer completed callbacks.
   1336            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1337            *                the configuration information for SAI module.
   1338            * @retval None
   1339            */

   \                                 In section .text, align 2, keep-with-next
   1340          __weak void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
   1341          {
   1342            /* Prevent unused argument(s) compilation warning */
   1343            UNUSED(hsai);
   1344            
   1345            /* NOTE : This function Should not be modified, when the callback is needed,
   1346                      the HAL_SAI_RxCpltCallback could be implemented in the user file
   1347             */
   1348          }
   \                     HAL_SAI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1349          
   1350          /**
   1351            * @brief Rx Transfer half completed callbacks
   1352            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1353            *                the configuration information for SAI module.
   1354            * @retval None
   1355            */

   \                                 In section .text, align 2, keep-with-next
   1356          __weak void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
   1357          {
   1358            /* Prevent unused argument(s) compilation warning */
   1359            UNUSED(hsai);
   1360            
   1361            /* NOTE : This function Should not be modified, when the callback is needed,
   1362                      the HAL_SAI_RxCpltCallback could be implemented in the user file
   1363             */
   1364          }
   \                     HAL_SAI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1365          
   1366          /**
   1367            * @brief SAI error callbacks.
   1368            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1369            *                the configuration information for SAI module.
   1370            * @retval None
   1371            */

   \                                 In section .text, align 2, keep-with-next
   1372          __weak void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
   1373          {
   1374            /* Prevent unused argument(s) compilation warning */
   1375            UNUSED(hsai);
   1376            
   1377            /* NOTE : This function Should not be modified, when the callback is needed,
   1378                      the HAL_SAI_ErrorCallback could be implemented in the user file
   1379             */ 
   1380          }
   \                     HAL_SAI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1381          
   1382          /**
   1383            * @}
   1384            */
   1385          
   1386          
   1387          /** @defgroup SAI_Exported_Functions_Group3 Peripheral State functions 
   1388           *  @brief   Peripheral State functions 
   1389           *
   1390          @verbatim   
   1391           ===============================================================================
   1392                          ##### Peripheral State and Errors functions #####
   1393           ===============================================================================  
   1394              [..]
   1395              This subsection permits to get in run-time the status of the peripheral 
   1396              and the data flow.
   1397          
   1398          @endverbatim
   1399            * @{
   1400            */
   1401          
   1402          /**
   1403            * @brief  Returns the SAI state.
   1404            * @param  hsai: pointer to a SAI_HandleTypeDef structure that contains
   1405            *                the configuration information for SAI module.
   1406            * @retval HAL state
   1407            */

   \                                 In section .text, align 2, keep-with-next
   1408          HAL_SAI_StateTypeDef HAL_SAI_GetState(SAI_HandleTypeDef *hsai)
   1409          {
   1410            return hsai->State;
   \                     HAL_SAI_GetState: (+1)
   \   00000000   0xF990 0x007D      LDRSB    R0,[R0, #+125]
   \   00000004   0x4770             BX       LR               ;; return
   1411          }
   1412          
   1413          /**
   1414          * @brief  Return the SAI error code
   1415          * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1416            *              the configuration information for the specified SAI Block.
   1417          * @retval SAI Error Code
   1418          */

   \                                 In section .text, align 2, keep-with-next
   1419          uint32_t HAL_SAI_GetError(SAI_HandleTypeDef *hsai)
   1420          {
   1421            return hsai->ErrorCode;
   \                     HAL_SAI_GetError: (+1)
   \   00000000   0xF8D0 0x0080      LDR      R0,[R0, #+128]
   \   00000004   0x4770             BX       LR               ;; return
   1422          }
   1423          /**
   1424            * @}
   1425            */
   1426          
   1427          /**
   1428            * @brief  Initializes the SAI I2S protocol according to the specified parameters 
   1429            *         in the SAI_InitTypeDef and create the associated handle.
   1430            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1431            *                the configuration information for SAI module.
   1432            * @param  protocol : one of the supported protocol
   1433            * @param  datasize : one of the supported datasize @ref SAI_Protocol_DataSize
   1434            *                the configuration information for SAI module.
   1435            * @param  nbslot : number of slot minimum value is 2 and max is 16. 
   1436            *                    the value must be a multiple of 2.
   1437            * @retval HAL status
   1438            */

   \                                 In section .text, align 4, keep-with-next
   1439          static HAL_StatusTypeDef SAI_InitI2S(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
   1440          {
   \                     SAI_InitI2S: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1441            /* Check the parameters */
   1442            assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   1443            assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   1444            
   1445            hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   \   00000002   0x2400             MOVS     R4,#+0
   1446            hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   1447            hsai->Init.ClockStrobing       = SAI_CLOCKSTROBING_FALLINGEDGE;
   1448            hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
   1449            hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1450            hsai->SlotInit.FirstBitOffset  = 0;
   1451            hsai->SlotInit.SlotNumber      = nbslot;
   \   00000004   0x65C3             STR      R3,[R0, #+92]
   \   00000006   0x6304             STR      R4,[R0, #+48]
   \   00000008   0x6384             STR      R4,[R0, #+56]
   \   0000000A   0x63C4             STR      R4,[R0, #+60]
   \   0000000C   0xF44F 0x3480      MOV      R4,#+65536
   \   00000010   0x6484             STR      R4,[R0, #+72]
   \   00000012   0xF64F 0x74FF      MOVW     R4,#+65535
   \   00000016   0x6604             STR      R4,[R0, #+96]
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0x6544             STR      R4,[R0, #+84]
   1452            
   1453            /* in IS2 the number of slot must be even */
   1454            if((nbslot & 0x1) != 0 )
   \   0000001C   0x07DC             LSLS     R4,R3,#+31
   \   0000001E   0xD441             BMI.N    ??SAI_InitI2S_1
   1455            {
   1456              return HAL_ERROR;
   1457            }
   1458            
   1459            switch(protocol)
   \   00000020   0xB129             CBZ.N    R1,??SAI_InitI2S_2
   \   00000022   0x2902             CMP      R1,#+2
   \   00000024   0xD008             BEQ.N    ??SAI_InitI2S_3
   \   00000026   0xD307             BCC.N    ??SAI_InitI2S_3
   1460            {
   1461            case SAI_I2S_STANDARD :
   1462              hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
   1463              hsai->FrameInit.FSOffset   = SAI_FS_BEFOREFIRSTBIT;
   1464              break;
   1465            case SAI_I2S_MSBJUSTIFIED :
   1466            case SAI_I2S_LSBJUSTIFIED :
   1467              hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_HIGH;
   1468              hsai->FrameInit.FSOffset   = SAI_FS_FIRSTBIT;
   1469              break;
   1470            default :
   1471              return HAL_ERROR;
   1472            }
   1473            
   1474            /* Frame definition */
   1475            switch(datasize)
   1476            {
   1477            case SAI_PROTOCOL_DATASIZE_16BIT:
   1478              hsai->Init.DataSize = SAI_DATASIZE_16;
   1479              hsai->FrameInit.FrameLength = 32*(nbslot/2);
   1480              hsai->FrameInit.ActiveFrameLength = 16*(nbslot/2);
   1481              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   1482              break; 
   1483            case SAI_PROTOCOL_DATASIZE_16BITEXTENDED :
   1484              hsai->Init.DataSize = SAI_DATASIZE_16;
   1485              hsai->FrameInit.FrameLength = 64*(nbslot/2);
   1486              hsai->FrameInit.ActiveFrameLength = 32*(nbslot/2);
   1487              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1488              break; 
   1489            case SAI_PROTOCOL_DATASIZE_24BIT:
   1490              hsai->Init.DataSize = SAI_DATASIZE_24;
   1491              hsai->FrameInit.FrameLength = 64*(nbslot/2);
   1492              hsai->FrameInit.ActiveFrameLength = 32*(nbslot/2);
   1493              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1494              break;
   1495            case SAI_PROTOCOL_DATASIZE_32BIT: 
   1496              hsai->Init.DataSize = SAI_DATASIZE_32;
   1497              hsai->FrameInit.FrameLength = 64*(nbslot/2);
   1498              hsai->FrameInit.ActiveFrameLength = 32*(nbslot/2);
   1499              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1500              break;
   1501            default :
   1502              return HAL_ERROR;  
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR
   \                     ??SAI_InitI2S_2: (+1)
   \   0000002E   0x2400             MOVS     R4,#+0
   \   00000030   0x64C4             STR      R4,[R0, #+76]
   \   00000032   0xF44F 0x2480      MOV      R4,#+262144
   \   00000036   0xE003             B.N      ??SAI_InitI2S_4
   \                     ??SAI_InitI2S_3: (+1)
   \   00000038   0xF44F 0x3400      MOV      R4,#+131072
   \   0000003C   0x64C4             STR      R4,[R0, #+76]
   \   0000003E   0x2400             MOVS     R4,#+0
   \                     ??SAI_InitI2S_4: (+1)
   \   00000040   0x2A04             CMP      R2,#+4
   \   00000042   0x6504             STR      R4,[R0, #+80]
   \   00000044   0xD82E             BHI.N    ??SAI_InitI2S_1
   \   00000046   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??SAI_InitI2S_0:
   \   0000004A   0x03 0x12          DC8      0x3,0x12,0x1B,0x2D
   \              0x1B 0x2D    
   \   0000004E   0x24 0x00          DC8      0x24,0x0
   \                     ??SAI_InitI2S_5: (+1)
   \   00000050   0x2480             MOVS     R4,#+128
   \   00000052   0x085B             LSRS     R3,R3,#+1
   \   00000054   0x6344             STR      R4,[R0, #+52]
   \   00000056   0x015C             LSLS     R4,R3,#+5
   \   00000058   0x011B             LSLS     R3,R3,#+4
   \   0000005A   0x6404             STR      R4,[R0, #+64]
   \   0000005C   0x6443             STR      R3,[R0, #+68]
   \   0000005E   0x2340             MOVS     R3,#+64
   1503            }
   1504            if(protocol == SAI_I2S_LSBJUSTIFIED)
   \                     ??SAI_InitI2S_6: (+1)
   \   00000060   0x2902             CMP      R1,#+2
   \   00000062   0x6583             STR      R3,[R0, #+88]
   \   00000064   0xD125             BNE.N    ??SAI_InitI2S_7
   1505            {
   1506              if (datasize == SAI_PROTOCOL_DATASIZE_16BITEXTENDED)
   \   00000066   0x2A01             CMP      R2,#+1
   \   00000068   0xD11F             BNE.N    ??SAI_InitI2S_8
   \   0000006A   0x2110             MOVS     R1,#+16
   \   0000006C   0xE020             B.N      ??SAI_InitI2S_9
   \                     ??SAI_InitI2S_10: (+1)
   \   0000006E   0x2480             MOVS     R4,#+128
   \   00000070   0x085B             LSRS     R3,R3,#+1
   \   00000072   0x6344             STR      R4,[R0, #+52]
   \   00000074   0x019C             LSLS     R4,R3,#+6
   \   00000076   0x015B             LSLS     R3,R3,#+5
   \   00000078   0x6404             STR      R4,[R0, #+64]
   \   0000007A   0x6443             STR      R3,[R0, #+68]
   \   0000007C   0x2380             MOVS     R3,#+128
   \   0000007E   0xE7EF             B.N      ??SAI_InitI2S_6
   \                     ??SAI_InitI2S_11: (+1)
   \   00000080   0x24C0             MOVS     R4,#+192
   \   00000082   0x085B             LSRS     R3,R3,#+1
   \   00000084   0x6344             STR      R4,[R0, #+52]
   \   00000086   0x019C             LSLS     R4,R3,#+6
   \   00000088   0x015B             LSLS     R3,R3,#+5
   \   0000008A   0x6404             STR      R4,[R0, #+64]
   \   0000008C   0x6443             STR      R3,[R0, #+68]
   \   0000008E   0x2380             MOVS     R3,#+128
   \   00000090   0xE7E6             B.N      ??SAI_InitI2S_6
   \                     ??SAI_InitI2S_12: (+1)
   \   00000092   0x24E0             MOVS     R4,#+224
   \   00000094   0x085B             LSRS     R3,R3,#+1
   \   00000096   0x6344             STR      R4,[R0, #+52]
   \   00000098   0x019C             LSLS     R4,R3,#+6
   \   0000009A   0x015B             LSLS     R3,R3,#+5
   \   0000009C   0x6404             STR      R4,[R0, #+64]
   \   0000009E   0x6443             STR      R3,[R0, #+68]
   \   000000A0   0x2380             MOVS     R3,#+128
   \   000000A2   0xE7DD             B.N      ??SAI_InitI2S_6
   \                     ??SAI_InitI2S_1: (+1)
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xBC10             POP      {R4}
   \   000000A8   0x4770             BX       LR
   1507              {
   1508                hsai->SlotInit.FirstBitOffset = 16;
   1509              }
   1510              if (datasize == SAI_PROTOCOL_DATASIZE_24BIT)
   \                     ??SAI_InitI2S_8: (+1)
   \   000000AA   0x2A02             CMP      R2,#+2
   \   000000AC   0xD101             BNE.N    ??SAI_InitI2S_7
   1511              {
   1512                hsai->SlotInit.FirstBitOffset = 8;
   \   000000AE   0x2108             MOVS     R1,#+8
   \                     ??SAI_InitI2S_9: (+1)
   \   000000B0   0x6541             STR      R1,[R0, #+84]
   1513              }
   1514            }
   1515            return HAL_OK;
   \                     ??SAI_InitI2S_7: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xBC10             POP      {R4}
   \   000000B6   0x4770             BX       LR               ;; return
   1516          }
   1517          
   1518          /**
   1519            * @brief  Initializes the SAI PCM protocol according to the specified parameters 
   1520            *         in the SAI_InitTypeDef and create the associated handle.
   1521            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1522            *                the configuration information for SAI module.
   1523            * @param  protocol : one of the supported protocol
   1524            * @param  datasize : one of the supported datasize @ref SAI_Protocol_DataSize
   1525            * @param  nbslot : number of slot minimum value is 1 and the max is 16.
   1526            * @retval HAL status
   1527            */
   1528          static HAL_StatusTypeDef SAI_InitPCM(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
   1529          {
   1530            /* Check the parameters */
   1531            assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
   1532            assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
   1533          
   1534            hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
   1535            hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
   1536            hsai->Init.ClockStrobing       = SAI_CLOCKSTROBING_FALLINGEDGE;
   1537            hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
   1538            hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
   1539            hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
   1540            hsai->SlotInit.FirstBitOffset  = 0;
   1541            hsai->SlotInit.SlotNumber      = nbslot;
   1542            hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
   1543            
   1544            switch(protocol)
   1545            {
   1546            case SAI_PCM_SHORT :
   1547              hsai->FrameInit.ActiveFrameLength = 1;
   1548              break;
   1549            case SAI_PCM_LONG :
   1550              hsai->FrameInit.ActiveFrameLength = 13;
   1551              break;
   1552            default :
   1553              return HAL_ERROR;
   1554            }
   1555           
   1556            switch(datasize)
   1557            {
   1558            case SAI_PROTOCOL_DATASIZE_16BIT:
   1559              hsai->Init.DataSize = SAI_DATASIZE_16;
   1560              hsai->FrameInit.FrameLength = 16 * nbslot;
   1561              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
   1562              break; 
   1563            case SAI_PROTOCOL_DATASIZE_16BITEXTENDED :
   1564              hsai->Init.DataSize = SAI_DATASIZE_16;
   1565              hsai->FrameInit.FrameLength = 32 * nbslot;
   1566              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1567              break;
   1568            case SAI_PROTOCOL_DATASIZE_24BIT :
   1569              hsai->Init.DataSize = SAI_DATASIZE_24;
   1570              hsai->FrameInit.FrameLength = 32 * nbslot;
   1571              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1572              break;    
   1573            case SAI_PROTOCOL_DATASIZE_32BIT: 
   1574              hsai->Init.DataSize = SAI_DATASIZE_32;
   1575              hsai->FrameInit.FrameLength = 32 * nbslot;
   1576              hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
   1577              break;
   1578            default :
   1579              return HAL_ERROR;
   1580            }
   1581           
   1582            return HAL_OK;
   1583          }
   1584          
   1585          /**
   1586            * @brief  Fill the fifo 
   1587            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1588            *                the configuration information for SAI module.
   1589            * @retval None.
   1590            */

   \                                 In section .text, align 2, keep-with-next
   1591          static void SAI_FillFifo(SAI_HandleTypeDef *hsai)
   1592          {
   \                     SAI_FillFifo: (+1)
   \   00000000   0xE008             B.N      ??SAI_FillFifo_0
   1593            /* fill the fifo with data before to enabled the SAI */
   1594            while(((hsai->Instance->SR & SAI_xSR_FLVL) != SAI_FIFOSTATUS_FULL) && (hsai->XferCount > 0))   
   1595            {
   1596              if((hsai->Init.DataSize == SAI_DATASIZE_8) && (hsai->Init.CompandingMode == SAI_NOCOMPANDING))
   1597              {
   1598                hsai->Instance->DR = (*hsai->pBuffPtr++);
   1599              }
   1600              else if(hsai->Init.DataSize <= SAI_DATASIZE_16)
   1601              {
   1602                hsai->Instance->DR = *((uint32_t *)hsai->pBuffPtr);
   1603                hsai->pBuffPtr+= 2;
   1604              }
   1605              else
   1606              {
   1607                hsai->Instance->DR = *((uint32_t *)hsai->pBuffPtr);
   \                     ??SAI_FillFifo_1: (+1)
   \   00000002   0x6E41             LDR      R1,[R0, #+100]
   \   00000004   0xF851 0xCB04      LDR      R12,[R1], #+4
   \   00000008   0xF8C2 0xC01C      STR      R12,[R2, #+28]
   1608                hsai->pBuffPtr+= 4;
   \                     ??SAI_FillFifo_2: (+1)
   \   0000000C   0x6641             STR      R1,[R0, #+100]
   1609              }
   1610              hsai->XferCount--;
   \                     ??SAI_FillFifo_3: (+1)
   \   0000000E   0x1E59             SUBS     R1,R3,#+1
   \   00000010   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   \                     ??SAI_FillFifo_0: (+1)
   \   00000014   0x6802             LDR      R2,[R0, #+0]
   \   00000016   0x6951             LDR      R1,[R2, #+20]
   \   00000018   0xF401 0x21E0      AND      R1,R1,#0x70000
   \   0000001C   0xF5B1 0x2FA0      CMP      R1,#+327680
   \   00000020   0xBF1C             ITT      NE 
   \   00000022   0xF8B0 0x306A      LDRHNE   R3,[R0, #+106]
   \   00000026   0x2B00             CMPNE    R3,#+0
   \   00000028   0xD013             BEQ.N    ??SAI_FillFifo_4
   \   0000002A   0x6B41             LDR      R1,[R0, #+52]
   \   0000002C   0x2940             CMP      R1,#+64
   \   0000002E   0xD108             BNE.N    ??SAI_FillFifo_5
   \   00000030   0x6A81             LDR      R1,[R0, #+40]
   \   00000032   0xB941             CBNZ.N   R1,??SAI_FillFifo_6
   \   00000034   0x6E41             LDR      R1,[R0, #+100]
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \   00000038   0x6641             STR      R1,[R0, #+100]
   \   0000003A   0x1E49             SUBS     R1,R1,#+1
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x61D1             STR      R1,[R2, #+28]
   \   00000040   0xE7E5             B.N      ??SAI_FillFifo_3
   \                     ??SAI_FillFifo_5: (+1)
   \   00000042   0x2981             CMP      R1,#+129
   \   00000044   0xD2DD             BCS.N    ??SAI_FillFifo_1
   \                     ??SAI_FillFifo_6: (+1)
   \   00000046   0x6E41             LDR      R1,[R0, #+100]
   \   00000048   0xF851 0xCB02      LDR      R12,[R1], #+2
   \   0000004C   0xF8C2 0xC01C      STR      R12,[R2, #+28]
   \   00000050   0xE7DC             B.N      ??SAI_FillFifo_2
   1611            }
   1612          }
   \                     ??SAI_FillFifo_4: (+1)
   \   00000052   0x4770             BX       LR               ;; return
   1613          
   1614          /**
   1615            * @brief  return the interrupt flag to set according the SAI setup 
   1616            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1617            *                the configuration information for SAI module.
   1618            * @param  mode : SAI_MODE_DMA or SAI_MODE_IT
   1619            * @retval the list of the IT flag to enable
   1620           */
   1621          static uint32_t SAI_InterruptFlag(SAI_HandleTypeDef *hsai, uint32_t mode)
   1622          {
   1623            uint32_t tmpIT = SAI_IT_OVRUDR; 
   1624            
   1625            if(mode == SAI_MODE_IT)
   1626            {
   1627              tmpIT|= SAI_IT_FREQ;
   1628            }
   1629          
   1630            if((hsai->Init.Protocol == SAI_AC97_PROTOCOL) && 
   1631              ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
   1632            {
   1633              tmpIT|= SAI_IT_CNRDY;
   1634            }
   1635            
   1636            if((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
   1637            {
   1638              tmpIT|= SAI_IT_AFSDET | SAI_IT_LFSDET;
   1639            }
   1640            else
   1641            {
   1642              /* hsai has been configured in master mode */
   1643              tmpIT|= SAI_IT_WCKCFG;
   1644            }
   1645            return tmpIT;
   1646          }
   1647          
   1648          /**
   1649            * @brief  disable the SAI and wait the disabling
   1650            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1651            *                the configuration information for SAI module.
   1652            * @retval None.
   1653            */
   1654          static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
   1655          {
   1656            uint32_t tickstart = HAL_GetTick();
   1657            HAL_StatusTypeDef status = HAL_OK;
   1658            
   1659            __HAL_SAI_DISABLE(hsai);
   1660            while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET)
   1661            {
   1662              /* Check for the Timeout */
   1663              if((HAL_GetTick() - tickstart ) > SAI_TIMEOUT_VALUE)
   1664              {         
   1665                /* Update error code */
   1666                hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
   1667                
   1668                return HAL_TIMEOUT;
   1669              }
   1670            }
   1671            return status;
   1672          }
   1673          
   1674          /**
   1675            * @brief  Tx Handler for Transmit in Interrupt mode 8Bit transfer
   1676            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1677            *                the configuration information for SAI module.
   1678            * @retval None.
   1679            */

   \                                 In section .text, align 4, keep-with-next
   1680          static void SAI_Transmit_IT8Bit(SAI_HandleTypeDef *hsai)
   1681          {
   \                     SAI_Transmit_IT8Bit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1682            if(hsai->XferCount == 0)
   \   00000004   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   00000008   0xBB09             CBNZ.N   R1,??SAI_Transmit_IT8Bit_0
   1683            {
   1684              /* Handle the end of the transmission */
   1685              /* Disable FREQ and OVRUDR interrupts */
   1686              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT)); 
   \   0000000A   0x6B02             LDR      R2,[R0, #+48]
   \   0000000C   0x2109             MOVS     R1,#+9
   \   0000000E   0x2A08             CMP      R2,#+8
   \   00000010   0xD115             BNE.N    ??SAI_Transmit_IT8Bit_1
   \   00000012   0x6842             LDR      R2,[R0, #+4]
   \   00000014   0x2A03             CMP      R2,#+3
   \   00000016   0xD10E             BNE.N    ??SAI_Transmit_IT8Bit_2
   \   00000018   0x2119             MOVS     R1,#+25
   \                     ??SAI_Transmit_IT8Bit_3: (+1)
   \   0000001A   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??SAI_Transmit_IT8Bit_4: (+1)
   \   0000001E   0x6802             LDR      R2,[R0, #+0]
   \   00000020   0x6913             LDR      R3,[R2, #+16]
   \   00000022   0xEA23 0x0101      BIC      R1,R3,R1
   \   00000026   0x6111             STR      R1,[R2, #+16]
   1687              hsai->State = HAL_SAI_STATE_READY;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x107D      STRB     R1,[R0, #+125]
   1688              HAL_SAI_TxCpltCallback(hsai);
   \   0000002E   0x.... 0x....      BL       HAL_SAI_TxCpltCallback
   1689            }
   1690            else
   1691            {
   1692              /* Write data on DR register */
   1693              hsai->Instance->DR = (*hsai->pBuffPtr++);
   1694              hsai->XferCount--;
   1695            }  
   1696          }
   \   00000032   0xB001             ADD      SP,SP,#+4
   \   00000034   0xBD00             POP      {PC}
   \                     ??SAI_Transmit_IT8Bit_2: (+1)
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xBF08             IT       EQ 
   \   0000003A   0x2119             MOVEQ    R1,#+25
   \   0000003C   0xD004             BEQ.N    ??SAI_Transmit_IT8Bit_5
   \                     ??SAI_Transmit_IT8Bit_1: (+1)
   \   0000003E   0x6842             LDR      R2,[R0, #+4]
   \   00000040   0x2A03             CMP      R2,#+3
   \   00000042   0xBF18             IT       NE 
   \   00000044   0x2A02             CMPNE    R2,#+2
   \   00000046   0xD0E8             BEQ.N    ??SAI_Transmit_IT8Bit_3
   \                     ??SAI_Transmit_IT8Bit_5: (+1)
   \   00000048   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000004C   0xE7E7             B.N      ??SAI_Transmit_IT8Bit_4
   \                     ??SAI_Transmit_IT8Bit_0: (+1)
   \   0000004E   0x6E41             LDR      R1,[R0, #+100]
   \   00000050   0x1C4A             ADDS     R2,R1,#+1
   \   00000052   0x6642             STR      R2,[R0, #+100]
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0x6802             LDR      R2,[R0, #+0]
   \   00000058   0x61D1             STR      R1,[R2, #+28]
   \   0000005A   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   0000005E   0x1E49             SUBS     R1,R1,#+1
   \   00000060   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   \   00000064   0xB001             ADD      SP,SP,#+4
   \   00000066   0xBD00             POP      {PC}             ;; return
   1697          
   1698          /**
   1699            * @brief  Tx Handler for Transmit in Interrupt mode for 16Bit transfer
   1700            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1701            *                the configuration information for SAI module.
   1702            * @retval None.
   1703            */

   \                                 In section .text, align 4, keep-with-next
   1704          static void SAI_Transmit_IT16Bit(SAI_HandleTypeDef *hsai)
   1705          {
   \                     SAI_Transmit_IT16Bit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1706            if(hsai->XferCount == 0)
   \   00000004   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   00000008   0xBB09             CBNZ.N   R1,??SAI_Transmit_IT16Bit_0
   1707            {
   1708              /* Handle the end of the transmission */    
   1709              /* Disable FREQ and OVRUDR interrupts */
   1710              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT)); 
   \   0000000A   0x6B02             LDR      R2,[R0, #+48]
   \   0000000C   0x2109             MOVS     R1,#+9
   \   0000000E   0x2A08             CMP      R2,#+8
   \   00000010   0xD115             BNE.N    ??SAI_Transmit_IT16Bit_1
   \   00000012   0x6842             LDR      R2,[R0, #+4]
   \   00000014   0x2A03             CMP      R2,#+3
   \   00000016   0xD10E             BNE.N    ??SAI_Transmit_IT16Bit_2
   \   00000018   0x2119             MOVS     R1,#+25
   \                     ??SAI_Transmit_IT16Bit_3: (+1)
   \   0000001A   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??SAI_Transmit_IT16Bit_4: (+1)
   \   0000001E   0x6802             LDR      R2,[R0, #+0]
   \   00000020   0x6913             LDR      R3,[R2, #+16]
   \   00000022   0xEA23 0x0101      BIC      R1,R3,R1
   \   00000026   0x6111             STR      R1,[R2, #+16]
   1711              hsai->State = HAL_SAI_STATE_READY;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x107D      STRB     R1,[R0, #+125]
   1712              HAL_SAI_TxCpltCallback(hsai);
   \   0000002E   0x.... 0x....      BL       HAL_SAI_TxCpltCallback
   1713            }
   1714            else
   1715            {
   1716              /* Write data on DR register */
   1717              hsai->Instance->DR = *(uint16_t *)hsai->pBuffPtr;
   1718              hsai->pBuffPtr+=2;
   1719              hsai->XferCount--;
   1720            }  
   1721          }
   \   00000032   0xB001             ADD      SP,SP,#+4
   \   00000034   0xBD00             POP      {PC}
   \                     ??SAI_Transmit_IT16Bit_2: (+1)
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xBF08             IT       EQ 
   \   0000003A   0x2119             MOVEQ    R1,#+25
   \   0000003C   0xD004             BEQ.N    ??SAI_Transmit_IT16Bit_5
   \                     ??SAI_Transmit_IT16Bit_1: (+1)
   \   0000003E   0x6842             LDR      R2,[R0, #+4]
   \   00000040   0x2A03             CMP      R2,#+3
   \   00000042   0xBF18             IT       NE 
   \   00000044   0x2A02             CMPNE    R2,#+2
   \   00000046   0xD0E8             BEQ.N    ??SAI_Transmit_IT16Bit_3
   \                     ??SAI_Transmit_IT16Bit_5: (+1)
   \   00000048   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000004C   0xE7E7             B.N      ??SAI_Transmit_IT16Bit_4
   \                     ??SAI_Transmit_IT16Bit_0: (+1)
   \   0000004E   0x6E41             LDR      R1,[R0, #+100]
   \   00000050   0x6802             LDR      R2,[R0, #+0]
   \   00000052   0x8809             LDRH     R1,[R1, #+0]
   \   00000054   0x61D1             STR      R1,[R2, #+28]
   \   00000056   0x6E41             LDR      R1,[R0, #+100]
   \   00000058   0x1C89             ADDS     R1,R1,#+2
   \   0000005A   0x6641             STR      R1,[R0, #+100]
   \   0000005C   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   00000060   0x1E49             SUBS     R1,R1,#+1
   \   00000062   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0xBD00             POP      {PC}             ;; return
   1722          
   1723          /**
   1724            * @brief  Tx Handler for Transmit in Interrupt mode for 32Bit transfer
   1725            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1726            *                the configuration information for SAI module.
   1727            * @retval None.
   1728            */

   \                                 In section .text, align 4, keep-with-next
   1729          static void SAI_Transmit_IT32Bit(SAI_HandleTypeDef *hsai)
   1730          {
   \                     SAI_Transmit_IT32Bit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1731            if(hsai->XferCount == 0)
   \   00000004   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   00000008   0xBB09             CBNZ.N   R1,??SAI_Transmit_IT32Bit_0
   1732            {
   1733              /* Handle the end of the transmission */
   1734              /* Disable FREQ and OVRUDR interrupts */
   1735              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT)); 
   \   0000000A   0x6B02             LDR      R2,[R0, #+48]
   \   0000000C   0x2109             MOVS     R1,#+9
   \   0000000E   0x2A08             CMP      R2,#+8
   \   00000010   0xD115             BNE.N    ??SAI_Transmit_IT32Bit_1
   \   00000012   0x6842             LDR      R2,[R0, #+4]
   \   00000014   0x2A03             CMP      R2,#+3
   \   00000016   0xD10E             BNE.N    ??SAI_Transmit_IT32Bit_2
   \   00000018   0x2119             MOVS     R1,#+25
   \                     ??SAI_Transmit_IT32Bit_3: (+1)
   \   0000001A   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??SAI_Transmit_IT32Bit_4: (+1)
   \   0000001E   0x6802             LDR      R2,[R0, #+0]
   \   00000020   0x6913             LDR      R3,[R2, #+16]
   \   00000022   0xEA23 0x0101      BIC      R1,R3,R1
   \   00000026   0x6111             STR      R1,[R2, #+16]
   1736              hsai->State = HAL_SAI_STATE_READY;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF880 0x107D      STRB     R1,[R0, #+125]
   1737              HAL_SAI_TxCpltCallback(hsai);
   \   0000002E   0x.... 0x....      BL       HAL_SAI_TxCpltCallback
   1738            }
   1739            else
   1740            {
   1741              /* Write data on DR register */
   1742              hsai->Instance->DR = *(uint32_t *)hsai->pBuffPtr;
   1743              hsai->pBuffPtr+=4;
   1744              hsai->XferCount--;
   1745            }
   1746          }
   \   00000032   0xB001             ADD      SP,SP,#+4
   \   00000034   0xBD00             POP      {PC}
   \                     ??SAI_Transmit_IT32Bit_2: (+1)
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xBF08             IT       EQ 
   \   0000003A   0x2119             MOVEQ    R1,#+25
   \   0000003C   0xD004             BEQ.N    ??SAI_Transmit_IT32Bit_5
   \                     ??SAI_Transmit_IT32Bit_1: (+1)
   \   0000003E   0x6842             LDR      R2,[R0, #+4]
   \   00000040   0x2A03             CMP      R2,#+3
   \   00000042   0xBF18             IT       NE 
   \   00000044   0x2A02             CMPNE    R2,#+2
   \   00000046   0xD0E8             BEQ.N    ??SAI_Transmit_IT32Bit_3
   \                     ??SAI_Transmit_IT32Bit_5: (+1)
   \   00000048   0xF041 0x0104      ORR      R1,R1,#0x4
   \   0000004C   0xE7E7             B.N      ??SAI_Transmit_IT32Bit_4
   \                     ??SAI_Transmit_IT32Bit_0: (+1)
   \   0000004E   0x6E41             LDR      R1,[R0, #+100]
   \   00000050   0x6802             LDR      R2,[R0, #+0]
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0x61D1             STR      R1,[R2, #+28]
   \   00000056   0x6E41             LDR      R1,[R0, #+100]
   \   00000058   0x1D09             ADDS     R1,R1,#+4
   \   0000005A   0x6641             STR      R1,[R0, #+100]
   \   0000005C   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   00000060   0x1E49             SUBS     R1,R1,#+1
   \   00000062   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0xBD00             POP      {PC}             ;; return
   1747          
   1748          /**
   1749            * @brief  Rx Handler for Receive in Interrupt mode 8Bit transfer
   1750            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1751            *                the configuration information for SAI module.
   1752            * @retval None.
   1753            */

   \                                 In section .text, align 4, keep-with-next
   1754          static void SAI_Receive_IT8Bit(SAI_HandleTypeDef *hsai)
   1755          {
   1756            /* Receive data */    
   1757            (*hsai->pBuffPtr++) = hsai->Instance->DR;
   \                     SAI_Receive_IT8Bit: (+1)
   \   00000000   0x6E41             LDR      R1,[R0, #+100]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6642             STR      R2,[R0, #+100]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x69D2             LDR      R2,[R2, #+28]
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   1758            hsai->XferCount--;
   \   0000000C   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   1759            
   1760            /* Check end of the transfer */  
   1761            if(hsai->XferCount == 0)
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0xB101             CBZ.N    R1,??SAI_Receive_IT8Bit_0
   \   0000001A   0x4770             BX       LR
   1762            {    
   1763              /* Disable TXE and OVRUDR interrupts */
   1764              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \                     ??SAI_Receive_IT8Bit_0: (+1)
   \   0000001C   0xB500             PUSH     {LR}
   \   0000001E   0xB081             SUB      SP,SP,#+4
   \   00000020   0x6B02             LDR      R2,[R0, #+48]
   \   00000022   0x2109             MOVS     R1,#+9
   \   00000024   0x2A08             CMP      R2,#+8
   \   00000026   0xD117             BNE.N    ??SAI_Receive_IT8Bit_1
   \   00000028   0x6842             LDR      R2,[R0, #+4]
   \   0000002A   0x2A03             CMP      R2,#+3
   \   0000002C   0xD110             BNE.N    ??SAI_Receive_IT8Bit_2
   \   0000002E   0x2119             MOVS     R1,#+25
   \                     ??SAI_Receive_IT8Bit_3: (+1)
   \   00000030   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??SAI_Receive_IT8Bit_4: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x6913             LDR      R3,[R2, #+16]
   \   00000038   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000003C   0x6111             STR      R1,[R2, #+16]
   1765              
   1766              /* Clear the SAI Overrun flag */
   1767              __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x6191             STR      R1,[R2, #+24]
   1768              
   1769              hsai->State = HAL_SAI_STATE_READY;
   \   00000044   0xF880 0x107D      STRB     R1,[R0, #+125]
   1770              HAL_SAI_RxCpltCallback(hsai); 
   \   00000048   0x.... 0x....      BL       HAL_SAI_RxCpltCallback
   1771            }
   1772          }
   \   0000004C   0xB001             ADD      SP,SP,#+4
   \   0000004E   0xBD00             POP      {PC}             ;; return
   \                     ??SAI_Receive_IT8Bit_2: (+1)
   \   00000050   0x2A01             CMP      R2,#+1
   \   00000052   0xBF08             IT       EQ 
   \   00000054   0x2119             MOVEQ    R1,#+25
   \   00000056   0xD004             BEQ.N    ??SAI_Receive_IT8Bit_5
   \                     ??SAI_Receive_IT8Bit_1: (+1)
   \   00000058   0x6842             LDR      R2,[R0, #+4]
   \   0000005A   0x2A03             CMP      R2,#+3
   \   0000005C   0xBF18             IT       NE 
   \   0000005E   0x2A02             CMPNE    R2,#+2
   \   00000060   0xD0E6             BEQ.N    ??SAI_Receive_IT8Bit_3
   \                     ??SAI_Receive_IT8Bit_5: (+1)
   \   00000062   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000066   0xE7E5             B.N      ??SAI_Receive_IT8Bit_4
   1773          
   1774          /**
   1775            * @brief  Rx Handler for Receive in Interrupt mode for 16Bit transfer
   1776            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1777            *                the configuration information for SAI module.
   1778            * @retval None.
   1779            */

   \                                 In section .text, align 4, keep-with-next
   1780          static void SAI_Receive_IT16Bit(SAI_HandleTypeDef *hsai)
   1781          {
   1782            /* Receive data */    
   1783            *(uint16_t*)hsai->pBuffPtr = hsai->Instance->DR;
   \                     SAI_Receive_IT16Bit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x69C9             LDR      R1,[R1, #+28]
   \   00000004   0x6E42             LDR      R2,[R0, #+100]
   \   00000006   0x8011             STRH     R1,[R2, #+0]
   1784            hsai->pBuffPtr+=2;
   \   00000008   0x6E41             LDR      R1,[R0, #+100]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6641             STR      R1,[R0, #+100]
   1785            hsai->XferCount--;
   \   0000000E   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   00000012   0x1E49             SUBS     R1,R1,#+1
   \   00000014   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   1786            
   1787            /* Check end of the transfer */  
   1788            if(hsai->XferCount == 0)
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0xB101             CBZ.N    R1,??SAI_Receive_IT16Bit_0
   \   0000001C   0x4770             BX       LR
   1789            {    
   1790              /* Disable TXE and OVRUDR interrupts */
   1791              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \                     ??SAI_Receive_IT16Bit_0: (+1)
   \   0000001E   0xB500             PUSH     {LR}
   \   00000020   0xB081             SUB      SP,SP,#+4
   \   00000022   0x6B02             LDR      R2,[R0, #+48]
   \   00000024   0x2109             MOVS     R1,#+9
   \   00000026   0x2A08             CMP      R2,#+8
   \   00000028   0xD117             BNE.N    ??SAI_Receive_IT16Bit_1
   \   0000002A   0x6842             LDR      R2,[R0, #+4]
   \   0000002C   0x2A03             CMP      R2,#+3
   \   0000002E   0xD110             BNE.N    ??SAI_Receive_IT16Bit_2
   \   00000030   0x2119             MOVS     R1,#+25
   \                     ??SAI_Receive_IT16Bit_3: (+1)
   \   00000032   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??SAI_Receive_IT16Bit_4: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x6913             LDR      R3,[R2, #+16]
   \   0000003A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000003E   0x6111             STR      R1,[R2, #+16]
   1792              
   1793              /* Clear the SAI Overrun flag */
   1794              __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x6191             STR      R1,[R2, #+24]
   1795              
   1796              hsai->State = HAL_SAI_STATE_READY;
   \   00000046   0xF880 0x107D      STRB     R1,[R0, #+125]
   1797              HAL_SAI_RxCpltCallback(hsai); 
   \   0000004A   0x.... 0x....      BL       HAL_SAI_RxCpltCallback
   1798            }
   1799          }
   \   0000004E   0xB001             ADD      SP,SP,#+4
   \   00000050   0xBD00             POP      {PC}             ;; return
   \                     ??SAI_Receive_IT16Bit_2: (+1)
   \   00000052   0x2A01             CMP      R2,#+1
   \   00000054   0xBF08             IT       EQ 
   \   00000056   0x2119             MOVEQ    R1,#+25
   \   00000058   0xD004             BEQ.N    ??SAI_Receive_IT16Bit_5
   \                     ??SAI_Receive_IT16Bit_1: (+1)
   \   0000005A   0x6842             LDR      R2,[R0, #+4]
   \   0000005C   0x2A03             CMP      R2,#+3
   \   0000005E   0xBF18             IT       NE 
   \   00000060   0x2A02             CMPNE    R2,#+2
   \   00000062   0xD0E6             BEQ.N    ??SAI_Receive_IT16Bit_3
   \                     ??SAI_Receive_IT16Bit_5: (+1)
   \   00000064   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000068   0xE7E5             B.N      ??SAI_Receive_IT16Bit_4
   1800          /**
   1801            * @brief  Rx Handler for Receive in Interrupt mode for 32Bit transfer
   1802            * @param  hsai : pointer to a SAI_HandleTypeDef structure that contains
   1803            *                the configuration information for SAI module.
   1804            * @retval None.
   1805            */

   \                                 In section .text, align 4, keep-with-next
   1806          static void SAI_Receive_IT32Bit(SAI_HandleTypeDef *hsai)
   1807          {
   1808            /* Receive data */    
   1809            *(uint32_t*)hsai->pBuffPtr = hsai->Instance->DR;
   \                     SAI_Receive_IT32Bit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x69C9             LDR      R1,[R1, #+28]
   \   00000004   0x6E42             LDR      R2,[R0, #+100]
   \   00000006   0x6011             STR      R1,[R2, #+0]
   1810            hsai->pBuffPtr+=4;
   \   00000008   0x6E41             LDR      R1,[R0, #+100]
   \   0000000A   0x1D09             ADDS     R1,R1,#+4
   \   0000000C   0x6641             STR      R1,[R0, #+100]
   1811            hsai->XferCount--;
   \   0000000E   0xF8B0 0x106A      LDRH     R1,[R0, #+106]
   \   00000012   0x1E49             SUBS     R1,R1,#+1
   \   00000014   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   1812            
   1813            /* Check end of the transfer */  
   1814            if(hsai->XferCount == 0)
   \   00000018   0xB289             UXTH     R1,R1
   \   0000001A   0xB101             CBZ.N    R1,??SAI_Receive_IT32Bit_0
   \   0000001C   0x4770             BX       LR
   1815            {    
   1816              /* Disable TXE and OVRUDR interrupts */
   1817              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_IT));
   \                     ??SAI_Receive_IT32Bit_0: (+1)
   \   0000001E   0xB500             PUSH     {LR}
   \   00000020   0xB081             SUB      SP,SP,#+4
   \   00000022   0x6B02             LDR      R2,[R0, #+48]
   \   00000024   0x2109             MOVS     R1,#+9
   \   00000026   0x2A08             CMP      R2,#+8
   \   00000028   0xD117             BNE.N    ??SAI_Receive_IT32Bit_1
   \   0000002A   0x6842             LDR      R2,[R0, #+4]
   \   0000002C   0x2A03             CMP      R2,#+3
   \   0000002E   0xD110             BNE.N    ??SAI_Receive_IT32Bit_2
   \   00000030   0x2119             MOVS     R1,#+25
   \                     ??SAI_Receive_IT32Bit_3: (+1)
   \   00000032   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??SAI_Receive_IT32Bit_4: (+1)
   \   00000036   0x6802             LDR      R2,[R0, #+0]
   \   00000038   0x6913             LDR      R3,[R2, #+16]
   \   0000003A   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000003E   0x6111             STR      R1,[R2, #+16]
   1818              
   1819              /* Clear the SAI Overrun flag */
   1820              __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x6191             STR      R1,[R2, #+24]
   1821              
   1822              hsai->State = HAL_SAI_STATE_READY;
   \   00000046   0xF880 0x107D      STRB     R1,[R0, #+125]
   1823              HAL_SAI_RxCpltCallback(hsai); 
   \   0000004A   0x.... 0x....      BL       HAL_SAI_RxCpltCallback
   1824            }
   1825          }
   \   0000004E   0xB001             ADD      SP,SP,#+4
   \   00000050   0xBD00             POP      {PC}             ;; return
   \                     ??SAI_Receive_IT32Bit_2: (+1)
   \   00000052   0x2A01             CMP      R2,#+1
   \   00000054   0xBF08             IT       EQ 
   \   00000056   0x2119             MOVEQ    R1,#+25
   \   00000058   0xD004             BEQ.N    ??SAI_Receive_IT32Bit_5
   \                     ??SAI_Receive_IT32Bit_1: (+1)
   \   0000005A   0x6842             LDR      R2,[R0, #+4]
   \   0000005C   0x2A03             CMP      R2,#+3
   \   0000005E   0xBF18             IT       NE 
   \   00000060   0x2A02             CMPNE    R2,#+2
   \   00000062   0xD0E6             BEQ.N    ??SAI_Receive_IT32Bit_3
   \                     ??SAI_Receive_IT32Bit_5: (+1)
   \   00000064   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000068   0xE7E5             B.N      ??SAI_Receive_IT32Bit_4
   1826          
   1827          /**
   1828            * @brief DMA SAI transmit process complete callback.
   1829            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1830            *                the configuration information for the specified DMA module.
   1831            * @retval None
   1832            */

   \                                 In section .text, align 4, keep-with-next
   1833          static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)   
   1834          {
   \                     SAI_DMATxCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1835            SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000006   0x6B88             LDR      R0,[R1, #+56]
   1836            
   1837            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x05C9             LSLS     R1,R1,#+23
   \   0000000E   0xD419             BMI.N    ??SAI_DMATxCplt_0
   1838            { 
   1839              hsai->XferCount = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   1840              
   1841              /* Disable SAI Tx DMA Request */  
   1842              hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0xF422 0x3200      BIC      R2,R2,#0x20000
   \   0000001E   0x600A             STR      R2,[R1, #+0]
   1843          
   1844              /* Stop the interrupts error handling */
   1845              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   \   00000020   0x6B02             LDR      R2,[R0, #+48]
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2A08             CMP      R2,#+8
   \   00000026   0xD115             BNE.N    ??SAI_DMATxCplt_1
   \   00000028   0x6842             LDR      R2,[R0, #+4]
   \   0000002A   0x2A03             CMP      R2,#+3
   \   0000002C   0xD10E             BNE.N    ??SAI_DMATxCplt_2
   \   0000002E   0x2111             MOVS     R1,#+17
   \                     ??SAI_DMATxCplt_3: (+1)
   \   00000030   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??SAI_DMATxCplt_4: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x6913             LDR      R3,[R2, #+16]
   \   00000038   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000003C   0x6111             STR      R1,[R2, #+16]
   1846              
   1847              hsai->State= HAL_SAI_STATE_READY;
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF880 0x107D      STRB     R1,[R0, #+125]
   1848            }
   1849            HAL_SAI_TxCpltCallback(hsai);
   \                     ??SAI_DMATxCplt_0: (+1)
   \   00000044   0x.... 0x....      BL       HAL_SAI_TxCpltCallback
   1850          }
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xBD00             POP      {PC}             ;; return
   \                     ??SAI_DMATxCplt_2: (+1)
   \   0000004C   0x2A01             CMP      R2,#+1
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0x2111             MOVEQ    R1,#+17
   \   00000052   0xD004             BEQ.N    ??SAI_DMATxCplt_5
   \                     ??SAI_DMATxCplt_1: (+1)
   \   00000054   0x6842             LDR      R2,[R0, #+4]
   \   00000056   0x2A03             CMP      R2,#+3
   \   00000058   0xBF18             IT       NE 
   \   0000005A   0x2A02             CMPNE    R2,#+2
   \   0000005C   0xD0E8             BEQ.N    ??SAI_DMATxCplt_3
   \                     ??SAI_DMATxCplt_5: (+1)
   \   0000005E   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000062   0xE7E7             B.N      ??SAI_DMATxCplt_4
   1851          
   1852          /**
   1853            * @brief DMA SAI transmit process half complete callback 
   1854            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1855            *                the configuration information for the specified DMA module.
   1856            * @retval None
   1857            */

   \                                 In section .text, align 4, keep-with-next
   1858          static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1859          {
   \                     SAI_DMATxHalfCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1860            SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1861          
   1862            HAL_SAI_TxHalfCpltCallback(hsai);
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x.... 0x....      BL       HAL_SAI_TxHalfCpltCallback
   1863          }
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xBD00             POP      {PC}             ;; return
   1864          
   1865          /**
   1866            * @brief DMA SAI receive process complete callback. 
   1867            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1868            *                the configuration information for the specified DMA module.
   1869            * @retval None
   1870            */

   \                                 In section .text, align 4, keep-with-next
   1871          static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)   
   1872          {
   \                     SAI_DMARxCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
   1873            SAI_HandleTypeDef* hsai = ( SAI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000006   0x6B88             LDR      R0,[R1, #+56]
   1874            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0)
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x05C9             LSLS     R1,R1,#+23
   \   0000000E   0xD419             BMI.N    ??SAI_DMARxCplt_0
   1875            {
   1876              /* Disable Rx DMA Request */
   1877              hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x680A             LDR      R2,[R1, #+0]
   \   00000014   0xF422 0x3200      BIC      R2,R2,#0x20000
   \   00000018   0x600A             STR      R2,[R1, #+0]
   1878              hsai->XferCount = 0;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xF8A0 0x106A      STRH     R1,[R0, #+106]
   1879              
   1880              /* Stop the interrupts error handling */
   1881              __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
   \   00000020   0x6B02             LDR      R2,[R0, #+48]
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x2A08             CMP      R2,#+8
   \   00000026   0xD115             BNE.N    ??SAI_DMARxCplt_1
   \   00000028   0x6842             LDR      R2,[R0, #+4]
   \   0000002A   0x2A03             CMP      R2,#+3
   \   0000002C   0xD10E             BNE.N    ??SAI_DMARxCplt_2
   \   0000002E   0x2111             MOVS     R1,#+17
   \                     ??SAI_DMARxCplt_3: (+1)
   \   00000030   0xF041 0x0160      ORR      R1,R1,#0x60
   \                     ??SAI_DMARxCplt_4: (+1)
   \   00000034   0x6802             LDR      R2,[R0, #+0]
   \   00000036   0x6913             LDR      R3,[R2, #+16]
   \   00000038   0xEA23 0x0101      BIC      R1,R3,R1
   \   0000003C   0x6111             STR      R1,[R2, #+16]
   1882              
   1883              hsai->State = HAL_SAI_STATE_READY;
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF880 0x107D      STRB     R1,[R0, #+125]
   1884            }
   1885            HAL_SAI_RxCpltCallback(hsai); 
   \                     ??SAI_DMARxCplt_0: (+1)
   \   00000044   0x.... 0x....      BL       HAL_SAI_RxCpltCallback
   1886          }
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xBD00             POP      {PC}             ;; return
   \                     ??SAI_DMARxCplt_2: (+1)
   \   0000004C   0x2A01             CMP      R2,#+1
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0x2111             MOVEQ    R1,#+17
   \   00000052   0xD004             BEQ.N    ??SAI_DMARxCplt_5
   \                     ??SAI_DMARxCplt_1: (+1)
   \   00000054   0x6842             LDR      R2,[R0, #+4]
   \   00000056   0x2A03             CMP      R2,#+3
   \   00000058   0xBF18             IT       NE 
   \   0000005A   0x2A02             CMPNE    R2,#+2
   \   0000005C   0xD0E8             BEQ.N    ??SAI_DMARxCplt_3
   \                     ??SAI_DMARxCplt_5: (+1)
   \   0000005E   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000062   0xE7E7             B.N      ??SAI_DMARxCplt_4
   1887          
   1888          /**
   1889            * @brief DMA SAI receive process half complete callback 
   1890            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1891            *                the configuration information for the specified DMA module.
   1892            * @retval None
   1893            */

   \                                 In section .text, align 4, keep-with-next
   1894          static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1895          {
   \                     SAI_DMARxHalfCplt: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1896            SAI_HandleTypeDef* hsai = (SAI_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   1897          
   1898            HAL_SAI_RxHalfCpltCallback(hsai); 
   \   00000004   0x6B80             LDR      R0,[R0, #+56]
   \   00000006   0x.... 0x....      BL       HAL_SAI_RxHalfCpltCallback
   1899          }
   \   0000000A   0xB001             ADD      SP,SP,#+4
   \   0000000C   0xBD00             POP      {PC}             ;; return
   1900          /**
   1901            * @brief DMA SAI communication error callback. 
   1902            * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
   1903            *                the configuration information for the specified DMA module.
   1904            * @retval None
   1905            */

   \                                 In section .text, align 4, keep-with-next
   1906          static void SAI_DMAError(DMA_HandleTypeDef *hdma)   
   1907          {
   \                     SAI_DMAError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1908            SAI_HandleTypeDef* hsai = ( SAI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   1909            
   1910            /* Stop the DMA transfer */
   1911            HAL_SAI_DMAStop(hsai);
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       HAL_SAI_DMAStop
   1912            
   1913            /* Set the SAI state ready to be able to start again the process */
   1914            hsai->State= HAL_SAI_STATE_READY;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xF884 0x007D      STRB     R0,[R4, #+125]
   1915            HAL_SAI_ErrorCallback(hsai);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_SAI_ErrorCallback
   1916            
   1917            hsai->XferCount = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8A4 0x006A      STRH     R0,[R4, #+106]
   1918          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFF05C010         DC32     0xff05c010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0xFFFF1FF0         DC32     0xffff1ff0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0xFFF88000         DC32     0xfff88000
   1919          
   1920          /**
   1921            * @}
   1922            */
   1923          
   1924          #endif /* HAL_SAI_MODULE_ENABLED */
   1925          /**
   1926            * @}
   1927            */
   1928          
   1929          /**
   1930            * @}
   1931            */
   1932          
   1933          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_SAI_Abort
        16   -> HAL_DMA_Abort
        16   -> HAL_GetTick
       0   HAL_SAI_DMAPause
       0   HAL_SAI_DMAResume
      16   HAL_SAI_DMAStop
        16   -> HAL_DMA_Abort
        16   -> HAL_GetTick
      16   HAL_SAI_DeInit
        16   -> HAL_GetTick
        16   -> HAL_SAI_MspDeInit
       0   HAL_SAI_DisableRxMuteMode
       0   HAL_SAI_DisableTxMuteMode
       0   HAL_SAI_EnableRxMuteMode
       0   HAL_SAI_EnableTxMuteMode
       0   HAL_SAI_ErrorCallback
       0   HAL_SAI_GetError
       0   HAL_SAI_GetState
      16   HAL_SAI_IRQHandler
        16   -- Indirect call
        16   -> HAL_SAI_Abort
        16   -> HAL_SAI_ErrorCallback
      16   HAL_SAI_Init
        16   -> HAL_GetTick
        16   -> HAL_SAI_MspInit
        16   -> SAI_BlockSynchroConfig
        16   -> SAI_GetInputClock
       8   HAL_SAI_InitProtocol
         0   -> HAL_SAI_Init
         8   -> SAI_InitI2S
       0   HAL_SAI_MspDeInit
       0   HAL_SAI_MspInit
      24   HAL_SAI_Receive
        24   -> HAL_GetTick
       8   HAL_SAI_Receive_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_SAI_Receive_IT
       0   HAL_SAI_RxCpltCallback
       0   HAL_SAI_RxHalfCpltCallback
      24   HAL_SAI_Transmit
        24   -> HAL_GetTick
        24   -> SAI_FillFifo
       8   HAL_SAI_Transmit_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_SAI_Transmit_IT
       0   HAL_SAI_TxCpltCallback
       0   HAL_SAI_TxHalfCpltCallback
       8   SAI_DMAError
         8   -> HAL_SAI_DMAStop
         8   -> HAL_SAI_ErrorCallback
       8   SAI_DMARxCplt
         8   -> HAL_SAI_RxCpltCallback
       8   SAI_DMARxHalfCplt
         8   -> HAL_SAI_RxHalfCpltCallback
       8   SAI_DMATxCplt
         8   -> HAL_SAI_TxCpltCallback
       8   SAI_DMATxHalfCplt
         8   -> HAL_SAI_TxHalfCpltCallback
       0   SAI_FillFifo
       4   SAI_InitI2S
       8   SAI_Receive_IT16Bit
         8   -> HAL_SAI_RxCpltCallback
       8   SAI_Receive_IT32Bit
         8   -> HAL_SAI_RxCpltCallback
       8   SAI_Receive_IT8Bit
         8   -> HAL_SAI_RxCpltCallback
       8   SAI_Transmit_IT16Bit
         8   -> HAL_SAI_TxCpltCallback
       8   SAI_Transmit_IT32Bit
         8   -> HAL_SAI_TxCpltCallback
       8   SAI_Transmit_IT8Bit
         8   -> HAL_SAI_TxCpltCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
     128  HAL_SAI_Abort
      38  HAL_SAI_DMAPause
      52  HAL_SAI_DMAResume
     122  HAL_SAI_DMAStop
     112  HAL_SAI_DeInit
      28  HAL_SAI_DisableRxMuteMode
      24  HAL_SAI_DisableTxMuteMode
      52  HAL_SAI_EnableRxMuteMode
      36  HAL_SAI_EnableTxMuteMode
       2  HAL_SAI_ErrorCallback
       6  HAL_SAI_GetError
       6  HAL_SAI_GetState
     202  HAL_SAI_IRQHandler
     342  HAL_SAI_Init
     146  HAL_SAI_InitProtocol
       2  HAL_SAI_MspDeInit
       2  HAL_SAI_MspInit
     232  HAL_SAI_Receive
     192  HAL_SAI_Receive_DMA
     170  HAL_SAI_Receive_IT
       2  HAL_SAI_RxCpltCallback
       2  HAL_SAI_RxHalfCpltCallback
     242  HAL_SAI_Transmit
     190  HAL_SAI_Transmit_DMA
     256  HAL_SAI_Transmit_IT
       2  HAL_SAI_TxCpltCallback
       2  HAL_SAI_TxHalfCpltCallback
      30  SAI_DMAError
     100  SAI_DMARxCplt
      14  SAI_DMARxHalfCplt
     100  SAI_DMATxCplt
      14  SAI_DMATxHalfCplt
      84  SAI_FillFifo
     184  SAI_InitI2S
     106  SAI_Receive_IT16Bit
     106  SAI_Receive_IT32Bit
     104  SAI_Receive_IT8Bit
     106  SAI_Transmit_IT16Bit
     106  SAI_Transmit_IT32Bit
     104  SAI_Transmit_IT8Bit

 
 3 760 bytes in section .text
 
 3 760 bytes of CODE memory

Errors: none
Warnings: none
