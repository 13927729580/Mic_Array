###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.3.10732/W32 for ARM       08/Nov/2016  10:26:30
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
#    Command line =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
#        -D USE_HAL_DRIVER -D STM32F746xx -D USE_STM32746G_DISCO -D
#        USE_IOEXPANDER -D USE_USB_FS -lC
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -lA
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List
#        -o
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj
#        --no_unroll --debug --endian=little --cpu=Cortex-M7 -e
#        --char_is_signed --fpu=VFPv5_sp --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F7xx\Include\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\STM32F7xx_HAL_Driver\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\STM32746G-Discovery\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Drivers\BSP\Components\Common\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Log\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\Fonts\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Utilities\CPU\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Core\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_HOST_Library\Class\MSC\Inc\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FatFs\src\drivers\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_Audio\Addons\PDM\
#        -I
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\..\..\..\..\..\..\Middlewares\ST\STM32_USB_Device_Library\Class\AUDIO\Inc\
#        -Ohs --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.3\arm\CMSIS\Include\" -D
#        ARM_MATH_CM7 --relaxed_fp
#    List file    =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\List\stm32f7xx_hal_pwr_ex.lst
#    Object file  =  
#        D:\sop1hc\Mic\Mic_Array\For_Window\Projects\STM32746G\Applications\Audio\Mic_Array\EWARM\STM32F7\Obj\stm32f7xx_hal_pwr_ex.o
#
###############################################################################

D:\sop1hc\Mic\Mic_Array\For_Window\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f7xx_hal_pwr_ex.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    09-December-2015
      7            * @brief   Extended PWR HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of PWR extension peripheral:           
     10            *           + Peripheral Extended features functions
     11            *         
     12            ******************************************************************************
     13            * @attention
     14            *
     15            * <h2><center>&copy; COPYRIGHT(c) 2015 STMicroelectronics</center></h2>
     16            *
     17            * Redistribution and use in source and binary forms, with or without modification,
     18            * are permitted provided that the following conditions are met:
     19            *   1. Redistributions of source code must retain the above copyright notice,
     20            *      this list of conditions and the following disclaimer.
     21            *   2. Redistributions in binary form must reproduce the above copyright notice,
     22            *      this list of conditions and the following disclaimer in the documentation
     23            *      and/or other materials provided with the distribution.
     24            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     25            *      may be used to endorse or promote products derived from this software
     26            *      without specific prior written permission.
     27            *
     28            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     29            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     30            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     31            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     32            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     33            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     34            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     35            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     36            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     37            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     38            *
     39            ******************************************************************************
     40            */ 
     41          
     42          /* Includes ------------------------------------------------------------------*/
     43          #include "stm32f7xx_hal.h"
     44          
     45          /** @addtogroup STM32F7xx_HAL_Driver
     46            * @{
     47            */
     48          
     49          /** @defgroup PWREx PWREx
     50            * @brief PWR HAL module driver
     51            * @{
     52            */
     53          
     54          #ifdef HAL_PWR_MODULE_ENABLED
     55          
     56          /* Private typedef -----------------------------------------------------------*/
     57          /* Private define ------------------------------------------------------------*/
     58          /** @addtogroup PWREx_Private_Constants
     59            * @{
     60            */    
     61          #define PWR_OVERDRIVE_TIMEOUT_VALUE  1000
     62          #define PWR_UDERDRIVE_TIMEOUT_VALUE  1000
     63          #define PWR_BKPREG_TIMEOUT_VALUE     1000
     64          #define PWR_VOSRDY_TIMEOUT_VALUE     1000
     65          /**
     66            * @}
     67            */
     68              
     69          /* Private macro -------------------------------------------------------------*/
     70          /* Private variables ---------------------------------------------------------*/
     71          /* Private function prototypes -----------------------------------------------*/
     72          /* Private functions ---------------------------------------------------------*/
     73          /** @defgroup PWREx_Exported_Functions PWREx Exported Functions
     74            *  @{
     75            */
     76          
     77          /** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended features functions 
     78            *  @brief Peripheral Extended features functions 
     79            *
     80          @verbatim   
     81          
     82           ===============================================================================
     83                           ##### Peripheral extended features functions #####
     84           ===============================================================================
     85          
     86              *** Main and Backup Regulators configuration ***
     87              ================================================
     88              [..] 
     89                (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
     90                    the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
     91                    retained even in Standby or VBAT mode when the low power backup regulator
     92                    is enabled. It can be considered as an internal EEPROM when VBAT is 
     93                    always present. You can use the HAL_PWREx_EnableBkUpReg() function to 
     94                    enable the low power backup regulator. 
     95          
     96                (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
     97                    the backup SRAM is powered from VDD which replaces the VBAT power supply to 
     98                    save battery life.
     99          
    100                (+) The backup SRAM is not mass erased by a tamper event. It is read 
    101                    protected to prevent confidential data, such as cryptographic private 
    102                    key, from being accessed. The backup SRAM can be erased only through 
    103                    the Flash interface when a protection level change from level 1 to 
    104                    level 0 is requested. 
    105                -@- Refer to the description of Read protection (RDP) in the Flash 
    106                    programming manual.
    107          
    108                (+) The main internal regulator can be configured to have a tradeoff between 
    109                    performance and power consumption when the device does not operate at 
    110                    the maximum frequency. This is done through __HAL_PWR_MAINREGULATORMODE_CONFIG() 
    111                    macro which configure VOS bit in PWR_CR register
    112                    
    113                  Refer to the product datasheets for more details.
    114          
    115              *** FLASH Power Down configuration ****
    116              =======================================
    117              [..] 
    118                (+) By setting the FPDS bit in the PWR_CR register by using the 
    119                    HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters power 
    120                    down mode when the device enters Stop mode. When the Flash memory 
    121                    is in power down mode, an additional startup delay is incurred when 
    122                    waking up from Stop mode.
    123          
    124              *** Over-Drive and Under-Drive configuration ****
    125              =================================================
    126              [..]         
    127                 (+) In Run mode: the main regulator has 2 operating modes available:
    128                  (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
    129                       voltage scaling (scale 1, scale 2 or scale 3)
    130                  (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
    131                      higher frequency than the normal mode for a given voltage scaling (scale 1,  
    132                      scale 2 or scale 3). This mode is enabled through HAL_PWREx_EnableOverDrive() function and
    133                      disabled by HAL_PWREx_DisableOverDrive() function, to enter or exit from Over-drive mode please follow 
    134                      the sequence described in Reference manual.
    135                       
    136                 (+) In Stop mode: the main regulator or low power regulator supplies a low power 
    137                     voltage to the 1.2V domain, thus preserving the content of registers 
    138                     and internal SRAM. 2 operating modes are available:
    139                   (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
    140                        available when the main regulator or the low power regulator is used in Scale 3 or 
    141                        low voltage mode.
    142                   (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only
    143                        available when the main regulator or the low power regulator is in low voltage mode.
    144          
    145          @endverbatim
    146            * @{
    147            */
    148          
    149          /**
    150            * @brief Enables the Backup Regulator.
    151            * @retval HAL status
    152            */

   \                                 In section .text, align 2, keep-with-next
    153          HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
    154          {
   \                     HAL_PWREx_EnableBkUpReg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    155            uint32_t tickstart = 0;
    156          
    157            /* Enable Backup regulator */
    158            PWR->CSR1 |= PWR_CSR1_BRE;
   \   00000002   0x....             LDR.N    R4,??DataTable12  ;; 0x40007004
   \   00000004   0xF240 0x36E9      MOVW     R6,#+1001
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0xF440 0x7000      ORR      R0,R0,#0x200
   \   0000000E   0x6020             STR      R0,[R4, #+0]
    159          
    160            /* Get tick */
    161            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4605             MOV      R5,R0
    162          
    163            /* Wait till Backup regulator ready flag is set */  
    164            while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
   \                     ??HAL_PWREx_EnableBkUpReg_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x0700             LSLS     R0,R0,#+28
   \   0000001A   0xD406             BMI.N    ??HAL_PWREx_EnableBkUpReg_1
    165            {
    166              if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0x42B0             CMP      R0,R6
   \   00000024   0xD3F7             BCC.N    ??HAL_PWREx_EnableBkUpReg_0
    167              {
    168                return HAL_TIMEOUT;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xBD70             POP      {R4-R6,PC}
    169              } 
    170            }
    171            return HAL_OK;
   \                     ??HAL_PWREx_EnableBkUpReg_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    172          }
    173          
    174          /**
    175            * @brief Disables the Backup Regulator.
    176            * @retval HAL status
    177            */

   \                                 In section .text, align 2, keep-with-next
    178          HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
    179          {
   \                     HAL_PWREx_DisableBkUpReg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    180            uint32_t tickstart = 0;
    181            
    182            /* Disable Backup regulator */
    183            PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
   \   00000002   0x....             LDR.N    R4,??DataTable12  ;; 0x40007004
   \   00000004   0xF240 0x36E9      MOVW     R6,#+1001
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0xF420 0x7000      BIC      R0,R0,#0x200
   \   0000000E   0x6020             STR      R0,[R4, #+0]
    184          
    185            /* Get tick */
    186            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4605             MOV      R5,R0
    187          
    188            /* Wait till Backup regulator ready flag is set */  
    189            while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
   \                     ??HAL_PWREx_DisableBkUpReg_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x0700             LSLS     R0,R0,#+28
   \   0000001A   0xD506             BPL.N    ??HAL_PWREx_DisableBkUpReg_1
    190            {
    191              if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
   \   0000001C   0x.... 0x....      BL       HAL_GetTick
   \   00000020   0x1B40             SUBS     R0,R0,R5
   \   00000022   0x42B0             CMP      R0,R6
   \   00000024   0xD3F7             BCC.N    ??HAL_PWREx_DisableBkUpReg_0
    192              {
    193                return HAL_TIMEOUT;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xBD70             POP      {R4-R6,PC}
    194              } 
    195            }
    196            return HAL_OK;
   \                     ??HAL_PWREx_DisableBkUpReg_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    197          }
    198          
    199          /**
    200            * @brief Enables the Flash Power Down in Stop mode.
    201            * @retval None
    202            */

   \                                 In section .text, align 2, keep-with-next
    203          void HAL_PWREx_EnableFlashPowerDown(void)
    204          {
    205            /* Enable the Flash Power Down */
    206            PWR->CR1 |= PWR_CR1_FPDS;
   \                     HAL_PWREx_EnableFlashPowerDown: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000008   0x6001             STR      R1,[R0, #+0]
    207          }
   \   0000000A   0x4770             BX       LR               ;; return
    208          
    209          /**
    210            * @brief Disables the Flash Power Down in Stop mode.
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void HAL_PWREx_DisableFlashPowerDown(void)
    214          {
    215            /* Disable the Flash Power Down */
    216            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
   \                     HAL_PWREx_DisableFlashPowerDown: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF421 0x7100      BIC      R1,R1,#0x200
   \   00000008   0x6001             STR      R1,[R0, #+0]
    217          }
   \   0000000A   0x4770             BX       LR               ;; return
    218          
    219          /**
    220            * @brief Enables Main Regulator low voltage mode.
    221            * @retval None
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
    224          {
    225            /* Enable Main regulator low voltage */
    226            PWR->CR1 |= PWR_CR1_MRUDS;
   \                     HAL_PWREx_EnableMainRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000008   0x6001             STR      R1,[R0, #+0]
    227          }
   \   0000000A   0x4770             BX       LR               ;; return
    228          
    229          /**
    230            * @brief Disables Main Regulator low voltage mode.
    231            * @retval None
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
    234          {  
    235            /* Disable Main regulator low voltage */
    236            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
   \                     HAL_PWREx_DisableMainRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000008   0x6001             STR      R1,[R0, #+0]
    237          }
   \   0000000A   0x4770             BX       LR               ;; return
    238          
    239          /**
    240            * @brief Enables Low Power Regulator low voltage mode.
    241            * @retval None
    242            */

   \                                 In section .text, align 2, keep-with-next
    243          void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
    244          {
    245            /* Enable low power regulator */
    246            PWR->CR1 |= PWR_CR1_LPUDS;
   \                     HAL_PWREx_EnableLowRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000008   0x6001             STR      R1,[R0, #+0]
    247          }
   \   0000000A   0x4770             BX       LR               ;; return
    248          
    249          /**
    250            * @brief Disables Low Power Regulator low voltage mode.
    251            * @retval None
    252            */

   \                                 In section .text, align 2, keep-with-next
    253          void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
    254          {
    255            /* Disable low power regulator */
    256            PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
   \                     HAL_PWREx_DisableLowRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF421 0x6180      BIC      R1,R1,#0x400
   \   00000008   0x6001             STR      R1,[R0, #+0]
    257          }
   \   0000000A   0x4770             BX       LR               ;; return
    258          
    259          /**
    260            * @brief  Activates the Over-Drive mode.
    261            * @note   This mode allows the CPU and the core logic to operate at a higher frequency
    262            *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
    263            * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
    264            *         critical tasks and when the system clock source is either HSI or HSE. 
    265            *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
    266            *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
    267            * @retval HAL status
    268            */

   \                                 In section .text, align 2, keep-with-next
    269          HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
    270          {
   \                     HAL_PWREx_EnableOverDrive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    271            uint32_t tickstart = 0;
    272          
    273            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
    274            
    275            /* Enable the Over-drive to extend the clock frequency to 216 MHz */
    276            __HAL_PWR_OVERDRIVE_ENABLE();
   \   0000000A   0x....             LDR.N    R4,??DataTable12_1  ;; 0x40007000
   \   0000000C   0xF240 0x36E9      MOVW     R6,#+1001
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF000 0x5080      AND      R0,R0,#0x10000000
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   00000028   0x6020             STR      R0,[R4, #+0]
    277          
    278            /* Get tick */
    279            tickstart = HAL_GetTick();
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x4605             MOV      R5,R0
    280          
    281            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
   \                     ??HAL_PWREx_EnableOverDrive_0: (+1)
   \   00000030   0x6860             LDR      R0,[R4, #+4]
   \   00000032   0x03C0             LSLS     R0,R0,#+15
   \   00000034   0xD407             BMI.N    ??HAL_PWREx_EnableOverDrive_1
    282            {
    283              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0x1B40             SUBS     R0,R0,R5
   \   0000003C   0x42B0             CMP      R0,R6
   \   0000003E   0xD3F7             BCC.N    ??HAL_PWREx_EnableOverDrive_0
    284              {
    285                return HAL_TIMEOUT;
    286              }
    287            }
    288            
    289            /* Enable the Over-drive switch */
    290            __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
    291          
    292            /* Get tick */
    293            tickstart = HAL_GetTick();
    294          
    295            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
    296            {
    297              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    298              {
    299                return HAL_TIMEOUT;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0xB002             ADD      SP,SP,#+8
   \   00000044   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_PWREx_EnableOverDrive_1: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xF440 0x3000      ORR      R0,R0,#0x20000
   \   0000004C   0x6020             STR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       HAL_GetTick
   \   00000052   0x4605             MOV      R5,R0
   \                     ??HAL_PWREx_EnableOverDrive_2: (+1)
   \   00000054   0x6860             LDR      R0,[R4, #+4]
   \   00000056   0x0380             LSLS     R0,R0,#+14
   \   00000058   0xD407             BMI.N    ??HAL_PWREx_EnableOverDrive_3
   \   0000005A   0x.... 0x....      BL       HAL_GetTick
   \   0000005E   0x1B40             SUBS     R0,R0,R5
   \   00000060   0x42B0             CMP      R0,R6
   \   00000062   0xD3F7             BCC.N    ??HAL_PWREx_EnableOverDrive_2
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0xB002             ADD      SP,SP,#+8
   \   00000068   0xBD70             POP      {R4-R6,PC}
    300              }
    301            } 
    302            return HAL_OK;
   \                     ??HAL_PWREx_EnableOverDrive_3: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xB002             ADD      SP,SP,#+8
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    303          }
    304          
    305          /**
    306            * @brief  Deactivates the Over-Drive mode.
    307            * @note   This mode allows the CPU and the core logic to operate at a higher frequency
    308            *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).    
    309            * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
    310            *         critical tasks and when the system clock source is either HSI or HSE. 
    311            *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
    312            *         The peripheral clocks must be enabled once the Over-drive mode is activated.
    313            * @retval HAL status
    314            */

   \                                 In section .text, align 2, keep-with-next
    315          HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
    316          {
   \                     HAL_PWREx_DisableOverDrive: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    317            uint32_t tickstart = 0;
    318            
    319            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
    320              
    321            /* Disable the Over-drive switch */
    322            __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
   \   0000000A   0x....             LDR.N    R4,??DataTable12_1  ;; 0x40007000
   \   0000000C   0xF240 0x36E9      MOVW     R6,#+1001
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xF000 0x5080      AND      R0,R0,#0x10000000
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0xF420 0x3000      BIC      R0,R0,#0x20000
   \   00000028   0x6020             STR      R0,[R4, #+0]
    323            
    324            /* Get tick */
    325            tickstart = HAL_GetTick();
   \   0000002A   0x.... 0x....      BL       HAL_GetTick
   \   0000002E   0x4605             MOV      R5,R0
    326           
    327            while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
   \                     ??HAL_PWREx_DisableOverDrive_0: (+1)
   \   00000030   0x6860             LDR      R0,[R4, #+4]
   \   00000032   0x0380             LSLS     R0,R0,#+14
   \   00000034   0xD507             BPL.N    ??HAL_PWREx_DisableOverDrive_1
    328            {
    329              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
   \   00000036   0x.... 0x....      BL       HAL_GetTick
   \   0000003A   0x1B40             SUBS     R0,R0,R5
   \   0000003C   0x42B0             CMP      R0,R6
   \   0000003E   0xD3F7             BCC.N    ??HAL_PWREx_DisableOverDrive_0
    330              {
    331                return HAL_TIMEOUT;
    332              }
    333            } 
    334            
    335            /* Disable the Over-drive */
    336            __HAL_PWR_OVERDRIVE_DISABLE();
    337          
    338            /* Get tick */
    339            tickstart = HAL_GetTick();
    340          
    341            while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
    342            {
    343              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    344              {
    345                return HAL_TIMEOUT;
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0xB002             ADD      SP,SP,#+8
   \   00000044   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_PWREx_DisableOverDrive_1: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0xF420 0x3080      BIC      R0,R0,#0x10000
   \   0000004C   0x6020             STR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       HAL_GetTick
   \   00000052   0x4605             MOV      R5,R0
   \                     ??HAL_PWREx_DisableOverDrive_2: (+1)
   \   00000054   0x6860             LDR      R0,[R4, #+4]
   \   00000056   0x03C0             LSLS     R0,R0,#+15
   \   00000058   0xD507             BPL.N    ??HAL_PWREx_DisableOverDrive_3
   \   0000005A   0x.... 0x....      BL       HAL_GetTick
   \   0000005E   0x1B40             SUBS     R0,R0,R5
   \   00000060   0x42B0             CMP      R0,R6
   \   00000062   0xD3F7             BCC.N    ??HAL_PWREx_DisableOverDrive_2
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0xB002             ADD      SP,SP,#+8
   \   00000068   0xBD70             POP      {R4-R6,PC}
    346              }
    347            }
    348            
    349            return HAL_OK;
   \                     ??HAL_PWREx_DisableOverDrive_3: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xB002             ADD      SP,SP,#+8
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    350          }
    351          
    352          /**
    353            * @brief  Enters in Under-Drive STOP mode.
    354            * 
    355            * @note    This mode can be selected only when the Under-Drive is already active 
    356            *   
    357            * @note    This mode is enabled only with STOP low power mode.
    358            *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
    359            *          mode is only available when the main regulator or the low power regulator 
    360            *          is in low voltage mode
    361            *        
    362            * @note   If the Under-drive mode was enabled, it is automatically disabled after 
    363            *         exiting Stop mode. 
    364            *         When the voltage regulator operates in Under-drive mode, an additional  
    365            *         startup delay is induced when waking up from Stop mode.
    366            *                    
    367            * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
    368            *   
    369            * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
    370            *         the HSI RC oscillator is selected as system clock.
    371            *           
    372            * @note   When the voltage regulator operates in low power mode, an additional 
    373            *         startup delay is incurred when waking up from Stop mode. 
    374            *         By keeping the internal regulator ON during Stop mode, the consumption 
    375            *         is higher although the startup time is reduced.
    376            *     
    377            * @param  Regulator: specifies the regulator state in STOP mode.
    378            *          This parameter can be one of the following values:
    379            *            @arg PWR_MAINREGULATOR_UNDERDRIVE_ON:  Main Regulator in under-drive mode 
    380            *                 and Flash memory in power-down when the device is in Stop under-drive mode
    381            *            @arg PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON:  Low Power Regulator in under-drive mode 
    382            *                and Flash memory in power-down when the device is in Stop under-drive mode
    383            * @param  STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
    384            *          This parameter can be one of the following values:
    385            *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
    386            *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
    387            * @retval None
    388            */

   \                                 In section .text, align 2, keep-with-next
    389          HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
    390          {
   \                     HAL_PWREx_EnterUnderDriveSTOPMode: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    391            uint32_t tempreg = 0;
    392            uint32_t tickstart = 0;
    393            
    394            /* Check the parameters */
    395            assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
    396            assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    397            
    398            /* Enable Power ctrl clock */
    399            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x460D             MOV      R5,R1
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40023840
    400            /* Enable the Under-drive Mode ---------------------------------------------*/
    401            /* Clear Under-drive flag */
    402            __HAL_PWR_CLEAR_ODRUDR_FLAG();
   \   00000010   0x....             LDR.N    R6,??DataTable12_1  ;; 0x40007000
    403            
    404            /* Enable the Under-drive */ 
    405            __HAL_PWR_UNDERDRIVE_ENABLE();
   \   00000012   0xF240 0x38E9      MOVW     R8,#+1001
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF041 0x5180      ORR      R1,R1,#0x10000000
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF000 0x5080      AND      R0,R0,#0x10000000
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x9800             LDR      R0,[SP, #+0]
   \   00000028   0x6870             LDR      R0,[R6, #+4]
   \   0000002A   0xF440 0x2040      ORR      R0,R0,#0xC0000
   \   0000002E   0x6070             STR      R0,[R6, #+4]
   \   00000030   0x6830             LDR      R0,[R6, #+0]
   \   00000032   0xF440 0x2040      ORR      R0,R0,#0xC0000
   \   00000036   0x6030             STR      R0,[R6, #+0]
    406          
    407            /* Get tick */
    408            tickstart = HAL_GetTick();
   \   00000038   0x.... 0x....      BL       HAL_GetTick
   \   0000003C   0x4607             MOV      R7,R0
    409          
    410            /* Wait for UnderDrive mode is ready */
    411            while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_0: (+1)
   \   0000003E   0x6870             LDR      R0,[R6, #+4]
   \   00000040   0xF400 0x2040      AND      R0,R0,#0xC0000
   \   00000044   0xF5B0 0x2F40      CMP      R0,#+786432
   \   00000048   0xD108             BNE.N    ??HAL_PWREx_EnterUnderDriveSTOPMode_1
    412            {
    413              if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
   \   0000004A   0x.... 0x....      BL       HAL_GetTick
   \   0000004E   0x1BC0             SUBS     R0,R0,R7
   \   00000050   0x4540             CMP      R0,R8
   \   00000052   0xD3F4             BCC.N    ??HAL_PWREx_EnterUnderDriveSTOPMode_0
    414              {
    415                return HAL_TIMEOUT;
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0xB002             ADD      SP,SP,#+8
   \   00000058   0xE8BD 0x81F0      POP      {R4-R8,PC}
    416              }
    417            }
    418            
    419            /* Select the regulator state in STOP mode ---------------------------------*/
    420            tempreg = PWR->CR1;
   \                     ??HAL_PWREx_EnterUnderDriveSTOPMode_1: (+1)
   \   0000005C   0x6830             LDR      R0,[R6, #+0]
    421            /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
    422            tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
    423            
    424            /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
    425            tempreg |= Regulator;
    426            
    427            /* Store the new value */
    428            PWR->CR1 = tempreg;
   \   0000005E   0x....             LDR.N    R1,??DataTable12_3  ;; 0xfffff3fc
   \   00000060   0x4008             ANDS     R0,R1,R0
   \   00000062   0x4320             ORRS     R0,R4,R0
   \   00000064   0x6030             STR      R0,[R6, #+0]
    429            
    430            /* Set SLEEPDEEP bit of Cortex System Control Register */
    431            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
   \   00000066   0x....             LDR.N    R0,??DataTable12_4  ;; 0xe000ed10
    432            
    433            /* Select STOP mode entry --------------------------------------------------*/
    434            if(STOPEntry == PWR_SLEEPENTRY_WFI)
   \   00000068   0x2D01             CMP      R5,#+1
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000070   0x6001             STR      R1,[R0, #+0]
   \   00000072   0xBF0C             ITE      EQ 
   \   00000074   0xBF30             WFIEQ    
   \   00000076   0xBF20             WFENE    
    435            {   
    436              /* Request Wait For Interrupt */
    437              __WFI();
    438            }
    439            else
    440            {
    441              /* Request Wait For Event */
    442              __WFE();
    443            }
    444            /* Reset SLEEPDEEP bit of Cortex System Control Register */
    445            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0xF021 0x0104      BIC      R1,R1,#0x4
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    446          
    447            return HAL_OK;  
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xB002             ADD      SP,SP,#+8
   \   00000084   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    448          }
    449          
    450          /**
    451            * @brief Returns Voltage Scaling Range.
    452            * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1, PWR_REGULATOR_VOLTAGE_SCALE2 or 
    453            *            PWR_REGULATOR_VOLTAGE_SCALE3)PWR_REGULATOR_VOLTAGE_SCALE1
    454            */  

   \                                 In section .text, align 2, keep-with-next
    455          uint32_t HAL_PWREx_GetVoltageRange(void)
    456          {
    457            return  (PWR->CR1 & PWR_CR1_VOS);
   \                     HAL_PWREx_GetVoltageRange: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF400 0x4040      AND      R0,R0,#0xC000
   \   00000008   0x4770             BX       LR               ;; return
    458          }
    459          
    460          /**
    461            * @brief Configures the main internal regulator output voltage.
    462            * @param  VoltageScaling: specifies the regulator output voltage to achieve
    463            *         a tradeoff between performance and power consumption.
    464            *          This parameter can be one of the following values:
    465            *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,
    466            *                                                typical output voltage at 1.4 V,  
    467            *                                                system frequency up to 216 MHz.
    468            *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,
    469            *                                                typical output voltage at 1.2 V,                
    470            *                                                system frequency up to 180 MHz.
    471            *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output range 2 mode,
    472            *                                                typical output voltage at 1.00 V,                
    473            *                                                system frequency up to 151 MHz.
    474            * @note To update the system clock frequency(SYSCLK):
    475            *        - Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig().
    476            *        - Call the HAL_RCC_OscConfig() to configure the PLL.
    477            *        - Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.
    478            *        - Set the new system clock frequency using the HAL_RCC_ClockConfig().
    479            * @note The scale can be modified only when the HSI or HSE clock source is selected 
    480            *        as system clock source, otherwise the API returns HAL_ERROR.  
    481            * @note When the PLL is OFF, the voltage scale 3 is automatically selected and the VOS bits
    482            *       value in the PWR_CR1 register are not taken in account.
    483            * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.
    484            * @note The new voltage scale is active only when the PLL is ON.  
    485            * @retval HAL Status
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
    488          {
   \                     HAL_PWREx_ControlVoltageScaling: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB081             SUB      SP,SP,#+4
    489            uint32_t tickstart = 0;
    490          
    491            assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));
    492          
    493            /* Enable Power ctrl clock */
    494            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR.N    R5,??DataTable12_5  ;; 0x40023800
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x6C28             LDR      R0,[R5, #+64]
   \   0000000E   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \   00000012   0x6428             STR      R0,[R5, #+64]
   \   00000014   0x6C28             LDR      R0,[R5, #+64]
   \   00000016   0xF000 0x5080      AND      R0,R0,#0x10000000
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
    495          
    496            /* Check if the PLL is used as system clock or not */
    497            if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
   \   0000001E   0x68A8             LDR      R0,[R5, #+8]
   \   00000020   0xF000 0x000C      AND      R0,R0,#0xC
   \   00000024   0x2808             CMP      R0,#+8
   \   00000026   0xD043             BEQ.N    ??HAL_PWREx_ControlVoltageScaling_0
    498            {
    499              /* Disable the main PLL */
    500              __HAL_RCC_PLL_DISABLE();
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0xF020 0x7080      BIC      R0,R0,#0x1000000
   \   0000002E   0x6028             STR      R0,[R5, #+0]
    501              
    502              /* Get Start Tick */
    503              tickstart = HAL_GetTick();    
   \   00000030   0x.... 0x....      BL       HAL_GetTick
   \   00000034   0x4607             MOV      R7,R0
    504              /* Wait till PLL is disabled */  
    505              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
   \                     ??HAL_PWREx_ControlVoltageScaling_1: (+1)
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x0180             LSLS     R0,R0,#+6
   \   0000003A   0xD507             BPL.N    ??HAL_PWREx_ControlVoltageScaling_2
    506              {
    507                if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   0000003C   0x.... 0x....      BL       HAL_GetTick
   \   00000040   0x1BC0             SUBS     R0,R0,R7
   \   00000042   0x2865             CMP      R0,#+101
   \   00000044   0xD3F7             BCC.N    ??HAL_PWREx_ControlVoltageScaling_1
    508                {
    509                  return HAL_TIMEOUT;
    510                }
    511              }
    512              
    513              /* Set Range */
    514              __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
    515              
    516              /* Enable the main PLL */
    517              __HAL_RCC_PLL_ENABLE();
    518              
    519              /* Get Start Tick */
    520              tickstart = HAL_GetTick();
    521              /* Wait till PLL is ready */  
    522              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
    523              {
    524                if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
    525                {
    526                  return HAL_TIMEOUT;
    527                } 
    528              }
    529              
    530              /* Get Start Tick */
    531              tickstart = HAL_GetTick();
    532              while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
    533              {
    534                if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
    535                {
    536                  return HAL_TIMEOUT;
   \   00000046   0x2003             MOVS     R0,#+3
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_PWREx_ControlVoltageScaling_2: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x....             LDR.N    R6,??DataTable12_1  ;; 0x40007000
   \   00000050   0x9000             STR      R0,[SP, #+0]
   \   00000052   0x6830             LDR      R0,[R6, #+0]
   \   00000054   0xF420 0x4040      BIC      R0,R0,#0xC000
   \   00000058   0x4320             ORRS     R0,R4,R0
   \   0000005A   0x6030             STR      R0,[R6, #+0]
   \   0000005C   0x6830             LDR      R0,[R6, #+0]
   \   0000005E   0xF400 0x4040      AND      R0,R0,#0xC000
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x6828             LDR      R0,[R5, #+0]
   \   00000068   0xF040 0x7080      ORR      R0,R0,#0x1000000
   \   0000006C   0x6028             STR      R0,[R5, #+0]
   \   0000006E   0x.... 0x....      BL       HAL_GetTick
   \   00000072   0x4607             MOV      R7,R0
   \                     ??HAL_PWREx_ControlVoltageScaling_3: (+1)
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0x0180             LSLS     R0,R0,#+6
   \   00000078   0xD407             BMI.N    ??HAL_PWREx_ControlVoltageScaling_4
   \   0000007A   0x.... 0x....      BL       HAL_GetTick
   \   0000007E   0x1BC0             SUBS     R0,R0,R7
   \   00000080   0x2865             CMP      R0,#+101
   \   00000082   0xD3F7             BCC.N    ??HAL_PWREx_ControlVoltageScaling_3
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_PWREx_ControlVoltageScaling_4: (+1)
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0x4607             MOV      R7,R0
   \   00000090   0xF240 0x34E9      MOVW     R4,#+1001
   \                     ??HAL_PWREx_ControlVoltageScaling_5: (+1)
   \   00000094   0x6870             LDR      R0,[R6, #+4]
   \   00000096   0x0440             LSLS     R0,R0,#+17
   \   00000098   0xD407             BMI.N    ??HAL_PWREx_ControlVoltageScaling_6
   \   0000009A   0x.... 0x....      BL       HAL_GetTick
   \   0000009E   0x1BC0             SUBS     R0,R0,R7
   \   000000A0   0x42A0             CMP      R0,R4
   \   000000A2   0xD3F7             BCC.N    ??HAL_PWREx_ControlVoltageScaling_5
   \   000000A4   0x2003             MOVS     R0,#+3
   \   000000A6   0xB001             ADD      SP,SP,#+4
   \   000000A8   0xBDF0             POP      {R4-R7,PC}
    537                } 
    538              }
    539            }
    540            else
    541            {
    542              return HAL_ERROR;
    543            }
    544            return HAL_OK;
   \                     ??HAL_PWREx_ControlVoltageScaling_6: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xB001             ADD      SP,SP,#+4
   \   000000AE   0xBDF0             POP      {R4-R7,PC}
   \                     ??HAL_PWREx_ControlVoltageScaling_0: (+1)
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0xB001             ADD      SP,SP,#+4
   \   000000B4   0xBDF0             POP      {R4-R7,PC}       ;; return
    545          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40007004         DC32     0x40007004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0xFFFFF3FC         DC32     0xfffff3fc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x40023800         DC32     0x40023800
    546          
    547          /**
    548            * @}
    549            */
    550          
    551          /**
    552            * @}
    553            */
    554          
    555          #endif /* HAL_PWR_MODULE_ENABLED */
    556          /**
    557            * @}
    558            */
    559          
    560          /**
    561            * @}
    562            */
    563          
    564          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   HAL_PWREx_ControlVoltageScaling
        24   -> HAL_GetTick
      16   HAL_PWREx_DisableBkUpReg
        16   -> HAL_GetTick
       0   HAL_PWREx_DisableFlashPowerDown
       0   HAL_PWREx_DisableLowRegulatorLowVoltage
       0   HAL_PWREx_DisableMainRegulatorLowVoltage
      24   HAL_PWREx_DisableOverDrive
        24   -> HAL_GetTick
      16   HAL_PWREx_EnableBkUpReg
        16   -> HAL_GetTick
       0   HAL_PWREx_EnableFlashPowerDown
       0   HAL_PWREx_EnableLowRegulatorLowVoltage
       0   HAL_PWREx_EnableMainRegulatorLowVoltage
      24   HAL_PWREx_EnableOverDrive
        24   -> HAL_GetTick
      32   HAL_PWREx_EnterUnderDriveSTOPMode
        32   -> HAL_GetTick
       0   HAL_PWREx_GetVoltageRange


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
     182  HAL_PWREx_ControlVoltageScaling
      46  HAL_PWREx_DisableBkUpReg
      12  HAL_PWREx_DisableFlashPowerDown
      12  HAL_PWREx_DisableLowRegulatorLowVoltage
      12  HAL_PWREx_DisableMainRegulatorLowVoltage
     112  HAL_PWREx_DisableOverDrive
      46  HAL_PWREx_EnableBkUpReg
      12  HAL_PWREx_EnableFlashPowerDown
      12  HAL_PWREx_EnableLowRegulatorLowVoltage
      12  HAL_PWREx_EnableMainRegulatorLowVoltage
     112  HAL_PWREx_EnableOverDrive
     136  HAL_PWREx_EnterUnderDriveSTOPMode
      10  HAL_PWREx_GetVoltageRange

 
 740 bytes in section .text
 
 740 bytes of CODE memory

Errors: none
Warnings: none
